// This file is generated. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPoorNetworkConditions {
    // message fields
    detection_type: ::std::option::Option<EPoorNetworkConditionsType>,
    players: ::protobuf::RepeatedField<CMsgPoorNetworkConditions_Player>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgPoorNetworkConditions {}

impl CMsgPoorNetworkConditions {
    pub fn new() -> CMsgPoorNetworkConditions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgPoorNetworkConditions {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPoorNetworkConditions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPoorNetworkConditions,
        };
        unsafe {
            instance.get(CMsgPoorNetworkConditions::new)
        }
    }

    // optional .EPoorNetworkConditionsType detection_type = 1;

    pub fn clear_detection_type(&mut self) {
        self.detection_type = ::std::option::Option::None;
    }

    pub fn has_detection_type(&self) -> bool {
        self.detection_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_detection_type(&mut self, v: EPoorNetworkConditionsType) {
        self.detection_type = ::std::option::Option::Some(v);
    }

    pub fn get_detection_type(&self) -> EPoorNetworkConditionsType {
        self.detection_type.unwrap_or(EPoorNetworkConditionsType::k_EPoorNetworkConditions_None)
    }

    fn get_detection_type_for_reflect(&self) -> &::std::option::Option<EPoorNetworkConditionsType> {
        &self.detection_type
    }

    fn mut_detection_type_for_reflect(&mut self) -> &mut ::std::option::Option<EPoorNetworkConditionsType> {
        &mut self.detection_type
    }

    // repeated .CMsgPoorNetworkConditions.Player players = 2;

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgPoorNetworkConditions_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPoorNetworkConditions_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgPoorNetworkConditions_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    pub fn get_players(&self) -> &[CMsgPoorNetworkConditions_Player] {
        &self.players
    }

    fn get_players_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgPoorNetworkConditions_Player> {
        &self.players
    }

    fn mut_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPoorNetworkConditions_Player> {
        &mut self.players
    }
}

impl ::protobuf::Message for CMsgPoorNetworkConditions {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.detection_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.detection_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.detection_type {
            os.write_enum(1, v.value())?;
        }
        for v in &self.players {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgPoorNetworkConditions {
    fn new() -> CMsgPoorNetworkConditions {
        CMsgPoorNetworkConditions::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgPoorNetworkConditions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EPoorNetworkConditionsType>>(
                    "detection_type",
                    CMsgPoorNetworkConditions::get_detection_type_for_reflect,
                    CMsgPoorNetworkConditions::mut_detection_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPoorNetworkConditions_Player>>(
                    "players",
                    CMsgPoorNetworkConditions::get_players_for_reflect,
                    CMsgPoorNetworkConditions::mut_players_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPoorNetworkConditions>(
                    "CMsgPoorNetworkConditions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgPoorNetworkConditions {
    fn clear(&mut self) {
        self.clear_detection_type();
        self.clear_players();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPoorNetworkConditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPoorNetworkConditions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPoorNetworkConditions_Player {
    // message fields
    account_id: ::std::option::Option<u32>,
    disconnect_reason: ::std::option::Option<super::network_connection::ENetworkDisconnectionReason>,
    num_bad_intervals: ::std::option::Option<u32>,
    peak_loss_pct: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgPoorNetworkConditions_Player {}

impl CMsgPoorNetworkConditions_Player {
    pub fn new() -> CMsgPoorNetworkConditions_Player {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgPoorNetworkConditions_Player {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPoorNetworkConditions_Player> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPoorNetworkConditions_Player,
        };
        unsafe {
            instance.get(CMsgPoorNetworkConditions_Player::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional .ENetworkDisconnectionReason disconnect_reason = 2;

    pub fn clear_disconnect_reason(&mut self) {
        self.disconnect_reason = ::std::option::Option::None;
    }

    pub fn has_disconnect_reason(&self) -> bool {
        self.disconnect_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disconnect_reason(&mut self, v: super::network_connection::ENetworkDisconnectionReason) {
        self.disconnect_reason = ::std::option::Option::Some(v);
    }

    pub fn get_disconnect_reason(&self) -> super::network_connection::ENetworkDisconnectionReason {
        self.disconnect_reason.unwrap_or(super::network_connection::ENetworkDisconnectionReason::NETWORK_DISCONNECT_INVALID)
    }

    fn get_disconnect_reason_for_reflect(&self) -> &::std::option::Option<super::network_connection::ENetworkDisconnectionReason> {
        &self.disconnect_reason
    }

    fn mut_disconnect_reason_for_reflect(&mut self) -> &mut ::std::option::Option<super::network_connection::ENetworkDisconnectionReason> {
        &mut self.disconnect_reason
    }

    // optional uint32 num_bad_intervals = 3;

    pub fn clear_num_bad_intervals(&mut self) {
        self.num_bad_intervals = ::std::option::Option::None;
    }

    pub fn has_num_bad_intervals(&self) -> bool {
        self.num_bad_intervals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_bad_intervals(&mut self, v: u32) {
        self.num_bad_intervals = ::std::option::Option::Some(v);
    }

    pub fn get_num_bad_intervals(&self) -> u32 {
        self.num_bad_intervals.unwrap_or(0)
    }

    fn get_num_bad_intervals_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.num_bad_intervals
    }

    fn mut_num_bad_intervals_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.num_bad_intervals
    }

    // optional uint32 peak_loss_pct = 4;

    pub fn clear_peak_loss_pct(&mut self) {
        self.peak_loss_pct = ::std::option::Option::None;
    }

    pub fn has_peak_loss_pct(&self) -> bool {
        self.peak_loss_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peak_loss_pct(&mut self, v: u32) {
        self.peak_loss_pct = ::std::option::Option::Some(v);
    }

    pub fn get_peak_loss_pct(&self) -> u32 {
        self.peak_loss_pct.unwrap_or(0)
    }

    fn get_peak_loss_pct_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.peak_loss_pct
    }

    fn mut_peak_loss_pct_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.peak_loss_pct
    }
}

impl ::protobuf::Message for CMsgPoorNetworkConditions_Player {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.disconnect_reason = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_bad_intervals = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.peak_loss_pct = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.disconnect_reason {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.num_bad_intervals {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.peak_loss_pct {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.disconnect_reason {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.num_bad_intervals {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.peak_loss_pct {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgPoorNetworkConditions_Player {
    fn new() -> CMsgPoorNetworkConditions_Player {
        CMsgPoorNetworkConditions_Player::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgPoorNetworkConditions_Player>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgPoorNetworkConditions_Player::get_account_id_for_reflect,
                    CMsgPoorNetworkConditions_Player::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::network_connection::ENetworkDisconnectionReason>>(
                    "disconnect_reason",
                    CMsgPoorNetworkConditions_Player::get_disconnect_reason_for_reflect,
                    CMsgPoorNetworkConditions_Player::mut_disconnect_reason_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_bad_intervals",
                    CMsgPoorNetworkConditions_Player::get_num_bad_intervals_for_reflect,
                    CMsgPoorNetworkConditions_Player::mut_num_bad_intervals_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "peak_loss_pct",
                    CMsgPoorNetworkConditions_Player::get_peak_loss_pct_for_reflect,
                    CMsgPoorNetworkConditions_Player::mut_peak_loss_pct_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPoorNetworkConditions_Player>(
                    "CMsgPoorNetworkConditions_Player",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgPoorNetworkConditions_Player {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_disconnect_reason();
        self.clear_num_bad_intervals();
        self.clear_peak_loss_pct();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPoorNetworkConditions_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPoorNetworkConditions_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameserverCrash {
    // message fields
    match_id: ::std::option::Option<u64>,
    lobby_id: ::std::option::Option<u64>,
    game_state: ::std::option::Option<super::dota_shared_enums::DOTA_GameState>,
    sentinel_save_time: ::std::option::Option<u32>,
    custom_game_id: ::std::option::Option<u64>,
    tournament_id: ::std::option::Option<u32>,
    server_steam_id: ::std::option::Option<u64>,
    server_public_ip_addr: ::std::option::Option<u32>,
    server_port: ::std::option::Option<u32>,
    server_cluster: ::std::option::Option<u32>,
    pid: ::std::option::Option<u32>,
    engine: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameserverCrash {}

impl CMsgGameserverCrash {
    pub fn new() -> CMsgGameserverCrash {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameserverCrash {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameserverCrash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameserverCrash,
        };
        unsafe {
            instance.get(CMsgGameserverCrash::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional fixed64 lobby_id = 2;

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    fn get_lobby_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.lobby_id
    }

    fn mut_lobby_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.lobby_id
    }

    // optional .DOTA_GameState game_state = 3;

    pub fn clear_game_state(&mut self) {
        self.game_state = ::std::option::Option::None;
    }

    pub fn has_game_state(&self) -> bool {
        self.game_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_state(&mut self, v: super::dota_shared_enums::DOTA_GameState) {
        self.game_state = ::std::option::Option::Some(v);
    }

    pub fn get_game_state(&self) -> super::dota_shared_enums::DOTA_GameState {
        self.game_state.unwrap_or(super::dota_shared_enums::DOTA_GameState::DOTA_GAMERULES_STATE_INIT)
    }

    fn get_game_state_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::DOTA_GameState> {
        &self.game_state
    }

    fn mut_game_state_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::DOTA_GameState> {
        &mut self.game_state
    }

    // optional fixed32 sentinel_save_time = 4;

    pub fn clear_sentinel_save_time(&mut self) {
        self.sentinel_save_time = ::std::option::Option::None;
    }

    pub fn has_sentinel_save_time(&self) -> bool {
        self.sentinel_save_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sentinel_save_time(&mut self, v: u32) {
        self.sentinel_save_time = ::std::option::Option::Some(v);
    }

    pub fn get_sentinel_save_time(&self) -> u32 {
        self.sentinel_save_time.unwrap_or(0)
    }

    fn get_sentinel_save_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.sentinel_save_time
    }

    fn mut_sentinel_save_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.sentinel_save_time
    }

    // optional fixed64 custom_game_id = 11;

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    pub fn get_custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    fn get_custom_game_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.custom_game_id
    }

    fn mut_custom_game_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.custom_game_id
    }

    // optional uint32 tournament_id = 12;

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id = ::std::option::Option::None;
    }

    pub fn has_tournament_id(&self) -> bool {
        self.tournament_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: u32) {
        self.tournament_id = ::std::option::Option::Some(v);
    }

    pub fn get_tournament_id(&self) -> u32 {
        self.tournament_id.unwrap_or(0)
    }

    fn get_tournament_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tournament_id
    }

    fn mut_tournament_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tournament_id
    }

    // optional fixed64 server_steam_id = 5;

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    fn get_server_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.server_steam_id
    }

    fn mut_server_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.server_steam_id
    }

    // optional fixed32 server_public_ip_addr = 6;

    pub fn clear_server_public_ip_addr(&mut self) {
        self.server_public_ip_addr = ::std::option::Option::None;
    }

    pub fn has_server_public_ip_addr(&self) -> bool {
        self.server_public_ip_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_public_ip_addr(&mut self, v: u32) {
        self.server_public_ip_addr = ::std::option::Option::Some(v);
    }

    pub fn get_server_public_ip_addr(&self) -> u32 {
        self.server_public_ip_addr.unwrap_or(0)
    }

    fn get_server_public_ip_addr_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_public_ip_addr
    }

    fn mut_server_public_ip_addr_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_public_ip_addr
    }

    // optional uint32 server_port = 7;

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    pub fn get_server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    fn get_server_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_port
    }

    fn mut_server_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_port
    }

    // optional uint32 server_cluster = 8;

    pub fn clear_server_cluster(&mut self) {
        self.server_cluster = ::std::option::Option::None;
    }

    pub fn has_server_cluster(&self) -> bool {
        self.server_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_cluster(&mut self, v: u32) {
        self.server_cluster = ::std::option::Option::Some(v);
    }

    pub fn get_server_cluster(&self) -> u32 {
        self.server_cluster.unwrap_or(0)
    }

    fn get_server_cluster_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_cluster
    }

    fn mut_server_cluster_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_cluster
    }

    // optional uint32 pid = 9;

    pub fn clear_pid(&mut self) {
        self.pid = ::std::option::Option::None;
    }

    pub fn has_pid(&self) -> bool {
        self.pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: u32) {
        self.pid = ::std::option::Option::Some(v);
    }

    pub fn get_pid(&self) -> u32 {
        self.pid.unwrap_or(0)
    }

    fn get_pid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.pid
    }

    fn mut_pid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.pid
    }

    // optional uint32 engine = 10;

    pub fn clear_engine(&mut self) {
        self.engine = ::std::option::Option::None;
    }

    pub fn has_engine(&self) -> bool {
        self.engine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engine(&mut self, v: u32) {
        self.engine = ::std::option::Option::Some(v);
    }

    pub fn get_engine(&self) -> u32 {
        self.engine.unwrap_or(0)
    }

    fn get_engine_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.engine
    }

    fn mut_engine_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.engine
    }
}

impl ::protobuf::Message for CMsgGameserverCrash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.lobby_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.game_state = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.sentinel_save_time = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.custom_game_id = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tournament_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.server_steam_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_public_ip_addr = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_port = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_cluster = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pid = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.engine = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_id {
            my_size += 9;
        }
        if let Some(v) = self.game_state {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.sentinel_save_time {
            my_size += 5;
        }
        if let Some(v) = self.custom_game_id {
            my_size += 9;
        }
        if let Some(v) = self.tournament_id {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.server_public_ip_addr {
            my_size += 5;
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_cluster {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pid {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.engine {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.game_state {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.sentinel_save_time {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.tournament_id {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.server_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.server_public_ip_addr {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.server_cluster {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.pid {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.engine {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameserverCrash {
    fn new() -> CMsgGameserverCrash {
        CMsgGameserverCrash::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameserverCrash>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgGameserverCrash::get_match_id_for_reflect,
                    CMsgGameserverCrash::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "lobby_id",
                    CMsgGameserverCrash::get_lobby_id_for_reflect,
                    CMsgGameserverCrash::mut_lobby_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::DOTA_GameState>>(
                    "game_state",
                    CMsgGameserverCrash::get_game_state_for_reflect,
                    CMsgGameserverCrash::mut_game_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "sentinel_save_time",
                    CMsgGameserverCrash::get_sentinel_save_time_for_reflect,
                    CMsgGameserverCrash::mut_sentinel_save_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "custom_game_id",
                    CMsgGameserverCrash::get_custom_game_id_for_reflect,
                    CMsgGameserverCrash::mut_custom_game_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tournament_id",
                    CMsgGameserverCrash::get_tournament_id_for_reflect,
                    CMsgGameserverCrash::mut_tournament_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "server_steam_id",
                    CMsgGameserverCrash::get_server_steam_id_for_reflect,
                    CMsgGameserverCrash::mut_server_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "server_public_ip_addr",
                    CMsgGameserverCrash::get_server_public_ip_addr_for_reflect,
                    CMsgGameserverCrash::mut_server_public_ip_addr_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_port",
                    CMsgGameserverCrash::get_server_port_for_reflect,
                    CMsgGameserverCrash::mut_server_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_cluster",
                    CMsgGameserverCrash::get_server_cluster_for_reflect,
                    CMsgGameserverCrash::mut_server_cluster_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pid",
                    CMsgGameserverCrash::get_pid_for_reflect,
                    CMsgGameserverCrash::mut_pid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "engine",
                    CMsgGameserverCrash::get_engine_for_reflect,
                    CMsgGameserverCrash::mut_engine_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameserverCrash>(
                    "CMsgGameserverCrash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameserverCrash {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_lobby_id();
        self.clear_game_state();
        self.clear_sentinel_save_time();
        self.clear_custom_game_id();
        self.clear_tournament_id();
        self.clear_server_steam_id();
        self.clear_server_public_ip_addr();
        self.clear_server_port();
        self.clear_server_cluster();
        self.clear_pid();
        self.clear_engine();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameserverCrash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameserverCrash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgConnectedPlayers {
    // message fields
    connected_players: ::protobuf::RepeatedField<CMsgConnectedPlayers_Player>,
    disconnected_players: ::protobuf::RepeatedField<CMsgConnectedPlayers_Player>,
    game_state: ::std::option::Option<super::dota_shared_enums::DOTA_GameState>,
    first_blood_happened: ::std::option::Option<bool>,
    legacy_mass_disconnect: ::std::option::Option<bool>,
    poor_network_conditions: ::protobuf::SingularPtrField<CMsgPoorNetworkConditions>,
    send_reason: ::std::option::Option<CMsgConnectedPlayers_SendReason>,
    radiant_kills: ::std::option::Option<u32>,
    dire_kills: ::std::option::Option<u32>,
    radiant_lead: ::std::option::Option<i32>,
    building_state: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgConnectedPlayers {}

impl CMsgConnectedPlayers {
    pub fn new() -> CMsgConnectedPlayers {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgConnectedPlayers {
        static mut instance: ::protobuf::lazy::Lazy<CMsgConnectedPlayers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgConnectedPlayers,
        };
        unsafe {
            instance.get(CMsgConnectedPlayers::new)
        }
    }

    // repeated .CMsgConnectedPlayers.Player connected_players = 1;

    pub fn clear_connected_players(&mut self) {
        self.connected_players.clear();
    }

    // Param is passed by value, moved
    pub fn set_connected_players(&mut self, v: ::protobuf::RepeatedField<CMsgConnectedPlayers_Player>) {
        self.connected_players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_connected_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgConnectedPlayers_Player> {
        &mut self.connected_players
    }

    // Take field
    pub fn take_connected_players(&mut self) -> ::protobuf::RepeatedField<CMsgConnectedPlayers_Player> {
        ::std::mem::replace(&mut self.connected_players, ::protobuf::RepeatedField::new())
    }

    pub fn get_connected_players(&self) -> &[CMsgConnectedPlayers_Player] {
        &self.connected_players
    }

    fn get_connected_players_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgConnectedPlayers_Player> {
        &self.connected_players
    }

    fn mut_connected_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgConnectedPlayers_Player> {
        &mut self.connected_players
    }

    // repeated .CMsgConnectedPlayers.Player disconnected_players = 7;

    pub fn clear_disconnected_players(&mut self) {
        self.disconnected_players.clear();
    }

    // Param is passed by value, moved
    pub fn set_disconnected_players(&mut self, v: ::protobuf::RepeatedField<CMsgConnectedPlayers_Player>) {
        self.disconnected_players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_disconnected_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgConnectedPlayers_Player> {
        &mut self.disconnected_players
    }

    // Take field
    pub fn take_disconnected_players(&mut self) -> ::protobuf::RepeatedField<CMsgConnectedPlayers_Player> {
        ::std::mem::replace(&mut self.disconnected_players, ::protobuf::RepeatedField::new())
    }

    pub fn get_disconnected_players(&self) -> &[CMsgConnectedPlayers_Player] {
        &self.disconnected_players
    }

    fn get_disconnected_players_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgConnectedPlayers_Player> {
        &self.disconnected_players
    }

    fn mut_disconnected_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgConnectedPlayers_Player> {
        &mut self.disconnected_players
    }

    // optional .DOTA_GameState game_state = 2;

    pub fn clear_game_state(&mut self) {
        self.game_state = ::std::option::Option::None;
    }

    pub fn has_game_state(&self) -> bool {
        self.game_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_state(&mut self, v: super::dota_shared_enums::DOTA_GameState) {
        self.game_state = ::std::option::Option::Some(v);
    }

    pub fn get_game_state(&self) -> super::dota_shared_enums::DOTA_GameState {
        self.game_state.unwrap_or(super::dota_shared_enums::DOTA_GameState::DOTA_GAMERULES_STATE_INIT)
    }

    fn get_game_state_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::DOTA_GameState> {
        &self.game_state
    }

    fn mut_game_state_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::DOTA_GameState> {
        &mut self.game_state
    }

    // optional bool first_blood_happened = 6;

    pub fn clear_first_blood_happened(&mut self) {
        self.first_blood_happened = ::std::option::Option::None;
    }

    pub fn has_first_blood_happened(&self) -> bool {
        self.first_blood_happened.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_happened(&mut self, v: bool) {
        self.first_blood_happened = ::std::option::Option::Some(v);
    }

    pub fn get_first_blood_happened(&self) -> bool {
        self.first_blood_happened.unwrap_or(false)
    }

    fn get_first_blood_happened_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.first_blood_happened
    }

    fn mut_first_blood_happened_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.first_blood_happened
    }

    // optional bool legacy_mass_disconnect = 9;

    pub fn clear_legacy_mass_disconnect(&mut self) {
        self.legacy_mass_disconnect = ::std::option::Option::None;
    }

    pub fn has_legacy_mass_disconnect(&self) -> bool {
        self.legacy_mass_disconnect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_mass_disconnect(&mut self, v: bool) {
        self.legacy_mass_disconnect = ::std::option::Option::Some(v);
    }

    pub fn get_legacy_mass_disconnect(&self) -> bool {
        self.legacy_mass_disconnect.unwrap_or(false)
    }

    fn get_legacy_mass_disconnect_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.legacy_mass_disconnect
    }

    fn mut_legacy_mass_disconnect_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.legacy_mass_disconnect
    }

    // optional .CMsgPoorNetworkConditions poor_network_conditions = 10;

    pub fn clear_poor_network_conditions(&mut self) {
        self.poor_network_conditions.clear();
    }

    pub fn has_poor_network_conditions(&self) -> bool {
        self.poor_network_conditions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poor_network_conditions(&mut self, v: CMsgPoorNetworkConditions) {
        self.poor_network_conditions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poor_network_conditions(&mut self) -> &mut CMsgPoorNetworkConditions {
        if self.poor_network_conditions.is_none() {
            self.poor_network_conditions.set_default();
        }
        self.poor_network_conditions.as_mut().unwrap()
    }

    // Take field
    pub fn take_poor_network_conditions(&mut self) -> CMsgPoorNetworkConditions {
        self.poor_network_conditions.take().unwrap_or_else(|| CMsgPoorNetworkConditions::new())
    }

    pub fn get_poor_network_conditions(&self) -> &CMsgPoorNetworkConditions {
        self.poor_network_conditions.as_ref().unwrap_or_else(|| CMsgPoorNetworkConditions::default_instance())
    }

    fn get_poor_network_conditions_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgPoorNetworkConditions> {
        &self.poor_network_conditions
    }

    fn mut_poor_network_conditions_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgPoorNetworkConditions> {
        &mut self.poor_network_conditions
    }

    // optional .CMsgConnectedPlayers.SendReason send_reason = 8;

    pub fn clear_send_reason(&mut self) {
        self.send_reason = ::std::option::Option::None;
    }

    pub fn has_send_reason(&self) -> bool {
        self.send_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_reason(&mut self, v: CMsgConnectedPlayers_SendReason) {
        self.send_reason = ::std::option::Option::Some(v);
    }

    pub fn get_send_reason(&self) -> CMsgConnectedPlayers_SendReason {
        self.send_reason.unwrap_or(CMsgConnectedPlayers_SendReason::INVALID)
    }

    fn get_send_reason_for_reflect(&self) -> &::std::option::Option<CMsgConnectedPlayers_SendReason> {
        &self.send_reason
    }

    fn mut_send_reason_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgConnectedPlayers_SendReason> {
        &mut self.send_reason
    }

    // optional uint32 radiant_kills = 11;

    pub fn clear_radiant_kills(&mut self) {
        self.radiant_kills = ::std::option::Option::None;
    }

    pub fn has_radiant_kills(&self) -> bool {
        self.radiant_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_kills(&mut self, v: u32) {
        self.radiant_kills = ::std::option::Option::Some(v);
    }

    pub fn get_radiant_kills(&self) -> u32 {
        self.radiant_kills.unwrap_or(0)
    }

    fn get_radiant_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.radiant_kills
    }

    fn mut_radiant_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.radiant_kills
    }

    // optional uint32 dire_kills = 12;

    pub fn clear_dire_kills(&mut self) {
        self.dire_kills = ::std::option::Option::None;
    }

    pub fn has_dire_kills(&self) -> bool {
        self.dire_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_kills(&mut self, v: u32) {
        self.dire_kills = ::std::option::Option::Some(v);
    }

    pub fn get_dire_kills(&self) -> u32 {
        self.dire_kills.unwrap_or(0)
    }

    fn get_dire_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.dire_kills
    }

    fn mut_dire_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.dire_kills
    }

    // optional int32 radiant_lead = 14;

    pub fn clear_radiant_lead(&mut self) {
        self.radiant_lead = ::std::option::Option::None;
    }

    pub fn has_radiant_lead(&self) -> bool {
        self.radiant_lead.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_lead(&mut self, v: i32) {
        self.radiant_lead = ::std::option::Option::Some(v);
    }

    pub fn get_radiant_lead(&self) -> i32 {
        self.radiant_lead.unwrap_or(0)
    }

    fn get_radiant_lead_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.radiant_lead
    }

    fn mut_radiant_lead_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.radiant_lead
    }

    // optional uint32 building_state = 15;

    pub fn clear_building_state(&mut self) {
        self.building_state = ::std::option::Option::None;
    }

    pub fn has_building_state(&self) -> bool {
        self.building_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_state(&mut self, v: u32) {
        self.building_state = ::std::option::Option::Some(v);
    }

    pub fn get_building_state(&self) -> u32 {
        self.building_state.unwrap_or(0)
    }

    fn get_building_state_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.building_state
    }

    fn mut_building_state_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.building_state
    }
}

impl ::protobuf::Message for CMsgConnectedPlayers {
    fn is_initialized(&self) -> bool {
        for v in &self.connected_players {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.disconnected_players {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.poor_network_conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.connected_players)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.disconnected_players)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.game_state = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.first_blood_happened = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.legacy_mass_disconnect = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.poor_network_conditions)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.send_reason = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.radiant_kills = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dire_kills = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.radiant_lead = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.building_state = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.connected_players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.disconnected_players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.game_state {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.first_blood_happened {
            my_size += 2;
        }
        if let Some(v) = self.legacy_mass_disconnect {
            my_size += 2;
        }
        if let Some(ref v) = self.poor_network_conditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.send_reason {
            my_size += ::protobuf::rt::enum_size(8, v);
        }
        if let Some(v) = self.radiant_kills {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dire_kills {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.radiant_lead {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.building_state {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.connected_players {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.disconnected_players {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.game_state {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.first_blood_happened {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.legacy_mass_disconnect {
            os.write_bool(9, v)?;
        }
        if let Some(ref v) = self.poor_network_conditions.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.send_reason {
            os.write_enum(8, v.value())?;
        }
        if let Some(v) = self.radiant_kills {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.dire_kills {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.radiant_lead {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.building_state {
            os.write_uint32(15, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgConnectedPlayers {
    fn new() -> CMsgConnectedPlayers {
        CMsgConnectedPlayers::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgConnectedPlayers>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgConnectedPlayers_Player>>(
                    "connected_players",
                    CMsgConnectedPlayers::get_connected_players_for_reflect,
                    CMsgConnectedPlayers::mut_connected_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgConnectedPlayers_Player>>(
                    "disconnected_players",
                    CMsgConnectedPlayers::get_disconnected_players_for_reflect,
                    CMsgConnectedPlayers::mut_disconnected_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::DOTA_GameState>>(
                    "game_state",
                    CMsgConnectedPlayers::get_game_state_for_reflect,
                    CMsgConnectedPlayers::mut_game_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "first_blood_happened",
                    CMsgConnectedPlayers::get_first_blood_happened_for_reflect,
                    CMsgConnectedPlayers::mut_first_blood_happened_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "legacy_mass_disconnect",
                    CMsgConnectedPlayers::get_legacy_mass_disconnect_for_reflect,
                    CMsgConnectedPlayers::mut_legacy_mass_disconnect_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPoorNetworkConditions>>(
                    "poor_network_conditions",
                    CMsgConnectedPlayers::get_poor_network_conditions_for_reflect,
                    CMsgConnectedPlayers::mut_poor_network_conditions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgConnectedPlayers_SendReason>>(
                    "send_reason",
                    CMsgConnectedPlayers::get_send_reason_for_reflect,
                    CMsgConnectedPlayers::mut_send_reason_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "radiant_kills",
                    CMsgConnectedPlayers::get_radiant_kills_for_reflect,
                    CMsgConnectedPlayers::mut_radiant_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dire_kills",
                    CMsgConnectedPlayers::get_dire_kills_for_reflect,
                    CMsgConnectedPlayers::mut_dire_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "radiant_lead",
                    CMsgConnectedPlayers::get_radiant_lead_for_reflect,
                    CMsgConnectedPlayers::mut_radiant_lead_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "building_state",
                    CMsgConnectedPlayers::get_building_state_for_reflect,
                    CMsgConnectedPlayers::mut_building_state_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgConnectedPlayers>(
                    "CMsgConnectedPlayers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgConnectedPlayers {
    fn clear(&mut self) {
        self.clear_connected_players();
        self.clear_disconnected_players();
        self.clear_game_state();
        self.clear_first_blood_happened();
        self.clear_legacy_mass_disconnect();
        self.clear_poor_network_conditions();
        self.clear_send_reason();
        self.clear_radiant_kills();
        self.clear_dire_kills();
        self.clear_radiant_lead();
        self.clear_building_state();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgConnectedPlayers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConnectedPlayers {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgConnectedPlayers_Player {
    // message fields
    steam_id: ::std::option::Option<u64>,
    hero_id: ::std::option::Option<u32>,
    leaver_state: ::protobuf::SingularPtrField<super::dota_gcmessages_common_match_management::CMsgLeaverState>,
    disconnect_reason: ::std::option::Option<super::network_connection::ENetworkDisconnectionReason>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgConnectedPlayers_Player {}

impl CMsgConnectedPlayers_Player {
    pub fn new() -> CMsgConnectedPlayers_Player {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgConnectedPlayers_Player {
        static mut instance: ::protobuf::lazy::Lazy<CMsgConnectedPlayers_Player> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgConnectedPlayers_Player,
        };
        unsafe {
            instance.get(CMsgConnectedPlayers_Player::new)
        }
    }

    // optional fixed64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    fn get_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.steam_id
    }

    fn mut_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.steam_id
    }

    // optional uint32 hero_id = 2;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional .CMsgLeaverState leaver_state = 3;

    pub fn clear_leaver_state(&mut self) {
        self.leaver_state.clear();
    }

    pub fn has_leaver_state(&self) -> bool {
        self.leaver_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaver_state(&mut self, v: super::dota_gcmessages_common_match_management::CMsgLeaverState) {
        self.leaver_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaver_state(&mut self) -> &mut super::dota_gcmessages_common_match_management::CMsgLeaverState {
        if self.leaver_state.is_none() {
            self.leaver_state.set_default();
        }
        self.leaver_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_leaver_state(&mut self) -> super::dota_gcmessages_common_match_management::CMsgLeaverState {
        self.leaver_state.take().unwrap_or_else(|| super::dota_gcmessages_common_match_management::CMsgLeaverState::new())
    }

    pub fn get_leaver_state(&self) -> &super::dota_gcmessages_common_match_management::CMsgLeaverState {
        self.leaver_state.as_ref().unwrap_or_else(|| super::dota_gcmessages_common_match_management::CMsgLeaverState::default_instance())
    }

    fn get_leaver_state_for_reflect(&self) -> &::protobuf::SingularPtrField<super::dota_gcmessages_common_match_management::CMsgLeaverState> {
        &self.leaver_state
    }

    fn mut_leaver_state_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::dota_gcmessages_common_match_management::CMsgLeaverState> {
        &mut self.leaver_state
    }

    // optional .ENetworkDisconnectionReason disconnect_reason = 4;

    pub fn clear_disconnect_reason(&mut self) {
        self.disconnect_reason = ::std::option::Option::None;
    }

    pub fn has_disconnect_reason(&self) -> bool {
        self.disconnect_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disconnect_reason(&mut self, v: super::network_connection::ENetworkDisconnectionReason) {
        self.disconnect_reason = ::std::option::Option::Some(v);
    }

    pub fn get_disconnect_reason(&self) -> super::network_connection::ENetworkDisconnectionReason {
        self.disconnect_reason.unwrap_or(super::network_connection::ENetworkDisconnectionReason::NETWORK_DISCONNECT_INVALID)
    }

    fn get_disconnect_reason_for_reflect(&self) -> &::std::option::Option<super::network_connection::ENetworkDisconnectionReason> {
        &self.disconnect_reason
    }

    fn mut_disconnect_reason_for_reflect(&mut self) -> &mut ::std::option::Option<super::network_connection::ENetworkDisconnectionReason> {
        &mut self.disconnect_reason
    }
}

impl ::protobuf::Message for CMsgConnectedPlayers_Player {
    fn is_initialized(&self) -> bool {
        for v in &self.leaver_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.leaver_state)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.disconnect_reason = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.leaver_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.disconnect_reason {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.leaver_state.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.disconnect_reason {
            os.write_enum(4, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgConnectedPlayers_Player {
    fn new() -> CMsgConnectedPlayers_Player {
        CMsgConnectedPlayers_Player::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgConnectedPlayers_Player>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steam_id",
                    CMsgConnectedPlayers_Player::get_steam_id_for_reflect,
                    CMsgConnectedPlayers_Player::mut_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgConnectedPlayers_Player::get_hero_id_for_reflect,
                    CMsgConnectedPlayers_Player::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common_match_management::CMsgLeaverState>>(
                    "leaver_state",
                    CMsgConnectedPlayers_Player::get_leaver_state_for_reflect,
                    CMsgConnectedPlayers_Player::mut_leaver_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::network_connection::ENetworkDisconnectionReason>>(
                    "disconnect_reason",
                    CMsgConnectedPlayers_Player::get_disconnect_reason_for_reflect,
                    CMsgConnectedPlayers_Player::mut_disconnect_reason_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgConnectedPlayers_Player>(
                    "CMsgConnectedPlayers_Player",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgConnectedPlayers_Player {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_hero_id();
        self.clear_leaver_state();
        self.clear_disconnect_reason();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgConnectedPlayers_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConnectedPlayers_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgConnectedPlayers_SendReason {
    INVALID = 0,
    HEARTBEAT = 1,
    GAME_STATE = 2,
    FIRST_BLOOD = 3,
    PLAYER_CONNECTED = 4,
    PLAYER_HERO = 5,
    PLAYER_DISCONNECTED_CONSEQUENCES = 6,
    PLAYER_DISCONNECTED_NOCONSEQUENCES = 7,
    GAMESTATE_TIMEOUT = 10,
    MASS_DISCONNECT = 11,
    KILLS = 13,
    BUILDING_STATE = 14,
}

impl ::protobuf::ProtobufEnum for CMsgConnectedPlayers_SendReason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgConnectedPlayers_SendReason> {
        match value {
            0 => ::std::option::Option::Some(CMsgConnectedPlayers_SendReason::INVALID),
            1 => ::std::option::Option::Some(CMsgConnectedPlayers_SendReason::HEARTBEAT),
            2 => ::std::option::Option::Some(CMsgConnectedPlayers_SendReason::GAME_STATE),
            3 => ::std::option::Option::Some(CMsgConnectedPlayers_SendReason::FIRST_BLOOD),
            4 => ::std::option::Option::Some(CMsgConnectedPlayers_SendReason::PLAYER_CONNECTED),
            5 => ::std::option::Option::Some(CMsgConnectedPlayers_SendReason::PLAYER_HERO),
            6 => ::std::option::Option::Some(CMsgConnectedPlayers_SendReason::PLAYER_DISCONNECTED_CONSEQUENCES),
            7 => ::std::option::Option::Some(CMsgConnectedPlayers_SendReason::PLAYER_DISCONNECTED_NOCONSEQUENCES),
            10 => ::std::option::Option::Some(CMsgConnectedPlayers_SendReason::GAMESTATE_TIMEOUT),
            11 => ::std::option::Option::Some(CMsgConnectedPlayers_SendReason::MASS_DISCONNECT),
            13 => ::std::option::Option::Some(CMsgConnectedPlayers_SendReason::KILLS),
            14 => ::std::option::Option::Some(CMsgConnectedPlayers_SendReason::BUILDING_STATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgConnectedPlayers_SendReason] = &[
            CMsgConnectedPlayers_SendReason::INVALID,
            CMsgConnectedPlayers_SendReason::HEARTBEAT,
            CMsgConnectedPlayers_SendReason::GAME_STATE,
            CMsgConnectedPlayers_SendReason::FIRST_BLOOD,
            CMsgConnectedPlayers_SendReason::PLAYER_CONNECTED,
            CMsgConnectedPlayers_SendReason::PLAYER_HERO,
            CMsgConnectedPlayers_SendReason::PLAYER_DISCONNECTED_CONSEQUENCES,
            CMsgConnectedPlayers_SendReason::PLAYER_DISCONNECTED_NOCONSEQUENCES,
            CMsgConnectedPlayers_SendReason::GAMESTATE_TIMEOUT,
            CMsgConnectedPlayers_SendReason::MASS_DISCONNECT,
            CMsgConnectedPlayers_SendReason::KILLS,
            CMsgConnectedPlayers_SendReason::BUILDING_STATE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgConnectedPlayers_SendReason>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgConnectedPlayers_SendReason", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgConnectedPlayers_SendReason {
}

impl ::protobuf::reflect::ProtobufValue for CMsgConnectedPlayers_SendReason {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerInfo {
    // message fields
    server_public_ip_addr: ::std::option::Option<u32>,
    server_private_ip_addr: ::std::option::Option<u32>,
    server_port: ::std::option::Option<u32>,
    server_tv_port: ::std::option::Option<u32>,
    assigned_server_tv_port: ::std::option::Option<u32>,
    server_steamdatagram_port: ::std::option::Option<u32>,
    server_key: ::protobuf::SingularField<::std::string::String>,
    server_hibernation: ::std::option::Option<bool>,
    server_type: ::std::option::Option<CMsgGameServerInfo_ServerType>,
    server_region: ::std::option::Option<u32>,
    server_loadavg: ::std::option::Option<f32>,
    server_tv_broadcast_time: ::std::option::Option<f32>,
    server_game_time: ::std::option::Option<f32>,
    server_relay_connected_steam_id: ::std::option::Option<u64>,
    relay_slots_max: ::std::option::Option<u32>,
    relays_connected: ::std::option::Option<i32>,
    relay_clients_connected: ::std::option::Option<i32>,
    relayed_game_server_steam_id: ::std::option::Option<u64>,
    parent_relay_count: ::std::option::Option<u32>,
    tv_secret_code: ::std::option::Option<u64>,
    server_version: ::std::option::Option<u32>,
    server_cluster: ::std::option::Option<u32>,
    allow_custom_games: ::std::option::Option<CMsgGameServerInfo_CustomGames>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameServerInfo {}

impl CMsgGameServerInfo {
    pub fn new() -> CMsgGameServerInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameServerInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameServerInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameServerInfo,
        };
        unsafe {
            instance.get(CMsgGameServerInfo::new)
        }
    }

    // optional fixed32 server_public_ip_addr = 1;

    pub fn clear_server_public_ip_addr(&mut self) {
        self.server_public_ip_addr = ::std::option::Option::None;
    }

    pub fn has_server_public_ip_addr(&self) -> bool {
        self.server_public_ip_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_public_ip_addr(&mut self, v: u32) {
        self.server_public_ip_addr = ::std::option::Option::Some(v);
    }

    pub fn get_server_public_ip_addr(&self) -> u32 {
        self.server_public_ip_addr.unwrap_or(0)
    }

    fn get_server_public_ip_addr_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_public_ip_addr
    }

    fn mut_server_public_ip_addr_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_public_ip_addr
    }

    // optional fixed32 server_private_ip_addr = 2;

    pub fn clear_server_private_ip_addr(&mut self) {
        self.server_private_ip_addr = ::std::option::Option::None;
    }

    pub fn has_server_private_ip_addr(&self) -> bool {
        self.server_private_ip_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_private_ip_addr(&mut self, v: u32) {
        self.server_private_ip_addr = ::std::option::Option::Some(v);
    }

    pub fn get_server_private_ip_addr(&self) -> u32 {
        self.server_private_ip_addr.unwrap_or(0)
    }

    fn get_server_private_ip_addr_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_private_ip_addr
    }

    fn mut_server_private_ip_addr_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_private_ip_addr
    }

    // optional uint32 server_port = 3;

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    pub fn get_server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    fn get_server_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_port
    }

    fn mut_server_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_port
    }

    // optional uint32 server_tv_port = 4;

    pub fn clear_server_tv_port(&mut self) {
        self.server_tv_port = ::std::option::Option::None;
    }

    pub fn has_server_tv_port(&self) -> bool {
        self.server_tv_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_tv_port(&mut self, v: u32) {
        self.server_tv_port = ::std::option::Option::Some(v);
    }

    pub fn get_server_tv_port(&self) -> u32 {
        self.server_tv_port.unwrap_or(0)
    }

    fn get_server_tv_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_tv_port
    }

    fn mut_server_tv_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_tv_port
    }

    // optional uint32 assigned_server_tv_port = 22;

    pub fn clear_assigned_server_tv_port(&mut self) {
        self.assigned_server_tv_port = ::std::option::Option::None;
    }

    pub fn has_assigned_server_tv_port(&self) -> bool {
        self.assigned_server_tv_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assigned_server_tv_port(&mut self, v: u32) {
        self.assigned_server_tv_port = ::std::option::Option::Some(v);
    }

    pub fn get_assigned_server_tv_port(&self) -> u32 {
        self.assigned_server_tv_port.unwrap_or(0)
    }

    fn get_assigned_server_tv_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.assigned_server_tv_port
    }

    fn mut_assigned_server_tv_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.assigned_server_tv_port
    }

    // optional uint32 server_steamdatagram_port = 21;

    pub fn clear_server_steamdatagram_port(&mut self) {
        self.server_steamdatagram_port = ::std::option::Option::None;
    }

    pub fn has_server_steamdatagram_port(&self) -> bool {
        self.server_steamdatagram_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steamdatagram_port(&mut self, v: u32) {
        self.server_steamdatagram_port = ::std::option::Option::Some(v);
    }

    pub fn get_server_steamdatagram_port(&self) -> u32 {
        self.server_steamdatagram_port.unwrap_or(0)
    }

    fn get_server_steamdatagram_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_steamdatagram_port
    }

    fn mut_server_steamdatagram_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_steamdatagram_port
    }

    // optional string server_key = 5;

    pub fn clear_server_key(&mut self) {
        self.server_key.clear();
    }

    pub fn has_server_key(&self) -> bool {
        self.server_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_key(&mut self, v: ::std::string::String) {
        self.server_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_key(&mut self) -> &mut ::std::string::String {
        if self.server_key.is_none() {
            self.server_key.set_default();
        }
        self.server_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_key(&mut self) -> ::std::string::String {
        self.server_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_server_key(&self) -> &str {
        match self.server_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_server_key_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.server_key
    }

    fn mut_server_key_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.server_key
    }

    // optional bool server_hibernation = 6;

    pub fn clear_server_hibernation(&mut self) {
        self.server_hibernation = ::std::option::Option::None;
    }

    pub fn has_server_hibernation(&self) -> bool {
        self.server_hibernation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_hibernation(&mut self, v: bool) {
        self.server_hibernation = ::std::option::Option::Some(v);
    }

    pub fn get_server_hibernation(&self) -> bool {
        self.server_hibernation.unwrap_or(false)
    }

    fn get_server_hibernation_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.server_hibernation
    }

    fn mut_server_hibernation_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.server_hibernation
    }

    // optional .CMsgGameServerInfo.ServerType server_type = 7;

    pub fn clear_server_type(&mut self) {
        self.server_type = ::std::option::Option::None;
    }

    pub fn has_server_type(&self) -> bool {
        self.server_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_type(&mut self, v: CMsgGameServerInfo_ServerType) {
        self.server_type = ::std::option::Option::Some(v);
    }

    pub fn get_server_type(&self) -> CMsgGameServerInfo_ServerType {
        self.server_type.unwrap_or(CMsgGameServerInfo_ServerType::UNSPECIFIED)
    }

    fn get_server_type_for_reflect(&self) -> &::std::option::Option<CMsgGameServerInfo_ServerType> {
        &self.server_type
    }

    fn mut_server_type_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgGameServerInfo_ServerType> {
        &mut self.server_type
    }

    // optional uint32 server_region = 8;

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    pub fn get_server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    fn get_server_region_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_region
    }

    fn mut_server_region_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_region
    }

    // optional float server_loadavg = 9;

    pub fn clear_server_loadavg(&mut self) {
        self.server_loadavg = ::std::option::Option::None;
    }

    pub fn has_server_loadavg(&self) -> bool {
        self.server_loadavg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_loadavg(&mut self, v: f32) {
        self.server_loadavg = ::std::option::Option::Some(v);
    }

    pub fn get_server_loadavg(&self) -> f32 {
        self.server_loadavg.unwrap_or(0.)
    }

    fn get_server_loadavg_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.server_loadavg
    }

    fn mut_server_loadavg_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.server_loadavg
    }

    // optional float server_tv_broadcast_time = 10;

    pub fn clear_server_tv_broadcast_time(&mut self) {
        self.server_tv_broadcast_time = ::std::option::Option::None;
    }

    pub fn has_server_tv_broadcast_time(&self) -> bool {
        self.server_tv_broadcast_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_tv_broadcast_time(&mut self, v: f32) {
        self.server_tv_broadcast_time = ::std::option::Option::Some(v);
    }

    pub fn get_server_tv_broadcast_time(&self) -> f32 {
        self.server_tv_broadcast_time.unwrap_or(0.)
    }

    fn get_server_tv_broadcast_time_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.server_tv_broadcast_time
    }

    fn mut_server_tv_broadcast_time_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.server_tv_broadcast_time
    }

    // optional float server_game_time = 11;

    pub fn clear_server_game_time(&mut self) {
        self.server_game_time = ::std::option::Option::None;
    }

    pub fn has_server_game_time(&self) -> bool {
        self.server_game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_game_time(&mut self, v: f32) {
        self.server_game_time = ::std::option::Option::Some(v);
    }

    pub fn get_server_game_time(&self) -> f32 {
        self.server_game_time.unwrap_or(0.)
    }

    fn get_server_game_time_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.server_game_time
    }

    fn mut_server_game_time_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.server_game_time
    }

    // optional fixed64 server_relay_connected_steam_id = 12;

    pub fn clear_server_relay_connected_steam_id(&mut self) {
        self.server_relay_connected_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_relay_connected_steam_id(&self) -> bool {
        self.server_relay_connected_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_relay_connected_steam_id(&mut self, v: u64) {
        self.server_relay_connected_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_server_relay_connected_steam_id(&self) -> u64 {
        self.server_relay_connected_steam_id.unwrap_or(0)
    }

    fn get_server_relay_connected_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.server_relay_connected_steam_id
    }

    fn mut_server_relay_connected_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.server_relay_connected_steam_id
    }

    // optional uint32 relay_slots_max = 13;

    pub fn clear_relay_slots_max(&mut self) {
        self.relay_slots_max = ::std::option::Option::None;
    }

    pub fn has_relay_slots_max(&self) -> bool {
        self.relay_slots_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_slots_max(&mut self, v: u32) {
        self.relay_slots_max = ::std::option::Option::Some(v);
    }

    pub fn get_relay_slots_max(&self) -> u32 {
        self.relay_slots_max.unwrap_or(0)
    }

    fn get_relay_slots_max_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.relay_slots_max
    }

    fn mut_relay_slots_max_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.relay_slots_max
    }

    // optional int32 relays_connected = 14;

    pub fn clear_relays_connected(&mut self) {
        self.relays_connected = ::std::option::Option::None;
    }

    pub fn has_relays_connected(&self) -> bool {
        self.relays_connected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relays_connected(&mut self, v: i32) {
        self.relays_connected = ::std::option::Option::Some(v);
    }

    pub fn get_relays_connected(&self) -> i32 {
        self.relays_connected.unwrap_or(0)
    }

    fn get_relays_connected_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.relays_connected
    }

    fn mut_relays_connected_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.relays_connected
    }

    // optional int32 relay_clients_connected = 15;

    pub fn clear_relay_clients_connected(&mut self) {
        self.relay_clients_connected = ::std::option::Option::None;
    }

    pub fn has_relay_clients_connected(&self) -> bool {
        self.relay_clients_connected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_clients_connected(&mut self, v: i32) {
        self.relay_clients_connected = ::std::option::Option::Some(v);
    }

    pub fn get_relay_clients_connected(&self) -> i32 {
        self.relay_clients_connected.unwrap_or(0)
    }

    fn get_relay_clients_connected_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.relay_clients_connected
    }

    fn mut_relay_clients_connected_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.relay_clients_connected
    }

    // optional fixed64 relayed_game_server_steam_id = 16;

    pub fn clear_relayed_game_server_steam_id(&mut self) {
        self.relayed_game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_relayed_game_server_steam_id(&self) -> bool {
        self.relayed_game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relayed_game_server_steam_id(&mut self, v: u64) {
        self.relayed_game_server_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_relayed_game_server_steam_id(&self) -> u64 {
        self.relayed_game_server_steam_id.unwrap_or(0)
    }

    fn get_relayed_game_server_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.relayed_game_server_steam_id
    }

    fn mut_relayed_game_server_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.relayed_game_server_steam_id
    }

    // optional uint32 parent_relay_count = 17;

    pub fn clear_parent_relay_count(&mut self) {
        self.parent_relay_count = ::std::option::Option::None;
    }

    pub fn has_parent_relay_count(&self) -> bool {
        self.parent_relay_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_relay_count(&mut self, v: u32) {
        self.parent_relay_count = ::std::option::Option::Some(v);
    }

    pub fn get_parent_relay_count(&self) -> u32 {
        self.parent_relay_count.unwrap_or(0)
    }

    fn get_parent_relay_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.parent_relay_count
    }

    fn mut_parent_relay_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.parent_relay_count
    }

    // optional fixed64 tv_secret_code = 18;

    pub fn clear_tv_secret_code(&mut self) {
        self.tv_secret_code = ::std::option::Option::None;
    }

    pub fn has_tv_secret_code(&self) -> bool {
        self.tv_secret_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_secret_code(&mut self, v: u64) {
        self.tv_secret_code = ::std::option::Option::Some(v);
    }

    pub fn get_tv_secret_code(&self) -> u64 {
        self.tv_secret_code.unwrap_or(0)
    }

    fn get_tv_secret_code_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.tv_secret_code
    }

    fn mut_tv_secret_code_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.tv_secret_code
    }

    // optional uint32 server_version = 19;

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    pub fn get_server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    fn get_server_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_version
    }

    fn mut_server_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_version
    }

    // optional uint32 server_cluster = 20;

    pub fn clear_server_cluster(&mut self) {
        self.server_cluster = ::std::option::Option::None;
    }

    pub fn has_server_cluster(&self) -> bool {
        self.server_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_cluster(&mut self, v: u32) {
        self.server_cluster = ::std::option::Option::Some(v);
    }

    pub fn get_server_cluster(&self) -> u32 {
        self.server_cluster.unwrap_or(0)
    }

    fn get_server_cluster_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_cluster
    }

    fn mut_server_cluster_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_cluster
    }

    // optional .CMsgGameServerInfo.CustomGames allow_custom_games = 23;

    pub fn clear_allow_custom_games(&mut self) {
        self.allow_custom_games = ::std::option::Option::None;
    }

    pub fn has_allow_custom_games(&self) -> bool {
        self.allow_custom_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_custom_games(&mut self, v: CMsgGameServerInfo_CustomGames) {
        self.allow_custom_games = ::std::option::Option::Some(v);
    }

    pub fn get_allow_custom_games(&self) -> CMsgGameServerInfo_CustomGames {
        self.allow_custom_games.unwrap_or(CMsgGameServerInfo_CustomGames::BOTH)
    }

    fn get_allow_custom_games_for_reflect(&self) -> &::std::option::Option<CMsgGameServerInfo_CustomGames> {
        &self.allow_custom_games
    }

    fn mut_allow_custom_games_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgGameServerInfo_CustomGames> {
        &mut self.allow_custom_games
    }
}

impl ::protobuf::Message for CMsgGameServerInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_public_ip_addr = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_private_ip_addr = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_port = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_tv_port = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.assigned_server_tv_port = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_steamdatagram_port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.server_key)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.server_hibernation = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.server_type = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_region = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.server_loadavg = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.server_tv_broadcast_time = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.server_game_time = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.server_relay_connected_steam_id = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.relay_slots_max = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.relays_connected = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.relay_clients_connected = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.relayed_game_server_steam_id = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.parent_relay_count = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.tv_secret_code = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_version = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_cluster = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.allow_custom_games = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_public_ip_addr {
            my_size += 5;
        }
        if let Some(v) = self.server_private_ip_addr {
            my_size += 5;
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_tv_port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.assigned_server_tv_port {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_steamdatagram_port {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.server_key.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.server_hibernation {
            my_size += 2;
        }
        if let Some(v) = self.server_type {
            my_size += ::protobuf::rt::enum_size(7, v);
        }
        if let Some(v) = self.server_region {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_loadavg {
            my_size += 5;
        }
        if let Some(v) = self.server_tv_broadcast_time {
            my_size += 5;
        }
        if let Some(v) = self.server_game_time {
            my_size += 5;
        }
        if let Some(v) = self.server_relay_connected_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.relay_slots_max {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.relays_connected {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.relay_clients_connected {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.relayed_game_server_steam_id {
            my_size += 10;
        }
        if let Some(v) = self.parent_relay_count {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_secret_code {
            my_size += 10;
        }
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_cluster {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.allow_custom_games {
            my_size += ::protobuf::rt::enum_size(23, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_public_ip_addr {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.server_private_ip_addr {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.server_tv_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.assigned_server_tv_port {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.server_steamdatagram_port {
            os.write_uint32(21, v)?;
        }
        if let Some(ref v) = self.server_key.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.server_hibernation {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.server_type {
            os.write_enum(7, v.value())?;
        }
        if let Some(v) = self.server_region {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.server_loadavg {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.server_tv_broadcast_time {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.server_game_time {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.server_relay_connected_steam_id {
            os.write_fixed64(12, v)?;
        }
        if let Some(v) = self.relay_slots_max {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.relays_connected {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.relay_clients_connected {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.relayed_game_server_steam_id {
            os.write_fixed64(16, v)?;
        }
        if let Some(v) = self.parent_relay_count {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.tv_secret_code {
            os.write_fixed64(18, v)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.server_cluster {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.allow_custom_games {
            os.write_enum(23, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameServerInfo {
    fn new() -> CMsgGameServerInfo {
        CMsgGameServerInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameServerInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "server_public_ip_addr",
                    CMsgGameServerInfo::get_server_public_ip_addr_for_reflect,
                    CMsgGameServerInfo::mut_server_public_ip_addr_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "server_private_ip_addr",
                    CMsgGameServerInfo::get_server_private_ip_addr_for_reflect,
                    CMsgGameServerInfo::mut_server_private_ip_addr_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_port",
                    CMsgGameServerInfo::get_server_port_for_reflect,
                    CMsgGameServerInfo::mut_server_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_tv_port",
                    CMsgGameServerInfo::get_server_tv_port_for_reflect,
                    CMsgGameServerInfo::mut_server_tv_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "assigned_server_tv_port",
                    CMsgGameServerInfo::get_assigned_server_tv_port_for_reflect,
                    CMsgGameServerInfo::mut_assigned_server_tv_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_steamdatagram_port",
                    CMsgGameServerInfo::get_server_steamdatagram_port_for_reflect,
                    CMsgGameServerInfo::mut_server_steamdatagram_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "server_key",
                    CMsgGameServerInfo::get_server_key_for_reflect,
                    CMsgGameServerInfo::mut_server_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "server_hibernation",
                    CMsgGameServerInfo::get_server_hibernation_for_reflect,
                    CMsgGameServerInfo::mut_server_hibernation_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGameServerInfo_ServerType>>(
                    "server_type",
                    CMsgGameServerInfo::get_server_type_for_reflect,
                    CMsgGameServerInfo::mut_server_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_region",
                    CMsgGameServerInfo::get_server_region_for_reflect,
                    CMsgGameServerInfo::mut_server_region_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "server_loadavg",
                    CMsgGameServerInfo::get_server_loadavg_for_reflect,
                    CMsgGameServerInfo::mut_server_loadavg_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "server_tv_broadcast_time",
                    CMsgGameServerInfo::get_server_tv_broadcast_time_for_reflect,
                    CMsgGameServerInfo::mut_server_tv_broadcast_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "server_game_time",
                    CMsgGameServerInfo::get_server_game_time_for_reflect,
                    CMsgGameServerInfo::mut_server_game_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "server_relay_connected_steam_id",
                    CMsgGameServerInfo::get_server_relay_connected_steam_id_for_reflect,
                    CMsgGameServerInfo::mut_server_relay_connected_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "relay_slots_max",
                    CMsgGameServerInfo::get_relay_slots_max_for_reflect,
                    CMsgGameServerInfo::mut_relay_slots_max_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "relays_connected",
                    CMsgGameServerInfo::get_relays_connected_for_reflect,
                    CMsgGameServerInfo::mut_relays_connected_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "relay_clients_connected",
                    CMsgGameServerInfo::get_relay_clients_connected_for_reflect,
                    CMsgGameServerInfo::mut_relay_clients_connected_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "relayed_game_server_steam_id",
                    CMsgGameServerInfo::get_relayed_game_server_steam_id_for_reflect,
                    CMsgGameServerInfo::mut_relayed_game_server_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "parent_relay_count",
                    CMsgGameServerInfo::get_parent_relay_count_for_reflect,
                    CMsgGameServerInfo::mut_parent_relay_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "tv_secret_code",
                    CMsgGameServerInfo::get_tv_secret_code_for_reflect,
                    CMsgGameServerInfo::mut_tv_secret_code_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_version",
                    CMsgGameServerInfo::get_server_version_for_reflect,
                    CMsgGameServerInfo::mut_server_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_cluster",
                    CMsgGameServerInfo::get_server_cluster_for_reflect,
                    CMsgGameServerInfo::mut_server_cluster_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGameServerInfo_CustomGames>>(
                    "allow_custom_games",
                    CMsgGameServerInfo::get_allow_custom_games_for_reflect,
                    CMsgGameServerInfo::mut_allow_custom_games_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameServerInfo>(
                    "CMsgGameServerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameServerInfo {
    fn clear(&mut self) {
        self.clear_server_public_ip_addr();
        self.clear_server_private_ip_addr();
        self.clear_server_port();
        self.clear_server_tv_port();
        self.clear_assigned_server_tv_port();
        self.clear_server_steamdatagram_port();
        self.clear_server_key();
        self.clear_server_hibernation();
        self.clear_server_type();
        self.clear_server_region();
        self.clear_server_loadavg();
        self.clear_server_tv_broadcast_time();
        self.clear_server_game_time();
        self.clear_server_relay_connected_steam_id();
        self.clear_relay_slots_max();
        self.clear_relays_connected();
        self.clear_relay_clients_connected();
        self.clear_relayed_game_server_steam_id();
        self.clear_parent_relay_count();
        self.clear_tv_secret_code();
        self.clear_server_version();
        self.clear_server_cluster();
        self.clear_allow_custom_games();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGameServerInfo_ServerType {
    UNSPECIFIED = 0,
    GAME = 1,
    PROXY = 2,
}

impl ::protobuf::ProtobufEnum for CMsgGameServerInfo_ServerType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGameServerInfo_ServerType> {
        match value {
            0 => ::std::option::Option::Some(CMsgGameServerInfo_ServerType::UNSPECIFIED),
            1 => ::std::option::Option::Some(CMsgGameServerInfo_ServerType::GAME),
            2 => ::std::option::Option::Some(CMsgGameServerInfo_ServerType::PROXY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGameServerInfo_ServerType] = &[
            CMsgGameServerInfo_ServerType::UNSPECIFIED,
            CMsgGameServerInfo_ServerType::GAME,
            CMsgGameServerInfo_ServerType::PROXY,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgGameServerInfo_ServerType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgGameServerInfo_ServerType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgGameServerInfo_ServerType {
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerInfo_ServerType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGameServerInfo_CustomGames {
    BOTH = 0,
    NONE = 1,
    ONLY = 2,
}

impl ::protobuf::ProtobufEnum for CMsgGameServerInfo_CustomGames {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGameServerInfo_CustomGames> {
        match value {
            0 => ::std::option::Option::Some(CMsgGameServerInfo_CustomGames::BOTH),
            1 => ::std::option::Option::Some(CMsgGameServerInfo_CustomGames::NONE),
            2 => ::std::option::Option::Some(CMsgGameServerInfo_CustomGames::ONLY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGameServerInfo_CustomGames] = &[
            CMsgGameServerInfo_CustomGames::BOTH,
            CMsgGameServerInfo_CustomGames::NONE,
            CMsgGameServerInfo_CustomGames::ONLY,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgGameServerInfo_CustomGames>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgGameServerInfo_CustomGames", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgGameServerInfo_CustomGames {
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerInfo_CustomGames {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLeaverDetected {
    // message fields
    steam_id: ::std::option::Option<u64>,
    leaver_status: ::std::option::Option<super::dota_shared_enums::DOTALeaverStatus_t>,
    leaver_state: ::protobuf::SingularPtrField<super::dota_gcmessages_common_match_management::CMsgLeaverState>,
    server_cluster: ::std::option::Option<u32>,
    disconnect_reason: ::std::option::Option<super::network_connection::ENetworkDisconnectionReason>,
    poor_network_conditions: ::protobuf::SingularPtrField<CMsgPoorNetworkConditions>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgLeaverDetected {}

impl CMsgLeaverDetected {
    pub fn new() -> CMsgLeaverDetected {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgLeaverDetected {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLeaverDetected> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLeaverDetected,
        };
        unsafe {
            instance.get(CMsgLeaverDetected::new)
        }
    }

    // optional fixed64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    fn get_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.steam_id
    }

    fn mut_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.steam_id
    }

    // optional .DOTALeaverStatus_t leaver_status = 2;

    pub fn clear_leaver_status(&mut self) {
        self.leaver_status = ::std::option::Option::None;
    }

    pub fn has_leaver_status(&self) -> bool {
        self.leaver_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaver_status(&mut self, v: super::dota_shared_enums::DOTALeaverStatus_t) {
        self.leaver_status = ::std::option::Option::Some(v);
    }

    pub fn get_leaver_status(&self) -> super::dota_shared_enums::DOTALeaverStatus_t {
        self.leaver_status.unwrap_or(super::dota_shared_enums::DOTALeaverStatus_t::DOTA_LEAVER_NONE)
    }

    fn get_leaver_status_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::DOTALeaverStatus_t> {
        &self.leaver_status
    }

    fn mut_leaver_status_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::DOTALeaverStatus_t> {
        &mut self.leaver_status
    }

    // optional .CMsgLeaverState leaver_state = 4;

    pub fn clear_leaver_state(&mut self) {
        self.leaver_state.clear();
    }

    pub fn has_leaver_state(&self) -> bool {
        self.leaver_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaver_state(&mut self, v: super::dota_gcmessages_common_match_management::CMsgLeaverState) {
        self.leaver_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaver_state(&mut self) -> &mut super::dota_gcmessages_common_match_management::CMsgLeaverState {
        if self.leaver_state.is_none() {
            self.leaver_state.set_default();
        }
        self.leaver_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_leaver_state(&mut self) -> super::dota_gcmessages_common_match_management::CMsgLeaverState {
        self.leaver_state.take().unwrap_or_else(|| super::dota_gcmessages_common_match_management::CMsgLeaverState::new())
    }

    pub fn get_leaver_state(&self) -> &super::dota_gcmessages_common_match_management::CMsgLeaverState {
        self.leaver_state.as_ref().unwrap_or_else(|| super::dota_gcmessages_common_match_management::CMsgLeaverState::default_instance())
    }

    fn get_leaver_state_for_reflect(&self) -> &::protobuf::SingularPtrField<super::dota_gcmessages_common_match_management::CMsgLeaverState> {
        &self.leaver_state
    }

    fn mut_leaver_state_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::dota_gcmessages_common_match_management::CMsgLeaverState> {
        &mut self.leaver_state
    }

    // optional uint32 server_cluster = 5;

    pub fn clear_server_cluster(&mut self) {
        self.server_cluster = ::std::option::Option::None;
    }

    pub fn has_server_cluster(&self) -> bool {
        self.server_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_cluster(&mut self, v: u32) {
        self.server_cluster = ::std::option::Option::Some(v);
    }

    pub fn get_server_cluster(&self) -> u32 {
        self.server_cluster.unwrap_or(0)
    }

    fn get_server_cluster_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_cluster
    }

    fn mut_server_cluster_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_cluster
    }

    // optional .ENetworkDisconnectionReason disconnect_reason = 6;

    pub fn clear_disconnect_reason(&mut self) {
        self.disconnect_reason = ::std::option::Option::None;
    }

    pub fn has_disconnect_reason(&self) -> bool {
        self.disconnect_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disconnect_reason(&mut self, v: super::network_connection::ENetworkDisconnectionReason) {
        self.disconnect_reason = ::std::option::Option::Some(v);
    }

    pub fn get_disconnect_reason(&self) -> super::network_connection::ENetworkDisconnectionReason {
        self.disconnect_reason.unwrap_or(super::network_connection::ENetworkDisconnectionReason::NETWORK_DISCONNECT_INVALID)
    }

    fn get_disconnect_reason_for_reflect(&self) -> &::std::option::Option<super::network_connection::ENetworkDisconnectionReason> {
        &self.disconnect_reason
    }

    fn mut_disconnect_reason_for_reflect(&mut self) -> &mut ::std::option::Option<super::network_connection::ENetworkDisconnectionReason> {
        &mut self.disconnect_reason
    }

    // optional .CMsgPoorNetworkConditions poor_network_conditions = 7;

    pub fn clear_poor_network_conditions(&mut self) {
        self.poor_network_conditions.clear();
    }

    pub fn has_poor_network_conditions(&self) -> bool {
        self.poor_network_conditions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poor_network_conditions(&mut self, v: CMsgPoorNetworkConditions) {
        self.poor_network_conditions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poor_network_conditions(&mut self) -> &mut CMsgPoorNetworkConditions {
        if self.poor_network_conditions.is_none() {
            self.poor_network_conditions.set_default();
        }
        self.poor_network_conditions.as_mut().unwrap()
    }

    // Take field
    pub fn take_poor_network_conditions(&mut self) -> CMsgPoorNetworkConditions {
        self.poor_network_conditions.take().unwrap_or_else(|| CMsgPoorNetworkConditions::new())
    }

    pub fn get_poor_network_conditions(&self) -> &CMsgPoorNetworkConditions {
        self.poor_network_conditions.as_ref().unwrap_or_else(|| CMsgPoorNetworkConditions::default_instance())
    }

    fn get_poor_network_conditions_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgPoorNetworkConditions> {
        &self.poor_network_conditions
    }

    fn mut_poor_network_conditions_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgPoorNetworkConditions> {
        &mut self.poor_network_conditions
    }
}

impl ::protobuf::Message for CMsgLeaverDetected {
    fn is_initialized(&self) -> bool {
        for v in &self.leaver_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.poor_network_conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.leaver_status = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.leaver_state)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_cluster = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.disconnect_reason = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.poor_network_conditions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.leaver_status {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.leaver_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.server_cluster {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.disconnect_reason {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(ref v) = self.poor_network_conditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.leaver_status {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.leaver_state.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.server_cluster {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.disconnect_reason {
            os.write_enum(6, v.value())?;
        }
        if let Some(ref v) = self.poor_network_conditions.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgLeaverDetected {
    fn new() -> CMsgLeaverDetected {
        CMsgLeaverDetected::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgLeaverDetected>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steam_id",
                    CMsgLeaverDetected::get_steam_id_for_reflect,
                    CMsgLeaverDetected::mut_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::DOTALeaverStatus_t>>(
                    "leaver_status",
                    CMsgLeaverDetected::get_leaver_status_for_reflect,
                    CMsgLeaverDetected::mut_leaver_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common_match_management::CMsgLeaverState>>(
                    "leaver_state",
                    CMsgLeaverDetected::get_leaver_state_for_reflect,
                    CMsgLeaverDetected::mut_leaver_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_cluster",
                    CMsgLeaverDetected::get_server_cluster_for_reflect,
                    CMsgLeaverDetected::mut_server_cluster_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::network_connection::ENetworkDisconnectionReason>>(
                    "disconnect_reason",
                    CMsgLeaverDetected::get_disconnect_reason_for_reflect,
                    CMsgLeaverDetected::mut_disconnect_reason_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPoorNetworkConditions>>(
                    "poor_network_conditions",
                    CMsgLeaverDetected::get_poor_network_conditions_for_reflect,
                    CMsgLeaverDetected::mut_poor_network_conditions_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLeaverDetected>(
                    "CMsgLeaverDetected",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgLeaverDetected {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_leaver_status();
        self.clear_leaver_state();
        self.clear_server_cluster();
        self.clear_disconnect_reason();
        self.clear_poor_network_conditions();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLeaverDetected {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLeaverDetected {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLeaverDetectedResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgLeaverDetectedResponse {}

impl CMsgLeaverDetectedResponse {
    pub fn new() -> CMsgLeaverDetectedResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgLeaverDetectedResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLeaverDetectedResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLeaverDetectedResponse,
        };
        unsafe {
            instance.get(CMsgLeaverDetectedResponse::new)
        }
    }

    // optional uint32 result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgLeaverDetectedResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgLeaverDetectedResponse {
    fn new() -> CMsgLeaverDetectedResponse {
        CMsgLeaverDetectedResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgLeaverDetectedResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "result",
                    CMsgLeaverDetectedResponse::get_result_for_reflect,
                    CMsgLeaverDetectedResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLeaverDetectedResponse>(
                    "CMsgLeaverDetectedResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgLeaverDetectedResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLeaverDetectedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLeaverDetectedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyFinalPlayerStats {
    // message fields
    stats: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyFinalPlayerStats {}

impl CMsgDOTAFantasyFinalPlayerStats {
    pub fn new() -> CMsgDOTAFantasyFinalPlayerStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyFinalPlayerStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyFinalPlayerStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyFinalPlayerStats,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyFinalPlayerStats::new)
        }
    }

    // repeated .CMsgDOTAFantasyPlayerStats stats = 2;

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats> {
        ::std::mem::replace(&mut self.stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_stats(&self) -> &[super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats] {
        &self.stats
    }

    fn get_stats_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats> {
        &self.stats
    }

    fn mut_stats_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats> {
        &mut self.stats
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyFinalPlayerStats {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.stats {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyFinalPlayerStats {
    fn new() -> CMsgDOTAFantasyFinalPlayerStats {
        CMsgDOTAFantasyFinalPlayerStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyFinalPlayerStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats>>(
                    "stats",
                    CMsgDOTAFantasyFinalPlayerStats::get_stats_for_reflect,
                    CMsgDOTAFantasyFinalPlayerStats::mut_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyFinalPlayerStats>(
                    "CMsgDOTAFantasyFinalPlayerStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyFinalPlayerStats {
    fn clear(&mut self) {
        self.clear_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyFinalPlayerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyFinalPlayerStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLivePlayerStats {
    // message fields
    stats: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLivePlayerStats {}

impl CMsgDOTAFantasyLivePlayerStats {
    pub fn new() -> CMsgDOTAFantasyLivePlayerStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLivePlayerStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLivePlayerStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLivePlayerStats,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLivePlayerStats::new)
        }
    }

    // repeated .CMsgDOTAFantasyPlayerStats stats = 2;

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats> {
        ::std::mem::replace(&mut self.stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_stats(&self) -> &[super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats] {
        &self.stats
    }

    fn get_stats_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats> {
        &self.stats
    }

    fn mut_stats_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats> {
        &mut self.stats
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLivePlayerStats {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.stats {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLivePlayerStats {
    fn new() -> CMsgDOTAFantasyLivePlayerStats {
        CMsgDOTAFantasyLivePlayerStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLivePlayerStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats>>(
                    "stats",
                    CMsgDOTAFantasyLivePlayerStats::get_stats_for_reflect,
                    CMsgDOTAFantasyLivePlayerStats::mut_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLivePlayerStats>(
                    "CMsgDOTAFantasyLivePlayerStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLivePlayerStats {
    fn clear(&mut self) {
        self.clear_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLivePlayerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLivePlayerStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyMatch {
    // message fields
    match_id: ::std::option::Option<u64>,
    league_id: ::std::option::Option<u32>,
    series_id: ::std::option::Option<u32>,
    start_time: ::std::option::Option<u32>,
    series_type: ::std::option::Option<u32>,
    team_1: ::std::option::Option<u32>,
    team_2: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyMatch {}

impl CMsgDOTAFantasyMatch {
    pub fn new() -> CMsgDOTAFantasyMatch {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyMatch {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyMatch> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyMatch,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyMatch::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 league_id = 2;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional uint32 series_id = 3;

    pub fn clear_series_id(&mut self) {
        self.series_id = ::std::option::Option::None;
    }

    pub fn has_series_id(&self) -> bool {
        self.series_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_id(&mut self, v: u32) {
        self.series_id = ::std::option::Option::Some(v);
    }

    pub fn get_series_id(&self) -> u32 {
        self.series_id.unwrap_or(0)
    }

    fn get_series_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.series_id
    }

    fn mut_series_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.series_id
    }

    // optional uint32 start_time = 4;

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    pub fn get_start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    fn get_start_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.start_time
    }

    fn mut_start_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.start_time
    }

    // optional uint32 series_type = 5;

    pub fn clear_series_type(&mut self) {
        self.series_type = ::std::option::Option::None;
    }

    pub fn has_series_type(&self) -> bool {
        self.series_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_type(&mut self, v: u32) {
        self.series_type = ::std::option::Option::Some(v);
    }

    pub fn get_series_type(&self) -> u32 {
        self.series_type.unwrap_or(0)
    }

    fn get_series_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.series_type
    }

    fn mut_series_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.series_type
    }

    // optional uint32 team_1 = 6;

    pub fn clear_team_1(&mut self) {
        self.team_1 = ::std::option::Option::None;
    }

    pub fn has_team_1(&self) -> bool {
        self.team_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_1(&mut self, v: u32) {
        self.team_1 = ::std::option::Option::Some(v);
    }

    pub fn get_team_1(&self) -> u32 {
        self.team_1.unwrap_or(0)
    }

    fn get_team_1_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_1
    }

    fn mut_team_1_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_1
    }

    // optional uint32 team_2 = 7;

    pub fn clear_team_2(&mut self) {
        self.team_2 = ::std::option::Option::None;
    }

    pub fn has_team_2(&self) -> bool {
        self.team_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_2(&mut self, v: u32) {
        self.team_2 = ::std::option::Option::Some(v);
    }

    pub fn get_team_2(&self) -> u32 {
        self.team_2.unwrap_or(0)
    }

    fn get_team_2_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_2
    }

    fn mut_team_2_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_2
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyMatch {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.series_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.series_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_1 = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_2 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.series_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.series_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_1 {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_2 {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.series_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.series_type {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.team_1 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.team_2 {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyMatch {
    fn new() -> CMsgDOTAFantasyMatch {
        CMsgDOTAFantasyMatch::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyMatch>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgDOTAFantasyMatch::get_match_id_for_reflect,
                    CMsgDOTAFantasyMatch::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgDOTAFantasyMatch::get_league_id_for_reflect,
                    CMsgDOTAFantasyMatch::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "series_id",
                    CMsgDOTAFantasyMatch::get_series_id_for_reflect,
                    CMsgDOTAFantasyMatch::mut_series_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "start_time",
                    CMsgDOTAFantasyMatch::get_start_time_for_reflect,
                    CMsgDOTAFantasyMatch::mut_start_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "series_type",
                    CMsgDOTAFantasyMatch::get_series_type_for_reflect,
                    CMsgDOTAFantasyMatch::mut_series_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_1",
                    CMsgDOTAFantasyMatch::get_team_1_for_reflect,
                    CMsgDOTAFantasyMatch::mut_team_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_2",
                    CMsgDOTAFantasyMatch::get_team_2_for_reflect,
                    CMsgDOTAFantasyMatch::mut_team_2_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyMatch>(
                    "CMsgDOTAFantasyMatch",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyMatch {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_league_id();
        self.clear_series_id();
        self.clear_start_time();
        self.clear_series_type();
        self.clear_team_1();
        self.clear_team_2();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyMatch {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCRealtimeStats {
    // message fields
    delayed: ::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgDOTARealtimeGameStatsTerse>,
    current: ::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgDOTARealtimeGameStats>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCRealtimeStats {}

impl CMsgServerToGCRealtimeStats {
    pub fn new() -> CMsgServerToGCRealtimeStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCRealtimeStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCRealtimeStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCRealtimeStats,
        };
        unsafe {
            instance.get(CMsgServerToGCRealtimeStats::new)
        }
    }

    // optional .CMsgDOTARealtimeGameStatsTerse delayed = 1;

    pub fn clear_delayed(&mut self) {
        self.delayed.clear();
    }

    pub fn has_delayed(&self) -> bool {
        self.delayed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delayed(&mut self, v: super::dota_gcmessages_common::CMsgDOTARealtimeGameStatsTerse) {
        self.delayed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delayed(&mut self) -> &mut super::dota_gcmessages_common::CMsgDOTARealtimeGameStatsTerse {
        if self.delayed.is_none() {
            self.delayed.set_default();
        }
        self.delayed.as_mut().unwrap()
    }

    // Take field
    pub fn take_delayed(&mut self) -> super::dota_gcmessages_common::CMsgDOTARealtimeGameStatsTerse {
        self.delayed.take().unwrap_or_else(|| super::dota_gcmessages_common::CMsgDOTARealtimeGameStatsTerse::new())
    }

    pub fn get_delayed(&self) -> &super::dota_gcmessages_common::CMsgDOTARealtimeGameStatsTerse {
        self.delayed.as_ref().unwrap_or_else(|| super::dota_gcmessages_common::CMsgDOTARealtimeGameStatsTerse::default_instance())
    }

    fn get_delayed_for_reflect(&self) -> &::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgDOTARealtimeGameStatsTerse> {
        &self.delayed
    }

    fn mut_delayed_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgDOTARealtimeGameStatsTerse> {
        &mut self.delayed
    }

    // optional .CMsgDOTARealtimeGameStats current = 2;

    pub fn clear_current(&mut self) {
        self.current.clear();
    }

    pub fn has_current(&self) -> bool {
        self.current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: super::dota_gcmessages_common::CMsgDOTARealtimeGameStats) {
        self.current = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current(&mut self) -> &mut super::dota_gcmessages_common::CMsgDOTARealtimeGameStats {
        if self.current.is_none() {
            self.current.set_default();
        }
        self.current.as_mut().unwrap()
    }

    // Take field
    pub fn take_current(&mut self) -> super::dota_gcmessages_common::CMsgDOTARealtimeGameStats {
        self.current.take().unwrap_or_else(|| super::dota_gcmessages_common::CMsgDOTARealtimeGameStats::new())
    }

    pub fn get_current(&self) -> &super::dota_gcmessages_common::CMsgDOTARealtimeGameStats {
        self.current.as_ref().unwrap_or_else(|| super::dota_gcmessages_common::CMsgDOTARealtimeGameStats::default_instance())
    }

    fn get_current_for_reflect(&self) -> &::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgDOTARealtimeGameStats> {
        &self.current
    }

    fn mut_current_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgDOTARealtimeGameStats> {
        &mut self.current
    }
}

impl ::protobuf::Message for CMsgServerToGCRealtimeStats {
    fn is_initialized(&self) -> bool {
        for v in &self.delayed {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.current {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.delayed)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.current)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.delayed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.current.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.delayed.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.current.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCRealtimeStats {
    fn new() -> CMsgServerToGCRealtimeStats {
        CMsgServerToGCRealtimeStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCRealtimeStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMsgDOTARealtimeGameStatsTerse>>(
                    "delayed",
                    CMsgServerToGCRealtimeStats::get_delayed_for_reflect,
                    CMsgServerToGCRealtimeStats::mut_delayed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMsgDOTARealtimeGameStats>>(
                    "current",
                    CMsgServerToGCRealtimeStats::get_current_for_reflect,
                    CMsgServerToGCRealtimeStats::mut_current_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCRealtimeStats>(
                    "CMsgServerToGCRealtimeStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCRealtimeStats {
    fn clear(&mut self) {
        self.clear_delayed();
        self.clear_current();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCRealtimeStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCRealtimeStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToServerRealtimeStatsStartStop {
    // message fields
    delayed: ::std::option::Option<bool>,
    current: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToServerRealtimeStatsStartStop {}

impl CMsgGCToServerRealtimeStatsStartStop {
    pub fn new() -> CMsgGCToServerRealtimeStatsStartStop {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToServerRealtimeStatsStartStop {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToServerRealtimeStatsStartStop> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToServerRealtimeStatsStartStop,
        };
        unsafe {
            instance.get(CMsgGCToServerRealtimeStatsStartStop::new)
        }
    }

    // optional bool delayed = 1;

    pub fn clear_delayed(&mut self) {
        self.delayed = ::std::option::Option::None;
    }

    pub fn has_delayed(&self) -> bool {
        self.delayed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delayed(&mut self, v: bool) {
        self.delayed = ::std::option::Option::Some(v);
    }

    pub fn get_delayed(&self) -> bool {
        self.delayed.unwrap_or(false)
    }

    fn get_delayed_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.delayed
    }

    fn mut_delayed_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.delayed
    }

    // optional bool current = 2;

    pub fn clear_current(&mut self) {
        self.current = ::std::option::Option::None;
    }

    pub fn has_current(&self) -> bool {
        self.current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: bool) {
        self.current = ::std::option::Option::Some(v);
    }

    pub fn get_current(&self) -> bool {
        self.current.unwrap_or(false)
    }

    fn get_current_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.current
    }

    fn mut_current_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.current
    }
}

impl ::protobuf::Message for CMsgGCToServerRealtimeStatsStartStop {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.delayed = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.current = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.delayed {
            my_size += 2;
        }
        if let Some(v) = self.current {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.delayed {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.current {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToServerRealtimeStatsStartStop {
    fn new() -> CMsgGCToServerRealtimeStatsStartStop {
        CMsgGCToServerRealtimeStatsStartStop::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToServerRealtimeStatsStartStop>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "delayed",
                    CMsgGCToServerRealtimeStatsStartStop::get_delayed_for_reflect,
                    CMsgGCToServerRealtimeStatsStartStop::mut_delayed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "current",
                    CMsgGCToServerRealtimeStatsStartStop::get_current_for_reflect,
                    CMsgGCToServerRealtimeStatsStartStop::mut_current_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToServerRealtimeStatsStartStop>(
                    "CMsgGCToServerRealtimeStatsStartStop",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToServerRealtimeStatsStartStop {
    fn clear(&mut self) {
        self.clear_delayed();
        self.clear_current();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToServerRealtimeStatsStartStop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerRealtimeStatsStartStop {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameMatchSignOut {
    // message fields
    match_id: ::std::option::Option<u64>,
    duration: ::std::option::Option<u32>,
    good_guys_win: ::std::option::Option<bool>,
    date: ::std::option::Option<u32>,
    num_players: ::std::vec::Vec<u32>,
    teams: ::protobuf::RepeatedField<CMsgGameMatchSignOut_CTeam>,
    tower_status: ::std::vec::Vec<u32>,
    barracks_status: ::std::vec::Vec<u32>,
    cluster: ::std::option::Option<u32>,
    server_addr: ::protobuf::SingularField<::std::string::String>,
    first_blood_time: ::std::option::Option<u32>,
    game_balance: ::std::option::Option<f32>,
    event_score: ::std::option::Option<u32>,
    picks_bans: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchHeroSelectEvent>,
    fantasy_stats: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats>,
    player_strange_count_adjustments: ::protobuf::RepeatedField<super::econ_gcmessages::CMsgEconPlayerStrangeCountAdjustment>,
    automatic_surrender: ::std::option::Option<bool>,
    server_version: ::std::option::Option<u32>,
    legacy_mass_disconnect: ::std::option::Option<bool>,
    poor_network_conditions: ::protobuf::SingularPtrField<CMsgPoorNetworkConditions>,
    additional_msgs: ::protobuf::RepeatedField<CMsgGameMatchSignOut_CAdditionalSignoutMsg>,
    social_feed_events: ::protobuf::RepeatedField<CMsgGameMatchSignOut_CSocialFeedMatchEvent>,
    average_networth_delta: ::std::option::Option<i32>,
    networth_delta_min10: ::std::option::Option<i32>,
    networth_delta_min20: ::std::option::Option<i32>,
    maximum_losing_networth_lead: ::std::option::Option<i32>,
    average_experience_delta: ::std::option::Option<i32>,
    experience_delta_min10: ::std::option::Option<i32>,
    experience_delta_min20: ::std::option::Option<i32>,
    bonus_gold_winner_min10: ::std::option::Option<i32>,
    bonus_gold_winner_min20: ::std::option::Option<i32>,
    bonus_gold_winner_total: ::std::option::Option<u32>,
    bonus_gold_loser_min10: ::std::option::Option<i32>,
    bonus_gold_loser_min20: ::std::option::Option<i32>,
    bonus_gold_loser_total: ::std::option::Option<u32>,
    custom_game_data: ::protobuf::SingularPtrField<CMsgGameMatchSignOut_CCustomGameData>,
    match_flags: ::std::option::Option<u32>,
    team_scores: ::std::vec::Vec<u32>,
    pre_game_duration: ::std::option::Option<u32>,
    event_game_leaderboard_entries: ::protobuf::RepeatedField<CMsgGameMatchSignOut_EventGameLeaderboardEntry>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameMatchSignOut {}

impl CMsgGameMatchSignOut {
    pub fn new() -> CMsgGameMatchSignOut {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameMatchSignOut {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameMatchSignOut> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameMatchSignOut,
        };
        unsafe {
            instance.get(CMsgGameMatchSignOut::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 duration = 2;

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    pub fn get_duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    fn get_duration_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.duration
    }

    fn mut_duration_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.duration
    }

    // optional bool good_guys_win = 3;

    pub fn clear_good_guys_win(&mut self) {
        self.good_guys_win = ::std::option::Option::None;
    }

    pub fn has_good_guys_win(&self) -> bool {
        self.good_guys_win.is_some()
    }

    // Param is passed by value, moved
    pub fn set_good_guys_win(&mut self, v: bool) {
        self.good_guys_win = ::std::option::Option::Some(v);
    }

    pub fn get_good_guys_win(&self) -> bool {
        self.good_guys_win.unwrap_or(false)
    }

    fn get_good_guys_win_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.good_guys_win
    }

    fn mut_good_guys_win_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.good_guys_win
    }

    // optional fixed32 date = 4;

    pub fn clear_date(&mut self) {
        self.date = ::std::option::Option::None;
    }

    pub fn has_date(&self) -> bool {
        self.date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: u32) {
        self.date = ::std::option::Option::Some(v);
    }

    pub fn get_date(&self) -> u32 {
        self.date.unwrap_or(0)
    }

    fn get_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.date
    }

    fn mut_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.date
    }

    // repeated uint32 num_players = 5;

    pub fn clear_num_players(&mut self) {
        self.num_players.clear();
    }

    // Param is passed by value, moved
    pub fn set_num_players(&mut self, v: ::std::vec::Vec<u32>) {
        self.num_players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_num_players(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.num_players
    }

    // Take field
    pub fn take_num_players(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.num_players, ::std::vec::Vec::new())
    }

    pub fn get_num_players(&self) -> &[u32] {
        &self.num_players
    }

    fn get_num_players_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.num_players
    }

    fn mut_num_players_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.num_players
    }

    // repeated .CMsgGameMatchSignOut.CTeam teams = 6;

    pub fn clear_teams(&mut self) {
        self.teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_teams(&mut self, v: ::protobuf::RepeatedField<CMsgGameMatchSignOut_CTeam>) {
        self.teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_teams(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGameMatchSignOut_CTeam> {
        &mut self.teams
    }

    // Take field
    pub fn take_teams(&mut self) -> ::protobuf::RepeatedField<CMsgGameMatchSignOut_CTeam> {
        ::std::mem::replace(&mut self.teams, ::protobuf::RepeatedField::new())
    }

    pub fn get_teams(&self) -> &[CMsgGameMatchSignOut_CTeam] {
        &self.teams
    }

    fn get_teams_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGameMatchSignOut_CTeam> {
        &self.teams
    }

    fn mut_teams_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGameMatchSignOut_CTeam> {
        &mut self.teams
    }

    // repeated uint32 tower_status = 8;

    pub fn clear_tower_status(&mut self) {
        self.tower_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_tower_status(&mut self, v: ::std::vec::Vec<u32>) {
        self.tower_status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tower_status(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.tower_status
    }

    // Take field
    pub fn take_tower_status(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.tower_status, ::std::vec::Vec::new())
    }

    pub fn get_tower_status(&self) -> &[u32] {
        &self.tower_status
    }

    fn get_tower_status_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.tower_status
    }

    fn mut_tower_status_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.tower_status
    }

    // repeated uint32 barracks_status = 9;

    pub fn clear_barracks_status(&mut self) {
        self.barracks_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_barracks_status(&mut self, v: ::std::vec::Vec<u32>) {
        self.barracks_status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_barracks_status(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.barracks_status
    }

    // Take field
    pub fn take_barracks_status(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.barracks_status, ::std::vec::Vec::new())
    }

    pub fn get_barracks_status(&self) -> &[u32] {
        &self.barracks_status
    }

    fn get_barracks_status_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.barracks_status
    }

    fn mut_barracks_status_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.barracks_status
    }

    // optional uint32 cluster = 10;

    pub fn clear_cluster(&mut self) {
        self.cluster = ::std::option::Option::None;
    }

    pub fn has_cluster(&self) -> bool {
        self.cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: u32) {
        self.cluster = ::std::option::Option::Some(v);
    }

    pub fn get_cluster(&self) -> u32 {
        self.cluster.unwrap_or(0)
    }

    fn get_cluster_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cluster
    }

    fn mut_cluster_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cluster
    }

    // optional string server_addr = 11;

    pub fn clear_server_addr(&mut self) {
        self.server_addr.clear();
    }

    pub fn has_server_addr(&self) -> bool {
        self.server_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_addr(&mut self, v: ::std::string::String) {
        self.server_addr = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_addr(&mut self) -> &mut ::std::string::String {
        if self.server_addr.is_none() {
            self.server_addr.set_default();
        }
        self.server_addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_addr(&mut self) -> ::std::string::String {
        self.server_addr.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_server_addr(&self) -> &str {
        match self.server_addr.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_server_addr_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.server_addr
    }

    fn mut_server_addr_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.server_addr
    }

    // optional uint32 first_blood_time = 12;

    pub fn clear_first_blood_time(&mut self) {
        self.first_blood_time = ::std::option::Option::None;
    }

    pub fn has_first_blood_time(&self) -> bool {
        self.first_blood_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_time(&mut self, v: u32) {
        self.first_blood_time = ::std::option::Option::Some(v);
    }

    pub fn get_first_blood_time(&self) -> u32 {
        self.first_blood_time.unwrap_or(0)
    }

    fn get_first_blood_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.first_blood_time
    }

    fn mut_first_blood_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.first_blood_time
    }

    // optional float game_balance = 13;

    pub fn clear_game_balance(&mut self) {
        self.game_balance = ::std::option::Option::None;
    }

    pub fn has_game_balance(&self) -> bool {
        self.game_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_balance(&mut self, v: f32) {
        self.game_balance = ::std::option::Option::Some(v);
    }

    pub fn get_game_balance(&self) -> f32 {
        self.game_balance.unwrap_or(0.)
    }

    fn get_game_balance_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.game_balance
    }

    fn mut_game_balance_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.game_balance
    }

    // optional uint32 event_score = 14;

    pub fn clear_event_score(&mut self) {
        self.event_score = ::std::option::Option::None;
    }

    pub fn has_event_score(&self) -> bool {
        self.event_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_score(&mut self, v: u32) {
        self.event_score = ::std::option::Option::Some(v);
    }

    pub fn get_event_score(&self) -> u32 {
        self.event_score.unwrap_or(0)
    }

    fn get_event_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_score
    }

    fn mut_event_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_score
    }

    // repeated .CMatchHeroSelectEvent picks_bans = 15;

    pub fn clear_picks_bans(&mut self) {
        self.picks_bans.clear();
    }

    // Param is passed by value, moved
    pub fn set_picks_bans(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchHeroSelectEvent>) {
        self.picks_bans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_picks_bans(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchHeroSelectEvent> {
        &mut self.picks_bans
    }

    // Take field
    pub fn take_picks_bans(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchHeroSelectEvent> {
        ::std::mem::replace(&mut self.picks_bans, ::protobuf::RepeatedField::new())
    }

    pub fn get_picks_bans(&self) -> &[super::dota_gcmessages_common::CMatchHeroSelectEvent] {
        &self.picks_bans
    }

    fn get_picks_bans_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchHeroSelectEvent> {
        &self.picks_bans
    }

    fn mut_picks_bans_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchHeroSelectEvent> {
        &mut self.picks_bans
    }

    // repeated .CMsgDOTAFantasyPlayerStats fantasy_stats = 41;

    pub fn clear_fantasy_stats(&mut self) {
        self.fantasy_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_fantasy_stats(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats>) {
        self.fantasy_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fantasy_stats(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats> {
        &mut self.fantasy_stats
    }

    // Take field
    pub fn take_fantasy_stats(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats> {
        ::std::mem::replace(&mut self.fantasy_stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_fantasy_stats(&self) -> &[super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats] {
        &self.fantasy_stats
    }

    fn get_fantasy_stats_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats> {
        &self.fantasy_stats
    }

    fn mut_fantasy_stats_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats> {
        &mut self.fantasy_stats
    }

    // repeated .CMsgEconPlayerStrangeCountAdjustment player_strange_count_adjustments = 17;

    pub fn clear_player_strange_count_adjustments(&mut self) {
        self.player_strange_count_adjustments.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_strange_count_adjustments(&mut self, v: ::protobuf::RepeatedField<super::econ_gcmessages::CMsgEconPlayerStrangeCountAdjustment>) {
        self.player_strange_count_adjustments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_strange_count_adjustments(&mut self) -> &mut ::protobuf::RepeatedField<super::econ_gcmessages::CMsgEconPlayerStrangeCountAdjustment> {
        &mut self.player_strange_count_adjustments
    }

    // Take field
    pub fn take_player_strange_count_adjustments(&mut self) -> ::protobuf::RepeatedField<super::econ_gcmessages::CMsgEconPlayerStrangeCountAdjustment> {
        ::std::mem::replace(&mut self.player_strange_count_adjustments, ::protobuf::RepeatedField::new())
    }

    pub fn get_player_strange_count_adjustments(&self) -> &[super::econ_gcmessages::CMsgEconPlayerStrangeCountAdjustment] {
        &self.player_strange_count_adjustments
    }

    fn get_player_strange_count_adjustments_for_reflect(&self) -> &::protobuf::RepeatedField<super::econ_gcmessages::CMsgEconPlayerStrangeCountAdjustment> {
        &self.player_strange_count_adjustments
    }

    fn mut_player_strange_count_adjustments_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::econ_gcmessages::CMsgEconPlayerStrangeCountAdjustment> {
        &mut self.player_strange_count_adjustments
    }

    // optional bool automatic_surrender = 18;

    pub fn clear_automatic_surrender(&mut self) {
        self.automatic_surrender = ::std::option::Option::None;
    }

    pub fn has_automatic_surrender(&self) -> bool {
        self.automatic_surrender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_automatic_surrender(&mut self, v: bool) {
        self.automatic_surrender = ::std::option::Option::Some(v);
    }

    pub fn get_automatic_surrender(&self) -> bool {
        self.automatic_surrender.unwrap_or(false)
    }

    fn get_automatic_surrender_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.automatic_surrender
    }

    fn mut_automatic_surrender_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.automatic_surrender
    }

    // optional uint32 server_version = 19;

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    pub fn get_server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    fn get_server_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_version
    }

    fn mut_server_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_version
    }

    // optional bool legacy_mass_disconnect = 21;

    pub fn clear_legacy_mass_disconnect(&mut self) {
        self.legacy_mass_disconnect = ::std::option::Option::None;
    }

    pub fn has_legacy_mass_disconnect(&self) -> bool {
        self.legacy_mass_disconnect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_mass_disconnect(&mut self, v: bool) {
        self.legacy_mass_disconnect = ::std::option::Option::Some(v);
    }

    pub fn get_legacy_mass_disconnect(&self) -> bool {
        self.legacy_mass_disconnect.unwrap_or(false)
    }

    fn get_legacy_mass_disconnect_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.legacy_mass_disconnect
    }

    fn mut_legacy_mass_disconnect_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.legacy_mass_disconnect
    }

    // optional .CMsgPoorNetworkConditions poor_network_conditions = 35;

    pub fn clear_poor_network_conditions(&mut self) {
        self.poor_network_conditions.clear();
    }

    pub fn has_poor_network_conditions(&self) -> bool {
        self.poor_network_conditions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poor_network_conditions(&mut self, v: CMsgPoorNetworkConditions) {
        self.poor_network_conditions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poor_network_conditions(&mut self) -> &mut CMsgPoorNetworkConditions {
        if self.poor_network_conditions.is_none() {
            self.poor_network_conditions.set_default();
        }
        self.poor_network_conditions.as_mut().unwrap()
    }

    // Take field
    pub fn take_poor_network_conditions(&mut self) -> CMsgPoorNetworkConditions {
        self.poor_network_conditions.take().unwrap_or_else(|| CMsgPoorNetworkConditions::new())
    }

    pub fn get_poor_network_conditions(&self) -> &CMsgPoorNetworkConditions {
        self.poor_network_conditions.as_ref().unwrap_or_else(|| CMsgPoorNetworkConditions::default_instance())
    }

    fn get_poor_network_conditions_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgPoorNetworkConditions> {
        &self.poor_network_conditions
    }

    fn mut_poor_network_conditions_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgPoorNetworkConditions> {
        &mut self.poor_network_conditions
    }

    // repeated .CMsgGameMatchSignOut.CAdditionalSignoutMsg additional_msgs = 20;

    pub fn clear_additional_msgs(&mut self) {
        self.additional_msgs.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_msgs(&mut self, v: ::protobuf::RepeatedField<CMsgGameMatchSignOut_CAdditionalSignoutMsg>) {
        self.additional_msgs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additional_msgs(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGameMatchSignOut_CAdditionalSignoutMsg> {
        &mut self.additional_msgs
    }

    // Take field
    pub fn take_additional_msgs(&mut self) -> ::protobuf::RepeatedField<CMsgGameMatchSignOut_CAdditionalSignoutMsg> {
        ::std::mem::replace(&mut self.additional_msgs, ::protobuf::RepeatedField::new())
    }

    pub fn get_additional_msgs(&self) -> &[CMsgGameMatchSignOut_CAdditionalSignoutMsg] {
        &self.additional_msgs
    }

    fn get_additional_msgs_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGameMatchSignOut_CAdditionalSignoutMsg> {
        &self.additional_msgs
    }

    fn mut_additional_msgs_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGameMatchSignOut_CAdditionalSignoutMsg> {
        &mut self.additional_msgs
    }

    // repeated .CMsgGameMatchSignOut.CSocialFeedMatchEvent social_feed_events = 36;

    pub fn clear_social_feed_events(&mut self) {
        self.social_feed_events.clear();
    }

    // Param is passed by value, moved
    pub fn set_social_feed_events(&mut self, v: ::protobuf::RepeatedField<CMsgGameMatchSignOut_CSocialFeedMatchEvent>) {
        self.social_feed_events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_social_feed_events(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGameMatchSignOut_CSocialFeedMatchEvent> {
        &mut self.social_feed_events
    }

    // Take field
    pub fn take_social_feed_events(&mut self) -> ::protobuf::RepeatedField<CMsgGameMatchSignOut_CSocialFeedMatchEvent> {
        ::std::mem::replace(&mut self.social_feed_events, ::protobuf::RepeatedField::new())
    }

    pub fn get_social_feed_events(&self) -> &[CMsgGameMatchSignOut_CSocialFeedMatchEvent] {
        &self.social_feed_events
    }

    fn get_social_feed_events_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGameMatchSignOut_CSocialFeedMatchEvent> {
        &self.social_feed_events
    }

    fn mut_social_feed_events_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGameMatchSignOut_CSocialFeedMatchEvent> {
        &mut self.social_feed_events
    }

    // optional sint32 average_networth_delta = 22;

    pub fn clear_average_networth_delta(&mut self) {
        self.average_networth_delta = ::std::option::Option::None;
    }

    pub fn has_average_networth_delta(&self) -> bool {
        self.average_networth_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_networth_delta(&mut self, v: i32) {
        self.average_networth_delta = ::std::option::Option::Some(v);
    }

    pub fn get_average_networth_delta(&self) -> i32 {
        self.average_networth_delta.unwrap_or(0)
    }

    fn get_average_networth_delta_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.average_networth_delta
    }

    fn mut_average_networth_delta_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.average_networth_delta
    }

    // optional sint32 networth_delta_min10 = 23;

    pub fn clear_networth_delta_min10(&mut self) {
        self.networth_delta_min10 = ::std::option::Option::None;
    }

    pub fn has_networth_delta_min10(&self) -> bool {
        self.networth_delta_min10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_networth_delta_min10(&mut self, v: i32) {
        self.networth_delta_min10 = ::std::option::Option::Some(v);
    }

    pub fn get_networth_delta_min10(&self) -> i32 {
        self.networth_delta_min10.unwrap_or(0)
    }

    fn get_networth_delta_min10_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.networth_delta_min10
    }

    fn mut_networth_delta_min10_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.networth_delta_min10
    }

    // optional sint32 networth_delta_min20 = 24;

    pub fn clear_networth_delta_min20(&mut self) {
        self.networth_delta_min20 = ::std::option::Option::None;
    }

    pub fn has_networth_delta_min20(&self) -> bool {
        self.networth_delta_min20.is_some()
    }

    // Param is passed by value, moved
    pub fn set_networth_delta_min20(&mut self, v: i32) {
        self.networth_delta_min20 = ::std::option::Option::Some(v);
    }

    pub fn get_networth_delta_min20(&self) -> i32 {
        self.networth_delta_min20.unwrap_or(0)
    }

    fn get_networth_delta_min20_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.networth_delta_min20
    }

    fn mut_networth_delta_min20_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.networth_delta_min20
    }

    // optional sint32 maximum_losing_networth_lead = 25;

    pub fn clear_maximum_losing_networth_lead(&mut self) {
        self.maximum_losing_networth_lead = ::std::option::Option::None;
    }

    pub fn has_maximum_losing_networth_lead(&self) -> bool {
        self.maximum_losing_networth_lead.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_losing_networth_lead(&mut self, v: i32) {
        self.maximum_losing_networth_lead = ::std::option::Option::Some(v);
    }

    pub fn get_maximum_losing_networth_lead(&self) -> i32 {
        self.maximum_losing_networth_lead.unwrap_or(0)
    }

    fn get_maximum_losing_networth_lead_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.maximum_losing_networth_lead
    }

    fn mut_maximum_losing_networth_lead_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.maximum_losing_networth_lead
    }

    // optional sint32 average_experience_delta = 26;

    pub fn clear_average_experience_delta(&mut self) {
        self.average_experience_delta = ::std::option::Option::None;
    }

    pub fn has_average_experience_delta(&self) -> bool {
        self.average_experience_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_experience_delta(&mut self, v: i32) {
        self.average_experience_delta = ::std::option::Option::Some(v);
    }

    pub fn get_average_experience_delta(&self) -> i32 {
        self.average_experience_delta.unwrap_or(0)
    }

    fn get_average_experience_delta_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.average_experience_delta
    }

    fn mut_average_experience_delta_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.average_experience_delta
    }

    // optional sint32 experience_delta_min10 = 27;

    pub fn clear_experience_delta_min10(&mut self) {
        self.experience_delta_min10 = ::std::option::Option::None;
    }

    pub fn has_experience_delta_min10(&self) -> bool {
        self.experience_delta_min10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experience_delta_min10(&mut self, v: i32) {
        self.experience_delta_min10 = ::std::option::Option::Some(v);
    }

    pub fn get_experience_delta_min10(&self) -> i32 {
        self.experience_delta_min10.unwrap_or(0)
    }

    fn get_experience_delta_min10_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.experience_delta_min10
    }

    fn mut_experience_delta_min10_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.experience_delta_min10
    }

    // optional sint32 experience_delta_min20 = 28;

    pub fn clear_experience_delta_min20(&mut self) {
        self.experience_delta_min20 = ::std::option::Option::None;
    }

    pub fn has_experience_delta_min20(&self) -> bool {
        self.experience_delta_min20.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experience_delta_min20(&mut self, v: i32) {
        self.experience_delta_min20 = ::std::option::Option::Some(v);
    }

    pub fn get_experience_delta_min20(&self) -> i32 {
        self.experience_delta_min20.unwrap_or(0)
    }

    fn get_experience_delta_min20_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.experience_delta_min20
    }

    fn mut_experience_delta_min20_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.experience_delta_min20
    }

    // optional sint32 bonus_gold_winner_min10 = 29;

    pub fn clear_bonus_gold_winner_min10(&mut self) {
        self.bonus_gold_winner_min10 = ::std::option::Option::None;
    }

    pub fn has_bonus_gold_winner_min10(&self) -> bool {
        self.bonus_gold_winner_min10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_gold_winner_min10(&mut self, v: i32) {
        self.bonus_gold_winner_min10 = ::std::option::Option::Some(v);
    }

    pub fn get_bonus_gold_winner_min10(&self) -> i32 {
        self.bonus_gold_winner_min10.unwrap_or(0)
    }

    fn get_bonus_gold_winner_min10_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.bonus_gold_winner_min10
    }

    fn mut_bonus_gold_winner_min10_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.bonus_gold_winner_min10
    }

    // optional sint32 bonus_gold_winner_min20 = 30;

    pub fn clear_bonus_gold_winner_min20(&mut self) {
        self.bonus_gold_winner_min20 = ::std::option::Option::None;
    }

    pub fn has_bonus_gold_winner_min20(&self) -> bool {
        self.bonus_gold_winner_min20.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_gold_winner_min20(&mut self, v: i32) {
        self.bonus_gold_winner_min20 = ::std::option::Option::Some(v);
    }

    pub fn get_bonus_gold_winner_min20(&self) -> i32 {
        self.bonus_gold_winner_min20.unwrap_or(0)
    }

    fn get_bonus_gold_winner_min20_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.bonus_gold_winner_min20
    }

    fn mut_bonus_gold_winner_min20_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.bonus_gold_winner_min20
    }

    // optional uint32 bonus_gold_winner_total = 31;

    pub fn clear_bonus_gold_winner_total(&mut self) {
        self.bonus_gold_winner_total = ::std::option::Option::None;
    }

    pub fn has_bonus_gold_winner_total(&self) -> bool {
        self.bonus_gold_winner_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_gold_winner_total(&mut self, v: u32) {
        self.bonus_gold_winner_total = ::std::option::Option::Some(v);
    }

    pub fn get_bonus_gold_winner_total(&self) -> u32 {
        self.bonus_gold_winner_total.unwrap_or(0)
    }

    fn get_bonus_gold_winner_total_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.bonus_gold_winner_total
    }

    fn mut_bonus_gold_winner_total_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.bonus_gold_winner_total
    }

    // optional sint32 bonus_gold_loser_min10 = 32;

    pub fn clear_bonus_gold_loser_min10(&mut self) {
        self.bonus_gold_loser_min10 = ::std::option::Option::None;
    }

    pub fn has_bonus_gold_loser_min10(&self) -> bool {
        self.bonus_gold_loser_min10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_gold_loser_min10(&mut self, v: i32) {
        self.bonus_gold_loser_min10 = ::std::option::Option::Some(v);
    }

    pub fn get_bonus_gold_loser_min10(&self) -> i32 {
        self.bonus_gold_loser_min10.unwrap_or(0)
    }

    fn get_bonus_gold_loser_min10_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.bonus_gold_loser_min10
    }

    fn mut_bonus_gold_loser_min10_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.bonus_gold_loser_min10
    }

    // optional sint32 bonus_gold_loser_min20 = 33;

    pub fn clear_bonus_gold_loser_min20(&mut self) {
        self.bonus_gold_loser_min20 = ::std::option::Option::None;
    }

    pub fn has_bonus_gold_loser_min20(&self) -> bool {
        self.bonus_gold_loser_min20.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_gold_loser_min20(&mut self, v: i32) {
        self.bonus_gold_loser_min20 = ::std::option::Option::Some(v);
    }

    pub fn get_bonus_gold_loser_min20(&self) -> i32 {
        self.bonus_gold_loser_min20.unwrap_or(0)
    }

    fn get_bonus_gold_loser_min20_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.bonus_gold_loser_min20
    }

    fn mut_bonus_gold_loser_min20_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.bonus_gold_loser_min20
    }

    // optional uint32 bonus_gold_loser_total = 34;

    pub fn clear_bonus_gold_loser_total(&mut self) {
        self.bonus_gold_loser_total = ::std::option::Option::None;
    }

    pub fn has_bonus_gold_loser_total(&self) -> bool {
        self.bonus_gold_loser_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_gold_loser_total(&mut self, v: u32) {
        self.bonus_gold_loser_total = ::std::option::Option::Some(v);
    }

    pub fn get_bonus_gold_loser_total(&self) -> u32 {
        self.bonus_gold_loser_total.unwrap_or(0)
    }

    fn get_bonus_gold_loser_total_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.bonus_gold_loser_total
    }

    fn mut_bonus_gold_loser_total_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.bonus_gold_loser_total
    }

    // optional .CMsgGameMatchSignOut.CCustomGameData custom_game_data = 37;

    pub fn clear_custom_game_data(&mut self) {
        self.custom_game_data.clear();
    }

    pub fn has_custom_game_data(&self) -> bool {
        self.custom_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_data(&mut self, v: CMsgGameMatchSignOut_CCustomGameData) {
        self.custom_game_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_game_data(&mut self) -> &mut CMsgGameMatchSignOut_CCustomGameData {
        if self.custom_game_data.is_none() {
            self.custom_game_data.set_default();
        }
        self.custom_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_game_data(&mut self) -> CMsgGameMatchSignOut_CCustomGameData {
        self.custom_game_data.take().unwrap_or_else(|| CMsgGameMatchSignOut_CCustomGameData::new())
    }

    pub fn get_custom_game_data(&self) -> &CMsgGameMatchSignOut_CCustomGameData {
        self.custom_game_data.as_ref().unwrap_or_else(|| CMsgGameMatchSignOut_CCustomGameData::default_instance())
    }

    fn get_custom_game_data_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGameMatchSignOut_CCustomGameData> {
        &self.custom_game_data
    }

    fn mut_custom_game_data_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGameMatchSignOut_CCustomGameData> {
        &mut self.custom_game_data
    }

    // optional uint32 match_flags = 38;

    pub fn clear_match_flags(&mut self) {
        self.match_flags = ::std::option::Option::None;
    }

    pub fn has_match_flags(&self) -> bool {
        self.match_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_flags(&mut self, v: u32) {
        self.match_flags = ::std::option::Option::Some(v);
    }

    pub fn get_match_flags(&self) -> u32 {
        self.match_flags.unwrap_or(0)
    }

    fn get_match_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.match_flags
    }

    fn mut_match_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.match_flags
    }

    // repeated uint32 team_scores = 39;

    pub fn clear_team_scores(&mut self) {
        self.team_scores.clear();
    }

    // Param is passed by value, moved
    pub fn set_team_scores(&mut self, v: ::std::vec::Vec<u32>) {
        self.team_scores = v;
    }

    // Mutable pointer to the field.
    pub fn mut_team_scores(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.team_scores
    }

    // Take field
    pub fn take_team_scores(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.team_scores, ::std::vec::Vec::new())
    }

    pub fn get_team_scores(&self) -> &[u32] {
        &self.team_scores
    }

    fn get_team_scores_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.team_scores
    }

    fn mut_team_scores_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.team_scores
    }

    // optional uint32 pre_game_duration = 40;

    pub fn clear_pre_game_duration(&mut self) {
        self.pre_game_duration = ::std::option::Option::None;
    }

    pub fn has_pre_game_duration(&self) -> bool {
        self.pre_game_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pre_game_duration(&mut self, v: u32) {
        self.pre_game_duration = ::std::option::Option::Some(v);
    }

    pub fn get_pre_game_duration(&self) -> u32 {
        self.pre_game_duration.unwrap_or(0)
    }

    fn get_pre_game_duration_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.pre_game_duration
    }

    fn mut_pre_game_duration_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.pre_game_duration
    }

    // repeated .CMsgGameMatchSignOut.EventGameLeaderboardEntry event_game_leaderboard_entries = 42;

    pub fn clear_event_game_leaderboard_entries(&mut self) {
        self.event_game_leaderboard_entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_game_leaderboard_entries(&mut self, v: ::protobuf::RepeatedField<CMsgGameMatchSignOut_EventGameLeaderboardEntry>) {
        self.event_game_leaderboard_entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_event_game_leaderboard_entries(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGameMatchSignOut_EventGameLeaderboardEntry> {
        &mut self.event_game_leaderboard_entries
    }

    // Take field
    pub fn take_event_game_leaderboard_entries(&mut self) -> ::protobuf::RepeatedField<CMsgGameMatchSignOut_EventGameLeaderboardEntry> {
        ::std::mem::replace(&mut self.event_game_leaderboard_entries, ::protobuf::RepeatedField::new())
    }

    pub fn get_event_game_leaderboard_entries(&self) -> &[CMsgGameMatchSignOut_EventGameLeaderboardEntry] {
        &self.event_game_leaderboard_entries
    }

    fn get_event_game_leaderboard_entries_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGameMatchSignOut_EventGameLeaderboardEntry> {
        &self.event_game_leaderboard_entries
    }

    fn mut_event_game_leaderboard_entries_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGameMatchSignOut_EventGameLeaderboardEntry> {
        &mut self.event_game_leaderboard_entries
    }
}

impl ::protobuf::Message for CMsgGameMatchSignOut {
    fn is_initialized(&self) -> bool {
        for v in &self.teams {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.picks_bans {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fantasy_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.player_strange_count_adjustments {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.poor_network_conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.additional_msgs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.social_feed_events {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.custom_game_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.event_game_leaderboard_entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.good_guys_win = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.date = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.num_players)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.teams)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.tower_status)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.barracks_status)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cluster = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.server_addr)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_blood_time = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.game_balance = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_score = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.picks_bans)?;
                },
                41 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fantasy_stats)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_strange_count_adjustments)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.automatic_surrender = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_version = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.legacy_mass_disconnect = ::std::option::Option::Some(tmp);
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.poor_network_conditions)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.additional_msgs)?;
                },
                36 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.social_feed_events)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.average_networth_delta = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.networth_delta_min10 = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.networth_delta_min20 = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.maximum_losing_networth_lead = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.average_experience_delta = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.experience_delta_min10 = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.experience_delta_min20 = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.bonus_gold_winner_min10 = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.bonus_gold_winner_min20 = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bonus_gold_winner_total = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.bonus_gold_loser_min10 = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.bonus_gold_loser_min20 = ::std::option::Option::Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bonus_gold_loser_total = ::std::option::Option::Some(tmp);
                },
                37 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.custom_game_data)?;
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.match_flags = ::std::option::Option::Some(tmp);
                },
                39 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.team_scores)?;
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pre_game_duration = ::std::option::Option::Some(tmp);
                },
                42 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.event_game_leaderboard_entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.good_guys_win {
            my_size += 2;
        }
        if let Some(v) = self.date {
            my_size += 5;
        }
        for value in &self.num_players {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tower_status {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.barracks_status {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.cluster {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.server_addr.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.first_blood_time {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_balance {
            my_size += 5;
        }
        if let Some(v) = self.event_score {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.picks_bans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.fantasy_stats {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.player_strange_count_adjustments {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.automatic_surrender {
            my_size += 3;
        }
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.legacy_mass_disconnect {
            my_size += 3;
        }
        if let Some(ref v) = self.poor_network_conditions.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.additional_msgs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.social_feed_events {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.average_networth_delta {
            my_size += ::protobuf::rt::value_varint_zigzag_size(22, v);
        }
        if let Some(v) = self.networth_delta_min10 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(23, v);
        }
        if let Some(v) = self.networth_delta_min20 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(24, v);
        }
        if let Some(v) = self.maximum_losing_networth_lead {
            my_size += ::protobuf::rt::value_varint_zigzag_size(25, v);
        }
        if let Some(v) = self.average_experience_delta {
            my_size += ::protobuf::rt::value_varint_zigzag_size(26, v);
        }
        if let Some(v) = self.experience_delta_min10 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(27, v);
        }
        if let Some(v) = self.experience_delta_min20 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(28, v);
        }
        if let Some(v) = self.bonus_gold_winner_min10 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(29, v);
        }
        if let Some(v) = self.bonus_gold_winner_min20 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(30, v);
        }
        if let Some(v) = self.bonus_gold_winner_total {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bonus_gold_loser_min10 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(32, v);
        }
        if let Some(v) = self.bonus_gold_loser_min20 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(33, v);
        }
        if let Some(v) = self.bonus_gold_loser_total {
            my_size += ::protobuf::rt::value_size(34, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.custom_game_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.match_flags {
            my_size += ::protobuf::rt::value_size(38, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.team_scores {
            my_size += ::protobuf::rt::value_size(39, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.pre_game_duration {
            my_size += ::protobuf::rt::value_size(40, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.event_game_leaderboard_entries {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.good_guys_win {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.date {
            os.write_fixed32(4, v)?;
        }
        for v in &self.num_players {
            os.write_uint32(5, *v)?;
        };
        for v in &self.teams {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tower_status {
            os.write_uint32(8, *v)?;
        };
        for v in &self.barracks_status {
            os.write_uint32(9, *v)?;
        };
        if let Some(v) = self.cluster {
            os.write_uint32(10, v)?;
        }
        if let Some(ref v) = self.server_addr.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.first_blood_time {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.game_balance {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.event_score {
            os.write_uint32(14, v)?;
        }
        for v in &self.picks_bans {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.fantasy_stats {
            os.write_tag(41, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.player_strange_count_adjustments {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.automatic_surrender {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.legacy_mass_disconnect {
            os.write_bool(21, v)?;
        }
        if let Some(ref v) = self.poor_network_conditions.as_ref() {
            os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.additional_msgs {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.social_feed_events {
            os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.average_networth_delta {
            os.write_sint32(22, v)?;
        }
        if let Some(v) = self.networth_delta_min10 {
            os.write_sint32(23, v)?;
        }
        if let Some(v) = self.networth_delta_min20 {
            os.write_sint32(24, v)?;
        }
        if let Some(v) = self.maximum_losing_networth_lead {
            os.write_sint32(25, v)?;
        }
        if let Some(v) = self.average_experience_delta {
            os.write_sint32(26, v)?;
        }
        if let Some(v) = self.experience_delta_min10 {
            os.write_sint32(27, v)?;
        }
        if let Some(v) = self.experience_delta_min20 {
            os.write_sint32(28, v)?;
        }
        if let Some(v) = self.bonus_gold_winner_min10 {
            os.write_sint32(29, v)?;
        }
        if let Some(v) = self.bonus_gold_winner_min20 {
            os.write_sint32(30, v)?;
        }
        if let Some(v) = self.bonus_gold_winner_total {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.bonus_gold_loser_min10 {
            os.write_sint32(32, v)?;
        }
        if let Some(v) = self.bonus_gold_loser_min20 {
            os.write_sint32(33, v)?;
        }
        if let Some(v) = self.bonus_gold_loser_total {
            os.write_uint32(34, v)?;
        }
        if let Some(ref v) = self.custom_game_data.as_ref() {
            os.write_tag(37, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.match_flags {
            os.write_uint32(38, v)?;
        }
        for v in &self.team_scores {
            os.write_uint32(39, *v)?;
        };
        if let Some(v) = self.pre_game_duration {
            os.write_uint32(40, v)?;
        }
        for v in &self.event_game_leaderboard_entries {
            os.write_tag(42, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameMatchSignOut {
    fn new() -> CMsgGameMatchSignOut {
        CMsgGameMatchSignOut::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameMatchSignOut>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgGameMatchSignOut::get_match_id_for_reflect,
                    CMsgGameMatchSignOut::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "duration",
                    CMsgGameMatchSignOut::get_duration_for_reflect,
                    CMsgGameMatchSignOut::mut_duration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "good_guys_win",
                    CMsgGameMatchSignOut::get_good_guys_win_for_reflect,
                    CMsgGameMatchSignOut::mut_good_guys_win_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "date",
                    CMsgGameMatchSignOut::get_date_for_reflect,
                    CMsgGameMatchSignOut::mut_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_players",
                    CMsgGameMatchSignOut::get_num_players_for_reflect,
                    CMsgGameMatchSignOut::mut_num_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGameMatchSignOut_CTeam>>(
                    "teams",
                    CMsgGameMatchSignOut::get_teams_for_reflect,
                    CMsgGameMatchSignOut::mut_teams_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tower_status",
                    CMsgGameMatchSignOut::get_tower_status_for_reflect,
                    CMsgGameMatchSignOut::mut_tower_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "barracks_status",
                    CMsgGameMatchSignOut::get_barracks_status_for_reflect,
                    CMsgGameMatchSignOut::mut_barracks_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cluster",
                    CMsgGameMatchSignOut::get_cluster_for_reflect,
                    CMsgGameMatchSignOut::mut_cluster_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "server_addr",
                    CMsgGameMatchSignOut::get_server_addr_for_reflect,
                    CMsgGameMatchSignOut::mut_server_addr_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "first_blood_time",
                    CMsgGameMatchSignOut::get_first_blood_time_for_reflect,
                    CMsgGameMatchSignOut::mut_first_blood_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "game_balance",
                    CMsgGameMatchSignOut::get_game_balance_for_reflect,
                    CMsgGameMatchSignOut::mut_game_balance_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_score",
                    CMsgGameMatchSignOut::get_event_score_for_reflect,
                    CMsgGameMatchSignOut::mut_event_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMatchHeroSelectEvent>>(
                    "picks_bans",
                    CMsgGameMatchSignOut::get_picks_bans_for_reflect,
                    CMsgGameMatchSignOut::mut_picks_bans_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats>>(
                    "fantasy_stats",
                    CMsgGameMatchSignOut::get_fantasy_stats_for_reflect,
                    CMsgGameMatchSignOut::mut_fantasy_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::econ_gcmessages::CMsgEconPlayerStrangeCountAdjustment>>(
                    "player_strange_count_adjustments",
                    CMsgGameMatchSignOut::get_player_strange_count_adjustments_for_reflect,
                    CMsgGameMatchSignOut::mut_player_strange_count_adjustments_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "automatic_surrender",
                    CMsgGameMatchSignOut::get_automatic_surrender_for_reflect,
                    CMsgGameMatchSignOut::mut_automatic_surrender_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_version",
                    CMsgGameMatchSignOut::get_server_version_for_reflect,
                    CMsgGameMatchSignOut::mut_server_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "legacy_mass_disconnect",
                    CMsgGameMatchSignOut::get_legacy_mass_disconnect_for_reflect,
                    CMsgGameMatchSignOut::mut_legacy_mass_disconnect_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPoorNetworkConditions>>(
                    "poor_network_conditions",
                    CMsgGameMatchSignOut::get_poor_network_conditions_for_reflect,
                    CMsgGameMatchSignOut::mut_poor_network_conditions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGameMatchSignOut_CAdditionalSignoutMsg>>(
                    "additional_msgs",
                    CMsgGameMatchSignOut::get_additional_msgs_for_reflect,
                    CMsgGameMatchSignOut::mut_additional_msgs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGameMatchSignOut_CSocialFeedMatchEvent>>(
                    "social_feed_events",
                    CMsgGameMatchSignOut::get_social_feed_events_for_reflect,
                    CMsgGameMatchSignOut::mut_social_feed_events_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "average_networth_delta",
                    CMsgGameMatchSignOut::get_average_networth_delta_for_reflect,
                    CMsgGameMatchSignOut::mut_average_networth_delta_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "networth_delta_min10",
                    CMsgGameMatchSignOut::get_networth_delta_min10_for_reflect,
                    CMsgGameMatchSignOut::mut_networth_delta_min10_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "networth_delta_min20",
                    CMsgGameMatchSignOut::get_networth_delta_min20_for_reflect,
                    CMsgGameMatchSignOut::mut_networth_delta_min20_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "maximum_losing_networth_lead",
                    CMsgGameMatchSignOut::get_maximum_losing_networth_lead_for_reflect,
                    CMsgGameMatchSignOut::mut_maximum_losing_networth_lead_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "average_experience_delta",
                    CMsgGameMatchSignOut::get_average_experience_delta_for_reflect,
                    CMsgGameMatchSignOut::mut_average_experience_delta_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "experience_delta_min10",
                    CMsgGameMatchSignOut::get_experience_delta_min10_for_reflect,
                    CMsgGameMatchSignOut::mut_experience_delta_min10_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "experience_delta_min20",
                    CMsgGameMatchSignOut::get_experience_delta_min20_for_reflect,
                    CMsgGameMatchSignOut::mut_experience_delta_min20_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "bonus_gold_winner_min10",
                    CMsgGameMatchSignOut::get_bonus_gold_winner_min10_for_reflect,
                    CMsgGameMatchSignOut::mut_bonus_gold_winner_min10_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "bonus_gold_winner_min20",
                    CMsgGameMatchSignOut::get_bonus_gold_winner_min20_for_reflect,
                    CMsgGameMatchSignOut::mut_bonus_gold_winner_min20_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bonus_gold_winner_total",
                    CMsgGameMatchSignOut::get_bonus_gold_winner_total_for_reflect,
                    CMsgGameMatchSignOut::mut_bonus_gold_winner_total_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "bonus_gold_loser_min10",
                    CMsgGameMatchSignOut::get_bonus_gold_loser_min10_for_reflect,
                    CMsgGameMatchSignOut::mut_bonus_gold_loser_min10_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "bonus_gold_loser_min20",
                    CMsgGameMatchSignOut::get_bonus_gold_loser_min20_for_reflect,
                    CMsgGameMatchSignOut::mut_bonus_gold_loser_min20_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bonus_gold_loser_total",
                    CMsgGameMatchSignOut::get_bonus_gold_loser_total_for_reflect,
                    CMsgGameMatchSignOut::mut_bonus_gold_loser_total_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGameMatchSignOut_CCustomGameData>>(
                    "custom_game_data",
                    CMsgGameMatchSignOut::get_custom_game_data_for_reflect,
                    CMsgGameMatchSignOut::mut_custom_game_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "match_flags",
                    CMsgGameMatchSignOut::get_match_flags_for_reflect,
                    CMsgGameMatchSignOut::mut_match_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_scores",
                    CMsgGameMatchSignOut::get_team_scores_for_reflect,
                    CMsgGameMatchSignOut::mut_team_scores_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pre_game_duration",
                    CMsgGameMatchSignOut::get_pre_game_duration_for_reflect,
                    CMsgGameMatchSignOut::mut_pre_game_duration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGameMatchSignOut_EventGameLeaderboardEntry>>(
                    "event_game_leaderboard_entries",
                    CMsgGameMatchSignOut::get_event_game_leaderboard_entries_for_reflect,
                    CMsgGameMatchSignOut::mut_event_game_leaderboard_entries_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameMatchSignOut>(
                    "CMsgGameMatchSignOut",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameMatchSignOut {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_duration();
        self.clear_good_guys_win();
        self.clear_date();
        self.clear_num_players();
        self.clear_teams();
        self.clear_tower_status();
        self.clear_barracks_status();
        self.clear_cluster();
        self.clear_server_addr();
        self.clear_first_blood_time();
        self.clear_game_balance();
        self.clear_event_score();
        self.clear_picks_bans();
        self.clear_fantasy_stats();
        self.clear_player_strange_count_adjustments();
        self.clear_automatic_surrender();
        self.clear_server_version();
        self.clear_legacy_mass_disconnect();
        self.clear_poor_network_conditions();
        self.clear_additional_msgs();
        self.clear_social_feed_events();
        self.clear_average_networth_delta();
        self.clear_networth_delta_min10();
        self.clear_networth_delta_min20();
        self.clear_maximum_losing_networth_lead();
        self.clear_average_experience_delta();
        self.clear_experience_delta_min10();
        self.clear_experience_delta_min20();
        self.clear_bonus_gold_winner_min10();
        self.clear_bonus_gold_winner_min20();
        self.clear_bonus_gold_winner_total();
        self.clear_bonus_gold_loser_min10();
        self.clear_bonus_gold_loser_min20();
        self.clear_bonus_gold_loser_total();
        self.clear_custom_game_data();
        self.clear_match_flags();
        self.clear_team_scores();
        self.clear_pre_game_duration();
        self.clear_event_game_leaderboard_entries();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameMatchSignOut {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignOut {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameMatchSignOut_CTeam {
    // message fields
    players: ::protobuf::RepeatedField<CMsgGameMatchSignOut_CTeam_CPlayer>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameMatchSignOut_CTeam {}

impl CMsgGameMatchSignOut_CTeam {
    pub fn new() -> CMsgGameMatchSignOut_CTeam {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameMatchSignOut_CTeam {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameMatchSignOut_CTeam> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameMatchSignOut_CTeam,
        };
        unsafe {
            instance.get(CMsgGameMatchSignOut_CTeam::new)
        }
    }

    // repeated .CMsgGameMatchSignOut.CTeam.CPlayer players = 1;

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgGameMatchSignOut_CTeam_CPlayer>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGameMatchSignOut_CTeam_CPlayer> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgGameMatchSignOut_CTeam_CPlayer> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    pub fn get_players(&self) -> &[CMsgGameMatchSignOut_CTeam_CPlayer] {
        &self.players
    }

    fn get_players_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGameMatchSignOut_CTeam_CPlayer> {
        &self.players
    }

    fn mut_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGameMatchSignOut_CTeam_CPlayer> {
        &mut self.players
    }
}

impl ::protobuf::Message for CMsgGameMatchSignOut_CTeam {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.players {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameMatchSignOut_CTeam {
    fn new() -> CMsgGameMatchSignOut_CTeam {
        CMsgGameMatchSignOut_CTeam::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameMatchSignOut_CTeam>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGameMatchSignOut_CTeam_CPlayer>>(
                    "players",
                    CMsgGameMatchSignOut_CTeam::get_players_for_reflect,
                    CMsgGameMatchSignOut_CTeam::mut_players_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameMatchSignOut_CTeam>(
                    "CMsgGameMatchSignOut_CTeam",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameMatchSignOut_CTeam {
    fn clear(&mut self) {
        self.clear_players();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameMatchSignOut_CTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignOut_CTeam {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameMatchSignOut_CTeam_CPlayer {
    // message fields
    steam_id: ::std::option::Option<u64>,
    hero_id: ::std::option::Option<u32>,
    items: ::std::vec::Vec<u32>,
    gold: ::std::option::Option<u32>,
    kills: ::std::option::Option<u32>,
    deaths: ::std::option::Option<u32>,
    assists: ::std::option::Option<u32>,
    leaver_status: ::std::option::Option<u32>,
    last_hits: ::std::option::Option<u32>,
    denies: ::std::option::Option<u32>,
    gold_per_min: ::std::option::Option<u32>,
    xp_per_minute: ::std::option::Option<u32>,
    gold_spent: ::std::option::Option<u32>,
    level: ::std::option::Option<u32>,
    scaled_hero_damage: ::std::option::Option<u32>,
    scaled_tower_damage: ::std::option::Option<u32>,
    scaled_hero_healing: ::std::option::Option<u32>,
    time_last_seen: ::std::option::Option<u32>,
    support_ability_value: ::std::option::Option<u32>,
    party_id: ::std::option::Option<u64>,
    scaled_kills: ::std::option::Option<f32>,
    scaled_deaths: ::std::option::Option<f32>,
    scaled_assists: ::std::option::Option<f32>,
    claimed_farm_gold: ::std::option::Option<u32>,
    support_gold: ::std::option::Option<u32>,
    claimed_denies: ::std::option::Option<u32>,
    claimed_misses: ::std::option::Option<u32>,
    misses: ::std::option::Option<u32>,
    net_worth: ::std::option::Option<u32>,
    hero_damage: ::std::option::Option<u32>,
    tower_damage: ::std::option::Option<u32>,
    hero_healing: ::std::option::Option<u32>,
    ability_upgrades: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchPlayerAbilityUpgrade>,
    additional_units_inventory: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchAdditionalUnitInventory>,
    permanent_buffs: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchPlayerPermanentBuff>,
    custom_game_data: ::protobuf::SingularPtrField<CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData>,
    match_player_flags: ::std::option::Option<u32>,
    talent_ability_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameMatchSignOut_CTeam_CPlayer {}

impl CMsgGameMatchSignOut_CTeam_CPlayer {
    pub fn new() -> CMsgGameMatchSignOut_CTeam_CPlayer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameMatchSignOut_CTeam_CPlayer {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameMatchSignOut_CTeam_CPlayer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameMatchSignOut_CTeam_CPlayer,
        };
        unsafe {
            instance.get(CMsgGameMatchSignOut_CTeam_CPlayer::new)
        }
    }

    // optional fixed64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    fn get_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.steam_id
    }

    fn mut_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.steam_id
    }

    // optional uint32 hero_id = 3;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // repeated uint32 items = 4;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::std::vec::Vec<u32>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.items, ::std::vec::Vec::new())
    }

    pub fn get_items(&self) -> &[u32] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.items
    }

    // optional uint32 gold = 5;

    pub fn clear_gold(&mut self) {
        self.gold = ::std::option::Option::None;
    }

    pub fn has_gold(&self) -> bool {
        self.gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold(&mut self, v: u32) {
        self.gold = ::std::option::Option::Some(v);
    }

    pub fn get_gold(&self) -> u32 {
        self.gold.unwrap_or(0)
    }

    fn get_gold_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gold
    }

    fn mut_gold_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gold
    }

    // optional uint32 kills = 6;

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    pub fn get_kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    fn get_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.kills
    }

    fn mut_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.kills
    }

    // optional uint32 deaths = 7;

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    pub fn get_deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    fn get_deaths_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.deaths
    }

    fn mut_deaths_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.deaths
    }

    // optional uint32 assists = 8;

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }

    pub fn get_assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    fn get_assists_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.assists
    }

    fn mut_assists_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.assists
    }

    // optional uint32 leaver_status = 9;

    pub fn clear_leaver_status(&mut self) {
        self.leaver_status = ::std::option::Option::None;
    }

    pub fn has_leaver_status(&self) -> bool {
        self.leaver_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaver_status(&mut self, v: u32) {
        self.leaver_status = ::std::option::Option::Some(v);
    }

    pub fn get_leaver_status(&self) -> u32 {
        self.leaver_status.unwrap_or(0)
    }

    fn get_leaver_status_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.leaver_status
    }

    fn mut_leaver_status_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.leaver_status
    }

    // optional uint32 last_hits = 10;

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: u32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    pub fn get_last_hits(&self) -> u32 {
        self.last_hits.unwrap_or(0)
    }

    fn get_last_hits_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.last_hits
    }

    fn mut_last_hits_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.last_hits
    }

    // optional uint32 denies = 11;

    pub fn clear_denies(&mut self) {
        self.denies = ::std::option::Option::None;
    }

    pub fn has_denies(&self) -> bool {
        self.denies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denies(&mut self, v: u32) {
        self.denies = ::std::option::Option::Some(v);
    }

    pub fn get_denies(&self) -> u32 {
        self.denies.unwrap_or(0)
    }

    fn get_denies_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.denies
    }

    fn mut_denies_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.denies
    }

    // optional uint32 gold_per_min = 12;

    pub fn clear_gold_per_min(&mut self) {
        self.gold_per_min = ::std::option::Option::None;
    }

    pub fn has_gold_per_min(&self) -> bool {
        self.gold_per_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_per_min(&mut self, v: u32) {
        self.gold_per_min = ::std::option::Option::Some(v);
    }

    pub fn get_gold_per_min(&self) -> u32 {
        self.gold_per_min.unwrap_or(0)
    }

    fn get_gold_per_min_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gold_per_min
    }

    fn mut_gold_per_min_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gold_per_min
    }

    // optional uint32 xp_per_minute = 13;

    pub fn clear_xp_per_minute(&mut self) {
        self.xp_per_minute = ::std::option::Option::None;
    }

    pub fn has_xp_per_minute(&self) -> bool {
        self.xp_per_minute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_per_minute(&mut self, v: u32) {
        self.xp_per_minute = ::std::option::Option::Some(v);
    }

    pub fn get_xp_per_minute(&self) -> u32 {
        self.xp_per_minute.unwrap_or(0)
    }

    fn get_xp_per_minute_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.xp_per_minute
    }

    fn mut_xp_per_minute_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.xp_per_minute
    }

    // optional uint32 gold_spent = 14;

    pub fn clear_gold_spent(&mut self) {
        self.gold_spent = ::std::option::Option::None;
    }

    pub fn has_gold_spent(&self) -> bool {
        self.gold_spent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_spent(&mut self, v: u32) {
        self.gold_spent = ::std::option::Option::Some(v);
    }

    pub fn get_gold_spent(&self) -> u32 {
        self.gold_spent.unwrap_or(0)
    }

    fn get_gold_spent_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gold_spent
    }

    fn mut_gold_spent_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gold_spent
    }

    // optional uint32 level = 15;

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    pub fn get_level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    fn get_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.level
    }

    fn mut_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.level
    }

    // optional uint32 scaled_hero_damage = 16;

    pub fn clear_scaled_hero_damage(&mut self) {
        self.scaled_hero_damage = ::std::option::Option::None;
    }

    pub fn has_scaled_hero_damage(&self) -> bool {
        self.scaled_hero_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaled_hero_damage(&mut self, v: u32) {
        self.scaled_hero_damage = ::std::option::Option::Some(v);
    }

    pub fn get_scaled_hero_damage(&self) -> u32 {
        self.scaled_hero_damage.unwrap_or(0)
    }

    fn get_scaled_hero_damage_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.scaled_hero_damage
    }

    fn mut_scaled_hero_damage_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.scaled_hero_damage
    }

    // optional uint32 scaled_tower_damage = 17;

    pub fn clear_scaled_tower_damage(&mut self) {
        self.scaled_tower_damage = ::std::option::Option::None;
    }

    pub fn has_scaled_tower_damage(&self) -> bool {
        self.scaled_tower_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaled_tower_damage(&mut self, v: u32) {
        self.scaled_tower_damage = ::std::option::Option::Some(v);
    }

    pub fn get_scaled_tower_damage(&self) -> u32 {
        self.scaled_tower_damage.unwrap_or(0)
    }

    fn get_scaled_tower_damage_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.scaled_tower_damage
    }

    fn mut_scaled_tower_damage_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.scaled_tower_damage
    }

    // optional uint32 scaled_hero_healing = 18;

    pub fn clear_scaled_hero_healing(&mut self) {
        self.scaled_hero_healing = ::std::option::Option::None;
    }

    pub fn has_scaled_hero_healing(&self) -> bool {
        self.scaled_hero_healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaled_hero_healing(&mut self, v: u32) {
        self.scaled_hero_healing = ::std::option::Option::Some(v);
    }

    pub fn get_scaled_hero_healing(&self) -> u32 {
        self.scaled_hero_healing.unwrap_or(0)
    }

    fn get_scaled_hero_healing_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.scaled_hero_healing
    }

    fn mut_scaled_hero_healing_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.scaled_hero_healing
    }

    // optional uint32 time_last_seen = 19;

    pub fn clear_time_last_seen(&mut self) {
        self.time_last_seen = ::std::option::Option::None;
    }

    pub fn has_time_last_seen(&self) -> bool {
        self.time_last_seen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_seen(&mut self, v: u32) {
        self.time_last_seen = ::std::option::Option::Some(v);
    }

    pub fn get_time_last_seen(&self) -> u32 {
        self.time_last_seen.unwrap_or(0)
    }

    fn get_time_last_seen_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time_last_seen
    }

    fn mut_time_last_seen_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time_last_seen
    }

    // optional uint32 support_ability_value = 20;

    pub fn clear_support_ability_value(&mut self) {
        self.support_ability_value = ::std::option::Option::None;
    }

    pub fn has_support_ability_value(&self) -> bool {
        self.support_ability_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_ability_value(&mut self, v: u32) {
        self.support_ability_value = ::std::option::Option::Some(v);
    }

    pub fn get_support_ability_value(&self) -> u32 {
        self.support_ability_value.unwrap_or(0)
    }

    fn get_support_ability_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.support_ability_value
    }

    fn mut_support_ability_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.support_ability_value
    }

    // optional uint64 party_id = 21;

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    pub fn get_party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    fn get_party_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.party_id
    }

    fn mut_party_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.party_id
    }

    // optional float scaled_kills = 24;

    pub fn clear_scaled_kills(&mut self) {
        self.scaled_kills = ::std::option::Option::None;
    }

    pub fn has_scaled_kills(&self) -> bool {
        self.scaled_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaled_kills(&mut self, v: f32) {
        self.scaled_kills = ::std::option::Option::Some(v);
    }

    pub fn get_scaled_kills(&self) -> f32 {
        self.scaled_kills.unwrap_or(0.)
    }

    fn get_scaled_kills_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.scaled_kills
    }

    fn mut_scaled_kills_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.scaled_kills
    }

    // optional float scaled_deaths = 25;

    pub fn clear_scaled_deaths(&mut self) {
        self.scaled_deaths = ::std::option::Option::None;
    }

    pub fn has_scaled_deaths(&self) -> bool {
        self.scaled_deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaled_deaths(&mut self, v: f32) {
        self.scaled_deaths = ::std::option::Option::Some(v);
    }

    pub fn get_scaled_deaths(&self) -> f32 {
        self.scaled_deaths.unwrap_or(0.)
    }

    fn get_scaled_deaths_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.scaled_deaths
    }

    fn mut_scaled_deaths_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.scaled_deaths
    }

    // optional float scaled_assists = 26;

    pub fn clear_scaled_assists(&mut self) {
        self.scaled_assists = ::std::option::Option::None;
    }

    pub fn has_scaled_assists(&self) -> bool {
        self.scaled_assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaled_assists(&mut self, v: f32) {
        self.scaled_assists = ::std::option::Option::Some(v);
    }

    pub fn get_scaled_assists(&self) -> f32 {
        self.scaled_assists.unwrap_or(0.)
    }

    fn get_scaled_assists_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.scaled_assists
    }

    fn mut_scaled_assists_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.scaled_assists
    }

    // optional uint32 claimed_farm_gold = 27;

    pub fn clear_claimed_farm_gold(&mut self) {
        self.claimed_farm_gold = ::std::option::Option::None;
    }

    pub fn has_claimed_farm_gold(&self) -> bool {
        self.claimed_farm_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claimed_farm_gold(&mut self, v: u32) {
        self.claimed_farm_gold = ::std::option::Option::Some(v);
    }

    pub fn get_claimed_farm_gold(&self) -> u32 {
        self.claimed_farm_gold.unwrap_or(0)
    }

    fn get_claimed_farm_gold_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.claimed_farm_gold
    }

    fn mut_claimed_farm_gold_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.claimed_farm_gold
    }

    // optional uint32 support_gold = 28;

    pub fn clear_support_gold(&mut self) {
        self.support_gold = ::std::option::Option::None;
    }

    pub fn has_support_gold(&self) -> bool {
        self.support_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_gold(&mut self, v: u32) {
        self.support_gold = ::std::option::Option::Some(v);
    }

    pub fn get_support_gold(&self) -> u32 {
        self.support_gold.unwrap_or(0)
    }

    fn get_support_gold_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.support_gold
    }

    fn mut_support_gold_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.support_gold
    }

    // optional uint32 claimed_denies = 29;

    pub fn clear_claimed_denies(&mut self) {
        self.claimed_denies = ::std::option::Option::None;
    }

    pub fn has_claimed_denies(&self) -> bool {
        self.claimed_denies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claimed_denies(&mut self, v: u32) {
        self.claimed_denies = ::std::option::Option::Some(v);
    }

    pub fn get_claimed_denies(&self) -> u32 {
        self.claimed_denies.unwrap_or(0)
    }

    fn get_claimed_denies_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.claimed_denies
    }

    fn mut_claimed_denies_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.claimed_denies
    }

    // optional uint32 claimed_misses = 30;

    pub fn clear_claimed_misses(&mut self) {
        self.claimed_misses = ::std::option::Option::None;
    }

    pub fn has_claimed_misses(&self) -> bool {
        self.claimed_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claimed_misses(&mut self, v: u32) {
        self.claimed_misses = ::std::option::Option::Some(v);
    }

    pub fn get_claimed_misses(&self) -> u32 {
        self.claimed_misses.unwrap_or(0)
    }

    fn get_claimed_misses_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.claimed_misses
    }

    fn mut_claimed_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.claimed_misses
    }

    // optional uint32 misses = 31;

    pub fn clear_misses(&mut self) {
        self.misses = ::std::option::Option::None;
    }

    pub fn has_misses(&self) -> bool {
        self.misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_misses(&mut self, v: u32) {
        self.misses = ::std::option::Option::Some(v);
    }

    pub fn get_misses(&self) -> u32 {
        self.misses.unwrap_or(0)
    }

    fn get_misses_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.misses
    }

    fn mut_misses_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.misses
    }

    // optional uint32 net_worth = 34;

    pub fn clear_net_worth(&mut self) {
        self.net_worth = ::std::option::Option::None;
    }

    pub fn has_net_worth(&self) -> bool {
        self.net_worth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_worth(&mut self, v: u32) {
        self.net_worth = ::std::option::Option::Some(v);
    }

    pub fn get_net_worth(&self) -> u32 {
        self.net_worth.unwrap_or(0)
    }

    fn get_net_worth_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.net_worth
    }

    fn mut_net_worth_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.net_worth
    }

    // optional uint32 hero_damage = 37;

    pub fn clear_hero_damage(&mut self) {
        self.hero_damage = ::std::option::Option::None;
    }

    pub fn has_hero_damage(&self) -> bool {
        self.hero_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_damage(&mut self, v: u32) {
        self.hero_damage = ::std::option::Option::Some(v);
    }

    pub fn get_hero_damage(&self) -> u32 {
        self.hero_damage.unwrap_or(0)
    }

    fn get_hero_damage_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_damage
    }

    fn mut_hero_damage_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_damage
    }

    // optional uint32 tower_damage = 38;

    pub fn clear_tower_damage(&mut self) {
        self.tower_damage = ::std::option::Option::None;
    }

    pub fn has_tower_damage(&self) -> bool {
        self.tower_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_damage(&mut self, v: u32) {
        self.tower_damage = ::std::option::Option::Some(v);
    }

    pub fn get_tower_damage(&self) -> u32 {
        self.tower_damage.unwrap_or(0)
    }

    fn get_tower_damage_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tower_damage
    }

    fn mut_tower_damage_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tower_damage
    }

    // optional uint32 hero_healing = 39;

    pub fn clear_hero_healing(&mut self) {
        self.hero_healing = ::std::option::Option::None;
    }

    pub fn has_hero_healing(&self) -> bool {
        self.hero_healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_healing(&mut self, v: u32) {
        self.hero_healing = ::std::option::Option::Some(v);
    }

    pub fn get_hero_healing(&self) -> u32 {
        self.hero_healing.unwrap_or(0)
    }

    fn get_hero_healing_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_healing
    }

    fn mut_hero_healing_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_healing
    }

    // repeated .CMatchPlayerAbilityUpgrade ability_upgrades = 32;

    pub fn clear_ability_upgrades(&mut self) {
        self.ability_upgrades.clear();
    }

    // Param is passed by value, moved
    pub fn set_ability_upgrades(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchPlayerAbilityUpgrade>) {
        self.ability_upgrades = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ability_upgrades(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchPlayerAbilityUpgrade> {
        &mut self.ability_upgrades
    }

    // Take field
    pub fn take_ability_upgrades(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchPlayerAbilityUpgrade> {
        ::std::mem::replace(&mut self.ability_upgrades, ::protobuf::RepeatedField::new())
    }

    pub fn get_ability_upgrades(&self) -> &[super::dota_gcmessages_common::CMatchPlayerAbilityUpgrade] {
        &self.ability_upgrades
    }

    fn get_ability_upgrades_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchPlayerAbilityUpgrade> {
        &self.ability_upgrades
    }

    fn mut_ability_upgrades_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchPlayerAbilityUpgrade> {
        &mut self.ability_upgrades
    }

    // repeated .CMatchAdditionalUnitInventory additional_units_inventory = 33;

    pub fn clear_additional_units_inventory(&mut self) {
        self.additional_units_inventory.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_units_inventory(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchAdditionalUnitInventory>) {
        self.additional_units_inventory = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additional_units_inventory(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchAdditionalUnitInventory> {
        &mut self.additional_units_inventory
    }

    // Take field
    pub fn take_additional_units_inventory(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchAdditionalUnitInventory> {
        ::std::mem::replace(&mut self.additional_units_inventory, ::protobuf::RepeatedField::new())
    }

    pub fn get_additional_units_inventory(&self) -> &[super::dota_gcmessages_common::CMatchAdditionalUnitInventory] {
        &self.additional_units_inventory
    }

    fn get_additional_units_inventory_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchAdditionalUnitInventory> {
        &self.additional_units_inventory
    }

    fn mut_additional_units_inventory_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchAdditionalUnitInventory> {
        &mut self.additional_units_inventory
    }

    // repeated .CMatchPlayerPermanentBuff permanent_buffs = 40;

    pub fn clear_permanent_buffs(&mut self) {
        self.permanent_buffs.clear();
    }

    // Param is passed by value, moved
    pub fn set_permanent_buffs(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchPlayerPermanentBuff>) {
        self.permanent_buffs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_permanent_buffs(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchPlayerPermanentBuff> {
        &mut self.permanent_buffs
    }

    // Take field
    pub fn take_permanent_buffs(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchPlayerPermanentBuff> {
        ::std::mem::replace(&mut self.permanent_buffs, ::protobuf::RepeatedField::new())
    }

    pub fn get_permanent_buffs(&self) -> &[super::dota_gcmessages_common::CMatchPlayerPermanentBuff] {
        &self.permanent_buffs
    }

    fn get_permanent_buffs_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchPlayerPermanentBuff> {
        &self.permanent_buffs
    }

    fn mut_permanent_buffs_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchPlayerPermanentBuff> {
        &mut self.permanent_buffs
    }

    // optional .CMsgGameMatchSignOut.CTeam.CPlayer.CCustomGameData custom_game_data = 35;

    pub fn clear_custom_game_data(&mut self) {
        self.custom_game_data.clear();
    }

    pub fn has_custom_game_data(&self) -> bool {
        self.custom_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_data(&mut self, v: CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData) {
        self.custom_game_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_game_data(&mut self) -> &mut CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
        if self.custom_game_data.is_none() {
            self.custom_game_data.set_default();
        }
        self.custom_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_game_data(&mut self) -> CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
        self.custom_game_data.take().unwrap_or_else(|| CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData::new())
    }

    pub fn get_custom_game_data(&self) -> &CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
        self.custom_game_data.as_ref().unwrap_or_else(|| CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData::default_instance())
    }

    fn get_custom_game_data_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData> {
        &self.custom_game_data
    }

    fn mut_custom_game_data_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData> {
        &mut self.custom_game_data
    }

    // optional uint32 match_player_flags = 36;

    pub fn clear_match_player_flags(&mut self) {
        self.match_player_flags = ::std::option::Option::None;
    }

    pub fn has_match_player_flags(&self) -> bool {
        self.match_player_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_player_flags(&mut self, v: u32) {
        self.match_player_flags = ::std::option::Option::Some(v);
    }

    pub fn get_match_player_flags(&self) -> u32 {
        self.match_player_flags.unwrap_or(0)
    }

    fn get_match_player_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.match_player_flags
    }

    fn mut_match_player_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.match_player_flags
    }

    // repeated uint32 talent_ability_ids = 41;

    pub fn clear_talent_ability_ids(&mut self) {
        self.talent_ability_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_talent_ability_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.talent_ability_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_talent_ability_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.talent_ability_ids
    }

    // Take field
    pub fn take_talent_ability_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.talent_ability_ids, ::std::vec::Vec::new())
    }

    pub fn get_talent_ability_ids(&self) -> &[u32] {
        &self.talent_ability_ids
    }

    fn get_talent_ability_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.talent_ability_ids
    }

    fn mut_talent_ability_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.talent_ability_ids
    }
}

impl ::protobuf::Message for CMsgGameMatchSignOut_CTeam_CPlayer {
    fn is_initialized(&self) -> bool {
        for v in &self.ability_upgrades {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.additional_units_inventory {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.permanent_buffs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.custom_game_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.items)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gold = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kills = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deaths = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.assists = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leaver_status = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_hits = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.denies = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gold_per_min = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xp_per_minute = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gold_spent = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scaled_hero_damage = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scaled_tower_damage = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scaled_hero_healing = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_last_seen = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.support_ability_value = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.party_id = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.scaled_kills = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.scaled_deaths = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.scaled_assists = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.claimed_farm_gold = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.support_gold = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.claimed_denies = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.claimed_misses = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.misses = ::std::option::Option::Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.net_worth = ::std::option::Option::Some(tmp);
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_damage = ::std::option::Option::Some(tmp);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tower_damage = ::std::option::Option::Some(tmp);
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_healing = ::std::option::Option::Some(tmp);
                },
                32 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ability_upgrades)?;
                },
                33 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.additional_units_inventory)?;
                },
                40 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.permanent_buffs)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.custom_game_data)?;
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.match_player_flags = ::std::option::Option::Some(tmp);
                },
                41 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.talent_ability_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.items {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.gold {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.assists {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leaver_status {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_hits {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.denies {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gold_per_min {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.xp_per_minute {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gold_spent {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scaled_hero_damage {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scaled_tower_damage {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scaled_hero_healing {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_last_seen {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.support_ability_value {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.party_id {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scaled_kills {
            my_size += 6;
        }
        if let Some(v) = self.scaled_deaths {
            my_size += 6;
        }
        if let Some(v) = self.scaled_assists {
            my_size += 6;
        }
        if let Some(v) = self.claimed_farm_gold {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.support_gold {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.claimed_denies {
            my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.claimed_misses {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.misses {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.net_worth {
            my_size += ::protobuf::rt::value_size(34, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_damage {
            my_size += ::protobuf::rt::value_size(37, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tower_damage {
            my_size += ::protobuf::rt::value_size(38, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_healing {
            my_size += ::protobuf::rt::value_size(39, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ability_upgrades {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.additional_units_inventory {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.permanent_buffs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.custom_game_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.match_player_flags {
            my_size += ::protobuf::rt::value_size(36, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.talent_ability_ids {
            my_size += ::protobuf::rt::value_size(41, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(3, v)?;
        }
        for v in &self.items {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.gold {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.leaver_status {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.last_hits {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.denies {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.gold_per_min {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.xp_per_minute {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.gold_spent {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.scaled_hero_damage {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.scaled_tower_damage {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.scaled_hero_healing {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.time_last_seen {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.support_ability_value {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.party_id {
            os.write_uint64(21, v)?;
        }
        if let Some(v) = self.scaled_kills {
            os.write_float(24, v)?;
        }
        if let Some(v) = self.scaled_deaths {
            os.write_float(25, v)?;
        }
        if let Some(v) = self.scaled_assists {
            os.write_float(26, v)?;
        }
        if let Some(v) = self.claimed_farm_gold {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.support_gold {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.claimed_denies {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.claimed_misses {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.misses {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.net_worth {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.hero_damage {
            os.write_uint32(37, v)?;
        }
        if let Some(v) = self.tower_damage {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.hero_healing {
            os.write_uint32(39, v)?;
        }
        for v in &self.ability_upgrades {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.additional_units_inventory {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.permanent_buffs {
            os.write_tag(40, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.custom_game_data.as_ref() {
            os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.match_player_flags {
            os.write_uint32(36, v)?;
        }
        for v in &self.talent_ability_ids {
            os.write_uint32(41, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameMatchSignOut_CTeam_CPlayer {
    fn new() -> CMsgGameMatchSignOut_CTeam_CPlayer {
        CMsgGameMatchSignOut_CTeam_CPlayer::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameMatchSignOut_CTeam_CPlayer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steam_id",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_steam_id_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_hero_id_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "items",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_items_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_items_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gold",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_gold_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_gold_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "kills",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_kills_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "deaths",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_deaths_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_deaths_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "assists",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_assists_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_assists_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "leaver_status",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_leaver_status_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_leaver_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_hits",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_last_hits_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_last_hits_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "denies",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_denies_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_denies_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gold_per_min",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_gold_per_min_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_gold_per_min_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "xp_per_minute",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_xp_per_minute_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_xp_per_minute_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gold_spent",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_gold_spent_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_gold_spent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "level",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_level_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scaled_hero_damage",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_scaled_hero_damage_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_scaled_hero_damage_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scaled_tower_damage",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_scaled_tower_damage_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_scaled_tower_damage_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "scaled_hero_healing",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_scaled_hero_healing_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_scaled_hero_healing_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_last_seen",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_time_last_seen_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_time_last_seen_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "support_ability_value",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_support_ability_value_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_support_ability_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "party_id",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_party_id_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_party_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "scaled_kills",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_scaled_kills_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_scaled_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "scaled_deaths",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_scaled_deaths_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_scaled_deaths_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "scaled_assists",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_scaled_assists_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_scaled_assists_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "claimed_farm_gold",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_claimed_farm_gold_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_claimed_farm_gold_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "support_gold",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_support_gold_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_support_gold_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "claimed_denies",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_claimed_denies_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_claimed_denies_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "claimed_misses",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_claimed_misses_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_claimed_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "misses",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_misses_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_misses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "net_worth",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_net_worth_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_net_worth_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_damage",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_hero_damage_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_hero_damage_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tower_damage",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_tower_damage_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_tower_damage_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_healing",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_hero_healing_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_hero_healing_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMatchPlayerAbilityUpgrade>>(
                    "ability_upgrades",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_ability_upgrades_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_ability_upgrades_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMatchAdditionalUnitInventory>>(
                    "additional_units_inventory",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_additional_units_inventory_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_additional_units_inventory_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMatchPlayerPermanentBuff>>(
                    "permanent_buffs",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_permanent_buffs_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_permanent_buffs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData>>(
                    "custom_game_data",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_custom_game_data_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_custom_game_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "match_player_flags",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_match_player_flags_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_match_player_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "talent_ability_ids",
                    CMsgGameMatchSignOut_CTeam_CPlayer::get_talent_ability_ids_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer::mut_talent_ability_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameMatchSignOut_CTeam_CPlayer>(
                    "CMsgGameMatchSignOut_CTeam_CPlayer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameMatchSignOut_CTeam_CPlayer {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_hero_id();
        self.clear_items();
        self.clear_gold();
        self.clear_kills();
        self.clear_deaths();
        self.clear_assists();
        self.clear_leaver_status();
        self.clear_last_hits();
        self.clear_denies();
        self.clear_gold_per_min();
        self.clear_xp_per_minute();
        self.clear_gold_spent();
        self.clear_level();
        self.clear_scaled_hero_damage();
        self.clear_scaled_tower_damage();
        self.clear_scaled_hero_healing();
        self.clear_time_last_seen();
        self.clear_support_ability_value();
        self.clear_party_id();
        self.clear_scaled_kills();
        self.clear_scaled_deaths();
        self.clear_scaled_assists();
        self.clear_claimed_farm_gold();
        self.clear_support_gold();
        self.clear_claimed_denies();
        self.clear_claimed_misses();
        self.clear_misses();
        self.clear_net_worth();
        self.clear_hero_damage();
        self.clear_tower_damage();
        self.clear_hero_healing();
        self.clear_ability_upgrades();
        self.clear_additional_units_inventory();
        self.clear_permanent_buffs();
        self.clear_custom_game_data();
        self.clear_match_player_flags();
        self.clear_talent_ability_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameMatchSignOut_CTeam_CPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignOut_CTeam_CPlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
    // message fields
    dota_team: ::std::option::Option<u32>,
    winner: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {}

impl CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
    pub fn new() -> CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData,
        };
        unsafe {
            instance.get(CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData::new)
        }
    }

    // optional uint32 dota_team = 1;

    pub fn clear_dota_team(&mut self) {
        self.dota_team = ::std::option::Option::None;
    }

    pub fn has_dota_team(&self) -> bool {
        self.dota_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dota_team(&mut self, v: u32) {
        self.dota_team = ::std::option::Option::Some(v);
    }

    pub fn get_dota_team(&self) -> u32 {
        self.dota_team.unwrap_or(0)
    }

    fn get_dota_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.dota_team
    }

    fn mut_dota_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.dota_team
    }

    // optional bool winner = 2;

    pub fn clear_winner(&mut self) {
        self.winner = ::std::option::Option::None;
    }

    pub fn has_winner(&self) -> bool {
        self.winner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winner(&mut self, v: bool) {
        self.winner = ::std::option::Option::Some(v);
    }

    pub fn get_winner(&self) -> bool {
        self.winner.unwrap_or(false)
    }

    fn get_winner_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.winner
    }

    fn mut_winner_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.winner
    }
}

impl ::protobuf::Message for CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dota_team = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.winner = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dota_team {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.winner {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dota_team {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.winner {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
    fn new() -> CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
        CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dota_team",
                    CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData::get_dota_team_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData::mut_dota_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "winner",
                    CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData::get_winner_for_reflect,
                    CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData::mut_winner_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData>(
                    "CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
    fn clear(&mut self) {
        self.clear_dota_team();
        self.clear_winner();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameMatchSignOut_CAdditionalSignoutMsg {
    // message fields
    id: ::std::option::Option<u32>,
    contents: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameMatchSignOut_CAdditionalSignoutMsg {}

impl CMsgGameMatchSignOut_CAdditionalSignoutMsg {
    pub fn new() -> CMsgGameMatchSignOut_CAdditionalSignoutMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameMatchSignOut_CAdditionalSignoutMsg {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameMatchSignOut_CAdditionalSignoutMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameMatchSignOut_CAdditionalSignoutMsg,
        };
        unsafe {
            instance.get(CMsgGameMatchSignOut_CAdditionalSignoutMsg::new)
        }
    }

    // optional uint32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.id
    }

    // optional bytes contents = 2;

    pub fn clear_contents(&mut self) {
        self.contents.clear();
    }

    pub fn has_contents(&self) -> bool {
        self.contents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contents(&mut self, v: ::std::vec::Vec<u8>) {
        self.contents = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contents(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.contents.is_none() {
            self.contents.set_default();
        }
        self.contents.as_mut().unwrap()
    }

    // Take field
    pub fn take_contents(&mut self) -> ::std::vec::Vec<u8> {
        self.contents.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_contents(&self) -> &[u8] {
        match self.contents.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_contents_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.contents
    }

    fn mut_contents_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.contents
    }
}

impl ::protobuf::Message for CMsgGameMatchSignOut_CAdditionalSignoutMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.contents)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.contents.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.contents.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameMatchSignOut_CAdditionalSignoutMsg {
    fn new() -> CMsgGameMatchSignOut_CAdditionalSignoutMsg {
        CMsgGameMatchSignOut_CAdditionalSignoutMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameMatchSignOut_CAdditionalSignoutMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    CMsgGameMatchSignOut_CAdditionalSignoutMsg::get_id_for_reflect,
                    CMsgGameMatchSignOut_CAdditionalSignoutMsg::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "contents",
                    CMsgGameMatchSignOut_CAdditionalSignoutMsg::get_contents_for_reflect,
                    CMsgGameMatchSignOut_CAdditionalSignoutMsg::mut_contents_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameMatchSignOut_CAdditionalSignoutMsg>(
                    "CMsgGameMatchSignOut_CAdditionalSignoutMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameMatchSignOut_CAdditionalSignoutMsg {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_contents();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameMatchSignOut_CAdditionalSignoutMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignOut_CAdditionalSignoutMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameMatchSignOut_CSocialFeedMatchEvent {
    // message fields
    account_id: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    event_type: ::std::option::Option<u32>,
    game_time: ::std::option::Option<i32>,
    replay_time: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameMatchSignOut_CSocialFeedMatchEvent {}

impl CMsgGameMatchSignOut_CSocialFeedMatchEvent {
    pub fn new() -> CMsgGameMatchSignOut_CSocialFeedMatchEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameMatchSignOut_CSocialFeedMatchEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameMatchSignOut_CSocialFeedMatchEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameMatchSignOut_CSocialFeedMatchEvent,
        };
        unsafe {
            instance.get(CMsgGameMatchSignOut_CSocialFeedMatchEvent::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 timestamp = 2;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional uint32 event_type = 3;

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    pub fn get_event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }

    fn get_event_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_type
    }

    fn mut_event_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_type
    }

    // optional int32 game_time = 4;

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: i32) {
        self.game_time = ::std::option::Option::Some(v);
    }

    pub fn get_game_time(&self) -> i32 {
        self.game_time.unwrap_or(0)
    }

    fn get_game_time_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.game_time
    }

    fn mut_game_time_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.game_time
    }

    // optional uint32 replay_time = 5;

    pub fn clear_replay_time(&mut self) {
        self.replay_time = ::std::option::Option::None;
    }

    pub fn has_replay_time(&self) -> bool {
        self.replay_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_time(&mut self, v: u32) {
        self.replay_time = ::std::option::Option::Some(v);
    }

    pub fn get_replay_time(&self) -> u32 {
        self.replay_time.unwrap_or(0)
    }

    fn get_replay_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.replay_time
    }

    fn mut_replay_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.replay_time
    }
}

impl ::protobuf::Message for CMsgGameMatchSignOut_CSocialFeedMatchEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.game_time = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replay_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_time {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.replay_time {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_time {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.replay_time {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameMatchSignOut_CSocialFeedMatchEvent {
    fn new() -> CMsgGameMatchSignOut_CSocialFeedMatchEvent {
        CMsgGameMatchSignOut_CSocialFeedMatchEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameMatchSignOut_CSocialFeedMatchEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGameMatchSignOut_CSocialFeedMatchEvent::get_account_id_for_reflect,
                    CMsgGameMatchSignOut_CSocialFeedMatchEvent::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgGameMatchSignOut_CSocialFeedMatchEvent::get_timestamp_for_reflect,
                    CMsgGameMatchSignOut_CSocialFeedMatchEvent::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_type",
                    CMsgGameMatchSignOut_CSocialFeedMatchEvent::get_event_type_for_reflect,
                    CMsgGameMatchSignOut_CSocialFeedMatchEvent::mut_event_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "game_time",
                    CMsgGameMatchSignOut_CSocialFeedMatchEvent::get_game_time_for_reflect,
                    CMsgGameMatchSignOut_CSocialFeedMatchEvent::mut_game_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "replay_time",
                    CMsgGameMatchSignOut_CSocialFeedMatchEvent::get_replay_time_for_reflect,
                    CMsgGameMatchSignOut_CSocialFeedMatchEvent::mut_replay_time_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameMatchSignOut_CSocialFeedMatchEvent>(
                    "CMsgGameMatchSignOut_CSocialFeedMatchEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameMatchSignOut_CSocialFeedMatchEvent {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_timestamp();
        self.clear_event_type();
        self.clear_game_time();
        self.clear_replay_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameMatchSignOut_CSocialFeedMatchEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignOut_CSocialFeedMatchEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameMatchSignOut_CCustomGameData {
    // message fields
    publish_timestamp: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameMatchSignOut_CCustomGameData {}

impl CMsgGameMatchSignOut_CCustomGameData {
    pub fn new() -> CMsgGameMatchSignOut_CCustomGameData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameMatchSignOut_CCustomGameData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameMatchSignOut_CCustomGameData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameMatchSignOut_CCustomGameData,
        };
        unsafe {
            instance.get(CMsgGameMatchSignOut_CCustomGameData::new)
        }
    }

    // optional uint32 publish_timestamp = 1;

    pub fn clear_publish_timestamp(&mut self) {
        self.publish_timestamp = ::std::option::Option::None;
    }

    pub fn has_publish_timestamp(&self) -> bool {
        self.publish_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publish_timestamp(&mut self, v: u32) {
        self.publish_timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_publish_timestamp(&self) -> u32 {
        self.publish_timestamp.unwrap_or(0)
    }

    fn get_publish_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.publish_timestamp
    }

    fn mut_publish_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.publish_timestamp
    }
}

impl ::protobuf::Message for CMsgGameMatchSignOut_CCustomGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.publish_timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publish_timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publish_timestamp {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameMatchSignOut_CCustomGameData {
    fn new() -> CMsgGameMatchSignOut_CCustomGameData {
        CMsgGameMatchSignOut_CCustomGameData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameMatchSignOut_CCustomGameData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "publish_timestamp",
                    CMsgGameMatchSignOut_CCustomGameData::get_publish_timestamp_for_reflect,
                    CMsgGameMatchSignOut_CCustomGameData::mut_publish_timestamp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameMatchSignOut_CCustomGameData>(
                    "CMsgGameMatchSignOut_CCustomGameData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameMatchSignOut_CCustomGameData {
    fn clear(&mut self) {
        self.clear_publish_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameMatchSignOut_CCustomGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignOut_CCustomGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameMatchSignOut_EventGameLeaderboardEntry {
    // message fields
    name_suffix: ::protobuf::SingularField<::std::string::String>,
    score: ::std::option::Option<i32>,
    extra_data_1: ::std::option::Option<u32>,
    extra_data_2: ::std::option::Option<u32>,
    extra_data_3: ::std::option::Option<u32>,
    extra_data_4: ::std::option::Option<u32>,
    extra_data_5: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameMatchSignOut_EventGameLeaderboardEntry {}

impl CMsgGameMatchSignOut_EventGameLeaderboardEntry {
    pub fn new() -> CMsgGameMatchSignOut_EventGameLeaderboardEntry {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameMatchSignOut_EventGameLeaderboardEntry {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameMatchSignOut_EventGameLeaderboardEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameMatchSignOut_EventGameLeaderboardEntry,
        };
        unsafe {
            instance.get(CMsgGameMatchSignOut_EventGameLeaderboardEntry::new)
        }
    }

    // optional string name_suffix = 1;

    pub fn clear_name_suffix(&mut self) {
        self.name_suffix.clear();
    }

    pub fn has_name_suffix(&self) -> bool {
        self.name_suffix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_suffix(&mut self, v: ::std::string::String) {
        self.name_suffix = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_suffix(&mut self) -> &mut ::std::string::String {
        if self.name_suffix.is_none() {
            self.name_suffix.set_default();
        }
        self.name_suffix.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_suffix(&mut self) -> ::std::string::String {
        self.name_suffix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name_suffix(&self) -> &str {
        match self.name_suffix.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_suffix_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name_suffix
    }

    fn mut_name_suffix_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name_suffix
    }

    // optional int32 score = 2;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score(&self) -> i32 {
        self.score.unwrap_or(0)
    }

    fn get_score_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.score
    }

    fn mut_score_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.score
    }

    // optional uint32 extra_data_1 = 3;

    pub fn clear_extra_data_1(&mut self) {
        self.extra_data_1 = ::std::option::Option::None;
    }

    pub fn has_extra_data_1(&self) -> bool {
        self.extra_data_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data_1(&mut self, v: u32) {
        self.extra_data_1 = ::std::option::Option::Some(v);
    }

    pub fn get_extra_data_1(&self) -> u32 {
        self.extra_data_1.unwrap_or(0)
    }

    fn get_extra_data_1_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.extra_data_1
    }

    fn mut_extra_data_1_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.extra_data_1
    }

    // optional uint32 extra_data_2 = 4;

    pub fn clear_extra_data_2(&mut self) {
        self.extra_data_2 = ::std::option::Option::None;
    }

    pub fn has_extra_data_2(&self) -> bool {
        self.extra_data_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data_2(&mut self, v: u32) {
        self.extra_data_2 = ::std::option::Option::Some(v);
    }

    pub fn get_extra_data_2(&self) -> u32 {
        self.extra_data_2.unwrap_or(0)
    }

    fn get_extra_data_2_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.extra_data_2
    }

    fn mut_extra_data_2_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.extra_data_2
    }

    // optional uint32 extra_data_3 = 5;

    pub fn clear_extra_data_3(&mut self) {
        self.extra_data_3 = ::std::option::Option::None;
    }

    pub fn has_extra_data_3(&self) -> bool {
        self.extra_data_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data_3(&mut self, v: u32) {
        self.extra_data_3 = ::std::option::Option::Some(v);
    }

    pub fn get_extra_data_3(&self) -> u32 {
        self.extra_data_3.unwrap_or(0)
    }

    fn get_extra_data_3_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.extra_data_3
    }

    fn mut_extra_data_3_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.extra_data_3
    }

    // optional uint32 extra_data_4 = 6;

    pub fn clear_extra_data_4(&mut self) {
        self.extra_data_4 = ::std::option::Option::None;
    }

    pub fn has_extra_data_4(&self) -> bool {
        self.extra_data_4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data_4(&mut self, v: u32) {
        self.extra_data_4 = ::std::option::Option::Some(v);
    }

    pub fn get_extra_data_4(&self) -> u32 {
        self.extra_data_4.unwrap_or(0)
    }

    fn get_extra_data_4_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.extra_data_4
    }

    fn mut_extra_data_4_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.extra_data_4
    }

    // optional uint32 extra_data_5 = 7;

    pub fn clear_extra_data_5(&mut self) {
        self.extra_data_5 = ::std::option::Option::None;
    }

    pub fn has_extra_data_5(&self) -> bool {
        self.extra_data_5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data_5(&mut self, v: u32) {
        self.extra_data_5 = ::std::option::Option::Some(v);
    }

    pub fn get_extra_data_5(&self) -> u32 {
        self.extra_data_5.unwrap_or(0)
    }

    fn get_extra_data_5_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.extra_data_5
    }

    fn mut_extra_data_5_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.extra_data_5
    }
}

impl ::protobuf::Message for CMsgGameMatchSignOut_EventGameLeaderboardEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name_suffix)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.extra_data_1 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.extra_data_2 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.extra_data_3 = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.extra_data_4 = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.extra_data_5 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name_suffix.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.extra_data_1 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.extra_data_2 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.extra_data_3 {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.extra_data_4 {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.extra_data_5 {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name_suffix.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.score {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.extra_data_1 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.extra_data_2 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.extra_data_3 {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.extra_data_4 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.extra_data_5 {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameMatchSignOut_EventGameLeaderboardEntry {
    fn new() -> CMsgGameMatchSignOut_EventGameLeaderboardEntry {
        CMsgGameMatchSignOut_EventGameLeaderboardEntry::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameMatchSignOut_EventGameLeaderboardEntry>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name_suffix",
                    CMsgGameMatchSignOut_EventGameLeaderboardEntry::get_name_suffix_for_reflect,
                    CMsgGameMatchSignOut_EventGameLeaderboardEntry::mut_name_suffix_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "score",
                    CMsgGameMatchSignOut_EventGameLeaderboardEntry::get_score_for_reflect,
                    CMsgGameMatchSignOut_EventGameLeaderboardEntry::mut_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "extra_data_1",
                    CMsgGameMatchSignOut_EventGameLeaderboardEntry::get_extra_data_1_for_reflect,
                    CMsgGameMatchSignOut_EventGameLeaderboardEntry::mut_extra_data_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "extra_data_2",
                    CMsgGameMatchSignOut_EventGameLeaderboardEntry::get_extra_data_2_for_reflect,
                    CMsgGameMatchSignOut_EventGameLeaderboardEntry::mut_extra_data_2_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "extra_data_3",
                    CMsgGameMatchSignOut_EventGameLeaderboardEntry::get_extra_data_3_for_reflect,
                    CMsgGameMatchSignOut_EventGameLeaderboardEntry::mut_extra_data_3_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "extra_data_4",
                    CMsgGameMatchSignOut_EventGameLeaderboardEntry::get_extra_data_4_for_reflect,
                    CMsgGameMatchSignOut_EventGameLeaderboardEntry::mut_extra_data_4_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "extra_data_5",
                    CMsgGameMatchSignOut_EventGameLeaderboardEntry::get_extra_data_5_for_reflect,
                    CMsgGameMatchSignOut_EventGameLeaderboardEntry::mut_extra_data_5_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameMatchSignOut_EventGameLeaderboardEntry>(
                    "CMsgGameMatchSignOut_EventGameLeaderboardEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameMatchSignOut_EventGameLeaderboardEntry {
    fn clear(&mut self) {
        self.clear_name_suffix();
        self.clear_score();
        self.clear_extra_data_1();
        self.clear_extra_data_2();
        self.clear_extra_data_3();
        self.clear_extra_data_4();
        self.clear_extra_data_5();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameMatchSignOut_EventGameLeaderboardEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignOut_EventGameLeaderboardEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSignOutDraftInfo {
    // message fields
    radiant_captain_account_id: ::std::option::Option<u32>,
    dire_captain_account_id: ::std::option::Option<u32>,
    picks_bans: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchHeroSelectEvent>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSignOutDraftInfo {}

impl CMsgSignOutDraftInfo {
    pub fn new() -> CMsgSignOutDraftInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSignOutDraftInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSignOutDraftInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSignOutDraftInfo,
        };
        unsafe {
            instance.get(CMsgSignOutDraftInfo::new)
        }
    }

    // optional uint32 radiant_captain_account_id = 1;

    pub fn clear_radiant_captain_account_id(&mut self) {
        self.radiant_captain_account_id = ::std::option::Option::None;
    }

    pub fn has_radiant_captain_account_id(&self) -> bool {
        self.radiant_captain_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_captain_account_id(&mut self, v: u32) {
        self.radiant_captain_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_radiant_captain_account_id(&self) -> u32 {
        self.radiant_captain_account_id.unwrap_or(0)
    }

    fn get_radiant_captain_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.radiant_captain_account_id
    }

    fn mut_radiant_captain_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.radiant_captain_account_id
    }

    // optional uint32 dire_captain_account_id = 2;

    pub fn clear_dire_captain_account_id(&mut self) {
        self.dire_captain_account_id = ::std::option::Option::None;
    }

    pub fn has_dire_captain_account_id(&self) -> bool {
        self.dire_captain_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_captain_account_id(&mut self, v: u32) {
        self.dire_captain_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_dire_captain_account_id(&self) -> u32 {
        self.dire_captain_account_id.unwrap_or(0)
    }

    fn get_dire_captain_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.dire_captain_account_id
    }

    fn mut_dire_captain_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.dire_captain_account_id
    }

    // repeated .CMatchHeroSelectEvent picks_bans = 3;

    pub fn clear_picks_bans(&mut self) {
        self.picks_bans.clear();
    }

    // Param is passed by value, moved
    pub fn set_picks_bans(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchHeroSelectEvent>) {
        self.picks_bans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_picks_bans(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchHeroSelectEvent> {
        &mut self.picks_bans
    }

    // Take field
    pub fn take_picks_bans(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchHeroSelectEvent> {
        ::std::mem::replace(&mut self.picks_bans, ::protobuf::RepeatedField::new())
    }

    pub fn get_picks_bans(&self) -> &[super::dota_gcmessages_common::CMatchHeroSelectEvent] {
        &self.picks_bans
    }

    fn get_picks_bans_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchHeroSelectEvent> {
        &self.picks_bans
    }

    fn mut_picks_bans_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMatchHeroSelectEvent> {
        &mut self.picks_bans
    }
}

impl ::protobuf::Message for CMsgSignOutDraftInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.picks_bans {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.radiant_captain_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dire_captain_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.picks_bans)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.radiant_captain_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dire_captain_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.picks_bans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.radiant_captain_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.dire_captain_account_id {
            os.write_uint32(2, v)?;
        }
        for v in &self.picks_bans {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSignOutDraftInfo {
    fn new() -> CMsgSignOutDraftInfo {
        CMsgSignOutDraftInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSignOutDraftInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "radiant_captain_account_id",
                    CMsgSignOutDraftInfo::get_radiant_captain_account_id_for_reflect,
                    CMsgSignOutDraftInfo::mut_radiant_captain_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dire_captain_account_id",
                    CMsgSignOutDraftInfo::get_dire_captain_account_id_for_reflect,
                    CMsgSignOutDraftInfo::mut_dire_captain_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMatchHeroSelectEvent>>(
                    "picks_bans",
                    CMsgSignOutDraftInfo::get_picks_bans_for_reflect,
                    CMsgSignOutDraftInfo::mut_picks_bans_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSignOutDraftInfo>(
                    "CMsgSignOutDraftInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSignOutDraftInfo {
    fn clear(&mut self) {
        self.clear_radiant_captain_account_id();
        self.clear_dire_captain_account_id();
        self.clear_picks_bans();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSignOutDraftInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutDraftInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSignOutBotInfo {
    // message fields
    allow_cheats: ::std::option::Option<bool>,
    bot_difficulty_radiant: ::std::option::Option<super::dota_shared_enums::DOTABotDifficulty>,
    created_lobby: ::std::option::Option<bool>,
    bot_difficulty_dire: ::std::option::Option<super::dota_shared_enums::DOTABotDifficulty>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSignOutBotInfo {}

impl CMsgSignOutBotInfo {
    pub fn new() -> CMsgSignOutBotInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSignOutBotInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSignOutBotInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSignOutBotInfo,
        };
        unsafe {
            instance.get(CMsgSignOutBotInfo::new)
        }
    }

    // optional bool allow_cheats = 1;

    pub fn clear_allow_cheats(&mut self) {
        self.allow_cheats = ::std::option::Option::None;
    }

    pub fn has_allow_cheats(&self) -> bool {
        self.allow_cheats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_cheats(&mut self, v: bool) {
        self.allow_cheats = ::std::option::Option::Some(v);
    }

    pub fn get_allow_cheats(&self) -> bool {
        self.allow_cheats.unwrap_or(false)
    }

    fn get_allow_cheats_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.allow_cheats
    }

    fn mut_allow_cheats_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.allow_cheats
    }

    // optional .DOTABotDifficulty bot_difficulty_radiant = 2;

    pub fn clear_bot_difficulty_radiant(&mut self) {
        self.bot_difficulty_radiant = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty_radiant(&self) -> bool {
        self.bot_difficulty_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty_radiant(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.bot_difficulty_radiant = ::std::option::Option::Some(v);
    }

    pub fn get_bot_difficulty_radiant(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        self.bot_difficulty_radiant.unwrap_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE)
    }

    fn get_bot_difficulty_radiant_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::DOTABotDifficulty> {
        &self.bot_difficulty_radiant
    }

    fn mut_bot_difficulty_radiant_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::DOTABotDifficulty> {
        &mut self.bot_difficulty_radiant
    }

    // optional bool created_lobby = 3;

    pub fn clear_created_lobby(&mut self) {
        self.created_lobby = ::std::option::Option::None;
    }

    pub fn has_created_lobby(&self) -> bool {
        self.created_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_lobby(&mut self, v: bool) {
        self.created_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_created_lobby(&self) -> bool {
        self.created_lobby.unwrap_or(false)
    }

    fn get_created_lobby_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.created_lobby
    }

    fn mut_created_lobby_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.created_lobby
    }

    // optional .DOTABotDifficulty bot_difficulty_dire = 5;

    pub fn clear_bot_difficulty_dire(&mut self) {
        self.bot_difficulty_dire = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty_dire(&self) -> bool {
        self.bot_difficulty_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty_dire(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.bot_difficulty_dire = ::std::option::Option::Some(v);
    }

    pub fn get_bot_difficulty_dire(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        self.bot_difficulty_dire.unwrap_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE)
    }

    fn get_bot_difficulty_dire_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::DOTABotDifficulty> {
        &self.bot_difficulty_dire
    }

    fn mut_bot_difficulty_dire_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::DOTABotDifficulty> {
        &mut self.bot_difficulty_dire
    }
}

impl ::protobuf::Message for CMsgSignOutBotInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_cheats = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.bot_difficulty_radiant = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.created_lobby = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.bot_difficulty_dire = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.allow_cheats {
            my_size += 2;
        }
        if let Some(v) = self.bot_difficulty_radiant {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.created_lobby {
            my_size += 2;
        }
        if let Some(v) = self.bot_difficulty_dire {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.allow_cheats {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.bot_difficulty_radiant {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.created_lobby {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.bot_difficulty_dire {
            os.write_enum(5, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSignOutBotInfo {
    fn new() -> CMsgSignOutBotInfo {
        CMsgSignOutBotInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSignOutBotInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "allow_cheats",
                    CMsgSignOutBotInfo::get_allow_cheats_for_reflect,
                    CMsgSignOutBotInfo::mut_allow_cheats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::DOTABotDifficulty>>(
                    "bot_difficulty_radiant",
                    CMsgSignOutBotInfo::get_bot_difficulty_radiant_for_reflect,
                    CMsgSignOutBotInfo::mut_bot_difficulty_radiant_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "created_lobby",
                    CMsgSignOutBotInfo::get_created_lobby_for_reflect,
                    CMsgSignOutBotInfo::mut_created_lobby_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::DOTABotDifficulty>>(
                    "bot_difficulty_dire",
                    CMsgSignOutBotInfo::get_bot_difficulty_dire_for_reflect,
                    CMsgSignOutBotInfo::mut_bot_difficulty_dire_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSignOutBotInfo>(
                    "CMsgSignOutBotInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSignOutBotInfo {
    fn clear(&mut self) {
        self.clear_allow_cheats();
        self.clear_bot_difficulty_radiant();
        self.clear_created_lobby();
        self.clear_bot_difficulty_dire();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSignOutBotInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutBotInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSignOutPlayerStats {
    // message fields
    account_id: ::std::option::Option<i32>,
    match_id: ::std::option::Option<u64>,
    rank: ::std::option::Option<u32>,
    hero_id: ::std::option::Option<u32>,
    rampages: ::std::option::Option<u32>,
    triple_kills: ::std::option::Option<u32>,
    first_blood_claimed: ::std::option::Option<u32>,
    first_blood_given: ::std::option::Option<u32>,
    couriers_killed: ::std::option::Option<u32>,
    aegises_snatched: ::std::option::Option<u32>,
    cheeses_eaten: ::std::option::Option<u32>,
    creeps_stacked: ::std::option::Option<u32>,
    fight_score: ::std::option::Option<f32>,
    farm_score: ::std::option::Option<f32>,
    support_score: ::std::option::Option<f32>,
    push_score: ::std::option::Option<f32>,
    kills: ::std::option::Option<u32>,
    deaths: ::std::option::Option<u32>,
    assists: ::std::option::Option<u32>,
    last_hits: ::std::option::Option<u32>,
    denies: ::std::option::Option<u32>,
    gpm: ::std::option::Option<f32>,
    xppm: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSignOutPlayerStats {}

impl CMsgSignOutPlayerStats {
    pub fn new() -> CMsgSignOutPlayerStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSignOutPlayerStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSignOutPlayerStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSignOutPlayerStats,
        };
        unsafe {
            instance.get(CMsgSignOutPlayerStats::new)
        }
    }

    // optional int32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: i32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> i32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.account_id
    }

    // optional uint64 match_id = 2;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 rank = 3;

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }

    pub fn get_rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }

    fn get_rank_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rank
    }

    fn mut_rank_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rank
    }

    // optional uint32 hero_id = 4;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 rampages = 5;

    pub fn clear_rampages(&mut self) {
        self.rampages = ::std::option::Option::None;
    }

    pub fn has_rampages(&self) -> bool {
        self.rampages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampages(&mut self, v: u32) {
        self.rampages = ::std::option::Option::Some(v);
    }

    pub fn get_rampages(&self) -> u32 {
        self.rampages.unwrap_or(0)
    }

    fn get_rampages_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rampages
    }

    fn mut_rampages_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rampages
    }

    // optional uint32 triple_kills = 6;

    pub fn clear_triple_kills(&mut self) {
        self.triple_kills = ::std::option::Option::None;
    }

    pub fn has_triple_kills(&self) -> bool {
        self.triple_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_triple_kills(&mut self, v: u32) {
        self.triple_kills = ::std::option::Option::Some(v);
    }

    pub fn get_triple_kills(&self) -> u32 {
        self.triple_kills.unwrap_or(0)
    }

    fn get_triple_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.triple_kills
    }

    fn mut_triple_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.triple_kills
    }

    // optional uint32 first_blood_claimed = 7;

    pub fn clear_first_blood_claimed(&mut self) {
        self.first_blood_claimed = ::std::option::Option::None;
    }

    pub fn has_first_blood_claimed(&self) -> bool {
        self.first_blood_claimed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_claimed(&mut self, v: u32) {
        self.first_blood_claimed = ::std::option::Option::Some(v);
    }

    pub fn get_first_blood_claimed(&self) -> u32 {
        self.first_blood_claimed.unwrap_or(0)
    }

    fn get_first_blood_claimed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.first_blood_claimed
    }

    fn mut_first_blood_claimed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.first_blood_claimed
    }

    // optional uint32 first_blood_given = 8;

    pub fn clear_first_blood_given(&mut self) {
        self.first_blood_given = ::std::option::Option::None;
    }

    pub fn has_first_blood_given(&self) -> bool {
        self.first_blood_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_given(&mut self, v: u32) {
        self.first_blood_given = ::std::option::Option::Some(v);
    }

    pub fn get_first_blood_given(&self) -> u32 {
        self.first_blood_given.unwrap_or(0)
    }

    fn get_first_blood_given_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.first_blood_given
    }

    fn mut_first_blood_given_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.first_blood_given
    }

    // optional uint32 couriers_killed = 9;

    pub fn clear_couriers_killed(&mut self) {
        self.couriers_killed = ::std::option::Option::None;
    }

    pub fn has_couriers_killed(&self) -> bool {
        self.couriers_killed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_couriers_killed(&mut self, v: u32) {
        self.couriers_killed = ::std::option::Option::Some(v);
    }

    pub fn get_couriers_killed(&self) -> u32 {
        self.couriers_killed.unwrap_or(0)
    }

    fn get_couriers_killed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.couriers_killed
    }

    fn mut_couriers_killed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.couriers_killed
    }

    // optional uint32 aegises_snatched = 10;

    pub fn clear_aegises_snatched(&mut self) {
        self.aegises_snatched = ::std::option::Option::None;
    }

    pub fn has_aegises_snatched(&self) -> bool {
        self.aegises_snatched.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aegises_snatched(&mut self, v: u32) {
        self.aegises_snatched = ::std::option::Option::Some(v);
    }

    pub fn get_aegises_snatched(&self) -> u32 {
        self.aegises_snatched.unwrap_or(0)
    }

    fn get_aegises_snatched_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.aegises_snatched
    }

    fn mut_aegises_snatched_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.aegises_snatched
    }

    // optional uint32 cheeses_eaten = 11;

    pub fn clear_cheeses_eaten(&mut self) {
        self.cheeses_eaten = ::std::option::Option::None;
    }

    pub fn has_cheeses_eaten(&self) -> bool {
        self.cheeses_eaten.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheeses_eaten(&mut self, v: u32) {
        self.cheeses_eaten = ::std::option::Option::Some(v);
    }

    pub fn get_cheeses_eaten(&self) -> u32 {
        self.cheeses_eaten.unwrap_or(0)
    }

    fn get_cheeses_eaten_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cheeses_eaten
    }

    fn mut_cheeses_eaten_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cheeses_eaten
    }

    // optional uint32 creeps_stacked = 12;

    pub fn clear_creeps_stacked(&mut self) {
        self.creeps_stacked = ::std::option::Option::None;
    }

    pub fn has_creeps_stacked(&self) -> bool {
        self.creeps_stacked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creeps_stacked(&mut self, v: u32) {
        self.creeps_stacked = ::std::option::Option::Some(v);
    }

    pub fn get_creeps_stacked(&self) -> u32 {
        self.creeps_stacked.unwrap_or(0)
    }

    fn get_creeps_stacked_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.creeps_stacked
    }

    fn mut_creeps_stacked_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.creeps_stacked
    }

    // optional float fight_score = 13;

    pub fn clear_fight_score(&mut self) {
        self.fight_score = ::std::option::Option::None;
    }

    pub fn has_fight_score(&self) -> bool {
        self.fight_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fight_score(&mut self, v: f32) {
        self.fight_score = ::std::option::Option::Some(v);
    }

    pub fn get_fight_score(&self) -> f32 {
        self.fight_score.unwrap_or(0.)
    }

    fn get_fight_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.fight_score
    }

    fn mut_fight_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.fight_score
    }

    // optional float farm_score = 14;

    pub fn clear_farm_score(&mut self) {
        self.farm_score = ::std::option::Option::None;
    }

    pub fn has_farm_score(&self) -> bool {
        self.farm_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_farm_score(&mut self, v: f32) {
        self.farm_score = ::std::option::Option::Some(v);
    }

    pub fn get_farm_score(&self) -> f32 {
        self.farm_score.unwrap_or(0.)
    }

    fn get_farm_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.farm_score
    }

    fn mut_farm_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.farm_score
    }

    // optional float support_score = 15;

    pub fn clear_support_score(&mut self) {
        self.support_score = ::std::option::Option::None;
    }

    pub fn has_support_score(&self) -> bool {
        self.support_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_score(&mut self, v: f32) {
        self.support_score = ::std::option::Option::Some(v);
    }

    pub fn get_support_score(&self) -> f32 {
        self.support_score.unwrap_or(0.)
    }

    fn get_support_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.support_score
    }

    fn mut_support_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.support_score
    }

    // optional float push_score = 16;

    pub fn clear_push_score(&mut self) {
        self.push_score = ::std::option::Option::None;
    }

    pub fn has_push_score(&self) -> bool {
        self.push_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_score(&mut self, v: f32) {
        self.push_score = ::std::option::Option::Some(v);
    }

    pub fn get_push_score(&self) -> f32 {
        self.push_score.unwrap_or(0.)
    }

    fn get_push_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.push_score
    }

    fn mut_push_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.push_score
    }

    // optional uint32 kills = 17;

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    pub fn get_kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    fn get_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.kills
    }

    fn mut_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.kills
    }

    // optional uint32 deaths = 18;

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    pub fn get_deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    fn get_deaths_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.deaths
    }

    fn mut_deaths_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.deaths
    }

    // optional uint32 assists = 19;

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }

    pub fn get_assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    fn get_assists_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.assists
    }

    fn mut_assists_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.assists
    }

    // optional uint32 last_hits = 20;

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: u32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    pub fn get_last_hits(&self) -> u32 {
        self.last_hits.unwrap_or(0)
    }

    fn get_last_hits_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.last_hits
    }

    fn mut_last_hits_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.last_hits
    }

    // optional uint32 denies = 21;

    pub fn clear_denies(&mut self) {
        self.denies = ::std::option::Option::None;
    }

    pub fn has_denies(&self) -> bool {
        self.denies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denies(&mut self, v: u32) {
        self.denies = ::std::option::Option::Some(v);
    }

    pub fn get_denies(&self) -> u32 {
        self.denies.unwrap_or(0)
    }

    fn get_denies_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.denies
    }

    fn mut_denies_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.denies
    }

    // optional float gpm = 22;

    pub fn clear_gpm(&mut self) {
        self.gpm = ::std::option::Option::None;
    }

    pub fn has_gpm(&self) -> bool {
        self.gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpm(&mut self, v: f32) {
        self.gpm = ::std::option::Option::Some(v);
    }

    pub fn get_gpm(&self) -> f32 {
        self.gpm.unwrap_or(0.)
    }

    fn get_gpm_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.gpm
    }

    fn mut_gpm_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.gpm
    }

    // optional float xppm = 23;

    pub fn clear_xppm(&mut self) {
        self.xppm = ::std::option::Option::None;
    }

    pub fn has_xppm(&self) -> bool {
        self.xppm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xppm(&mut self, v: f32) {
        self.xppm = ::std::option::Option::Some(v);
    }

    pub fn get_xppm(&self) -> f32 {
        self.xppm.unwrap_or(0.)
    }

    fn get_xppm_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.xppm
    }

    fn mut_xppm_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.xppm
    }
}

impl ::protobuf::Message for CMsgSignOutPlayerStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rank = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rampages = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.triple_kills = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_blood_claimed = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_blood_given = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.couriers_killed = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.aegises_snatched = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cheeses_eaten = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.creeps_stacked = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.fight_score = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.farm_score = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.support_score = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.push_score = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kills = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deaths = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.assists = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_hits = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.denies = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.gpm = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.xppm = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rampages {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.triple_kills {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.first_blood_claimed {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.first_blood_given {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.couriers_killed {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.aegises_snatched {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cheeses_eaten {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.creeps_stacked {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fight_score {
            my_size += 5;
        }
        if let Some(v) = self.farm_score {
            my_size += 5;
        }
        if let Some(v) = self.support_score {
            my_size += 5;
        }
        if let Some(v) = self.push_score {
            my_size += 6;
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.assists {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_hits {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.denies {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gpm {
            my_size += 6;
        }
        if let Some(v) = self.xppm {
            my_size += 6;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.rank {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rampages {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.triple_kills {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.first_blood_claimed {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.first_blood_given {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.couriers_killed {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.aegises_snatched {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.cheeses_eaten {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.creeps_stacked {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.fight_score {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.farm_score {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.support_score {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.push_score {
            os.write_float(16, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.last_hits {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.denies {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.gpm {
            os.write_float(22, v)?;
        }
        if let Some(v) = self.xppm {
            os.write_float(23, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSignOutPlayerStats {
    fn new() -> CMsgSignOutPlayerStats {
        CMsgSignOutPlayerStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSignOutPlayerStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "account_id",
                    CMsgSignOutPlayerStats::get_account_id_for_reflect,
                    CMsgSignOutPlayerStats::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgSignOutPlayerStats::get_match_id_for_reflect,
                    CMsgSignOutPlayerStats::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rank",
                    CMsgSignOutPlayerStats::get_rank_for_reflect,
                    CMsgSignOutPlayerStats::mut_rank_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgSignOutPlayerStats::get_hero_id_for_reflect,
                    CMsgSignOutPlayerStats::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rampages",
                    CMsgSignOutPlayerStats::get_rampages_for_reflect,
                    CMsgSignOutPlayerStats::mut_rampages_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "triple_kills",
                    CMsgSignOutPlayerStats::get_triple_kills_for_reflect,
                    CMsgSignOutPlayerStats::mut_triple_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "first_blood_claimed",
                    CMsgSignOutPlayerStats::get_first_blood_claimed_for_reflect,
                    CMsgSignOutPlayerStats::mut_first_blood_claimed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "first_blood_given",
                    CMsgSignOutPlayerStats::get_first_blood_given_for_reflect,
                    CMsgSignOutPlayerStats::mut_first_blood_given_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "couriers_killed",
                    CMsgSignOutPlayerStats::get_couriers_killed_for_reflect,
                    CMsgSignOutPlayerStats::mut_couriers_killed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "aegises_snatched",
                    CMsgSignOutPlayerStats::get_aegises_snatched_for_reflect,
                    CMsgSignOutPlayerStats::mut_aegises_snatched_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cheeses_eaten",
                    CMsgSignOutPlayerStats::get_cheeses_eaten_for_reflect,
                    CMsgSignOutPlayerStats::mut_cheeses_eaten_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "creeps_stacked",
                    CMsgSignOutPlayerStats::get_creeps_stacked_for_reflect,
                    CMsgSignOutPlayerStats::mut_creeps_stacked_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "fight_score",
                    CMsgSignOutPlayerStats::get_fight_score_for_reflect,
                    CMsgSignOutPlayerStats::mut_fight_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "farm_score",
                    CMsgSignOutPlayerStats::get_farm_score_for_reflect,
                    CMsgSignOutPlayerStats::mut_farm_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "support_score",
                    CMsgSignOutPlayerStats::get_support_score_for_reflect,
                    CMsgSignOutPlayerStats::mut_support_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "push_score",
                    CMsgSignOutPlayerStats::get_push_score_for_reflect,
                    CMsgSignOutPlayerStats::mut_push_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "kills",
                    CMsgSignOutPlayerStats::get_kills_for_reflect,
                    CMsgSignOutPlayerStats::mut_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "deaths",
                    CMsgSignOutPlayerStats::get_deaths_for_reflect,
                    CMsgSignOutPlayerStats::mut_deaths_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "assists",
                    CMsgSignOutPlayerStats::get_assists_for_reflect,
                    CMsgSignOutPlayerStats::mut_assists_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_hits",
                    CMsgSignOutPlayerStats::get_last_hits_for_reflect,
                    CMsgSignOutPlayerStats::mut_last_hits_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "denies",
                    CMsgSignOutPlayerStats::get_denies_for_reflect,
                    CMsgSignOutPlayerStats::mut_denies_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "gpm",
                    CMsgSignOutPlayerStats::get_gpm_for_reflect,
                    CMsgSignOutPlayerStats::mut_gpm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "xppm",
                    CMsgSignOutPlayerStats::get_xppm_for_reflect,
                    CMsgSignOutPlayerStats::mut_xppm_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSignOutPlayerStats>(
                    "CMsgSignOutPlayerStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSignOutPlayerStats {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_match_id();
        self.clear_rank();
        self.clear_hero_id();
        self.clear_rampages();
        self.clear_triple_kills();
        self.clear_first_blood_claimed();
        self.clear_first_blood_given();
        self.clear_couriers_killed();
        self.clear_aegises_snatched();
        self.clear_cheeses_eaten();
        self.clear_creeps_stacked();
        self.clear_fight_score();
        self.clear_farm_score();
        self.clear_support_score();
        self.clear_push_score();
        self.clear_kills();
        self.clear_deaths();
        self.clear_assists();
        self.clear_last_hits();
        self.clear_denies();
        self.clear_gpm();
        self.clear_xppm();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSignOutPlayerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutPlayerStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSignOutCommunicationSummary {
    // message fields
    players: ::protobuf::RepeatedField<CMsgSignOutCommunicationSummary_PlayerCommunication>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSignOutCommunicationSummary {}

impl CMsgSignOutCommunicationSummary {
    pub fn new() -> CMsgSignOutCommunicationSummary {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSignOutCommunicationSummary {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSignOutCommunicationSummary> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSignOutCommunicationSummary,
        };
        unsafe {
            instance.get(CMsgSignOutCommunicationSummary::new)
        }
    }

    // repeated .CMsgSignOutCommunicationSummary.PlayerCommunication players = 1;

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgSignOutCommunicationSummary_PlayerCommunication>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSignOutCommunicationSummary_PlayerCommunication> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgSignOutCommunicationSummary_PlayerCommunication> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    pub fn get_players(&self) -> &[CMsgSignOutCommunicationSummary_PlayerCommunication] {
        &self.players
    }

    fn get_players_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgSignOutCommunicationSummary_PlayerCommunication> {
        &self.players
    }

    fn mut_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSignOutCommunicationSummary_PlayerCommunication> {
        &mut self.players
    }
}

impl ::protobuf::Message for CMsgSignOutCommunicationSummary {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.players {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSignOutCommunicationSummary {
    fn new() -> CMsgSignOutCommunicationSummary {
        CMsgSignOutCommunicationSummary::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSignOutCommunicationSummary>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSignOutCommunicationSummary_PlayerCommunication>>(
                    "players",
                    CMsgSignOutCommunicationSummary::get_players_for_reflect,
                    CMsgSignOutCommunicationSummary::mut_players_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSignOutCommunicationSummary>(
                    "CMsgSignOutCommunicationSummary",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSignOutCommunicationSummary {
    fn clear(&mut self) {
        self.clear_players();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSignOutCommunicationSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutCommunicationSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSignOutCommunicationSummary_PlayerCommunication {
    // message fields
    account_id: ::std::option::Option<u32>,
    pings: ::std::option::Option<u32>,
    max_pings_per_interval: ::std::option::Option<u32>,
    teammate_pings: ::std::option::Option<u32>,
    max_teammate_pings_per_interval: ::std::option::Option<u32>,
    team_chat_messages: ::std::option::Option<u32>,
    all_chat_messages: ::std::option::Option<u32>,
    chat_wheel_messages: ::std::option::Option<u32>,
    pauses: ::std::option::Option<u32>,
    unpauses: ::std::option::Option<u32>,
    lines_drawn: ::std::option::Option<u32>,
    voice_chat_seconds: ::std::option::Option<u32>,
    chat_mutes: ::std::option::Option<u32>,
    voice_mutes: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSignOutCommunicationSummary_PlayerCommunication {}

impl CMsgSignOutCommunicationSummary_PlayerCommunication {
    pub fn new() -> CMsgSignOutCommunicationSummary_PlayerCommunication {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSignOutCommunicationSummary_PlayerCommunication {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSignOutCommunicationSummary_PlayerCommunication> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSignOutCommunicationSummary_PlayerCommunication,
        };
        unsafe {
            instance.get(CMsgSignOutCommunicationSummary_PlayerCommunication::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 pings = 2;

    pub fn clear_pings(&mut self) {
        self.pings = ::std::option::Option::None;
    }

    pub fn has_pings(&self) -> bool {
        self.pings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pings(&mut self, v: u32) {
        self.pings = ::std::option::Option::Some(v);
    }

    pub fn get_pings(&self) -> u32 {
        self.pings.unwrap_or(0)
    }

    fn get_pings_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.pings
    }

    fn mut_pings_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.pings
    }

    // optional uint32 max_pings_per_interval = 3;

    pub fn clear_max_pings_per_interval(&mut self) {
        self.max_pings_per_interval = ::std::option::Option::None;
    }

    pub fn has_max_pings_per_interval(&self) -> bool {
        self.max_pings_per_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_pings_per_interval(&mut self, v: u32) {
        self.max_pings_per_interval = ::std::option::Option::Some(v);
    }

    pub fn get_max_pings_per_interval(&self) -> u32 {
        self.max_pings_per_interval.unwrap_or(0)
    }

    fn get_max_pings_per_interval_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.max_pings_per_interval
    }

    fn mut_max_pings_per_interval_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.max_pings_per_interval
    }

    // optional uint32 teammate_pings = 4;

    pub fn clear_teammate_pings(&mut self) {
        self.teammate_pings = ::std::option::Option::None;
    }

    pub fn has_teammate_pings(&self) -> bool {
        self.teammate_pings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teammate_pings(&mut self, v: u32) {
        self.teammate_pings = ::std::option::Option::Some(v);
    }

    pub fn get_teammate_pings(&self) -> u32 {
        self.teammate_pings.unwrap_or(0)
    }

    fn get_teammate_pings_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.teammate_pings
    }

    fn mut_teammate_pings_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.teammate_pings
    }

    // optional uint32 max_teammate_pings_per_interval = 5;

    pub fn clear_max_teammate_pings_per_interval(&mut self) {
        self.max_teammate_pings_per_interval = ::std::option::Option::None;
    }

    pub fn has_max_teammate_pings_per_interval(&self) -> bool {
        self.max_teammate_pings_per_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_teammate_pings_per_interval(&mut self, v: u32) {
        self.max_teammate_pings_per_interval = ::std::option::Option::Some(v);
    }

    pub fn get_max_teammate_pings_per_interval(&self) -> u32 {
        self.max_teammate_pings_per_interval.unwrap_or(0)
    }

    fn get_max_teammate_pings_per_interval_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.max_teammate_pings_per_interval
    }

    fn mut_max_teammate_pings_per_interval_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.max_teammate_pings_per_interval
    }

    // optional uint32 team_chat_messages = 6;

    pub fn clear_team_chat_messages(&mut self) {
        self.team_chat_messages = ::std::option::Option::None;
    }

    pub fn has_team_chat_messages(&self) -> bool {
        self.team_chat_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_chat_messages(&mut self, v: u32) {
        self.team_chat_messages = ::std::option::Option::Some(v);
    }

    pub fn get_team_chat_messages(&self) -> u32 {
        self.team_chat_messages.unwrap_or(0)
    }

    fn get_team_chat_messages_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_chat_messages
    }

    fn mut_team_chat_messages_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_chat_messages
    }

    // optional uint32 all_chat_messages = 7;

    pub fn clear_all_chat_messages(&mut self) {
        self.all_chat_messages = ::std::option::Option::None;
    }

    pub fn has_all_chat_messages(&self) -> bool {
        self.all_chat_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_all_chat_messages(&mut self, v: u32) {
        self.all_chat_messages = ::std::option::Option::Some(v);
    }

    pub fn get_all_chat_messages(&self) -> u32 {
        self.all_chat_messages.unwrap_or(0)
    }

    fn get_all_chat_messages_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.all_chat_messages
    }

    fn mut_all_chat_messages_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.all_chat_messages
    }

    // optional uint32 chat_wheel_messages = 8;

    pub fn clear_chat_wheel_messages(&mut self) {
        self.chat_wheel_messages = ::std::option::Option::None;
    }

    pub fn has_chat_wheel_messages(&self) -> bool {
        self.chat_wheel_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_wheel_messages(&mut self, v: u32) {
        self.chat_wheel_messages = ::std::option::Option::Some(v);
    }

    pub fn get_chat_wheel_messages(&self) -> u32 {
        self.chat_wheel_messages.unwrap_or(0)
    }

    fn get_chat_wheel_messages_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.chat_wheel_messages
    }

    fn mut_chat_wheel_messages_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.chat_wheel_messages
    }

    // optional uint32 pauses = 9;

    pub fn clear_pauses(&mut self) {
        self.pauses = ::std::option::Option::None;
    }

    pub fn has_pauses(&self) -> bool {
        self.pauses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pauses(&mut self, v: u32) {
        self.pauses = ::std::option::Option::Some(v);
    }

    pub fn get_pauses(&self) -> u32 {
        self.pauses.unwrap_or(0)
    }

    fn get_pauses_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.pauses
    }

    fn mut_pauses_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.pauses
    }

    // optional uint32 unpauses = 10;

    pub fn clear_unpauses(&mut self) {
        self.unpauses = ::std::option::Option::None;
    }

    pub fn has_unpauses(&self) -> bool {
        self.unpauses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unpauses(&mut self, v: u32) {
        self.unpauses = ::std::option::Option::Some(v);
    }

    pub fn get_unpauses(&self) -> u32 {
        self.unpauses.unwrap_or(0)
    }

    fn get_unpauses_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.unpauses
    }

    fn mut_unpauses_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.unpauses
    }

    // optional uint32 lines_drawn = 11;

    pub fn clear_lines_drawn(&mut self) {
        self.lines_drawn = ::std::option::Option::None;
    }

    pub fn has_lines_drawn(&self) -> bool {
        self.lines_drawn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lines_drawn(&mut self, v: u32) {
        self.lines_drawn = ::std::option::Option::Some(v);
    }

    pub fn get_lines_drawn(&self) -> u32 {
        self.lines_drawn.unwrap_or(0)
    }

    fn get_lines_drawn_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lines_drawn
    }

    fn mut_lines_drawn_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lines_drawn
    }

    // optional uint32 voice_chat_seconds = 12;

    pub fn clear_voice_chat_seconds(&mut self) {
        self.voice_chat_seconds = ::std::option::Option::None;
    }

    pub fn has_voice_chat_seconds(&self) -> bool {
        self.voice_chat_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_chat_seconds(&mut self, v: u32) {
        self.voice_chat_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_voice_chat_seconds(&self) -> u32 {
        self.voice_chat_seconds.unwrap_or(0)
    }

    fn get_voice_chat_seconds_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.voice_chat_seconds
    }

    fn mut_voice_chat_seconds_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.voice_chat_seconds
    }

    // optional uint32 chat_mutes = 13;

    pub fn clear_chat_mutes(&mut self) {
        self.chat_mutes = ::std::option::Option::None;
    }

    pub fn has_chat_mutes(&self) -> bool {
        self.chat_mutes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_mutes(&mut self, v: u32) {
        self.chat_mutes = ::std::option::Option::Some(v);
    }

    pub fn get_chat_mutes(&self) -> u32 {
        self.chat_mutes.unwrap_or(0)
    }

    fn get_chat_mutes_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.chat_mutes
    }

    fn mut_chat_mutes_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.chat_mutes
    }

    // optional uint32 voice_mutes = 14;

    pub fn clear_voice_mutes(&mut self) {
        self.voice_mutes = ::std::option::Option::None;
    }

    pub fn has_voice_mutes(&self) -> bool {
        self.voice_mutes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_mutes(&mut self, v: u32) {
        self.voice_mutes = ::std::option::Option::Some(v);
    }

    pub fn get_voice_mutes(&self) -> u32 {
        self.voice_mutes.unwrap_or(0)
    }

    fn get_voice_mutes_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.voice_mutes
    }

    fn mut_voice_mutes_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.voice_mutes
    }
}

impl ::protobuf::Message for CMsgSignOutCommunicationSummary_PlayerCommunication {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pings = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_pings_per_interval = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.teammate_pings = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_teammate_pings_per_interval = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_chat_messages = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.all_chat_messages = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.chat_wheel_messages = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pauses = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.unpauses = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lines_drawn = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.voice_chat_seconds = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.chat_mutes = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.voice_mutes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pings {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_pings_per_interval {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.teammate_pings {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_teammate_pings_per_interval {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_chat_messages {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.all_chat_messages {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_wheel_messages {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pauses {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unpauses {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lines_drawn {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.voice_chat_seconds {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_mutes {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.voice_mutes {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.pings {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.max_pings_per_interval {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.teammate_pings {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.max_teammate_pings_per_interval {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.team_chat_messages {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.all_chat_messages {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.chat_wheel_messages {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.pauses {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.unpauses {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.lines_drawn {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.voice_chat_seconds {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.chat_mutes {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.voice_mutes {
            os.write_uint32(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSignOutCommunicationSummary_PlayerCommunication {
    fn new() -> CMsgSignOutCommunicationSummary_PlayerCommunication {
        CMsgSignOutCommunicationSummary_PlayerCommunication::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSignOutCommunicationSummary_PlayerCommunication>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgSignOutCommunicationSummary_PlayerCommunication::get_account_id_for_reflect,
                    CMsgSignOutCommunicationSummary_PlayerCommunication::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pings",
                    CMsgSignOutCommunicationSummary_PlayerCommunication::get_pings_for_reflect,
                    CMsgSignOutCommunicationSummary_PlayerCommunication::mut_pings_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_pings_per_interval",
                    CMsgSignOutCommunicationSummary_PlayerCommunication::get_max_pings_per_interval_for_reflect,
                    CMsgSignOutCommunicationSummary_PlayerCommunication::mut_max_pings_per_interval_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "teammate_pings",
                    CMsgSignOutCommunicationSummary_PlayerCommunication::get_teammate_pings_for_reflect,
                    CMsgSignOutCommunicationSummary_PlayerCommunication::mut_teammate_pings_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_teammate_pings_per_interval",
                    CMsgSignOutCommunicationSummary_PlayerCommunication::get_max_teammate_pings_per_interval_for_reflect,
                    CMsgSignOutCommunicationSummary_PlayerCommunication::mut_max_teammate_pings_per_interval_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_chat_messages",
                    CMsgSignOutCommunicationSummary_PlayerCommunication::get_team_chat_messages_for_reflect,
                    CMsgSignOutCommunicationSummary_PlayerCommunication::mut_team_chat_messages_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "all_chat_messages",
                    CMsgSignOutCommunicationSummary_PlayerCommunication::get_all_chat_messages_for_reflect,
                    CMsgSignOutCommunicationSummary_PlayerCommunication::mut_all_chat_messages_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "chat_wheel_messages",
                    CMsgSignOutCommunicationSummary_PlayerCommunication::get_chat_wheel_messages_for_reflect,
                    CMsgSignOutCommunicationSummary_PlayerCommunication::mut_chat_wheel_messages_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pauses",
                    CMsgSignOutCommunicationSummary_PlayerCommunication::get_pauses_for_reflect,
                    CMsgSignOutCommunicationSummary_PlayerCommunication::mut_pauses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "unpauses",
                    CMsgSignOutCommunicationSummary_PlayerCommunication::get_unpauses_for_reflect,
                    CMsgSignOutCommunicationSummary_PlayerCommunication::mut_unpauses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lines_drawn",
                    CMsgSignOutCommunicationSummary_PlayerCommunication::get_lines_drawn_for_reflect,
                    CMsgSignOutCommunicationSummary_PlayerCommunication::mut_lines_drawn_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "voice_chat_seconds",
                    CMsgSignOutCommunicationSummary_PlayerCommunication::get_voice_chat_seconds_for_reflect,
                    CMsgSignOutCommunicationSummary_PlayerCommunication::mut_voice_chat_seconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "chat_mutes",
                    CMsgSignOutCommunicationSummary_PlayerCommunication::get_chat_mutes_for_reflect,
                    CMsgSignOutCommunicationSummary_PlayerCommunication::mut_chat_mutes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "voice_mutes",
                    CMsgSignOutCommunicationSummary_PlayerCommunication::get_voice_mutes_for_reflect,
                    CMsgSignOutCommunicationSummary_PlayerCommunication::mut_voice_mutes_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSignOutCommunicationSummary_PlayerCommunication>(
                    "CMsgSignOutCommunicationSummary_PlayerCommunication",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSignOutCommunicationSummary_PlayerCommunication {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_pings();
        self.clear_max_pings_per_interval();
        self.clear_teammate_pings();
        self.clear_max_teammate_pings_per_interval();
        self.clear_team_chat_messages();
        self.clear_all_chat_messages();
        self.clear_chat_wheel_messages();
        self.clear_pauses();
        self.clear_unpauses();
        self.clear_lines_drawn();
        self.clear_voice_chat_seconds();
        self.clear_chat_mutes();
        self.clear_voice_mutes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSignOutCommunicationSummary_PlayerCommunication {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutCommunicationSummary_PlayerCommunication {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameMatchSignoutResponse {
    // message fields
    match_id: ::std::option::Option<u64>,
    replay_salt: ::std::option::Option<u32>,
    timed_reward_details: ::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CLobbyTimedRewardDetails>,
    xp_reward_details: ::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CDOTALobbyMember>,
    leagueid: ::std::option::Option<u32>,
    additional_msgs: ::protobuf::RepeatedField<CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg>,
    metadata_private_key: ::std::option::Option<u32>,
    match_details: ::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgDOTAMatch>,
    players_metadata: ::protobuf::RepeatedField<CMsgGameMatchSignoutResponse_PlayerMetadata>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameMatchSignoutResponse {}

impl CMsgGameMatchSignoutResponse {
    pub fn new() -> CMsgGameMatchSignoutResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameMatchSignoutResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameMatchSignoutResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameMatchSignoutResponse,
        };
        unsafe {
            instance.get(CMsgGameMatchSignoutResponse::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional fixed32 replay_salt = 2;

    pub fn clear_replay_salt(&mut self) {
        self.replay_salt = ::std::option::Option::None;
    }

    pub fn has_replay_salt(&self) -> bool {
        self.replay_salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_salt(&mut self, v: u32) {
        self.replay_salt = ::std::option::Option::Some(v);
    }

    pub fn get_replay_salt(&self) -> u32 {
        self.replay_salt.unwrap_or(0)
    }

    fn get_replay_salt_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.replay_salt
    }

    fn mut_replay_salt_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.replay_salt
    }

    // repeated .CLobbyTimedRewardDetails timed_reward_details = 3;

    pub fn clear_timed_reward_details(&mut self) {
        self.timed_reward_details.clear();
    }

    // Param is passed by value, moved
    pub fn set_timed_reward_details(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CLobbyTimedRewardDetails>) {
        self.timed_reward_details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_timed_reward_details(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CLobbyTimedRewardDetails> {
        &mut self.timed_reward_details
    }

    // Take field
    pub fn take_timed_reward_details(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CLobbyTimedRewardDetails> {
        ::std::mem::replace(&mut self.timed_reward_details, ::protobuf::RepeatedField::new())
    }

    pub fn get_timed_reward_details(&self) -> &[super::dota_gcmessages_common_match_management::CLobbyTimedRewardDetails] {
        &self.timed_reward_details
    }

    fn get_timed_reward_details_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CLobbyTimedRewardDetails> {
        &self.timed_reward_details
    }

    fn mut_timed_reward_details_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CLobbyTimedRewardDetails> {
        &mut self.timed_reward_details
    }

    // repeated .CDOTALobbyMember xp_reward_details = 4;

    pub fn clear_xp_reward_details(&mut self) {
        self.xp_reward_details.clear();
    }

    // Param is passed by value, moved
    pub fn set_xp_reward_details(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CDOTALobbyMember>) {
        self.xp_reward_details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_xp_reward_details(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CDOTALobbyMember> {
        &mut self.xp_reward_details
    }

    // Take field
    pub fn take_xp_reward_details(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CDOTALobbyMember> {
        ::std::mem::replace(&mut self.xp_reward_details, ::protobuf::RepeatedField::new())
    }

    pub fn get_xp_reward_details(&self) -> &[super::dota_gcmessages_common_match_management::CDOTALobbyMember] {
        &self.xp_reward_details
    }

    fn get_xp_reward_details_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CDOTALobbyMember> {
        &self.xp_reward_details
    }

    fn mut_xp_reward_details_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CDOTALobbyMember> {
        &mut self.xp_reward_details
    }

    // optional uint32 leagueid = 5;

    pub fn clear_leagueid(&mut self) {
        self.leagueid = ::std::option::Option::None;
    }

    pub fn has_leagueid(&self) -> bool {
        self.leagueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leagueid(&mut self, v: u32) {
        self.leagueid = ::std::option::Option::Some(v);
    }

    pub fn get_leagueid(&self) -> u32 {
        self.leagueid.unwrap_or(0)
    }

    fn get_leagueid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.leagueid
    }

    fn mut_leagueid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.leagueid
    }

    // repeated .CMsgGameMatchSignoutResponse.CAdditionalSignoutMsg additional_msgs = 6;

    pub fn clear_additional_msgs(&mut self) {
        self.additional_msgs.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_msgs(&mut self, v: ::protobuf::RepeatedField<CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg>) {
        self.additional_msgs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additional_msgs(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg> {
        &mut self.additional_msgs
    }

    // Take field
    pub fn take_additional_msgs(&mut self) -> ::protobuf::RepeatedField<CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg> {
        ::std::mem::replace(&mut self.additional_msgs, ::protobuf::RepeatedField::new())
    }

    pub fn get_additional_msgs(&self) -> &[CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg] {
        &self.additional_msgs
    }

    fn get_additional_msgs_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg> {
        &self.additional_msgs
    }

    fn mut_additional_msgs_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg> {
        &mut self.additional_msgs
    }

    // optional fixed32 metadata_private_key = 7;

    pub fn clear_metadata_private_key(&mut self) {
        self.metadata_private_key = ::std::option::Option::None;
    }

    pub fn has_metadata_private_key(&self) -> bool {
        self.metadata_private_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata_private_key(&mut self, v: u32) {
        self.metadata_private_key = ::std::option::Option::Some(v);
    }

    pub fn get_metadata_private_key(&self) -> u32 {
        self.metadata_private_key.unwrap_or(0)
    }

    fn get_metadata_private_key_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.metadata_private_key
    }

    fn mut_metadata_private_key_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.metadata_private_key
    }

    // optional .CMsgDOTAMatch match_details = 8;

    pub fn clear_match_details(&mut self) {
        self.match_details.clear();
    }

    pub fn has_match_details(&self) -> bool {
        self.match_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_details(&mut self, v: super::dota_gcmessages_common::CMsgDOTAMatch) {
        self.match_details = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_match_details(&mut self) -> &mut super::dota_gcmessages_common::CMsgDOTAMatch {
        if self.match_details.is_none() {
            self.match_details.set_default();
        }
        self.match_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_match_details(&mut self) -> super::dota_gcmessages_common::CMsgDOTAMatch {
        self.match_details.take().unwrap_or_else(|| super::dota_gcmessages_common::CMsgDOTAMatch::new())
    }

    pub fn get_match_details(&self) -> &super::dota_gcmessages_common::CMsgDOTAMatch {
        self.match_details.as_ref().unwrap_or_else(|| super::dota_gcmessages_common::CMsgDOTAMatch::default_instance())
    }

    fn get_match_details_for_reflect(&self) -> &::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &self.match_details
    }

    fn mut_match_details_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &mut self.match_details
    }

    // repeated .CMsgGameMatchSignoutResponse.PlayerMetadata players_metadata = 9;

    pub fn clear_players_metadata(&mut self) {
        self.players_metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_players_metadata(&mut self, v: ::protobuf::RepeatedField<CMsgGameMatchSignoutResponse_PlayerMetadata>) {
        self.players_metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players_metadata(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGameMatchSignoutResponse_PlayerMetadata> {
        &mut self.players_metadata
    }

    // Take field
    pub fn take_players_metadata(&mut self) -> ::protobuf::RepeatedField<CMsgGameMatchSignoutResponse_PlayerMetadata> {
        ::std::mem::replace(&mut self.players_metadata, ::protobuf::RepeatedField::new())
    }

    pub fn get_players_metadata(&self) -> &[CMsgGameMatchSignoutResponse_PlayerMetadata] {
        &self.players_metadata
    }

    fn get_players_metadata_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGameMatchSignoutResponse_PlayerMetadata> {
        &self.players_metadata
    }

    fn mut_players_metadata_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGameMatchSignoutResponse_PlayerMetadata> {
        &mut self.players_metadata
    }
}

impl ::protobuf::Message for CMsgGameMatchSignoutResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.timed_reward_details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.xp_reward_details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.additional_msgs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.match_details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.players_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.replay_salt = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.timed_reward_details)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.xp_reward_details)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leagueid = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.additional_msgs)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.metadata_private_key = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.match_details)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players_metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.replay_salt {
            my_size += 5;
        }
        for value in &self.timed_reward_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.xp_reward_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.leagueid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.additional_msgs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.metadata_private_key {
            my_size += 5;
        }
        if let Some(ref v) = self.match_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.players_metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.replay_salt {
            os.write_fixed32(2, v)?;
        }
        for v in &self.timed_reward_details {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.xp_reward_details {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.leagueid {
            os.write_uint32(5, v)?;
        }
        for v in &self.additional_msgs {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.metadata_private_key {
            os.write_fixed32(7, v)?;
        }
        if let Some(ref v) = self.match_details.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.players_metadata {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameMatchSignoutResponse {
    fn new() -> CMsgGameMatchSignoutResponse {
        CMsgGameMatchSignoutResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameMatchSignoutResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgGameMatchSignoutResponse::get_match_id_for_reflect,
                    CMsgGameMatchSignoutResponse::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "replay_salt",
                    CMsgGameMatchSignoutResponse::get_replay_salt_for_reflect,
                    CMsgGameMatchSignoutResponse::mut_replay_salt_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common_match_management::CLobbyTimedRewardDetails>>(
                    "timed_reward_details",
                    CMsgGameMatchSignoutResponse::get_timed_reward_details_for_reflect,
                    CMsgGameMatchSignoutResponse::mut_timed_reward_details_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common_match_management::CDOTALobbyMember>>(
                    "xp_reward_details",
                    CMsgGameMatchSignoutResponse::get_xp_reward_details_for_reflect,
                    CMsgGameMatchSignoutResponse::mut_xp_reward_details_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "leagueid",
                    CMsgGameMatchSignoutResponse::get_leagueid_for_reflect,
                    CMsgGameMatchSignoutResponse::mut_leagueid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg>>(
                    "additional_msgs",
                    CMsgGameMatchSignoutResponse::get_additional_msgs_for_reflect,
                    CMsgGameMatchSignoutResponse::mut_additional_msgs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "metadata_private_key",
                    CMsgGameMatchSignoutResponse::get_metadata_private_key_for_reflect,
                    CMsgGameMatchSignoutResponse::mut_metadata_private_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMsgDOTAMatch>>(
                    "match_details",
                    CMsgGameMatchSignoutResponse::get_match_details_for_reflect,
                    CMsgGameMatchSignoutResponse::mut_match_details_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGameMatchSignoutResponse_PlayerMetadata>>(
                    "players_metadata",
                    CMsgGameMatchSignoutResponse::get_players_metadata_for_reflect,
                    CMsgGameMatchSignoutResponse::mut_players_metadata_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameMatchSignoutResponse>(
                    "CMsgGameMatchSignoutResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameMatchSignoutResponse {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_replay_salt();
        self.clear_timed_reward_details();
        self.clear_xp_reward_details();
        self.clear_leagueid();
        self.clear_additional_msgs();
        self.clear_metadata_private_key();
        self.clear_match_details();
        self.clear_players_metadata();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameMatchSignoutResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignoutResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg {
    // message fields
    id: ::std::option::Option<u32>,
    contents: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg {}

impl CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg {
    pub fn new() -> CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg,
        };
        unsafe {
            instance.get(CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg::new)
        }
    }

    // optional uint32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.id
    }

    // optional bytes contents = 2;

    pub fn clear_contents(&mut self) {
        self.contents.clear();
    }

    pub fn has_contents(&self) -> bool {
        self.contents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contents(&mut self, v: ::std::vec::Vec<u8>) {
        self.contents = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contents(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.contents.is_none() {
            self.contents.set_default();
        }
        self.contents.as_mut().unwrap()
    }

    // Take field
    pub fn take_contents(&mut self) -> ::std::vec::Vec<u8> {
        self.contents.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_contents(&self) -> &[u8] {
        match self.contents.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_contents_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.contents
    }

    fn mut_contents_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.contents
    }
}

impl ::protobuf::Message for CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.contents)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.contents.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.contents.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg {
    fn new() -> CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg {
        CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg::get_id_for_reflect,
                    CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "contents",
                    CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg::get_contents_for_reflect,
                    CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg::mut_contents_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg>(
                    "CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_contents();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignoutResponse_CAdditionalSignoutMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameMatchSignoutResponse_PlayerMetadata {
    // message fields
    hero_id: ::std::option::Option<u32>,
    avg_kills_x16: ::std::option::Option<u32>,
    avg_deaths_x16: ::std::option::Option<u32>,
    avg_assists_x16: ::std::option::Option<u32>,
    avg_gpm_x16: ::std::option::Option<u32>,
    avg_xpm_x16: ::std::option::Option<u32>,
    best_kills_x16: ::std::option::Option<u32>,
    best_assists_x16: ::std::option::Option<u32>,
    best_gpm_x16: ::std::option::Option<u32>,
    best_xpm_x16: ::std::option::Option<u32>,
    win_streak: ::std::option::Option<u32>,
    best_win_streak: ::std::option::Option<u32>,
    games_played: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameMatchSignoutResponse_PlayerMetadata {}

impl CMsgGameMatchSignoutResponse_PlayerMetadata {
    pub fn new() -> CMsgGameMatchSignoutResponse_PlayerMetadata {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameMatchSignoutResponse_PlayerMetadata {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameMatchSignoutResponse_PlayerMetadata> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameMatchSignoutResponse_PlayerMetadata,
        };
        unsafe {
            instance.get(CMsgGameMatchSignoutResponse_PlayerMetadata::new)
        }
    }

    // optional uint32 hero_id = 1;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 avg_kills_x16 = 2;

    pub fn clear_avg_kills_x16(&mut self) {
        self.avg_kills_x16 = ::std::option::Option::None;
    }

    pub fn has_avg_kills_x16(&self) -> bool {
        self.avg_kills_x16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_kills_x16(&mut self, v: u32) {
        self.avg_kills_x16 = ::std::option::Option::Some(v);
    }

    pub fn get_avg_kills_x16(&self) -> u32 {
        self.avg_kills_x16.unwrap_or(0)
    }

    fn get_avg_kills_x16_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.avg_kills_x16
    }

    fn mut_avg_kills_x16_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.avg_kills_x16
    }

    // optional uint32 avg_deaths_x16 = 3;

    pub fn clear_avg_deaths_x16(&mut self) {
        self.avg_deaths_x16 = ::std::option::Option::None;
    }

    pub fn has_avg_deaths_x16(&self) -> bool {
        self.avg_deaths_x16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_deaths_x16(&mut self, v: u32) {
        self.avg_deaths_x16 = ::std::option::Option::Some(v);
    }

    pub fn get_avg_deaths_x16(&self) -> u32 {
        self.avg_deaths_x16.unwrap_or(0)
    }

    fn get_avg_deaths_x16_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.avg_deaths_x16
    }

    fn mut_avg_deaths_x16_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.avg_deaths_x16
    }

    // optional uint32 avg_assists_x16 = 4;

    pub fn clear_avg_assists_x16(&mut self) {
        self.avg_assists_x16 = ::std::option::Option::None;
    }

    pub fn has_avg_assists_x16(&self) -> bool {
        self.avg_assists_x16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_assists_x16(&mut self, v: u32) {
        self.avg_assists_x16 = ::std::option::Option::Some(v);
    }

    pub fn get_avg_assists_x16(&self) -> u32 {
        self.avg_assists_x16.unwrap_or(0)
    }

    fn get_avg_assists_x16_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.avg_assists_x16
    }

    fn mut_avg_assists_x16_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.avg_assists_x16
    }

    // optional uint32 avg_gpm_x16 = 5;

    pub fn clear_avg_gpm_x16(&mut self) {
        self.avg_gpm_x16 = ::std::option::Option::None;
    }

    pub fn has_avg_gpm_x16(&self) -> bool {
        self.avg_gpm_x16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_gpm_x16(&mut self, v: u32) {
        self.avg_gpm_x16 = ::std::option::Option::Some(v);
    }

    pub fn get_avg_gpm_x16(&self) -> u32 {
        self.avg_gpm_x16.unwrap_or(0)
    }

    fn get_avg_gpm_x16_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.avg_gpm_x16
    }

    fn mut_avg_gpm_x16_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.avg_gpm_x16
    }

    // optional uint32 avg_xpm_x16 = 6;

    pub fn clear_avg_xpm_x16(&mut self) {
        self.avg_xpm_x16 = ::std::option::Option::None;
    }

    pub fn has_avg_xpm_x16(&self) -> bool {
        self.avg_xpm_x16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_xpm_x16(&mut self, v: u32) {
        self.avg_xpm_x16 = ::std::option::Option::Some(v);
    }

    pub fn get_avg_xpm_x16(&self) -> u32 {
        self.avg_xpm_x16.unwrap_or(0)
    }

    fn get_avg_xpm_x16_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.avg_xpm_x16
    }

    fn mut_avg_xpm_x16_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.avg_xpm_x16
    }

    // optional uint32 best_kills_x16 = 7;

    pub fn clear_best_kills_x16(&mut self) {
        self.best_kills_x16 = ::std::option::Option::None;
    }

    pub fn has_best_kills_x16(&self) -> bool {
        self.best_kills_x16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_kills_x16(&mut self, v: u32) {
        self.best_kills_x16 = ::std::option::Option::Some(v);
    }

    pub fn get_best_kills_x16(&self) -> u32 {
        self.best_kills_x16.unwrap_or(0)
    }

    fn get_best_kills_x16_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.best_kills_x16
    }

    fn mut_best_kills_x16_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.best_kills_x16
    }

    // optional uint32 best_assists_x16 = 8;

    pub fn clear_best_assists_x16(&mut self) {
        self.best_assists_x16 = ::std::option::Option::None;
    }

    pub fn has_best_assists_x16(&self) -> bool {
        self.best_assists_x16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_assists_x16(&mut self, v: u32) {
        self.best_assists_x16 = ::std::option::Option::Some(v);
    }

    pub fn get_best_assists_x16(&self) -> u32 {
        self.best_assists_x16.unwrap_or(0)
    }

    fn get_best_assists_x16_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.best_assists_x16
    }

    fn mut_best_assists_x16_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.best_assists_x16
    }

    // optional uint32 best_gpm_x16 = 9;

    pub fn clear_best_gpm_x16(&mut self) {
        self.best_gpm_x16 = ::std::option::Option::None;
    }

    pub fn has_best_gpm_x16(&self) -> bool {
        self.best_gpm_x16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_gpm_x16(&mut self, v: u32) {
        self.best_gpm_x16 = ::std::option::Option::Some(v);
    }

    pub fn get_best_gpm_x16(&self) -> u32 {
        self.best_gpm_x16.unwrap_or(0)
    }

    fn get_best_gpm_x16_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.best_gpm_x16
    }

    fn mut_best_gpm_x16_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.best_gpm_x16
    }

    // optional uint32 best_xpm_x16 = 10;

    pub fn clear_best_xpm_x16(&mut self) {
        self.best_xpm_x16 = ::std::option::Option::None;
    }

    pub fn has_best_xpm_x16(&self) -> bool {
        self.best_xpm_x16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_xpm_x16(&mut self, v: u32) {
        self.best_xpm_x16 = ::std::option::Option::Some(v);
    }

    pub fn get_best_xpm_x16(&self) -> u32 {
        self.best_xpm_x16.unwrap_or(0)
    }

    fn get_best_xpm_x16_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.best_xpm_x16
    }

    fn mut_best_xpm_x16_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.best_xpm_x16
    }

    // optional uint32 win_streak = 11;

    pub fn clear_win_streak(&mut self) {
        self.win_streak = ::std::option::Option::None;
    }

    pub fn has_win_streak(&self) -> bool {
        self.win_streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win_streak(&mut self, v: u32) {
        self.win_streak = ::std::option::Option::Some(v);
    }

    pub fn get_win_streak(&self) -> u32 {
        self.win_streak.unwrap_or(0)
    }

    fn get_win_streak_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.win_streak
    }

    fn mut_win_streak_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.win_streak
    }

    // optional uint32 best_win_streak = 12;

    pub fn clear_best_win_streak(&mut self) {
        self.best_win_streak = ::std::option::Option::None;
    }

    pub fn has_best_win_streak(&self) -> bool {
        self.best_win_streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_win_streak(&mut self, v: u32) {
        self.best_win_streak = ::std::option::Option::Some(v);
    }

    pub fn get_best_win_streak(&self) -> u32 {
        self.best_win_streak.unwrap_or(0)
    }

    fn get_best_win_streak_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.best_win_streak
    }

    fn mut_best_win_streak_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.best_win_streak
    }

    // optional uint32 games_played = 13;

    pub fn clear_games_played(&mut self) {
        self.games_played = ::std::option::Option::None;
    }

    pub fn has_games_played(&self) -> bool {
        self.games_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games_played(&mut self, v: u32) {
        self.games_played = ::std::option::Option::Some(v);
    }

    pub fn get_games_played(&self) -> u32 {
        self.games_played.unwrap_or(0)
    }

    fn get_games_played_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.games_played
    }

    fn mut_games_played_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.games_played
    }
}

impl ::protobuf::Message for CMsgGameMatchSignoutResponse_PlayerMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.avg_kills_x16 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.avg_deaths_x16 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.avg_assists_x16 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.avg_gpm_x16 = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.avg_xpm_x16 = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.best_kills_x16 = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.best_assists_x16 = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.best_gpm_x16 = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.best_xpm_x16 = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.win_streak = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.best_win_streak = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.games_played = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.avg_kills_x16 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.avg_deaths_x16 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.avg_assists_x16 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.avg_gpm_x16 {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.avg_xpm_x16 {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.best_kills_x16 {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.best_assists_x16 {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.best_gpm_x16 {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.best_xpm_x16 {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.win_streak {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.best_win_streak {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.games_played {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.avg_kills_x16 {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.avg_deaths_x16 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.avg_assists_x16 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.avg_gpm_x16 {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.avg_xpm_x16 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.best_kills_x16 {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.best_assists_x16 {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.best_gpm_x16 {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.best_xpm_x16 {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.win_streak {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.best_win_streak {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.games_played {
            os.write_uint32(13, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameMatchSignoutResponse_PlayerMetadata {
    fn new() -> CMsgGameMatchSignoutResponse_PlayerMetadata {
        CMsgGameMatchSignoutResponse_PlayerMetadata::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameMatchSignoutResponse_PlayerMetadata>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgGameMatchSignoutResponse_PlayerMetadata::get_hero_id_for_reflect,
                    CMsgGameMatchSignoutResponse_PlayerMetadata::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "avg_kills_x16",
                    CMsgGameMatchSignoutResponse_PlayerMetadata::get_avg_kills_x16_for_reflect,
                    CMsgGameMatchSignoutResponse_PlayerMetadata::mut_avg_kills_x16_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "avg_deaths_x16",
                    CMsgGameMatchSignoutResponse_PlayerMetadata::get_avg_deaths_x16_for_reflect,
                    CMsgGameMatchSignoutResponse_PlayerMetadata::mut_avg_deaths_x16_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "avg_assists_x16",
                    CMsgGameMatchSignoutResponse_PlayerMetadata::get_avg_assists_x16_for_reflect,
                    CMsgGameMatchSignoutResponse_PlayerMetadata::mut_avg_assists_x16_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "avg_gpm_x16",
                    CMsgGameMatchSignoutResponse_PlayerMetadata::get_avg_gpm_x16_for_reflect,
                    CMsgGameMatchSignoutResponse_PlayerMetadata::mut_avg_gpm_x16_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "avg_xpm_x16",
                    CMsgGameMatchSignoutResponse_PlayerMetadata::get_avg_xpm_x16_for_reflect,
                    CMsgGameMatchSignoutResponse_PlayerMetadata::mut_avg_xpm_x16_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "best_kills_x16",
                    CMsgGameMatchSignoutResponse_PlayerMetadata::get_best_kills_x16_for_reflect,
                    CMsgGameMatchSignoutResponse_PlayerMetadata::mut_best_kills_x16_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "best_assists_x16",
                    CMsgGameMatchSignoutResponse_PlayerMetadata::get_best_assists_x16_for_reflect,
                    CMsgGameMatchSignoutResponse_PlayerMetadata::mut_best_assists_x16_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "best_gpm_x16",
                    CMsgGameMatchSignoutResponse_PlayerMetadata::get_best_gpm_x16_for_reflect,
                    CMsgGameMatchSignoutResponse_PlayerMetadata::mut_best_gpm_x16_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "best_xpm_x16",
                    CMsgGameMatchSignoutResponse_PlayerMetadata::get_best_xpm_x16_for_reflect,
                    CMsgGameMatchSignoutResponse_PlayerMetadata::mut_best_xpm_x16_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "win_streak",
                    CMsgGameMatchSignoutResponse_PlayerMetadata::get_win_streak_for_reflect,
                    CMsgGameMatchSignoutResponse_PlayerMetadata::mut_win_streak_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "best_win_streak",
                    CMsgGameMatchSignoutResponse_PlayerMetadata::get_best_win_streak_for_reflect,
                    CMsgGameMatchSignoutResponse_PlayerMetadata::mut_best_win_streak_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "games_played",
                    CMsgGameMatchSignoutResponse_PlayerMetadata::get_games_played_for_reflect,
                    CMsgGameMatchSignoutResponse_PlayerMetadata::mut_games_played_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameMatchSignoutResponse_PlayerMetadata>(
                    "CMsgGameMatchSignoutResponse_PlayerMetadata",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameMatchSignoutResponse_PlayerMetadata {
    fn clear(&mut self) {
        self.clear_hero_id();
        self.clear_avg_kills_x16();
        self.clear_avg_deaths_x16();
        self.clear_avg_assists_x16();
        self.clear_avg_gpm_x16();
        self.clear_avg_xpm_x16();
        self.clear_best_kills_x16();
        self.clear_best_assists_x16();
        self.clear_best_gpm_x16();
        self.clear_best_xpm_x16();
        self.clear_win_streak();
        self.clear_best_win_streak();
        self.clear_games_played();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameMatchSignoutResponse_PlayerMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignoutResponse_PlayerMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTimedRewardContainer {
    // message fields
    timed_reward_details: ::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CLobbyTimedRewardDetails>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgTimedRewardContainer {}

impl CMsgTimedRewardContainer {
    pub fn new() -> CMsgTimedRewardContainer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgTimedRewardContainer {
        static mut instance: ::protobuf::lazy::Lazy<CMsgTimedRewardContainer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgTimedRewardContainer,
        };
        unsafe {
            instance.get(CMsgTimedRewardContainer::new)
        }
    }

    // repeated .CLobbyTimedRewardDetails timed_reward_details = 1;

    pub fn clear_timed_reward_details(&mut self) {
        self.timed_reward_details.clear();
    }

    // Param is passed by value, moved
    pub fn set_timed_reward_details(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CLobbyTimedRewardDetails>) {
        self.timed_reward_details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_timed_reward_details(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CLobbyTimedRewardDetails> {
        &mut self.timed_reward_details
    }

    // Take field
    pub fn take_timed_reward_details(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CLobbyTimedRewardDetails> {
        ::std::mem::replace(&mut self.timed_reward_details, ::protobuf::RepeatedField::new())
    }

    pub fn get_timed_reward_details(&self) -> &[super::dota_gcmessages_common_match_management::CLobbyTimedRewardDetails] {
        &self.timed_reward_details
    }

    fn get_timed_reward_details_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CLobbyTimedRewardDetails> {
        &self.timed_reward_details
    }

    fn mut_timed_reward_details_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common_match_management::CLobbyTimedRewardDetails> {
        &mut self.timed_reward_details
    }
}

impl ::protobuf::Message for CMsgTimedRewardContainer {
    fn is_initialized(&self) -> bool {
        for v in &self.timed_reward_details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.timed_reward_details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.timed_reward_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.timed_reward_details {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgTimedRewardContainer {
    fn new() -> CMsgTimedRewardContainer {
        CMsgTimedRewardContainer::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgTimedRewardContainer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common_match_management::CLobbyTimedRewardDetails>>(
                    "timed_reward_details",
                    CMsgTimedRewardContainer::get_timed_reward_details_for_reflect,
                    CMsgTimedRewardContainer::mut_timed_reward_details_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgTimedRewardContainer>(
                    "CMsgTimedRewardContainer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgTimedRewardContainer {
    fn clear(&mut self) {
        self.clear_timed_reward_details();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTimedRewardContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTimedRewardContainer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameMatchSignOutPermissionRequest {
    // message fields
    server_version: ::std::option::Option<u32>,
    local_attempt: ::std::option::Option<u32>,
    total_attempt: ::std::option::Option<u32>,
    seconds_waited: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameMatchSignOutPermissionRequest {}

impl CMsgGameMatchSignOutPermissionRequest {
    pub fn new() -> CMsgGameMatchSignOutPermissionRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameMatchSignOutPermissionRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameMatchSignOutPermissionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameMatchSignOutPermissionRequest,
        };
        unsafe {
            instance.get(CMsgGameMatchSignOutPermissionRequest::new)
        }
    }

    // optional uint32 server_version = 1;

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    pub fn get_server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    fn get_server_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_version
    }

    fn mut_server_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_version
    }

    // optional uint32 local_attempt = 2;

    pub fn clear_local_attempt(&mut self) {
        self.local_attempt = ::std::option::Option::None;
    }

    pub fn has_local_attempt(&self) -> bool {
        self.local_attempt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_attempt(&mut self, v: u32) {
        self.local_attempt = ::std::option::Option::Some(v);
    }

    pub fn get_local_attempt(&self) -> u32 {
        self.local_attempt.unwrap_or(0)
    }

    fn get_local_attempt_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.local_attempt
    }

    fn mut_local_attempt_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.local_attempt
    }

    // optional uint32 total_attempt = 3;

    pub fn clear_total_attempt(&mut self) {
        self.total_attempt = ::std::option::Option::None;
    }

    pub fn has_total_attempt(&self) -> bool {
        self.total_attempt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_attempt(&mut self, v: u32) {
        self.total_attempt = ::std::option::Option::Some(v);
    }

    pub fn get_total_attempt(&self) -> u32 {
        self.total_attempt.unwrap_or(0)
    }

    fn get_total_attempt_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_attempt
    }

    fn mut_total_attempt_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_attempt
    }

    // optional uint32 seconds_waited = 4;

    pub fn clear_seconds_waited(&mut self) {
        self.seconds_waited = ::std::option::Option::None;
    }

    pub fn has_seconds_waited(&self) -> bool {
        self.seconds_waited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_waited(&mut self, v: u32) {
        self.seconds_waited = ::std::option::Option::Some(v);
    }

    pub fn get_seconds_waited(&self) -> u32 {
        self.seconds_waited.unwrap_or(0)
    }

    fn get_seconds_waited_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.seconds_waited
    }

    fn mut_seconds_waited_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.seconds_waited
    }
}

impl ::protobuf::Message for CMsgGameMatchSignOutPermissionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_attempt = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_attempt = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_waited = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.local_attempt {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_attempt {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds_waited {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.local_attempt {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.total_attempt {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.seconds_waited {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameMatchSignOutPermissionRequest {
    fn new() -> CMsgGameMatchSignOutPermissionRequest {
        CMsgGameMatchSignOutPermissionRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameMatchSignOutPermissionRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_version",
                    CMsgGameMatchSignOutPermissionRequest::get_server_version_for_reflect,
                    CMsgGameMatchSignOutPermissionRequest::mut_server_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_attempt",
                    CMsgGameMatchSignOutPermissionRequest::get_local_attempt_for_reflect,
                    CMsgGameMatchSignOutPermissionRequest::mut_local_attempt_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_attempt",
                    CMsgGameMatchSignOutPermissionRequest::get_total_attempt_for_reflect,
                    CMsgGameMatchSignOutPermissionRequest::mut_total_attempt_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "seconds_waited",
                    CMsgGameMatchSignOutPermissionRequest::get_seconds_waited_for_reflect,
                    CMsgGameMatchSignOutPermissionRequest::mut_seconds_waited_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameMatchSignOutPermissionRequest>(
                    "CMsgGameMatchSignOutPermissionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameMatchSignOutPermissionRequest {
    fn clear(&mut self) {
        self.clear_server_version();
        self.clear_local_attempt();
        self.clear_total_attempt();
        self.clear_seconds_waited();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameMatchSignOutPermissionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignOutPermissionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameMatchSignOutPermissionResponse {
    // message fields
    permission_granted: ::std::option::Option<bool>,
    abandon_signout: ::std::option::Option<bool>,
    retry_delay_seconds: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameMatchSignOutPermissionResponse {}

impl CMsgGameMatchSignOutPermissionResponse {
    pub fn new() -> CMsgGameMatchSignOutPermissionResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameMatchSignOutPermissionResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameMatchSignOutPermissionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameMatchSignOutPermissionResponse,
        };
        unsafe {
            instance.get(CMsgGameMatchSignOutPermissionResponse::new)
        }
    }

    // optional bool permission_granted = 1;

    pub fn clear_permission_granted(&mut self) {
        self.permission_granted = ::std::option::Option::None;
    }

    pub fn has_permission_granted(&self) -> bool {
        self.permission_granted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission_granted(&mut self, v: bool) {
        self.permission_granted = ::std::option::Option::Some(v);
    }

    pub fn get_permission_granted(&self) -> bool {
        self.permission_granted.unwrap_or(false)
    }

    fn get_permission_granted_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.permission_granted
    }

    fn mut_permission_granted_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.permission_granted
    }

    // optional bool abandon_signout = 2;

    pub fn clear_abandon_signout(&mut self) {
        self.abandon_signout = ::std::option::Option::None;
    }

    pub fn has_abandon_signout(&self) -> bool {
        self.abandon_signout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abandon_signout(&mut self, v: bool) {
        self.abandon_signout = ::std::option::Option::Some(v);
    }

    pub fn get_abandon_signout(&self) -> bool {
        self.abandon_signout.unwrap_or(false)
    }

    fn get_abandon_signout_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.abandon_signout
    }

    fn mut_abandon_signout_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.abandon_signout
    }

    // optional uint32 retry_delay_seconds = 3;

    pub fn clear_retry_delay_seconds(&mut self) {
        self.retry_delay_seconds = ::std::option::Option::None;
    }

    pub fn has_retry_delay_seconds(&self) -> bool {
        self.retry_delay_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_delay_seconds(&mut self, v: u32) {
        self.retry_delay_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_retry_delay_seconds(&self) -> u32 {
        self.retry_delay_seconds.unwrap_or(0u32)
    }

    fn get_retry_delay_seconds_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.retry_delay_seconds
    }

    fn mut_retry_delay_seconds_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.retry_delay_seconds
    }
}

impl ::protobuf::Message for CMsgGameMatchSignOutPermissionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.permission_granted = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.abandon_signout = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.retry_delay_seconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.permission_granted {
            my_size += 2;
        }
        if let Some(v) = self.abandon_signout {
            my_size += 2;
        }
        if let Some(v) = self.retry_delay_seconds {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.permission_granted {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.abandon_signout {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.retry_delay_seconds {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameMatchSignOutPermissionResponse {
    fn new() -> CMsgGameMatchSignOutPermissionResponse {
        CMsgGameMatchSignOutPermissionResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameMatchSignOutPermissionResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "permission_granted",
                    CMsgGameMatchSignOutPermissionResponse::get_permission_granted_for_reflect,
                    CMsgGameMatchSignOutPermissionResponse::mut_permission_granted_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "abandon_signout",
                    CMsgGameMatchSignOutPermissionResponse::get_abandon_signout_for_reflect,
                    CMsgGameMatchSignOutPermissionResponse::mut_abandon_signout_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "retry_delay_seconds",
                    CMsgGameMatchSignOutPermissionResponse::get_retry_delay_seconds_for_reflect,
                    CMsgGameMatchSignOutPermissionResponse::mut_retry_delay_seconds_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameMatchSignOutPermissionResponse>(
                    "CMsgGameMatchSignOutPermissionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameMatchSignOutPermissionResponse {
    fn clear(&mut self) {
        self.clear_permission_granted();
        self.clear_abandon_signout();
        self.clear_retry_delay_seconds();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameMatchSignOutPermissionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignOutPermissionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameMatchSignOutEventGameData {
    // message fields
    event_id: ::std::option::Option<super::dota_shared_enums::EEvent>,
    game_name: ::protobuf::SingularField<::std::string::String>,
    map_name: ::protobuf::SingularField<::std::string::String>,
    event_game_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameMatchSignOutEventGameData {}

impl CMsgGameMatchSignOutEventGameData {
    pub fn new() -> CMsgGameMatchSignOutEventGameData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameMatchSignOutEventGameData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameMatchSignOutEventGameData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameMatchSignOutEventGameData,
        };
        unsafe {
            instance.get(CMsgGameMatchSignOutEventGameData::new)
        }
    }

    // optional .EEvent event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> super::dota_shared_enums::EEvent {
        self.event_id.unwrap_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::EEvent> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::EEvent> {
        &mut self.event_id
    }

    // optional string game_name = 2;

    pub fn clear_game_name(&mut self) {
        self.game_name.clear();
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name.set_default();
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_game_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.game_name
    }

    fn mut_game_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.game_name
    }

    // optional string map_name = 3;

    pub fn clear_map_name(&mut self) {
        self.map_name.clear();
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name.set_default();
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_map_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.map_name
    }

    fn mut_map_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.map_name
    }

    // optional bytes event_game_data = 4;

    pub fn clear_event_game_data(&mut self) {
        self.event_game_data.clear();
    }

    pub fn has_event_game_data(&self) -> bool {
        self.event_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.event_game_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.event_game_data.is_none() {
            self.event_game_data.set_default();
        }
        self.event_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.event_game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_event_game_data(&self) -> &[u8] {
        match self.event_game_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_event_game_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.event_game_data
    }

    fn mut_event_game_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.event_game_data
    }
}

impl ::protobuf::Message for CMsgGameMatchSignOutEventGameData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.event_game_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.game_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.event_game_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.game_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.map_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.event_game_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameMatchSignOutEventGameData {
    fn new() -> CMsgGameMatchSignOutEventGameData {
        CMsgGameMatchSignOutEventGameData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameMatchSignOutEventGameData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::EEvent>>(
                    "event_id",
                    CMsgGameMatchSignOutEventGameData::get_event_id_for_reflect,
                    CMsgGameMatchSignOutEventGameData::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "game_name",
                    CMsgGameMatchSignOutEventGameData::get_game_name_for_reflect,
                    CMsgGameMatchSignOutEventGameData::mut_game_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "map_name",
                    CMsgGameMatchSignOutEventGameData::get_map_name_for_reflect,
                    CMsgGameMatchSignOutEventGameData::mut_map_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "event_game_data",
                    CMsgGameMatchSignOutEventGameData::get_event_game_data_for_reflect,
                    CMsgGameMatchSignOutEventGameData::mut_event_game_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameMatchSignOutEventGameData>(
                    "CMsgGameMatchSignOutEventGameData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameMatchSignOutEventGameData {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_game_name();
        self.clear_map_name();
        self.clear_event_game_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameMatchSignOutEventGameData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameMatchSignOutEventGameData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALiveScoreboardUpdate {
    // message fields
    tournament_id: ::std::option::Option<u32>,
    tournament_game_id: ::std::option::Option<u32>,
    duration: ::std::option::Option<f32>,
    hltv_delay: ::std::option::Option<i32>,
    team_good: ::protobuf::SingularPtrField<CMsgDOTALiveScoreboardUpdate_Team>,
    team_bad: ::protobuf::SingularPtrField<CMsgDOTALiveScoreboardUpdate_Team>,
    roshan_respawn_timer: ::std::option::Option<u32>,
    league_id: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALiveScoreboardUpdate {}

impl CMsgDOTALiveScoreboardUpdate {
    pub fn new() -> CMsgDOTALiveScoreboardUpdate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALiveScoreboardUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALiveScoreboardUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALiveScoreboardUpdate,
        };
        unsafe {
            instance.get(CMsgDOTALiveScoreboardUpdate::new)
        }
    }

    // optional uint32 tournament_id = 1;

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id = ::std::option::Option::None;
    }

    pub fn has_tournament_id(&self) -> bool {
        self.tournament_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: u32) {
        self.tournament_id = ::std::option::Option::Some(v);
    }

    pub fn get_tournament_id(&self) -> u32 {
        self.tournament_id.unwrap_or(0)
    }

    fn get_tournament_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tournament_id
    }

    fn mut_tournament_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tournament_id
    }

    // optional uint32 tournament_game_id = 2;

    pub fn clear_tournament_game_id(&mut self) {
        self.tournament_game_id = ::std::option::Option::None;
    }

    pub fn has_tournament_game_id(&self) -> bool {
        self.tournament_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_game_id(&mut self, v: u32) {
        self.tournament_game_id = ::std::option::Option::Some(v);
    }

    pub fn get_tournament_game_id(&self) -> u32 {
        self.tournament_game_id.unwrap_or(0)
    }

    fn get_tournament_game_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tournament_game_id
    }

    fn mut_tournament_game_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tournament_game_id
    }

    // optional float duration = 3;

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    fn get_duration_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.duration
    }

    fn mut_duration_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.duration
    }

    // optional int32 hltv_delay = 4;

    pub fn clear_hltv_delay(&mut self) {
        self.hltv_delay = ::std::option::Option::None;
    }

    pub fn has_hltv_delay(&self) -> bool {
        self.hltv_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hltv_delay(&mut self, v: i32) {
        self.hltv_delay = ::std::option::Option::Some(v);
    }

    pub fn get_hltv_delay(&self) -> i32 {
        self.hltv_delay.unwrap_or(0)
    }

    fn get_hltv_delay_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.hltv_delay
    }

    fn mut_hltv_delay_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.hltv_delay
    }

    // optional .CMsgDOTALiveScoreboardUpdate.Team team_good = 5;

    pub fn clear_team_good(&mut self) {
        self.team_good.clear();
    }

    pub fn has_team_good(&self) -> bool {
        self.team_good.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_good(&mut self, v: CMsgDOTALiveScoreboardUpdate_Team) {
        self.team_good = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_good(&mut self) -> &mut CMsgDOTALiveScoreboardUpdate_Team {
        if self.team_good.is_none() {
            self.team_good.set_default();
        }
        self.team_good.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_good(&mut self) -> CMsgDOTALiveScoreboardUpdate_Team {
        self.team_good.take().unwrap_or_else(|| CMsgDOTALiveScoreboardUpdate_Team::new())
    }

    pub fn get_team_good(&self) -> &CMsgDOTALiveScoreboardUpdate_Team {
        self.team_good.as_ref().unwrap_or_else(|| CMsgDOTALiveScoreboardUpdate_Team::default_instance())
    }

    fn get_team_good_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTALiveScoreboardUpdate_Team> {
        &self.team_good
    }

    fn mut_team_good_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTALiveScoreboardUpdate_Team> {
        &mut self.team_good
    }

    // optional .CMsgDOTALiveScoreboardUpdate.Team team_bad = 6;

    pub fn clear_team_bad(&mut self) {
        self.team_bad.clear();
    }

    pub fn has_team_bad(&self) -> bool {
        self.team_bad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_bad(&mut self, v: CMsgDOTALiveScoreboardUpdate_Team) {
        self.team_bad = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_bad(&mut self) -> &mut CMsgDOTALiveScoreboardUpdate_Team {
        if self.team_bad.is_none() {
            self.team_bad.set_default();
        }
        self.team_bad.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_bad(&mut self) -> CMsgDOTALiveScoreboardUpdate_Team {
        self.team_bad.take().unwrap_or_else(|| CMsgDOTALiveScoreboardUpdate_Team::new())
    }

    pub fn get_team_bad(&self) -> &CMsgDOTALiveScoreboardUpdate_Team {
        self.team_bad.as_ref().unwrap_or_else(|| CMsgDOTALiveScoreboardUpdate_Team::default_instance())
    }

    fn get_team_bad_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTALiveScoreboardUpdate_Team> {
        &self.team_bad
    }

    fn mut_team_bad_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTALiveScoreboardUpdate_Team> {
        &mut self.team_bad
    }

    // optional uint32 roshan_respawn_timer = 7;

    pub fn clear_roshan_respawn_timer(&mut self) {
        self.roshan_respawn_timer = ::std::option::Option::None;
    }

    pub fn has_roshan_respawn_timer(&self) -> bool {
        self.roshan_respawn_timer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roshan_respawn_timer(&mut self, v: u32) {
        self.roshan_respawn_timer = ::std::option::Option::Some(v);
    }

    pub fn get_roshan_respawn_timer(&self) -> u32 {
        self.roshan_respawn_timer.unwrap_or(0)
    }

    fn get_roshan_respawn_timer_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.roshan_respawn_timer
    }

    fn mut_roshan_respawn_timer_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.roshan_respawn_timer
    }

    // optional uint32 league_id = 8;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional uint64 match_id = 9;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }
}

impl ::protobuf::Message for CMsgDOTALiveScoreboardUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.team_good {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.team_bad {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tournament_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tournament_game_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.hltv_delay = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.team_good)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.team_bad)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.roshan_respawn_timer = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tournament_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tournament_game_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.duration {
            my_size += 5;
        }
        if let Some(v) = self.hltv_delay {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.team_good.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.team_bad.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.roshan_respawn_timer {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tournament_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tournament_game_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.hltv_delay {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.team_good.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.team_bad.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.roshan_respawn_timer {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALiveScoreboardUpdate {
    fn new() -> CMsgDOTALiveScoreboardUpdate {
        CMsgDOTALiveScoreboardUpdate::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALiveScoreboardUpdate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tournament_id",
                    CMsgDOTALiveScoreboardUpdate::get_tournament_id_for_reflect,
                    CMsgDOTALiveScoreboardUpdate::mut_tournament_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tournament_game_id",
                    CMsgDOTALiveScoreboardUpdate::get_tournament_game_id_for_reflect,
                    CMsgDOTALiveScoreboardUpdate::mut_tournament_game_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "duration",
                    CMsgDOTALiveScoreboardUpdate::get_duration_for_reflect,
                    CMsgDOTALiveScoreboardUpdate::mut_duration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "hltv_delay",
                    CMsgDOTALiveScoreboardUpdate::get_hltv_delay_for_reflect,
                    CMsgDOTALiveScoreboardUpdate::mut_hltv_delay_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTALiveScoreboardUpdate_Team>>(
                    "team_good",
                    CMsgDOTALiveScoreboardUpdate::get_team_good_for_reflect,
                    CMsgDOTALiveScoreboardUpdate::mut_team_good_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTALiveScoreboardUpdate_Team>>(
                    "team_bad",
                    CMsgDOTALiveScoreboardUpdate::get_team_bad_for_reflect,
                    CMsgDOTALiveScoreboardUpdate::mut_team_bad_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "roshan_respawn_timer",
                    CMsgDOTALiveScoreboardUpdate::get_roshan_respawn_timer_for_reflect,
                    CMsgDOTALiveScoreboardUpdate::mut_roshan_respawn_timer_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgDOTALiveScoreboardUpdate::get_league_id_for_reflect,
                    CMsgDOTALiveScoreboardUpdate::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgDOTALiveScoreboardUpdate::get_match_id_for_reflect,
                    CMsgDOTALiveScoreboardUpdate::mut_match_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALiveScoreboardUpdate>(
                    "CMsgDOTALiveScoreboardUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALiveScoreboardUpdate {
    fn clear(&mut self) {
        self.clear_tournament_id();
        self.clear_tournament_game_id();
        self.clear_duration();
        self.clear_hltv_delay();
        self.clear_team_good();
        self.clear_team_bad();
        self.clear_roshan_respawn_timer();
        self.clear_league_id();
        self.clear_match_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALiveScoreboardUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALiveScoreboardUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALiveScoreboardUpdate_Team {
    // message fields
    players: ::protobuf::RepeatedField<CMsgDOTALiveScoreboardUpdate_Team_Player>,
    score: ::std::option::Option<u32>,
    tower_state: ::std::option::Option<u32>,
    barracks_state: ::std::option::Option<u32>,
    hero_picks: ::std::vec::Vec<u32>,
    hero_bans: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALiveScoreboardUpdate_Team {}

impl CMsgDOTALiveScoreboardUpdate_Team {
    pub fn new() -> CMsgDOTALiveScoreboardUpdate_Team {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALiveScoreboardUpdate_Team {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALiveScoreboardUpdate_Team> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALiveScoreboardUpdate_Team,
        };
        unsafe {
            instance.get(CMsgDOTALiveScoreboardUpdate_Team::new)
        }
    }

    // repeated .CMsgDOTALiveScoreboardUpdate.Team.Player players = 1;

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgDOTALiveScoreboardUpdate_Team_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTALiveScoreboardUpdate_Team_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgDOTALiveScoreboardUpdate_Team_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    pub fn get_players(&self) -> &[CMsgDOTALiveScoreboardUpdate_Team_Player] {
        &self.players
    }

    fn get_players_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTALiveScoreboardUpdate_Team_Player> {
        &self.players
    }

    fn mut_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTALiveScoreboardUpdate_Team_Player> {
        &mut self.players
    }

    // optional uint32 score = 2;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    fn get_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.score
    }

    fn mut_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.score
    }

    // optional uint32 tower_state = 3;

    pub fn clear_tower_state(&mut self) {
        self.tower_state = ::std::option::Option::None;
    }

    pub fn has_tower_state(&self) -> bool {
        self.tower_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_state(&mut self, v: u32) {
        self.tower_state = ::std::option::Option::Some(v);
    }

    pub fn get_tower_state(&self) -> u32 {
        self.tower_state.unwrap_or(0)
    }

    fn get_tower_state_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tower_state
    }

    fn mut_tower_state_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tower_state
    }

    // optional uint32 barracks_state = 4;

    pub fn clear_barracks_state(&mut self) {
        self.barracks_state = ::std::option::Option::None;
    }

    pub fn has_barracks_state(&self) -> bool {
        self.barracks_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_barracks_state(&mut self, v: u32) {
        self.barracks_state = ::std::option::Option::Some(v);
    }

    pub fn get_barracks_state(&self) -> u32 {
        self.barracks_state.unwrap_or(0)
    }

    fn get_barracks_state_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.barracks_state
    }

    fn mut_barracks_state_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.barracks_state
    }

    // repeated uint32 hero_picks = 5;

    pub fn clear_hero_picks(&mut self) {
        self.hero_picks.clear();
    }

    // Param is passed by value, moved
    pub fn set_hero_picks(&mut self, v: ::std::vec::Vec<u32>) {
        self.hero_picks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hero_picks(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.hero_picks
    }

    // Take field
    pub fn take_hero_picks(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.hero_picks, ::std::vec::Vec::new())
    }

    pub fn get_hero_picks(&self) -> &[u32] {
        &self.hero_picks
    }

    fn get_hero_picks_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.hero_picks
    }

    fn mut_hero_picks_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.hero_picks
    }

    // repeated uint32 hero_bans = 6;

    pub fn clear_hero_bans(&mut self) {
        self.hero_bans.clear();
    }

    // Param is passed by value, moved
    pub fn set_hero_bans(&mut self, v: ::std::vec::Vec<u32>) {
        self.hero_bans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hero_bans(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.hero_bans
    }

    // Take field
    pub fn take_hero_bans(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.hero_bans, ::std::vec::Vec::new())
    }

    pub fn get_hero_bans(&self) -> &[u32] {
        &self.hero_bans
    }

    fn get_hero_bans_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.hero_bans
    }

    fn mut_hero_bans_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.hero_bans
    }
}

impl ::protobuf::Message for CMsgDOTALiveScoreboardUpdate_Team {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tower_state = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.barracks_state = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.hero_picks)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.hero_bans)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tower_state {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.barracks_state {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.hero_picks {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.hero_bans {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.players {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.score {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.tower_state {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.barracks_state {
            os.write_uint32(4, v)?;
        }
        for v in &self.hero_picks {
            os.write_uint32(5, *v)?;
        };
        for v in &self.hero_bans {
            os.write_uint32(6, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALiveScoreboardUpdate_Team {
    fn new() -> CMsgDOTALiveScoreboardUpdate_Team {
        CMsgDOTALiveScoreboardUpdate_Team::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALiveScoreboardUpdate_Team>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTALiveScoreboardUpdate_Team_Player>>(
                    "players",
                    CMsgDOTALiveScoreboardUpdate_Team::get_players_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team::mut_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "score",
                    CMsgDOTALiveScoreboardUpdate_Team::get_score_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team::mut_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tower_state",
                    CMsgDOTALiveScoreboardUpdate_Team::get_tower_state_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team::mut_tower_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "barracks_state",
                    CMsgDOTALiveScoreboardUpdate_Team::get_barracks_state_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team::mut_barracks_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_picks",
                    CMsgDOTALiveScoreboardUpdate_Team::get_hero_picks_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team::mut_hero_picks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_bans",
                    CMsgDOTALiveScoreboardUpdate_Team::get_hero_bans_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team::mut_hero_bans_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALiveScoreboardUpdate_Team>(
                    "CMsgDOTALiveScoreboardUpdate_Team",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALiveScoreboardUpdate_Team {
    fn clear(&mut self) {
        self.clear_players();
        self.clear_score();
        self.clear_tower_state();
        self.clear_barracks_state();
        self.clear_hero_picks();
        self.clear_hero_bans();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALiveScoreboardUpdate_Team {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALiveScoreboardUpdate_Team {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALiveScoreboardUpdate_Team_Player {
    // message fields
    player_slot: ::std::option::Option<u32>,
    player_name: ::protobuf::SingularField<::std::string::String>,
    hero_name: ::protobuf::SingularField<::std::string::String>,
    hero_id: ::std::option::Option<u32>,
    kills: ::std::option::Option<u32>,
    deaths: ::std::option::Option<u32>,
    assists: ::std::option::Option<u32>,
    last_hits: ::std::option::Option<u32>,
    denies: ::std::option::Option<u32>,
    gold: ::std::option::Option<u32>,
    level: ::std::option::Option<u32>,
    gold_per_min: ::std::option::Option<f32>,
    xp_per_min: ::std::option::Option<f32>,
    ultimate_state: ::std::option::Option<CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState>,
    ultimate_cooldown: ::std::option::Option<f32>,
    item0: ::std::option::Option<u32>,
    item1: ::std::option::Option<u32>,
    item2: ::std::option::Option<u32>,
    item3: ::std::option::Option<u32>,
    item4: ::std::option::Option<u32>,
    item5: ::std::option::Option<u32>,
    respawn_timer: ::std::option::Option<u32>,
    account_id: ::std::option::Option<u32>,
    position_x: ::std::option::Option<f32>,
    position_y: ::std::option::Option<f32>,
    net_worth: ::std::option::Option<u32>,
    abilities: ::protobuf::RepeatedField<CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALiveScoreboardUpdate_Team_Player {}

impl CMsgDOTALiveScoreboardUpdate_Team_Player {
    pub fn new() -> CMsgDOTALiveScoreboardUpdate_Team_Player {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALiveScoreboardUpdate_Team_Player {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALiveScoreboardUpdate_Team_Player> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALiveScoreboardUpdate_Team_Player,
        };
        unsafe {
            instance.get(CMsgDOTALiveScoreboardUpdate_Team_Player::new)
        }
    }

    // optional uint32 player_slot = 1;

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: u32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    pub fn get_player_slot(&self) -> u32 {
        self.player_slot.unwrap_or(0)
    }

    fn get_player_slot_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_slot
    }

    fn mut_player_slot_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_slot
    }

    // optional string player_name = 2;

    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_player_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.player_name
    }

    fn mut_player_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.player_name
    }

    // optional string hero_name = 3;

    pub fn clear_hero_name(&mut self) {
        self.hero_name.clear();
    }

    pub fn has_hero_name(&self) -> bool {
        self.hero_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_name(&mut self, v: ::std::string::String) {
        self.hero_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hero_name(&mut self) -> &mut ::std::string::String {
        if self.hero_name.is_none() {
            self.hero_name.set_default();
        }
        self.hero_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_hero_name(&mut self) -> ::std::string::String {
        self.hero_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hero_name(&self) -> &str {
        match self.hero_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_hero_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.hero_name
    }

    fn mut_hero_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.hero_name
    }

    // optional uint32 hero_id = 4;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 kills = 5;

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    pub fn get_kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    fn get_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.kills
    }

    fn mut_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.kills
    }

    // optional uint32 deaths = 6;

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    pub fn get_deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    fn get_deaths_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.deaths
    }

    fn mut_deaths_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.deaths
    }

    // optional uint32 assists = 7;

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }

    pub fn get_assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    fn get_assists_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.assists
    }

    fn mut_assists_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.assists
    }

    // optional uint32 last_hits = 8;

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: u32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    pub fn get_last_hits(&self) -> u32 {
        self.last_hits.unwrap_or(0)
    }

    fn get_last_hits_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.last_hits
    }

    fn mut_last_hits_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.last_hits
    }

    // optional uint32 denies = 9;

    pub fn clear_denies(&mut self) {
        self.denies = ::std::option::Option::None;
    }

    pub fn has_denies(&self) -> bool {
        self.denies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denies(&mut self, v: u32) {
        self.denies = ::std::option::Option::Some(v);
    }

    pub fn get_denies(&self) -> u32 {
        self.denies.unwrap_or(0)
    }

    fn get_denies_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.denies
    }

    fn mut_denies_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.denies
    }

    // optional uint32 gold = 10;

    pub fn clear_gold(&mut self) {
        self.gold = ::std::option::Option::None;
    }

    pub fn has_gold(&self) -> bool {
        self.gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold(&mut self, v: u32) {
        self.gold = ::std::option::Option::Some(v);
    }

    pub fn get_gold(&self) -> u32 {
        self.gold.unwrap_or(0)
    }

    fn get_gold_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gold
    }

    fn mut_gold_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gold
    }

    // optional uint32 level = 11;

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    pub fn get_level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    fn get_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.level
    }

    fn mut_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.level
    }

    // optional float gold_per_min = 12;

    pub fn clear_gold_per_min(&mut self) {
        self.gold_per_min = ::std::option::Option::None;
    }

    pub fn has_gold_per_min(&self) -> bool {
        self.gold_per_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_per_min(&mut self, v: f32) {
        self.gold_per_min = ::std::option::Option::Some(v);
    }

    pub fn get_gold_per_min(&self) -> f32 {
        self.gold_per_min.unwrap_or(0.)
    }

    fn get_gold_per_min_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.gold_per_min
    }

    fn mut_gold_per_min_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.gold_per_min
    }

    // optional float xp_per_min = 13;

    pub fn clear_xp_per_min(&mut self) {
        self.xp_per_min = ::std::option::Option::None;
    }

    pub fn has_xp_per_min(&self) -> bool {
        self.xp_per_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_per_min(&mut self, v: f32) {
        self.xp_per_min = ::std::option::Option::Some(v);
    }

    pub fn get_xp_per_min(&self) -> f32 {
        self.xp_per_min.unwrap_or(0.)
    }

    fn get_xp_per_min_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.xp_per_min
    }

    fn mut_xp_per_min_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.xp_per_min
    }

    // optional .CMsgDOTALiveScoreboardUpdate.Team.Player.DOTAUltimateState ultimate_state = 14;

    pub fn clear_ultimate_state(&mut self) {
        self.ultimate_state = ::std::option::Option::None;
    }

    pub fn has_ultimate_state(&self) -> bool {
        self.ultimate_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ultimate_state(&mut self, v: CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState) {
        self.ultimate_state = ::std::option::Option::Some(v);
    }

    pub fn get_ultimate_state(&self) -> CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState {
        self.ultimate_state.unwrap_or(CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState::k_EDOTAUltimateStateNotLearned)
    }

    fn get_ultimate_state_for_reflect(&self) -> &::std::option::Option<CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState> {
        &self.ultimate_state
    }

    fn mut_ultimate_state_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState> {
        &mut self.ultimate_state
    }

    // optional float ultimate_cooldown = 15;

    pub fn clear_ultimate_cooldown(&mut self) {
        self.ultimate_cooldown = ::std::option::Option::None;
    }

    pub fn has_ultimate_cooldown(&self) -> bool {
        self.ultimate_cooldown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ultimate_cooldown(&mut self, v: f32) {
        self.ultimate_cooldown = ::std::option::Option::Some(v);
    }

    pub fn get_ultimate_cooldown(&self) -> f32 {
        self.ultimate_cooldown.unwrap_or(0.)
    }

    fn get_ultimate_cooldown_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.ultimate_cooldown
    }

    fn mut_ultimate_cooldown_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.ultimate_cooldown
    }

    // optional uint32 item0 = 16;

    pub fn clear_item0(&mut self) {
        self.item0 = ::std::option::Option::None;
    }

    pub fn has_item0(&self) -> bool {
        self.item0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item0(&mut self, v: u32) {
        self.item0 = ::std::option::Option::Some(v);
    }

    pub fn get_item0(&self) -> u32 {
        self.item0.unwrap_or(0)
    }

    fn get_item0_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item0
    }

    fn mut_item0_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item0
    }

    // optional uint32 item1 = 17;

    pub fn clear_item1(&mut self) {
        self.item1 = ::std::option::Option::None;
    }

    pub fn has_item1(&self) -> bool {
        self.item1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item1(&mut self, v: u32) {
        self.item1 = ::std::option::Option::Some(v);
    }

    pub fn get_item1(&self) -> u32 {
        self.item1.unwrap_or(0)
    }

    fn get_item1_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item1
    }

    fn mut_item1_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item1
    }

    // optional uint32 item2 = 18;

    pub fn clear_item2(&mut self) {
        self.item2 = ::std::option::Option::None;
    }

    pub fn has_item2(&self) -> bool {
        self.item2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item2(&mut self, v: u32) {
        self.item2 = ::std::option::Option::Some(v);
    }

    pub fn get_item2(&self) -> u32 {
        self.item2.unwrap_or(0)
    }

    fn get_item2_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item2
    }

    fn mut_item2_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item2
    }

    // optional uint32 item3 = 19;

    pub fn clear_item3(&mut self) {
        self.item3 = ::std::option::Option::None;
    }

    pub fn has_item3(&self) -> bool {
        self.item3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item3(&mut self, v: u32) {
        self.item3 = ::std::option::Option::Some(v);
    }

    pub fn get_item3(&self) -> u32 {
        self.item3.unwrap_or(0)
    }

    fn get_item3_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item3
    }

    fn mut_item3_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item3
    }

    // optional uint32 item4 = 20;

    pub fn clear_item4(&mut self) {
        self.item4 = ::std::option::Option::None;
    }

    pub fn has_item4(&self) -> bool {
        self.item4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item4(&mut self, v: u32) {
        self.item4 = ::std::option::Option::Some(v);
    }

    pub fn get_item4(&self) -> u32 {
        self.item4.unwrap_or(0)
    }

    fn get_item4_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item4
    }

    fn mut_item4_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item4
    }

    // optional uint32 item5 = 21;

    pub fn clear_item5(&mut self) {
        self.item5 = ::std::option::Option::None;
    }

    pub fn has_item5(&self) -> bool {
        self.item5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item5(&mut self, v: u32) {
        self.item5 = ::std::option::Option::Some(v);
    }

    pub fn get_item5(&self) -> u32 {
        self.item5.unwrap_or(0)
    }

    fn get_item5_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item5
    }

    fn mut_item5_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item5
    }

    // optional uint32 respawn_timer = 22;

    pub fn clear_respawn_timer(&mut self) {
        self.respawn_timer = ::std::option::Option::None;
    }

    pub fn has_respawn_timer(&self) -> bool {
        self.respawn_timer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_respawn_timer(&mut self, v: u32) {
        self.respawn_timer = ::std::option::Option::Some(v);
    }

    pub fn get_respawn_timer(&self) -> u32 {
        self.respawn_timer.unwrap_or(0)
    }

    fn get_respawn_timer_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.respawn_timer
    }

    fn mut_respawn_timer_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.respawn_timer
    }

    // optional uint32 account_id = 23;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional float position_x = 24;

    pub fn clear_position_x(&mut self) {
        self.position_x = ::std::option::Option::None;
    }

    pub fn has_position_x(&self) -> bool {
        self.position_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_x(&mut self, v: f32) {
        self.position_x = ::std::option::Option::Some(v);
    }

    pub fn get_position_x(&self) -> f32 {
        self.position_x.unwrap_or(0.)
    }

    fn get_position_x_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.position_x
    }

    fn mut_position_x_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.position_x
    }

    // optional float position_y = 25;

    pub fn clear_position_y(&mut self) {
        self.position_y = ::std::option::Option::None;
    }

    pub fn has_position_y(&self) -> bool {
        self.position_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_y(&mut self, v: f32) {
        self.position_y = ::std::option::Option::Some(v);
    }

    pub fn get_position_y(&self) -> f32 {
        self.position_y.unwrap_or(0.)
    }

    fn get_position_y_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.position_y
    }

    fn mut_position_y_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.position_y
    }

    // optional uint32 net_worth = 26;

    pub fn clear_net_worth(&mut self) {
        self.net_worth = ::std::option::Option::None;
    }

    pub fn has_net_worth(&self) -> bool {
        self.net_worth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_worth(&mut self, v: u32) {
        self.net_worth = ::std::option::Option::Some(v);
    }

    pub fn get_net_worth(&self) -> u32 {
        self.net_worth.unwrap_or(0)
    }

    fn get_net_worth_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.net_worth
    }

    fn mut_net_worth_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.net_worth
    }

    // repeated .CMsgDOTALiveScoreboardUpdate.Team.Player.HeroAbility abilities = 27;

    pub fn clear_abilities(&mut self) {
        self.abilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_abilities(&mut self, v: ::protobuf::RepeatedField<CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility>) {
        self.abilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_abilities(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility> {
        &mut self.abilities
    }

    // Take field
    pub fn take_abilities(&mut self) -> ::protobuf::RepeatedField<CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility> {
        ::std::mem::replace(&mut self.abilities, ::protobuf::RepeatedField::new())
    }

    pub fn get_abilities(&self) -> &[CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility] {
        &self.abilities
    }

    fn get_abilities_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility> {
        &self.abilities
    }

    fn mut_abilities_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility> {
        &mut self.abilities
    }
}

impl ::protobuf::Message for CMsgDOTALiveScoreboardUpdate_Team_Player {
    fn is_initialized(&self) -> bool {
        for v in &self.abilities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_slot = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hero_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kills = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deaths = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.assists = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_hits = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.denies = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gold = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.gold_per_min = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.xp_per_min = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.ultimate_state = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ultimate_cooldown = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item0 = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item1 = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item2 = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item3 = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item4 = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item5 = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.respawn_timer = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.position_x = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.position_y = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.net_worth = ::std::option::Option::Some(tmp);
                },
                27 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.abilities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_slot {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.hero_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.assists {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_hits {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.denies {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gold {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gold_per_min {
            my_size += 5;
        }
        if let Some(v) = self.xp_per_min {
            my_size += 5;
        }
        if let Some(v) = self.ultimate_state {
            my_size += ::protobuf::rt::enum_size(14, v);
        }
        if let Some(v) = self.ultimate_cooldown {
            my_size += 5;
        }
        if let Some(v) = self.item0 {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item1 {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item2 {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item3 {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item4 {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item5 {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.respawn_timer {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.position_x {
            my_size += 6;
        }
        if let Some(v) = self.position_y {
            my_size += 6;
        }
        if let Some(v) = self.net_worth {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.abilities {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_slot {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.player_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.hero_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.last_hits {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.denies {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.gold {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.gold_per_min {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.xp_per_min {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.ultimate_state {
            os.write_enum(14, v.value())?;
        }
        if let Some(v) = self.ultimate_cooldown {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.item0 {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.item1 {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.item2 {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.item3 {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.item4 {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.item5 {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.respawn_timer {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.position_x {
            os.write_float(24, v)?;
        }
        if let Some(v) = self.position_y {
            os.write_float(25, v)?;
        }
        if let Some(v) = self.net_worth {
            os.write_uint32(26, v)?;
        }
        for v in &self.abilities {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALiveScoreboardUpdate_Team_Player {
    fn new() -> CMsgDOTALiveScoreboardUpdate_Team_Player {
        CMsgDOTALiveScoreboardUpdate_Team_Player::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALiveScoreboardUpdate_Team_Player>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_slot",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_player_slot_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_player_slot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "player_name",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_player_name_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_player_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hero_name",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_hero_name_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_hero_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_hero_id_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "kills",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_kills_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "deaths",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_deaths_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_deaths_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "assists",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_assists_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_assists_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_hits",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_last_hits_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_last_hits_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "denies",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_denies_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_denies_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gold",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_gold_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_gold_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "level",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_level_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "gold_per_min",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_gold_per_min_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_gold_per_min_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "xp_per_min",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_xp_per_min_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_xp_per_min_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState>>(
                    "ultimate_state",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_ultimate_state_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_ultimate_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "ultimate_cooldown",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_ultimate_cooldown_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_ultimate_cooldown_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item0",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_item0_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_item0_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item1",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_item1_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_item1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item2",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_item2_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_item2_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item3",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_item3_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_item3_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item4",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_item4_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_item4_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item5",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_item5_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_item5_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "respawn_timer",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_respawn_timer_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_respawn_timer_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_account_id_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "position_x",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_position_x_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_position_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "position_y",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_position_y_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_position_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "net_worth",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_net_worth_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_net_worth_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility>>(
                    "abilities",
                    CMsgDOTALiveScoreboardUpdate_Team_Player::get_abilities_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player::mut_abilities_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALiveScoreboardUpdate_Team_Player>(
                    "CMsgDOTALiveScoreboardUpdate_Team_Player",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALiveScoreboardUpdate_Team_Player {
    fn clear(&mut self) {
        self.clear_player_slot();
        self.clear_player_name();
        self.clear_hero_name();
        self.clear_hero_id();
        self.clear_kills();
        self.clear_deaths();
        self.clear_assists();
        self.clear_last_hits();
        self.clear_denies();
        self.clear_gold();
        self.clear_level();
        self.clear_gold_per_min();
        self.clear_xp_per_min();
        self.clear_ultimate_state();
        self.clear_ultimate_cooldown();
        self.clear_item0();
        self.clear_item1();
        self.clear_item2();
        self.clear_item3();
        self.clear_item4();
        self.clear_item5();
        self.clear_respawn_timer();
        self.clear_account_id();
        self.clear_position_x();
        self.clear_position_y();
        self.clear_net_worth();
        self.clear_abilities();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALiveScoreboardUpdate_Team_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALiveScoreboardUpdate_Team_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility {
    // message fields
    ability_id: ::std::option::Option<u32>,
    ability_level: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility {}

impl CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility {
    pub fn new() -> CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility,
        };
        unsafe {
            instance.get(CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility::new)
        }
    }

    // optional uint32 ability_id = 1;

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: u32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    pub fn get_ability_id(&self) -> u32 {
        self.ability_id.unwrap_or(0)
    }

    fn get_ability_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ability_id
    }

    fn mut_ability_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ability_id
    }

    // optional uint32 ability_level = 2;

    pub fn clear_ability_level(&mut self) {
        self.ability_level = ::std::option::Option::None;
    }

    pub fn has_ability_level(&self) -> bool {
        self.ability_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_level(&mut self, v: u32) {
        self.ability_level = ::std::option::Option::Some(v);
    }

    pub fn get_ability_level(&self) -> u32 {
        self.ability_level.unwrap_or(0)
    }

    fn get_ability_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ability_level
    }

    fn mut_ability_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ability_level
    }
}

impl ::protobuf::Message for CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ability_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ability_level = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ability_level {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ability_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ability_level {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility {
    fn new() -> CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility {
        CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ability_id",
                    CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility::get_ability_id_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility::mut_ability_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ability_level",
                    CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility::get_ability_level_for_reflect,
                    CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility::mut_ability_level_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility>(
                    "CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility {
    fn clear(&mut self) {
        self.clear_ability_id();
        self.clear_ability_level();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState {
    k_EDOTAUltimateStateNotLearned = 0,
    k_EDOTAUltimateStateCooldown = 1,
    k_EDOTAUltimateStateNeedsMana = 2,
    k_EDOTAUltimateStateReady = 3,
}

impl ::protobuf::ProtobufEnum for CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState::k_EDOTAUltimateStateNotLearned),
            1 => ::std::option::Option::Some(CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState::k_EDOTAUltimateStateCooldown),
            2 => ::std::option::Option::Some(CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState::k_EDOTAUltimateStateNeedsMana),
            3 => ::std::option::Option::Some(CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState::k_EDOTAUltimateStateReady),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState] = &[
            CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState::k_EDOTAUltimateStateNotLearned,
            CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState::k_EDOTAUltimateStateCooldown,
            CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState::k_EDOTAUltimateStateNeedsMana,
            CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState::k_EDOTAUltimateStateReady,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARequestPlayerResources {
    // message fields
    steam_id: ::std::option::Option<u64>,
    player_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARequestPlayerResources {}

impl CMsgDOTARequestPlayerResources {
    pub fn new() -> CMsgDOTARequestPlayerResources {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARequestPlayerResources {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARequestPlayerResources> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARequestPlayerResources,
        };
        unsafe {
            instance.get(CMsgDOTARequestPlayerResources::new)
        }
    }

    // optional fixed64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    fn get_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.steam_id
    }

    fn mut_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.steam_id
    }

    // optional uint32 player_id = 2;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }
}

impl ::protobuf::Message for CMsgDOTARequestPlayerResources {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARequestPlayerResources {
    fn new() -> CMsgDOTARequestPlayerResources {
        CMsgDOTARequestPlayerResources::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARequestPlayerResources>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steam_id",
                    CMsgDOTARequestPlayerResources::get_steam_id_for_reflect,
                    CMsgDOTARequestPlayerResources::mut_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CMsgDOTARequestPlayerResources::get_player_id_for_reflect,
                    CMsgDOTARequestPlayerResources::mut_player_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARequestPlayerResources>(
                    "CMsgDOTARequestPlayerResources",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARequestPlayerResources {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_player_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARequestPlayerResources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARequestPlayerResources {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARequestPlayerResourcesResponse {
    // message fields
    steam_id: ::std::option::Option<u64>,
    rank: ::std::option::Option<u32>,
    player_id: ::std::option::Option<u32>,
    prevent_text_chat: ::std::option::Option<bool>,
    prevent_voice_chat: ::std::option::Option<bool>,
    low_priority: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARequestPlayerResourcesResponse {}

impl CMsgDOTARequestPlayerResourcesResponse {
    pub fn new() -> CMsgDOTARequestPlayerResourcesResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARequestPlayerResourcesResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARequestPlayerResourcesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARequestPlayerResourcesResponse,
        };
        unsafe {
            instance.get(CMsgDOTARequestPlayerResourcesResponse::new)
        }
    }

    // optional fixed64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    fn get_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.steam_id
    }

    fn mut_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.steam_id
    }

    // optional uint32 rank = 2;

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }

    pub fn get_rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }

    fn get_rank_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rank
    }

    fn mut_rank_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rank
    }

    // optional uint32 player_id = 3;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional bool prevent_text_chat = 4;

    pub fn clear_prevent_text_chat(&mut self) {
        self.prevent_text_chat = ::std::option::Option::None;
    }

    pub fn has_prevent_text_chat(&self) -> bool {
        self.prevent_text_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevent_text_chat(&mut self, v: bool) {
        self.prevent_text_chat = ::std::option::Option::Some(v);
    }

    pub fn get_prevent_text_chat(&self) -> bool {
        self.prevent_text_chat.unwrap_or(false)
    }

    fn get_prevent_text_chat_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.prevent_text_chat
    }

    fn mut_prevent_text_chat_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.prevent_text_chat
    }

    // optional bool prevent_voice_chat = 5;

    pub fn clear_prevent_voice_chat(&mut self) {
        self.prevent_voice_chat = ::std::option::Option::None;
    }

    pub fn has_prevent_voice_chat(&self) -> bool {
        self.prevent_voice_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevent_voice_chat(&mut self, v: bool) {
        self.prevent_voice_chat = ::std::option::Option::Some(v);
    }

    pub fn get_prevent_voice_chat(&self) -> bool {
        self.prevent_voice_chat.unwrap_or(false)
    }

    fn get_prevent_voice_chat_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.prevent_voice_chat
    }

    fn mut_prevent_voice_chat_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.prevent_voice_chat
    }

    // optional bool low_priority = 6;

    pub fn clear_low_priority(&mut self) {
        self.low_priority = ::std::option::Option::None;
    }

    pub fn has_low_priority(&self) -> bool {
        self.low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority(&mut self, v: bool) {
        self.low_priority = ::std::option::Option::Some(v);
    }

    pub fn get_low_priority(&self) -> bool {
        self.low_priority.unwrap_or(false)
    }

    fn get_low_priority_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.low_priority
    }

    fn mut_low_priority_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.low_priority
    }
}

impl ::protobuf::Message for CMsgDOTARequestPlayerResourcesResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rank = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prevent_text_chat = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prevent_voice_chat = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.low_priority = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prevent_text_chat {
            my_size += 2;
        }
        if let Some(v) = self.prevent_voice_chat {
            my_size += 2;
        }
        if let Some(v) = self.low_priority {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.rank {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.prevent_text_chat {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.prevent_voice_chat {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.low_priority {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARequestPlayerResourcesResponse {
    fn new() -> CMsgDOTARequestPlayerResourcesResponse {
        CMsgDOTARequestPlayerResourcesResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARequestPlayerResourcesResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steam_id",
                    CMsgDOTARequestPlayerResourcesResponse::get_steam_id_for_reflect,
                    CMsgDOTARequestPlayerResourcesResponse::mut_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rank",
                    CMsgDOTARequestPlayerResourcesResponse::get_rank_for_reflect,
                    CMsgDOTARequestPlayerResourcesResponse::mut_rank_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CMsgDOTARequestPlayerResourcesResponse::get_player_id_for_reflect,
                    CMsgDOTARequestPlayerResourcesResponse::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "prevent_text_chat",
                    CMsgDOTARequestPlayerResourcesResponse::get_prevent_text_chat_for_reflect,
                    CMsgDOTARequestPlayerResourcesResponse::mut_prevent_text_chat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "prevent_voice_chat",
                    CMsgDOTARequestPlayerResourcesResponse::get_prevent_voice_chat_for_reflect,
                    CMsgDOTARequestPlayerResourcesResponse::mut_prevent_voice_chat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "low_priority",
                    CMsgDOTARequestPlayerResourcesResponse::get_low_priority_for_reflect,
                    CMsgDOTARequestPlayerResourcesResponse::mut_low_priority_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARequestPlayerResourcesResponse>(
                    "CMsgDOTARequestPlayerResourcesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARequestPlayerResourcesResponse {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_rank();
        self.clear_player_id();
        self.clear_prevent_text_chat();
        self.clear_prevent_voice_chat();
        self.clear_low_priority();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARequestPlayerResourcesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARequestPlayerResourcesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARequestBatchPlayerResources {
    // message fields
    account_ids: ::std::vec::Vec<u32>,
    rank_types: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARequestBatchPlayerResources {}

impl CMsgDOTARequestBatchPlayerResources {
    pub fn new() -> CMsgDOTARequestBatchPlayerResources {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARequestBatchPlayerResources {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARequestBatchPlayerResources> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARequestBatchPlayerResources,
        };
        unsafe {
            instance.get(CMsgDOTARequestBatchPlayerResources::new)
        }
    }

    // repeated uint32 account_ids = 1;

    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }

    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }

    fn get_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.account_ids
    }

    fn mut_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // repeated uint32 rank_types = 4;

    pub fn clear_rank_types(&mut self) {
        self.rank_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_rank_types(&mut self, v: ::std::vec::Vec<u32>) {
        self.rank_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rank_types(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.rank_types
    }

    // Take field
    pub fn take_rank_types(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.rank_types, ::std::vec::Vec::new())
    }

    pub fn get_rank_types(&self) -> &[u32] {
        &self.rank_types
    }

    fn get_rank_types_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.rank_types
    }

    fn mut_rank_types_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.rank_types
    }
}

impl ::protobuf::Message for CMsgDOTARequestBatchPlayerResources {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.rank_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_ids.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(1, &self.account_ids);
        }
        if !self.rank_types.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(4, &self.rank_types);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.account_ids.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.account_ids))?;
            for v in &self.account_ids {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if !self.rank_types.is_empty() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.rank_types))?;
            for v in &self.rank_types {
                os.write_uint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARequestBatchPlayerResources {
    fn new() -> CMsgDOTARequestBatchPlayerResources {
        CMsgDOTARequestBatchPlayerResources::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARequestBatchPlayerResources>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids",
                    CMsgDOTARequestBatchPlayerResources::get_account_ids_for_reflect,
                    CMsgDOTARequestBatchPlayerResources::mut_account_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rank_types",
                    CMsgDOTARequestBatchPlayerResources::get_rank_types_for_reflect,
                    CMsgDOTARequestBatchPlayerResources::mut_rank_types_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARequestBatchPlayerResources>(
                    "CMsgDOTARequestBatchPlayerResources",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARequestBatchPlayerResources {
    fn clear(&mut self) {
        self.clear_account_ids();
        self.clear_rank_types();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARequestBatchPlayerResources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARequestBatchPlayerResources {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARequestBatchPlayerResourcesResponse {
    // message fields
    results: ::protobuf::RepeatedField<CMsgDOTARequestBatchPlayerResourcesResponse_Result>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARequestBatchPlayerResourcesResponse {}

impl CMsgDOTARequestBatchPlayerResourcesResponse {
    pub fn new() -> CMsgDOTARequestBatchPlayerResourcesResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARequestBatchPlayerResourcesResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARequestBatchPlayerResourcesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARequestBatchPlayerResourcesResponse,
        };
        unsafe {
            instance.get(CMsgDOTARequestBatchPlayerResourcesResponse::new)
        }
    }

    // repeated .CMsgDOTARequestBatchPlayerResourcesResponse.Result results = 6;

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARequestBatchPlayerResourcesResponse_Result>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARequestBatchPlayerResourcesResponse_Result> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARequestBatchPlayerResourcesResponse_Result> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }

    pub fn get_results(&self) -> &[CMsgDOTARequestBatchPlayerResourcesResponse_Result] {
        &self.results
    }

    fn get_results_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARequestBatchPlayerResourcesResponse_Result> {
        &self.results
    }

    fn mut_results_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARequestBatchPlayerResourcesResponse_Result> {
        &mut self.results
    }
}

impl ::protobuf::Message for CMsgDOTARequestBatchPlayerResourcesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.results {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARequestBatchPlayerResourcesResponse {
    fn new() -> CMsgDOTARequestBatchPlayerResourcesResponse {
        CMsgDOTARequestBatchPlayerResourcesResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARequestBatchPlayerResourcesResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARequestBatchPlayerResourcesResponse_Result>>(
                    "results",
                    CMsgDOTARequestBatchPlayerResourcesResponse::get_results_for_reflect,
                    CMsgDOTARequestBatchPlayerResourcesResponse::mut_results_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARequestBatchPlayerResourcesResponse>(
                    "CMsgDOTARequestBatchPlayerResourcesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARequestBatchPlayerResourcesResponse {
    fn clear(&mut self) {
        self.clear_results();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARequestBatchPlayerResourcesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARequestBatchPlayerResourcesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARequestBatchPlayerResourcesResponse_Result {
    // message fields
    account_id: ::std::option::Option<u32>,
    prevent_text_chat: ::std::option::Option<bool>,
    prevent_voice_chat: ::std::option::Option<bool>,
    rank: ::std::option::Option<u32>,
    rank_calibrated: ::std::option::Option<bool>,
    low_priority: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARequestBatchPlayerResourcesResponse_Result {}

impl CMsgDOTARequestBatchPlayerResourcesResponse_Result {
    pub fn new() -> CMsgDOTARequestBatchPlayerResourcesResponse_Result {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARequestBatchPlayerResourcesResponse_Result {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARequestBatchPlayerResourcesResponse_Result> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARequestBatchPlayerResourcesResponse_Result,
        };
        unsafe {
            instance.get(CMsgDOTARequestBatchPlayerResourcesResponse_Result::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional bool prevent_text_chat = 2;

    pub fn clear_prevent_text_chat(&mut self) {
        self.prevent_text_chat = ::std::option::Option::None;
    }

    pub fn has_prevent_text_chat(&self) -> bool {
        self.prevent_text_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevent_text_chat(&mut self, v: bool) {
        self.prevent_text_chat = ::std::option::Option::Some(v);
    }

    pub fn get_prevent_text_chat(&self) -> bool {
        self.prevent_text_chat.unwrap_or(false)
    }

    fn get_prevent_text_chat_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.prevent_text_chat
    }

    fn mut_prevent_text_chat_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.prevent_text_chat
    }

    // optional bool prevent_voice_chat = 3;

    pub fn clear_prevent_voice_chat(&mut self) {
        self.prevent_voice_chat = ::std::option::Option::None;
    }

    pub fn has_prevent_voice_chat(&self) -> bool {
        self.prevent_voice_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevent_voice_chat(&mut self, v: bool) {
        self.prevent_voice_chat = ::std::option::Option::Some(v);
    }

    pub fn get_prevent_voice_chat(&self) -> bool {
        self.prevent_voice_chat.unwrap_or(false)
    }

    fn get_prevent_voice_chat_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.prevent_voice_chat
    }

    fn mut_prevent_voice_chat_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.prevent_voice_chat
    }

    // optional uint32 rank = 4;

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }

    pub fn get_rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }

    fn get_rank_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rank
    }

    fn mut_rank_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rank
    }

    // optional bool rank_calibrated = 5;

    pub fn clear_rank_calibrated(&mut self) {
        self.rank_calibrated = ::std::option::Option::None;
    }

    pub fn has_rank_calibrated(&self) -> bool {
        self.rank_calibrated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_calibrated(&mut self, v: bool) {
        self.rank_calibrated = ::std::option::Option::Some(v);
    }

    pub fn get_rank_calibrated(&self) -> bool {
        self.rank_calibrated.unwrap_or(false)
    }

    fn get_rank_calibrated_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.rank_calibrated
    }

    fn mut_rank_calibrated_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.rank_calibrated
    }

    // optional bool low_priority = 6;

    pub fn clear_low_priority(&mut self) {
        self.low_priority = ::std::option::Option::None;
    }

    pub fn has_low_priority(&self) -> bool {
        self.low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority(&mut self, v: bool) {
        self.low_priority = ::std::option::Option::Some(v);
    }

    pub fn get_low_priority(&self) -> bool {
        self.low_priority.unwrap_or(false)
    }

    fn get_low_priority_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.low_priority
    }

    fn mut_low_priority_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.low_priority
    }
}

impl ::protobuf::Message for CMsgDOTARequestBatchPlayerResourcesResponse_Result {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prevent_text_chat = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prevent_voice_chat = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rank = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.rank_calibrated = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.low_priority = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prevent_text_chat {
            my_size += 2;
        }
        if let Some(v) = self.prevent_voice_chat {
            my_size += 2;
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_calibrated {
            my_size += 2;
        }
        if let Some(v) = self.low_priority {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.prevent_text_chat {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.prevent_voice_chat {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.rank {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rank_calibrated {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.low_priority {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARequestBatchPlayerResourcesResponse_Result {
    fn new() -> CMsgDOTARequestBatchPlayerResourcesResponse_Result {
        CMsgDOTARequestBatchPlayerResourcesResponse_Result::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARequestBatchPlayerResourcesResponse_Result>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTARequestBatchPlayerResourcesResponse_Result::get_account_id_for_reflect,
                    CMsgDOTARequestBatchPlayerResourcesResponse_Result::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "prevent_text_chat",
                    CMsgDOTARequestBatchPlayerResourcesResponse_Result::get_prevent_text_chat_for_reflect,
                    CMsgDOTARequestBatchPlayerResourcesResponse_Result::mut_prevent_text_chat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "prevent_voice_chat",
                    CMsgDOTARequestBatchPlayerResourcesResponse_Result::get_prevent_voice_chat_for_reflect,
                    CMsgDOTARequestBatchPlayerResourcesResponse_Result::mut_prevent_voice_chat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rank",
                    CMsgDOTARequestBatchPlayerResourcesResponse_Result::get_rank_for_reflect,
                    CMsgDOTARequestBatchPlayerResourcesResponse_Result::mut_rank_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "rank_calibrated",
                    CMsgDOTARequestBatchPlayerResourcesResponse_Result::get_rank_calibrated_for_reflect,
                    CMsgDOTARequestBatchPlayerResourcesResponse_Result::mut_rank_calibrated_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "low_priority",
                    CMsgDOTARequestBatchPlayerResourcesResponse_Result::get_low_priority_for_reflect,
                    CMsgDOTARequestBatchPlayerResourcesResponse_Result::mut_low_priority_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARequestBatchPlayerResourcesResponse_Result>(
                    "CMsgDOTARequestBatchPlayerResourcesResponse_Result",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARequestBatchPlayerResourcesResponse_Result {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_prevent_text_chat();
        self.clear_prevent_voice_chat();
        self.clear_rank();
        self.clear_rank_calibrated();
        self.clear_low_priority();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARequestBatchPlayerResourcesResponse_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARequestBatchPlayerResourcesResponse_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAPlayerFailedToConnect {
    // message fields
    failed_loaders: ::std::vec::Vec<u64>,
    abandoned_loaders: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAPlayerFailedToConnect {}

impl CMsgDOTAPlayerFailedToConnect {
    pub fn new() -> CMsgDOTAPlayerFailedToConnect {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAPlayerFailedToConnect {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAPlayerFailedToConnect> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAPlayerFailedToConnect,
        };
        unsafe {
            instance.get(CMsgDOTAPlayerFailedToConnect::new)
        }
    }

    // repeated fixed64 failed_loaders = 1;

    pub fn clear_failed_loaders(&mut self) {
        self.failed_loaders.clear();
    }

    // Param is passed by value, moved
    pub fn set_failed_loaders(&mut self, v: ::std::vec::Vec<u64>) {
        self.failed_loaders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failed_loaders(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.failed_loaders
    }

    // Take field
    pub fn take_failed_loaders(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.failed_loaders, ::std::vec::Vec::new())
    }

    pub fn get_failed_loaders(&self) -> &[u64] {
        &self.failed_loaders
    }

    fn get_failed_loaders_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.failed_loaders
    }

    fn mut_failed_loaders_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.failed_loaders
    }

    // repeated fixed64 abandoned_loaders = 2;

    pub fn clear_abandoned_loaders(&mut self) {
        self.abandoned_loaders.clear();
    }

    // Param is passed by value, moved
    pub fn set_abandoned_loaders(&mut self, v: ::std::vec::Vec<u64>) {
        self.abandoned_loaders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_abandoned_loaders(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.abandoned_loaders
    }

    // Take field
    pub fn take_abandoned_loaders(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.abandoned_loaders, ::std::vec::Vec::new())
    }

    pub fn get_abandoned_loaders(&self) -> &[u64] {
        &self.abandoned_loaders
    }

    fn get_abandoned_loaders_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.abandoned_loaders
    }

    fn mut_abandoned_loaders_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.abandoned_loaders
    }
}

impl ::protobuf::Message for CMsgDOTAPlayerFailedToConnect {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.failed_loaders)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.abandoned_loaders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 9 * self.failed_loaders.len() as u32;
        my_size += 9 * self.abandoned_loaders.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.failed_loaders {
            os.write_fixed64(1, *v)?;
        };
        for v in &self.abandoned_loaders {
            os.write_fixed64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAPlayerFailedToConnect {
    fn new() -> CMsgDOTAPlayerFailedToConnect {
        CMsgDOTAPlayerFailedToConnect::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAPlayerFailedToConnect>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "failed_loaders",
                    CMsgDOTAPlayerFailedToConnect::get_failed_loaders_for_reflect,
                    CMsgDOTAPlayerFailedToConnect::mut_failed_loaders_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "abandoned_loaders",
                    CMsgDOTAPlayerFailedToConnect::get_abandoned_loaders_for_reflect,
                    CMsgDOTAPlayerFailedToConnect::mut_abandoned_loaders_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAPlayerFailedToConnect>(
                    "CMsgDOTAPlayerFailedToConnect",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAPlayerFailedToConnect {
    fn clear(&mut self) {
        self.clear_failed_loaders();
        self.clear_abandoned_loaders();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAPlayerFailedToConnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAPlayerFailedToConnect {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToRelayConnect {
    // message fields
    source_tv_public_addr: ::std::option::Option<u32>,
    source_tv_private_addr: ::std::option::Option<u32>,
    source_tv_port: ::std::option::Option<u32>,
    game_server_steam_id: ::std::option::Option<u64>,
    parent_count: ::std::option::Option<u32>,
    tv_unique_secret_code: ::std::option::Option<u64>,
    source_tv_steamid: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToRelayConnect {}

impl CMsgGCToRelayConnect {
    pub fn new() -> CMsgGCToRelayConnect {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToRelayConnect {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToRelayConnect> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToRelayConnect,
        };
        unsafe {
            instance.get(CMsgGCToRelayConnect::new)
        }
    }

    // optional uint32 source_tv_public_addr = 1;

    pub fn clear_source_tv_public_addr(&mut self) {
        self.source_tv_public_addr = ::std::option::Option::None;
    }

    pub fn has_source_tv_public_addr(&self) -> bool {
        self.source_tv_public_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_tv_public_addr(&mut self, v: u32) {
        self.source_tv_public_addr = ::std::option::Option::Some(v);
    }

    pub fn get_source_tv_public_addr(&self) -> u32 {
        self.source_tv_public_addr.unwrap_or(0)
    }

    fn get_source_tv_public_addr_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.source_tv_public_addr
    }

    fn mut_source_tv_public_addr_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.source_tv_public_addr
    }

    // optional uint32 source_tv_private_addr = 2;

    pub fn clear_source_tv_private_addr(&mut self) {
        self.source_tv_private_addr = ::std::option::Option::None;
    }

    pub fn has_source_tv_private_addr(&self) -> bool {
        self.source_tv_private_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_tv_private_addr(&mut self, v: u32) {
        self.source_tv_private_addr = ::std::option::Option::Some(v);
    }

    pub fn get_source_tv_private_addr(&self) -> u32 {
        self.source_tv_private_addr.unwrap_or(0)
    }

    fn get_source_tv_private_addr_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.source_tv_private_addr
    }

    fn mut_source_tv_private_addr_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.source_tv_private_addr
    }

    // optional uint32 source_tv_port = 3;

    pub fn clear_source_tv_port(&mut self) {
        self.source_tv_port = ::std::option::Option::None;
    }

    pub fn has_source_tv_port(&self) -> bool {
        self.source_tv_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_tv_port(&mut self, v: u32) {
        self.source_tv_port = ::std::option::Option::Some(v);
    }

    pub fn get_source_tv_port(&self) -> u32 {
        self.source_tv_port.unwrap_or(0)
    }

    fn get_source_tv_port_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.source_tv_port
    }

    fn mut_source_tv_port_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.source_tv_port
    }

    // optional uint64 game_server_steam_id = 4;

    pub fn clear_game_server_steam_id(&mut self) {
        self.game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_game_server_steam_id(&self) -> bool {
        self.game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_steam_id(&mut self, v: u64) {
        self.game_server_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_game_server_steam_id(&self) -> u64 {
        self.game_server_steam_id.unwrap_or(0)
    }

    fn get_game_server_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.game_server_steam_id
    }

    fn mut_game_server_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.game_server_steam_id
    }

    // optional uint32 parent_count = 5;

    pub fn clear_parent_count(&mut self) {
        self.parent_count = ::std::option::Option::None;
    }

    pub fn has_parent_count(&self) -> bool {
        self.parent_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_count(&mut self, v: u32) {
        self.parent_count = ::std::option::Option::Some(v);
    }

    pub fn get_parent_count(&self) -> u32 {
        self.parent_count.unwrap_or(0)
    }

    fn get_parent_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.parent_count
    }

    fn mut_parent_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.parent_count
    }

    // optional fixed64 tv_unique_secret_code = 6;

    pub fn clear_tv_unique_secret_code(&mut self) {
        self.tv_unique_secret_code = ::std::option::Option::None;
    }

    pub fn has_tv_unique_secret_code(&self) -> bool {
        self.tv_unique_secret_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_unique_secret_code(&mut self, v: u64) {
        self.tv_unique_secret_code = ::std::option::Option::Some(v);
    }

    pub fn get_tv_unique_secret_code(&self) -> u64 {
        self.tv_unique_secret_code.unwrap_or(0)
    }

    fn get_tv_unique_secret_code_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.tv_unique_secret_code
    }

    fn mut_tv_unique_secret_code_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.tv_unique_secret_code
    }

    // optional fixed64 source_tv_steamid = 7;

    pub fn clear_source_tv_steamid(&mut self) {
        self.source_tv_steamid = ::std::option::Option::None;
    }

    pub fn has_source_tv_steamid(&self) -> bool {
        self.source_tv_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_tv_steamid(&mut self, v: u64) {
        self.source_tv_steamid = ::std::option::Option::Some(v);
    }

    pub fn get_source_tv_steamid(&self) -> u64 {
        self.source_tv_steamid.unwrap_or(0)
    }

    fn get_source_tv_steamid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.source_tv_steamid
    }

    fn mut_source_tv_steamid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.source_tv_steamid
    }
}

impl ::protobuf::Message for CMsgGCToRelayConnect {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.source_tv_public_addr = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.source_tv_private_addr = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.source_tv_port = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.game_server_steam_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.parent_count = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.tv_unique_secret_code = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.source_tv_steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.source_tv_public_addr {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.source_tv_private_addr {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.source_tv_port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_server_steam_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.parent_count {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tv_unique_secret_code {
            my_size += 9;
        }
        if let Some(v) = self.source_tv_steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.source_tv_public_addr {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.source_tv_private_addr {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.source_tv_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_server_steam_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.parent_count {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.tv_unique_secret_code {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.source_tv_steamid {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToRelayConnect {
    fn new() -> CMsgGCToRelayConnect {
        CMsgGCToRelayConnect::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToRelayConnect>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "source_tv_public_addr",
                    CMsgGCToRelayConnect::get_source_tv_public_addr_for_reflect,
                    CMsgGCToRelayConnect::mut_source_tv_public_addr_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "source_tv_private_addr",
                    CMsgGCToRelayConnect::get_source_tv_private_addr_for_reflect,
                    CMsgGCToRelayConnect::mut_source_tv_private_addr_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "source_tv_port",
                    CMsgGCToRelayConnect::get_source_tv_port_for_reflect,
                    CMsgGCToRelayConnect::mut_source_tv_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "game_server_steam_id",
                    CMsgGCToRelayConnect::get_game_server_steam_id_for_reflect,
                    CMsgGCToRelayConnect::mut_game_server_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "parent_count",
                    CMsgGCToRelayConnect::get_parent_count_for_reflect,
                    CMsgGCToRelayConnect::mut_parent_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "tv_unique_secret_code",
                    CMsgGCToRelayConnect::get_tv_unique_secret_code_for_reflect,
                    CMsgGCToRelayConnect::mut_tv_unique_secret_code_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "source_tv_steamid",
                    CMsgGCToRelayConnect::get_source_tv_steamid_for_reflect,
                    CMsgGCToRelayConnect::mut_source_tv_steamid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToRelayConnect>(
                    "CMsgGCToRelayConnect",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToRelayConnect {
    fn clear(&mut self) {
        self.clear_source_tv_public_addr();
        self.clear_source_tv_private_addr();
        self.clear_source_tv_port();
        self.clear_game_server_steam_id();
        self.clear_parent_count();
        self.clear_tv_unique_secret_code();
        self.clear_source_tv_steamid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToRelayConnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToRelayConnect {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCGCToLANServerRelayConnect {
    // message fields
    relay_steamid: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCGCToLANServerRelayConnect {}

impl CMsgGCGCToLANServerRelayConnect {
    pub fn new() -> CMsgGCGCToLANServerRelayConnect {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCGCToLANServerRelayConnect {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCGCToLANServerRelayConnect> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCGCToLANServerRelayConnect,
        };
        unsafe {
            instance.get(CMsgGCGCToLANServerRelayConnect::new)
        }
    }

    // optional fixed64 relay_steamid = 1;

    pub fn clear_relay_steamid(&mut self) {
        self.relay_steamid = ::std::option::Option::None;
    }

    pub fn has_relay_steamid(&self) -> bool {
        self.relay_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_steamid(&mut self, v: u64) {
        self.relay_steamid = ::std::option::Option::Some(v);
    }

    pub fn get_relay_steamid(&self) -> u64 {
        self.relay_steamid.unwrap_or(0)
    }

    fn get_relay_steamid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.relay_steamid
    }

    fn mut_relay_steamid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.relay_steamid
    }
}

impl ::protobuf::Message for CMsgGCGCToLANServerRelayConnect {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.relay_steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.relay_steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.relay_steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCGCToLANServerRelayConnect {
    fn new() -> CMsgGCGCToLANServerRelayConnect {
        CMsgGCGCToLANServerRelayConnect::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCGCToLANServerRelayConnect>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "relay_steamid",
                    CMsgGCGCToLANServerRelayConnect::get_relay_steamid_for_reflect,
                    CMsgGCGCToLANServerRelayConnect::mut_relay_steamid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCGCToLANServerRelayConnect>(
                    "CMsgGCGCToLANServerRelayConnect",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCGCToLANServerRelayConnect {
    fn clear(&mut self) {
        self.clear_relay_steamid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCGCToLANServerRelayConnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCGCToLANServerRelayConnect {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToRelayConnectResponse {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToRelayConnectResponse {}

impl CMsgGCToRelayConnectResponse {
    pub fn new() -> CMsgGCToRelayConnectResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToRelayConnectResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToRelayConnectResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToRelayConnectResponse,
        };
        unsafe {
            instance.get(CMsgGCToRelayConnectResponse::new)
        }
    }
}

impl ::protobuf::Message for CMsgGCToRelayConnectResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToRelayConnectResponse {
    fn new() -> CMsgGCToRelayConnectResponse {
        CMsgGCToRelayConnectResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToRelayConnectResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToRelayConnectResponse>(
                    "CMsgGCToRelayConnectResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToRelayConnectResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToRelayConnectResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToRelayConnectResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCBanStatusRequest {
    // message fields
    account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCBanStatusRequest {}

impl CMsgGCBanStatusRequest {
    pub fn new() -> CMsgGCBanStatusRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCBanStatusRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCBanStatusRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCBanStatusRequest,
        };
        unsafe {
            instance.get(CMsgGCBanStatusRequest::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgGCBanStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCBanStatusRequest {
    fn new() -> CMsgGCBanStatusRequest {
        CMsgGCBanStatusRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCBanStatusRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCBanStatusRequest::get_account_id_for_reflect,
                    CMsgGCBanStatusRequest::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCBanStatusRequest>(
                    "CMsgGCBanStatusRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCBanStatusRequest {
    fn clear(&mut self) {
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCBanStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCBanStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCBanStatusResponse {
    // message fields
    result: ::std::option::Option<u32>,
    low_priority: ::std::option::Option<bool>,
    text_chat_banned: ::std::option::Option<bool>,
    voice_chat_banned: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCBanStatusResponse {}

impl CMsgGCBanStatusResponse {
    pub fn new() -> CMsgGCBanStatusResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCBanStatusResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCBanStatusResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCBanStatusResponse,
        };
        unsafe {
            instance.get(CMsgGCBanStatusResponse::new)
        }
    }

    // optional uint32 result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.result
    }

    // optional bool low_priority = 2;

    pub fn clear_low_priority(&mut self) {
        self.low_priority = ::std::option::Option::None;
    }

    pub fn has_low_priority(&self) -> bool {
        self.low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority(&mut self, v: bool) {
        self.low_priority = ::std::option::Option::Some(v);
    }

    pub fn get_low_priority(&self) -> bool {
        self.low_priority.unwrap_or(false)
    }

    fn get_low_priority_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.low_priority
    }

    fn mut_low_priority_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.low_priority
    }

    // optional bool text_chat_banned = 3;

    pub fn clear_text_chat_banned(&mut self) {
        self.text_chat_banned = ::std::option::Option::None;
    }

    pub fn has_text_chat_banned(&self) -> bool {
        self.text_chat_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_chat_banned(&mut self, v: bool) {
        self.text_chat_banned = ::std::option::Option::Some(v);
    }

    pub fn get_text_chat_banned(&self) -> bool {
        self.text_chat_banned.unwrap_or(false)
    }

    fn get_text_chat_banned_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.text_chat_banned
    }

    fn mut_text_chat_banned_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.text_chat_banned
    }

    // optional bool voice_chat_banned = 4;

    pub fn clear_voice_chat_banned(&mut self) {
        self.voice_chat_banned = ::std::option::Option::None;
    }

    pub fn has_voice_chat_banned(&self) -> bool {
        self.voice_chat_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_chat_banned(&mut self, v: bool) {
        self.voice_chat_banned = ::std::option::Option::Some(v);
    }

    pub fn get_voice_chat_banned(&self) -> bool {
        self.voice_chat_banned.unwrap_or(false)
    }

    fn get_voice_chat_banned_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.voice_chat_banned
    }

    fn mut_voice_chat_banned_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.voice_chat_banned
    }
}

impl ::protobuf::Message for CMsgGCBanStatusResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.low_priority = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.text_chat_banned = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.voice_chat_banned = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.low_priority {
            my_size += 2;
        }
        if let Some(v) = self.text_chat_banned {
            my_size += 2;
        }
        if let Some(v) = self.voice_chat_banned {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.low_priority {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.text_chat_banned {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.voice_chat_banned {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCBanStatusResponse {
    fn new() -> CMsgGCBanStatusResponse {
        CMsgGCBanStatusResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCBanStatusResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "result",
                    CMsgGCBanStatusResponse::get_result_for_reflect,
                    CMsgGCBanStatusResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "low_priority",
                    CMsgGCBanStatusResponse::get_low_priority_for_reflect,
                    CMsgGCBanStatusResponse::mut_low_priority_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "text_chat_banned",
                    CMsgGCBanStatusResponse::get_text_chat_banned_for_reflect,
                    CMsgGCBanStatusResponse::mut_text_chat_banned_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "voice_chat_banned",
                    CMsgGCBanStatusResponse::get_voice_chat_banned_for_reflect,
                    CMsgGCBanStatusResponse::mut_voice_chat_banned_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCBanStatusResponse>(
                    "CMsgGCBanStatusResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCBanStatusResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_low_priority();
        self.clear_text_chat_banned();
        self.clear_voice_chat_banned();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCBanStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCBanStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTournamentItemEvent {
    // message fields
    killer_account_id: ::std::option::Option<u32>,
    victim_account_id: ::std::option::Option<u32>,
    event_type: ::std::option::Option<super::dota_gcmessages_common::DOTA_TournamentEvents>,
    tv_delay: ::std::option::Option<i32>,
    dota_time: ::std::option::Option<i32>,
    replay_time: ::std::option::Option<f32>,
    loot_list: ::protobuf::SingularField<::std::string::String>,
    event_team: ::std::option::Option<u32>,
    multi_kill_count: ::std::option::Option<u32>,
    winner_score: ::std::option::Option<u32>,
    loser_score: ::std::option::Option<u32>,
    hero_statues: ::protobuf::RepeatedField<super::dota_gcmessages_common::CProtoItemHeroStatue>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgTournamentItemEvent {}

impl CMsgTournamentItemEvent {
    pub fn new() -> CMsgTournamentItemEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgTournamentItemEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMsgTournamentItemEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgTournamentItemEvent,
        };
        unsafe {
            instance.get(CMsgTournamentItemEvent::new)
        }
    }

    // optional fixed32 killer_account_id = 1;

    pub fn clear_killer_account_id(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
    }

    pub fn has_killer_account_id(&self) -> bool {
        self.killer_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_account_id(&mut self, v: u32) {
        self.killer_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_killer_account_id(&self) -> u32 {
        self.killer_account_id.unwrap_or(0)
    }

    fn get_killer_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.killer_account_id
    }

    fn mut_killer_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.killer_account_id
    }

    // optional fixed32 victim_account_id = 2;

    pub fn clear_victim_account_id(&mut self) {
        self.victim_account_id = ::std::option::Option::None;
    }

    pub fn has_victim_account_id(&self) -> bool {
        self.victim_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_account_id(&mut self, v: u32) {
        self.victim_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_victim_account_id(&self) -> u32 {
        self.victim_account_id.unwrap_or(0)
    }

    fn get_victim_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.victim_account_id
    }

    fn mut_victim_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.victim_account_id
    }

    // optional .DOTA_TournamentEvents event_type = 3;

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: super::dota_gcmessages_common::DOTA_TournamentEvents) {
        self.event_type = ::std::option::Option::Some(v);
    }

    pub fn get_event_type(&self) -> super::dota_gcmessages_common::DOTA_TournamentEvents {
        self.event_type.unwrap_or(super::dota_gcmessages_common::DOTA_TournamentEvents::TE_FIRST_BLOOD)
    }

    fn get_event_type_for_reflect(&self) -> &::std::option::Option<super::dota_gcmessages_common::DOTA_TournamentEvents> {
        &self.event_type
    }

    fn mut_event_type_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_gcmessages_common::DOTA_TournamentEvents> {
        &mut self.event_type
    }

    // optional int32 tv_delay = 4;

    pub fn clear_tv_delay(&mut self) {
        self.tv_delay = ::std::option::Option::None;
    }

    pub fn has_tv_delay(&self) -> bool {
        self.tv_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_delay(&mut self, v: i32) {
        self.tv_delay = ::std::option::Option::Some(v);
    }

    pub fn get_tv_delay(&self) -> i32 {
        self.tv_delay.unwrap_or(0)
    }

    fn get_tv_delay_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.tv_delay
    }

    fn mut_tv_delay_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.tv_delay
    }

    // optional int32 dota_time = 5;

    pub fn clear_dota_time(&mut self) {
        self.dota_time = ::std::option::Option::None;
    }

    pub fn has_dota_time(&self) -> bool {
        self.dota_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dota_time(&mut self, v: i32) {
        self.dota_time = ::std::option::Option::Some(v);
    }

    pub fn get_dota_time(&self) -> i32 {
        self.dota_time.unwrap_or(0)
    }

    fn get_dota_time_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.dota_time
    }

    fn mut_dota_time_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.dota_time
    }

    // optional float replay_time = 6;

    pub fn clear_replay_time(&mut self) {
        self.replay_time = ::std::option::Option::None;
    }

    pub fn has_replay_time(&self) -> bool {
        self.replay_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_time(&mut self, v: f32) {
        self.replay_time = ::std::option::Option::Some(v);
    }

    pub fn get_replay_time(&self) -> f32 {
        self.replay_time.unwrap_or(0.)
    }

    fn get_replay_time_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.replay_time
    }

    fn mut_replay_time_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.replay_time
    }

    // optional string loot_list = 7;

    pub fn clear_loot_list(&mut self) {
        self.loot_list.clear();
    }

    pub fn has_loot_list(&self) -> bool {
        self.loot_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loot_list(&mut self, v: ::std::string::String) {
        self.loot_list = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loot_list(&mut self) -> &mut ::std::string::String {
        if self.loot_list.is_none() {
            self.loot_list.set_default();
        }
        self.loot_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_loot_list(&mut self) -> ::std::string::String {
        self.loot_list.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_loot_list(&self) -> &str {
        match self.loot_list.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_loot_list_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.loot_list
    }

    fn mut_loot_list_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.loot_list
    }

    // optional uint32 event_team = 8;

    pub fn clear_event_team(&mut self) {
        self.event_team = ::std::option::Option::None;
    }

    pub fn has_event_team(&self) -> bool {
        self.event_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_team(&mut self, v: u32) {
        self.event_team = ::std::option::Option::Some(v);
    }

    pub fn get_event_team(&self) -> u32 {
        self.event_team.unwrap_or(0)
    }

    fn get_event_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_team
    }

    fn mut_event_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_team
    }

    // optional uint32 multi_kill_count = 9;

    pub fn clear_multi_kill_count(&mut self) {
        self.multi_kill_count = ::std::option::Option::None;
    }

    pub fn has_multi_kill_count(&self) -> bool {
        self.multi_kill_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multi_kill_count(&mut self, v: u32) {
        self.multi_kill_count = ::std::option::Option::Some(v);
    }

    pub fn get_multi_kill_count(&self) -> u32 {
        self.multi_kill_count.unwrap_or(0)
    }

    fn get_multi_kill_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.multi_kill_count
    }

    fn mut_multi_kill_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.multi_kill_count
    }

    // optional uint32 winner_score = 10;

    pub fn clear_winner_score(&mut self) {
        self.winner_score = ::std::option::Option::None;
    }

    pub fn has_winner_score(&self) -> bool {
        self.winner_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winner_score(&mut self, v: u32) {
        self.winner_score = ::std::option::Option::Some(v);
    }

    pub fn get_winner_score(&self) -> u32 {
        self.winner_score.unwrap_or(0)
    }

    fn get_winner_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.winner_score
    }

    fn mut_winner_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.winner_score
    }

    // optional uint32 loser_score = 11;

    pub fn clear_loser_score(&mut self) {
        self.loser_score = ::std::option::Option::None;
    }

    pub fn has_loser_score(&self) -> bool {
        self.loser_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loser_score(&mut self, v: u32) {
        self.loser_score = ::std::option::Option::Some(v);
    }

    pub fn get_loser_score(&self) -> u32 {
        self.loser_score.unwrap_or(0)
    }

    fn get_loser_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.loser_score
    }

    fn mut_loser_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.loser_score
    }

    // repeated .CProtoItemHeroStatue hero_statues = 12;

    pub fn clear_hero_statues(&mut self) {
        self.hero_statues.clear();
    }

    // Param is passed by value, moved
    pub fn set_hero_statues(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CProtoItemHeroStatue>) {
        self.hero_statues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hero_statues(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CProtoItemHeroStatue> {
        &mut self.hero_statues
    }

    // Take field
    pub fn take_hero_statues(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CProtoItemHeroStatue> {
        ::std::mem::replace(&mut self.hero_statues, ::protobuf::RepeatedField::new())
    }

    pub fn get_hero_statues(&self) -> &[super::dota_gcmessages_common::CProtoItemHeroStatue] {
        &self.hero_statues
    }

    fn get_hero_statues_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CProtoItemHeroStatue> {
        &self.hero_statues
    }

    fn mut_hero_statues_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CProtoItemHeroStatue> {
        &mut self.hero_statues
    }
}

impl ::protobuf::Message for CMsgTournamentItemEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.hero_statues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.killer_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.victim_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.event_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tv_delay = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dota_time = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.replay_time = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loot_list)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_team = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.multi_kill_count = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.winner_score = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.loser_score = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hero_statues)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.killer_account_id {
            my_size += 5;
        }
        if let Some(v) = self.victim_account_id {
            my_size += 5;
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.tv_delay {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dota_time {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.replay_time {
            my_size += 5;
        }
        if let Some(ref v) = self.loot_list.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.event_team {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.multi_kill_count {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.winner_score {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.loser_score {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.hero_statues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.killer_account_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.victim_account_id {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.tv_delay {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.dota_time {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.replay_time {
            os.write_float(6, v)?;
        }
        if let Some(ref v) = self.loot_list.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.event_team {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.multi_kill_count {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.winner_score {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.loser_score {
            os.write_uint32(11, v)?;
        }
        for v in &self.hero_statues {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgTournamentItemEvent {
    fn new() -> CMsgTournamentItemEvent {
        CMsgTournamentItemEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgTournamentItemEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "killer_account_id",
                    CMsgTournamentItemEvent::get_killer_account_id_for_reflect,
                    CMsgTournamentItemEvent::mut_killer_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "victim_account_id",
                    CMsgTournamentItemEvent::get_victim_account_id_for_reflect,
                    CMsgTournamentItemEvent::mut_victim_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_gcmessages_common::DOTA_TournamentEvents>>(
                    "event_type",
                    CMsgTournamentItemEvent::get_event_type_for_reflect,
                    CMsgTournamentItemEvent::mut_event_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "tv_delay",
                    CMsgTournamentItemEvent::get_tv_delay_for_reflect,
                    CMsgTournamentItemEvent::mut_tv_delay_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dota_time",
                    CMsgTournamentItemEvent::get_dota_time_for_reflect,
                    CMsgTournamentItemEvent::mut_dota_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "replay_time",
                    CMsgTournamentItemEvent::get_replay_time_for_reflect,
                    CMsgTournamentItemEvent::mut_replay_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "loot_list",
                    CMsgTournamentItemEvent::get_loot_list_for_reflect,
                    CMsgTournamentItemEvent::mut_loot_list_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_team",
                    CMsgTournamentItemEvent::get_event_team_for_reflect,
                    CMsgTournamentItemEvent::mut_event_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "multi_kill_count",
                    CMsgTournamentItemEvent::get_multi_kill_count_for_reflect,
                    CMsgTournamentItemEvent::mut_multi_kill_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "winner_score",
                    CMsgTournamentItemEvent::get_winner_score_for_reflect,
                    CMsgTournamentItemEvent::mut_winner_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "loser_score",
                    CMsgTournamentItemEvent::get_loser_score_for_reflect,
                    CMsgTournamentItemEvent::mut_loser_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CProtoItemHeroStatue>>(
                    "hero_statues",
                    CMsgTournamentItemEvent::get_hero_statues_for_reflect,
                    CMsgTournamentItemEvent::mut_hero_statues_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgTournamentItemEvent>(
                    "CMsgTournamentItemEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgTournamentItemEvent {
    fn clear(&mut self) {
        self.clear_killer_account_id();
        self.clear_victim_account_id();
        self.clear_event_type();
        self.clear_tv_delay();
        self.clear_dota_time();
        self.clear_replay_time();
        self.clear_loot_list();
        self.clear_event_team();
        self.clear_multi_kill_count();
        self.clear_winner_score();
        self.clear_loser_score();
        self.clear_hero_statues();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTournamentItemEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTournamentItemEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTournamentItemEventResponse {
    // message fields
    event_type: ::std::option::Option<super::dota_gcmessages_common::DOTA_TournamentEvents>,
    viewers_granted: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgTournamentItemEventResponse {}

impl CMsgTournamentItemEventResponse {
    pub fn new() -> CMsgTournamentItemEventResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgTournamentItemEventResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgTournamentItemEventResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgTournamentItemEventResponse,
        };
        unsafe {
            instance.get(CMsgTournamentItemEventResponse::new)
        }
    }

    // optional .DOTA_TournamentEvents event_type = 1;

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: super::dota_gcmessages_common::DOTA_TournamentEvents) {
        self.event_type = ::std::option::Option::Some(v);
    }

    pub fn get_event_type(&self) -> super::dota_gcmessages_common::DOTA_TournamentEvents {
        self.event_type.unwrap_or(super::dota_gcmessages_common::DOTA_TournamentEvents::TE_FIRST_BLOOD)
    }

    fn get_event_type_for_reflect(&self) -> &::std::option::Option<super::dota_gcmessages_common::DOTA_TournamentEvents> {
        &self.event_type
    }

    fn mut_event_type_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_gcmessages_common::DOTA_TournamentEvents> {
        &mut self.event_type
    }

    // optional uint32 viewers_granted = 6;

    pub fn clear_viewers_granted(&mut self) {
        self.viewers_granted = ::std::option::Option::None;
    }

    pub fn has_viewers_granted(&self) -> bool {
        self.viewers_granted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewers_granted(&mut self, v: u32) {
        self.viewers_granted = ::std::option::Option::Some(v);
    }

    pub fn get_viewers_granted(&self) -> u32 {
        self.viewers_granted.unwrap_or(0)
    }

    fn get_viewers_granted_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.viewers_granted
    }

    fn mut_viewers_granted_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.viewers_granted
    }
}

impl ::protobuf::Message for CMsgTournamentItemEventResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.event_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.viewers_granted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.viewers_granted {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.viewers_granted {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgTournamentItemEventResponse {
    fn new() -> CMsgTournamentItemEventResponse {
        CMsgTournamentItemEventResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgTournamentItemEventResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_gcmessages_common::DOTA_TournamentEvents>>(
                    "event_type",
                    CMsgTournamentItemEventResponse::get_event_type_for_reflect,
                    CMsgTournamentItemEventResponse::mut_event_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "viewers_granted",
                    CMsgTournamentItemEventResponse::get_viewers_granted_for_reflect,
                    CMsgTournamentItemEventResponse::mut_viewers_granted_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgTournamentItemEventResponse>(
                    "CMsgTournamentItemEventResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgTournamentItemEventResponse {
    fn clear(&mut self) {
        self.clear_event_type();
        self.clear_viewers_granted();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTournamentItemEventResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTournamentItemEventResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTeamFanfare {
    // message fields
    match_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgTeamFanfare {}

impl CMsgTeamFanfare {
    pub fn new() -> CMsgTeamFanfare {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgTeamFanfare {
        static mut instance: ::protobuf::lazy::Lazy<CMsgTeamFanfare> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgTeamFanfare,
        };
        unsafe {
            instance.get(CMsgTeamFanfare::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }
}

impl ::protobuf::Message for CMsgTeamFanfare {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgTeamFanfare {
    fn new() -> CMsgTeamFanfare {
        CMsgTeamFanfare::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgTeamFanfare>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgTeamFanfare::get_match_id_for_reflect,
                    CMsgTeamFanfare::mut_match_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgTeamFanfare>(
                    "CMsgTeamFanfare",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgTeamFanfare {
    fn clear(&mut self) {
        self.clear_match_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTeamFanfare {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTeamFanfare {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgResponseTeamFanfare {
    // message fields
    fanfare_goodguys: ::std::option::Option<u32>,
    fanfare_badguys: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgResponseTeamFanfare {}

impl CMsgResponseTeamFanfare {
    pub fn new() -> CMsgResponseTeamFanfare {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgResponseTeamFanfare {
        static mut instance: ::protobuf::lazy::Lazy<CMsgResponseTeamFanfare> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgResponseTeamFanfare,
        };
        unsafe {
            instance.get(CMsgResponseTeamFanfare::new)
        }
    }

    // optional uint32 fanfare_goodguys = 1;

    pub fn clear_fanfare_goodguys(&mut self) {
        self.fanfare_goodguys = ::std::option::Option::None;
    }

    pub fn has_fanfare_goodguys(&self) -> bool {
        self.fanfare_goodguys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fanfare_goodguys(&mut self, v: u32) {
        self.fanfare_goodguys = ::std::option::Option::Some(v);
    }

    pub fn get_fanfare_goodguys(&self) -> u32 {
        self.fanfare_goodguys.unwrap_or(0)
    }

    fn get_fanfare_goodguys_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fanfare_goodguys
    }

    fn mut_fanfare_goodguys_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fanfare_goodguys
    }

    // optional uint32 fanfare_badguys = 2;

    pub fn clear_fanfare_badguys(&mut self) {
        self.fanfare_badguys = ::std::option::Option::None;
    }

    pub fn has_fanfare_badguys(&self) -> bool {
        self.fanfare_badguys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fanfare_badguys(&mut self, v: u32) {
        self.fanfare_badguys = ::std::option::Option::Some(v);
    }

    pub fn get_fanfare_badguys(&self) -> u32 {
        self.fanfare_badguys.unwrap_or(0)
    }

    fn get_fanfare_badguys_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fanfare_badguys
    }

    fn mut_fanfare_badguys_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fanfare_badguys
    }
}

impl ::protobuf::Message for CMsgResponseTeamFanfare {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fanfare_goodguys = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fanfare_badguys = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fanfare_goodguys {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fanfare_badguys {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fanfare_goodguys {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fanfare_badguys {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgResponseTeamFanfare {
    fn new() -> CMsgResponseTeamFanfare {
        CMsgResponseTeamFanfare::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgResponseTeamFanfare>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fanfare_goodguys",
                    CMsgResponseTeamFanfare::get_fanfare_goodguys_for_reflect,
                    CMsgResponseTeamFanfare::mut_fanfare_goodguys_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fanfare_badguys",
                    CMsgResponseTeamFanfare::get_fanfare_badguys_for_reflect,
                    CMsgResponseTeamFanfare::mut_fanfare_badguys_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgResponseTeamFanfare>(
                    "CMsgResponseTeamFanfare",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgResponseTeamFanfare {
    fn clear(&mut self) {
        self.clear_fanfare_goodguys();
        self.clear_fanfare_badguys();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgResponseTeamFanfare {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgResponseTeamFanfare {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerUploadSaveGame {
    // message fields
    game_time: ::std::option::Option<u32>,
    save_game_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    lobby_id: ::std::option::Option<u64>,
    player_steam_ids: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameServerUploadSaveGame {}

impl CMsgGameServerUploadSaveGame {
    pub fn new() -> CMsgGameServerUploadSaveGame {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameServerUploadSaveGame {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameServerUploadSaveGame> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameServerUploadSaveGame,
        };
        unsafe {
            instance.get(CMsgGameServerUploadSaveGame::new)
        }
    }

    // optional uint32 game_time = 1;

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: u32) {
        self.game_time = ::std::option::Option::Some(v);
    }

    pub fn get_game_time(&self) -> u32 {
        self.game_time.unwrap_or(0)
    }

    fn get_game_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.game_time
    }

    fn mut_game_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.game_time
    }

    // optional bytes save_game_data = 2;

    pub fn clear_save_game_data(&mut self) {
        self.save_game_data.clear();
    }

    pub fn has_save_game_data(&self) -> bool {
        self.save_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.save_game_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_save_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.save_game_data.is_none() {
            self.save_game_data.set_default();
        }
        self.save_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_save_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.save_game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_save_game_data(&self) -> &[u8] {
        match self.save_game_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_save_game_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.save_game_data
    }

    fn mut_save_game_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.save_game_data
    }

    // optional uint64 lobby_id = 3;

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    fn get_lobby_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.lobby_id
    }

    fn mut_lobby_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.lobby_id
    }

    // repeated uint64 player_steam_ids = 4;

    pub fn clear_player_steam_ids(&mut self) {
        self.player_steam_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_steam_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.player_steam_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_steam_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.player_steam_ids
    }

    // Take field
    pub fn take_player_steam_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.player_steam_ids, ::std::vec::Vec::new())
    }

    pub fn get_player_steam_ids(&self) -> &[u64] {
        &self.player_steam_ids
    }

    fn get_player_steam_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.player_steam_ids
    }

    fn mut_player_steam_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.player_steam_ids
    }
}

impl ::protobuf::Message for CMsgGameServerUploadSaveGame {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_time = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.save_game_data)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lobby_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.player_steam_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_time {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.save_game_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.player_steam_ids {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_time {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.save_game_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(3, v)?;
        }
        for v in &self.player_steam_ids {
            os.write_uint64(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameServerUploadSaveGame {
    fn new() -> CMsgGameServerUploadSaveGame {
        CMsgGameServerUploadSaveGame::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameServerUploadSaveGame>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_time",
                    CMsgGameServerUploadSaveGame::get_game_time_for_reflect,
                    CMsgGameServerUploadSaveGame::mut_game_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "save_game_data",
                    CMsgGameServerUploadSaveGame::get_save_game_data_for_reflect,
                    CMsgGameServerUploadSaveGame::mut_save_game_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "lobby_id",
                    CMsgGameServerUploadSaveGame::get_lobby_id_for_reflect,
                    CMsgGameServerUploadSaveGame::mut_lobby_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "player_steam_ids",
                    CMsgGameServerUploadSaveGame::get_player_steam_ids_for_reflect,
                    CMsgGameServerUploadSaveGame::mut_player_steam_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameServerUploadSaveGame>(
                    "CMsgGameServerUploadSaveGame",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameServerUploadSaveGame {
    fn clear(&mut self) {
        self.clear_game_time();
        self.clear_save_game_data();
        self.clear_lobby_id();
        self.clear_player_steam_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerUploadSaveGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerUploadSaveGame {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerSaveGameResult {
    // message fields
    result: ::std::option::Option<CMsgGameServerSaveGameResult_Result>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameServerSaveGameResult {}

impl CMsgGameServerSaveGameResult {
    pub fn new() -> CMsgGameServerSaveGameResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameServerSaveGameResult {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameServerSaveGameResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameServerSaveGameResult,
        };
        unsafe {
            instance.get(CMsgGameServerSaveGameResult::new)
        }
    }

    // optional .CMsgGameServerSaveGameResult.Result result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgGameServerSaveGameResult_Result) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgGameServerSaveGameResult_Result {
        self.result.unwrap_or(CMsgGameServerSaveGameResult_Result::SaveSuccessful)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgGameServerSaveGameResult_Result> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgGameServerSaveGameResult_Result> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgGameServerSaveGameResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameServerSaveGameResult {
    fn new() -> CMsgGameServerSaveGameResult {
        CMsgGameServerSaveGameResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameServerSaveGameResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGameServerSaveGameResult_Result>>(
                    "result",
                    CMsgGameServerSaveGameResult::get_result_for_reflect,
                    CMsgGameServerSaveGameResult::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameServerSaveGameResult>(
                    "CMsgGameServerSaveGameResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameServerSaveGameResult {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerSaveGameResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerSaveGameResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGameServerSaveGameResult_Result {
    SaveSuccessful = 0,
    SessionNotFound = 1,
    DatabaseError = 2,
    TooBig = 3,
}

impl ::protobuf::ProtobufEnum for CMsgGameServerSaveGameResult_Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGameServerSaveGameResult_Result> {
        match value {
            0 => ::std::option::Option::Some(CMsgGameServerSaveGameResult_Result::SaveSuccessful),
            1 => ::std::option::Option::Some(CMsgGameServerSaveGameResult_Result::SessionNotFound),
            2 => ::std::option::Option::Some(CMsgGameServerSaveGameResult_Result::DatabaseError),
            3 => ::std::option::Option::Some(CMsgGameServerSaveGameResult_Result::TooBig),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGameServerSaveGameResult_Result] = &[
            CMsgGameServerSaveGameResult_Result::SaveSuccessful,
            CMsgGameServerSaveGameResult_Result::SessionNotFound,
            CMsgGameServerSaveGameResult_Result::DatabaseError,
            CMsgGameServerSaveGameResult_Result::TooBig,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgGameServerSaveGameResult_Result>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgGameServerSaveGameResult_Result", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgGameServerSaveGameResult_Result {
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerSaveGameResult_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerGetLoadGame {
    // message fields
    save_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameServerGetLoadGame {}

impl CMsgGameServerGetLoadGame {
    pub fn new() -> CMsgGameServerGetLoadGame {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameServerGetLoadGame {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameServerGetLoadGame> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameServerGetLoadGame,
        };
        unsafe {
            instance.get(CMsgGameServerGetLoadGame::new)
        }
    }

    // optional uint32 save_id = 1;

    pub fn clear_save_id(&mut self) {
        self.save_id = ::std::option::Option::None;
    }

    pub fn has_save_id(&self) -> bool {
        self.save_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_id(&mut self, v: u32) {
        self.save_id = ::std::option::Option::Some(v);
    }

    pub fn get_save_id(&self) -> u32 {
        self.save_id.unwrap_or(0)
    }

    fn get_save_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.save_id
    }

    fn mut_save_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.save_id
    }
}

impl ::protobuf::Message for CMsgGameServerGetLoadGame {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.save_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.save_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.save_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameServerGetLoadGame {
    fn new() -> CMsgGameServerGetLoadGame {
        CMsgGameServerGetLoadGame::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameServerGetLoadGame>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "save_id",
                    CMsgGameServerGetLoadGame::get_save_id_for_reflect,
                    CMsgGameServerGetLoadGame::mut_save_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameServerGetLoadGame>(
                    "CMsgGameServerGetLoadGame",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameServerGetLoadGame {
    fn clear(&mut self) {
        self.clear_save_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerGetLoadGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerGetLoadGame {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerGetLoadGameResult {
    // message fields
    save_game_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGameServerGetLoadGameResult {}

impl CMsgGameServerGetLoadGameResult {
    pub fn new() -> CMsgGameServerGetLoadGameResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGameServerGetLoadGameResult {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGameServerGetLoadGameResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGameServerGetLoadGameResult,
        };
        unsafe {
            instance.get(CMsgGameServerGetLoadGameResult::new)
        }
    }

    // optional bytes save_game_data = 1;

    pub fn clear_save_game_data(&mut self) {
        self.save_game_data.clear();
    }

    pub fn has_save_game_data(&self) -> bool {
        self.save_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.save_game_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_save_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.save_game_data.is_none() {
            self.save_game_data.set_default();
        }
        self.save_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_save_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.save_game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_save_game_data(&self) -> &[u8] {
        match self.save_game_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_save_game_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.save_game_data
    }

    fn mut_save_game_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.save_game_data
    }
}

impl ::protobuf::Message for CMsgGameServerGetLoadGameResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.save_game_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.save_game_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.save_game_data.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGameServerGetLoadGameResult {
    fn new() -> CMsgGameServerGetLoadGameResult {
        CMsgGameServerGetLoadGameResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGameServerGetLoadGameResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "save_game_data",
                    CMsgGameServerGetLoadGameResult::get_save_game_data_for_reflect,
                    CMsgGameServerGetLoadGameResult::mut_save_game_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGameServerGetLoadGameResult>(
                    "CMsgGameServerGetLoadGameResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGameServerGetLoadGameResult {
    fn clear(&mut self) {
        self.clear_save_game_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerGetLoadGameResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerGetLoadGameResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAGenerateDiretidePrizeList {
    // message fields
    prize_list: ::std::option::Option<u32>,
    highest_roshan_level: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAGenerateDiretidePrizeList {}

impl CMsgDOTAGenerateDiretidePrizeList {
    pub fn new() -> CMsgDOTAGenerateDiretidePrizeList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAGenerateDiretidePrizeList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAGenerateDiretidePrizeList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAGenerateDiretidePrizeList,
        };
        unsafe {
            instance.get(CMsgDOTAGenerateDiretidePrizeList::new)
        }
    }

    // optional uint32 prize_list = 1;

    pub fn clear_prize_list(&mut self) {
        self.prize_list = ::std::option::Option::None;
    }

    pub fn has_prize_list(&self) -> bool {
        self.prize_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prize_list(&mut self, v: u32) {
        self.prize_list = ::std::option::Option::Some(v);
    }

    pub fn get_prize_list(&self) -> u32 {
        self.prize_list.unwrap_or(0)
    }

    fn get_prize_list_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prize_list
    }

    fn mut_prize_list_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prize_list
    }

    // optional uint32 highest_roshan_level = 2;

    pub fn clear_highest_roshan_level(&mut self) {
        self.highest_roshan_level = ::std::option::Option::None;
    }

    pub fn has_highest_roshan_level(&self) -> bool {
        self.highest_roshan_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_highest_roshan_level(&mut self, v: u32) {
        self.highest_roshan_level = ::std::option::Option::Some(v);
    }

    pub fn get_highest_roshan_level(&self) -> u32 {
        self.highest_roshan_level.unwrap_or(0)
    }

    fn get_highest_roshan_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.highest_roshan_level
    }

    fn mut_highest_roshan_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.highest_roshan_level
    }
}

impl ::protobuf::Message for CMsgDOTAGenerateDiretidePrizeList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prize_list = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.highest_roshan_level = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.prize_list {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.highest_roshan_level {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prize_list {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.highest_roshan_level {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAGenerateDiretidePrizeList {
    fn new() -> CMsgDOTAGenerateDiretidePrizeList {
        CMsgDOTAGenerateDiretidePrizeList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAGenerateDiretidePrizeList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prize_list",
                    CMsgDOTAGenerateDiretidePrizeList::get_prize_list_for_reflect,
                    CMsgDOTAGenerateDiretidePrizeList::mut_prize_list_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "highest_roshan_level",
                    CMsgDOTAGenerateDiretidePrizeList::get_highest_roshan_level_for_reflect,
                    CMsgDOTAGenerateDiretidePrizeList::mut_highest_roshan_level_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAGenerateDiretidePrizeList>(
                    "CMsgDOTAGenerateDiretidePrizeList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAGenerateDiretidePrizeList {
    fn clear(&mut self) {
        self.clear_prize_list();
        self.clear_highest_roshan_level();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAGenerateDiretidePrizeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAGenerateDiretidePrizeList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAGenerateDiretidePrizeListResponse {
    // message fields
    item_defs: ::std::vec::Vec<u32>,
    steam_ids: ::std::vec::Vec<u64>,
    prize_list: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAGenerateDiretidePrizeListResponse {}

impl CMsgDOTAGenerateDiretidePrizeListResponse {
    pub fn new() -> CMsgDOTAGenerateDiretidePrizeListResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAGenerateDiretidePrizeListResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAGenerateDiretidePrizeListResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAGenerateDiretidePrizeListResponse,
        };
        unsafe {
            instance.get(CMsgDOTAGenerateDiretidePrizeListResponse::new)
        }
    }

    // repeated uint32 item_defs = 1;

    pub fn clear_item_defs(&mut self) {
        self.item_defs.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_defs(&mut self, v: ::std::vec::Vec<u32>) {
        self.item_defs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_defs(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.item_defs
    }

    // Take field
    pub fn take_item_defs(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.item_defs, ::std::vec::Vec::new())
    }

    pub fn get_item_defs(&self) -> &[u32] {
        &self.item_defs
    }

    fn get_item_defs_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.item_defs
    }

    fn mut_item_defs_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.item_defs
    }

    // repeated fixed64 steam_ids = 2;

    pub fn clear_steam_ids(&mut self) {
        self.steam_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_steam_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.steam_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steam_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steam_ids
    }

    // Take field
    pub fn take_steam_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steam_ids, ::std::vec::Vec::new())
    }

    pub fn get_steam_ids(&self) -> &[u64] {
        &self.steam_ids
    }

    fn get_steam_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.steam_ids
    }

    fn mut_steam_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steam_ids
    }

    // optional uint32 prize_list = 3;

    pub fn clear_prize_list(&mut self) {
        self.prize_list = ::std::option::Option::None;
    }

    pub fn has_prize_list(&self) -> bool {
        self.prize_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prize_list(&mut self, v: u32) {
        self.prize_list = ::std::option::Option::Some(v);
    }

    pub fn get_prize_list(&self) -> u32 {
        self.prize_list.unwrap_or(0)
    }

    fn get_prize_list_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prize_list
    }

    fn mut_prize_list_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prize_list
    }
}

impl ::protobuf::Message for CMsgDOTAGenerateDiretidePrizeListResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.item_defs)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steam_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prize_list = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item_defs {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += 9 * self.steam_ids.len() as u32;
        if let Some(v) = self.prize_list {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item_defs {
            os.write_uint32(1, *v)?;
        };
        for v in &self.steam_ids {
            os.write_fixed64(2, *v)?;
        };
        if let Some(v) = self.prize_list {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAGenerateDiretidePrizeListResponse {
    fn new() -> CMsgDOTAGenerateDiretidePrizeListResponse {
        CMsgDOTAGenerateDiretidePrizeListResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAGenerateDiretidePrizeListResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_defs",
                    CMsgDOTAGenerateDiretidePrizeListResponse::get_item_defs_for_reflect,
                    CMsgDOTAGenerateDiretidePrizeListResponse::mut_item_defs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steam_ids",
                    CMsgDOTAGenerateDiretidePrizeListResponse::get_steam_ids_for_reflect,
                    CMsgDOTAGenerateDiretidePrizeListResponse::mut_steam_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prize_list",
                    CMsgDOTAGenerateDiretidePrizeListResponse::get_prize_list_for_reflect,
                    CMsgDOTAGenerateDiretidePrizeListResponse::mut_prize_list_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAGenerateDiretidePrizeListResponse>(
                    "CMsgDOTAGenerateDiretidePrizeListResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAGenerateDiretidePrizeListResponse {
    fn clear(&mut self) {
        self.clear_item_defs();
        self.clear_steam_ids();
        self.clear_prize_list();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAGenerateDiretidePrizeListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAGenerateDiretidePrizeListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARewardDiretidePrizes {
    // message fields
    team: ::std::option::Option<u32>,
    prize_list: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARewardDiretidePrizes {}

impl CMsgDOTARewardDiretidePrizes {
    pub fn new() -> CMsgDOTARewardDiretidePrizes {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARewardDiretidePrizes {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARewardDiretidePrizes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARewardDiretidePrizes,
        };
        unsafe {
            instance.get(CMsgDOTARewardDiretidePrizes::new)
        }
    }

    // optional uint32 team = 1;

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    pub fn get_team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    fn get_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team
    }

    fn mut_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team
    }

    // optional uint32 prize_list = 2;

    pub fn clear_prize_list(&mut self) {
        self.prize_list = ::std::option::Option::None;
    }

    pub fn has_prize_list(&self) -> bool {
        self.prize_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prize_list(&mut self, v: u32) {
        self.prize_list = ::std::option::Option::Some(v);
    }

    pub fn get_prize_list(&self) -> u32 {
        self.prize_list.unwrap_or(0)
    }

    fn get_prize_list_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prize_list
    }

    fn mut_prize_list_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prize_list
    }
}

impl ::protobuf::Message for CMsgDOTARewardDiretidePrizes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prize_list = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prize_list {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.prize_list {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARewardDiretidePrizes {
    fn new() -> CMsgDOTARewardDiretidePrizes {
        CMsgDOTARewardDiretidePrizes::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARewardDiretidePrizes>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team",
                    CMsgDOTARewardDiretidePrizes::get_team_for_reflect,
                    CMsgDOTARewardDiretidePrizes::mut_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prize_list",
                    CMsgDOTARewardDiretidePrizes::get_prize_list_for_reflect,
                    CMsgDOTARewardDiretidePrizes::mut_prize_list_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARewardDiretidePrizes>(
                    "CMsgDOTARewardDiretidePrizes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARewardDiretidePrizes {
    fn clear(&mut self) {
        self.clear_team();
        self.clear_prize_list();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARewardDiretidePrizes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARewardDiretidePrizes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTADiretidePrizesRewardedResponse {
    // message fields
    prize_list: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTADiretidePrizesRewardedResponse {}

impl CMsgDOTADiretidePrizesRewardedResponse {
    pub fn new() -> CMsgDOTADiretidePrizesRewardedResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTADiretidePrizesRewardedResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTADiretidePrizesRewardedResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTADiretidePrizesRewardedResponse,
        };
        unsafe {
            instance.get(CMsgDOTADiretidePrizesRewardedResponse::new)
        }
    }

    // optional uint32 prize_list = 1;

    pub fn clear_prize_list(&mut self) {
        self.prize_list = ::std::option::Option::None;
    }

    pub fn has_prize_list(&self) -> bool {
        self.prize_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prize_list(&mut self, v: u32) {
        self.prize_list = ::std::option::Option::Some(v);
    }

    pub fn get_prize_list(&self) -> u32 {
        self.prize_list.unwrap_or(0)
    }

    fn get_prize_list_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prize_list
    }

    fn mut_prize_list_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prize_list
    }
}

impl ::protobuf::Message for CMsgDOTADiretidePrizesRewardedResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prize_list = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.prize_list {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prize_list {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTADiretidePrizesRewardedResponse {
    fn new() -> CMsgDOTADiretidePrizesRewardedResponse {
        CMsgDOTADiretidePrizesRewardedResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTADiretidePrizesRewardedResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prize_list",
                    CMsgDOTADiretidePrizesRewardedResponse::get_prize_list_for_reflect,
                    CMsgDOTADiretidePrizesRewardedResponse::mut_prize_list_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTADiretidePrizesRewardedResponse>(
                    "CMsgDOTADiretidePrizesRewardedResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTADiretidePrizesRewardedResponse {
    fn clear(&mut self) {
        self.clear_prize_list();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTADiretidePrizesRewardedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTADiretidePrizesRewardedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAAwardEventPoints {
    // message fields
    award_points: ::protobuf::RepeatedField<CMsgDOTAAwardEventPoints_AwardPoints>,
    match_id: ::std::option::Option<u64>,
    event_id: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    audit_action: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAAwardEventPoints {}

impl CMsgDOTAAwardEventPoints {
    pub fn new() -> CMsgDOTAAwardEventPoints {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAAwardEventPoints {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAAwardEventPoints> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAAwardEventPoints,
        };
        unsafe {
            instance.get(CMsgDOTAAwardEventPoints::new)
        }
    }

    // repeated .CMsgDOTAAwardEventPoints.AwardPoints award_points = 1;

    pub fn clear_award_points(&mut self) {
        self.award_points.clear();
    }

    // Param is passed by value, moved
    pub fn set_award_points(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAAwardEventPoints_AwardPoints>) {
        self.award_points = v;
    }

    // Mutable pointer to the field.
    pub fn mut_award_points(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAAwardEventPoints_AwardPoints> {
        &mut self.award_points
    }

    // Take field
    pub fn take_award_points(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAAwardEventPoints_AwardPoints> {
        ::std::mem::replace(&mut self.award_points, ::protobuf::RepeatedField::new())
    }

    pub fn get_award_points(&self) -> &[CMsgDOTAAwardEventPoints_AwardPoints] {
        &self.award_points
    }

    fn get_award_points_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAAwardEventPoints_AwardPoints> {
        &self.award_points
    }

    fn mut_award_points_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAAwardEventPoints_AwardPoints> {
        &mut self.award_points
    }

    // optional uint64 match_id = 2;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 event_id = 4;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // optional uint32 timestamp = 5;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional uint32 audit_action = 6;

    pub fn clear_audit_action(&mut self) {
        self.audit_action = ::std::option::Option::None;
    }

    pub fn has_audit_action(&self) -> bool {
        self.audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_action(&mut self, v: u32) {
        self.audit_action = ::std::option::Option::Some(v);
    }

    pub fn get_audit_action(&self) -> u32 {
        self.audit_action.unwrap_or(0)
    }

    fn get_audit_action_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.audit_action
    }

    fn mut_audit_action_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.audit_action
    }
}

impl ::protobuf::Message for CMsgDOTAAwardEventPoints {
    fn is_initialized(&self) -> bool {
        for v in &self.award_points {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.award_points)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.audit_action = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.award_points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.audit_action {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.award_points {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.audit_action {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAAwardEventPoints {
    fn new() -> CMsgDOTAAwardEventPoints {
        CMsgDOTAAwardEventPoints::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAAwardEventPoints>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAAwardEventPoints_AwardPoints>>(
                    "award_points",
                    CMsgDOTAAwardEventPoints::get_award_points_for_reflect,
                    CMsgDOTAAwardEventPoints::mut_award_points_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgDOTAAwardEventPoints::get_match_id_for_reflect,
                    CMsgDOTAAwardEventPoints::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgDOTAAwardEventPoints::get_event_id_for_reflect,
                    CMsgDOTAAwardEventPoints::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgDOTAAwardEventPoints::get_timestamp_for_reflect,
                    CMsgDOTAAwardEventPoints::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "audit_action",
                    CMsgDOTAAwardEventPoints::get_audit_action_for_reflect,
                    CMsgDOTAAwardEventPoints::mut_audit_action_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAAwardEventPoints>(
                    "CMsgDOTAAwardEventPoints",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAAwardEventPoints {
    fn clear(&mut self) {
        self.clear_award_points();
        self.clear_match_id();
        self.clear_event_id();
        self.clear_timestamp();
        self.clear_audit_action();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAAwardEventPoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAAwardEventPoints {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAAwardEventPoints_AwardPoints {
    // message fields
    account_id: ::std::option::Option<u32>,
    points: ::std::option::Option<i32>,
    premium_points: ::std::option::Option<i32>,
    trade_ban_time: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAAwardEventPoints_AwardPoints {}

impl CMsgDOTAAwardEventPoints_AwardPoints {
    pub fn new() -> CMsgDOTAAwardEventPoints_AwardPoints {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAAwardEventPoints_AwardPoints {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAAwardEventPoints_AwardPoints> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAAwardEventPoints_AwardPoints,
        };
        unsafe {
            instance.get(CMsgDOTAAwardEventPoints_AwardPoints::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional int32 points = 2;

    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: i32) {
        self.points = ::std::option::Option::Some(v);
    }

    pub fn get_points(&self) -> i32 {
        self.points.unwrap_or(0)
    }

    fn get_points_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.points
    }

    fn mut_points_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.points
    }

    // optional int32 premium_points = 3;

    pub fn clear_premium_points(&mut self) {
        self.premium_points = ::std::option::Option::None;
    }

    pub fn has_premium_points(&self) -> bool {
        self.premium_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_premium_points(&mut self, v: i32) {
        self.premium_points = ::std::option::Option::Some(v);
    }

    pub fn get_premium_points(&self) -> i32 {
        self.premium_points.unwrap_or(0)
    }

    fn get_premium_points_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.premium_points
    }

    fn mut_premium_points_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.premium_points
    }

    // optional uint32 trade_ban_time = 5;

    pub fn clear_trade_ban_time(&mut self) {
        self.trade_ban_time = ::std::option::Option::None;
    }

    pub fn has_trade_ban_time(&self) -> bool {
        self.trade_ban_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_ban_time(&mut self, v: u32) {
        self.trade_ban_time = ::std::option::Option::Some(v);
    }

    pub fn get_trade_ban_time(&self) -> u32 {
        self.trade_ban_time.unwrap_or(0)
    }

    fn get_trade_ban_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.trade_ban_time
    }

    fn mut_trade_ban_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.trade_ban_time
    }
}

impl ::protobuf::Message for CMsgDOTAAwardEventPoints_AwardPoints {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.points = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.premium_points = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.trade_ban_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.premium_points {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.trade_ban_time {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.points {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.premium_points {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.trade_ban_time {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAAwardEventPoints_AwardPoints {
    fn new() -> CMsgDOTAAwardEventPoints_AwardPoints {
        CMsgDOTAAwardEventPoints_AwardPoints::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAAwardEventPoints_AwardPoints>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAAwardEventPoints_AwardPoints::get_account_id_for_reflect,
                    CMsgDOTAAwardEventPoints_AwardPoints::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "points",
                    CMsgDOTAAwardEventPoints_AwardPoints::get_points_for_reflect,
                    CMsgDOTAAwardEventPoints_AwardPoints::mut_points_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "premium_points",
                    CMsgDOTAAwardEventPoints_AwardPoints::get_premium_points_for_reflect,
                    CMsgDOTAAwardEventPoints_AwardPoints::mut_premium_points_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "trade_ban_time",
                    CMsgDOTAAwardEventPoints_AwardPoints::get_trade_ban_time_for_reflect,
                    CMsgDOTAAwardEventPoints_AwardPoints::mut_trade_ban_time_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAAwardEventPoints_AwardPoints>(
                    "CMsgDOTAAwardEventPoints_AwardPoints",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAAwardEventPoints_AwardPoints {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_points();
        self.clear_premium_points();
        self.clear_trade_ban_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAAwardEventPoints_AwardPoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAAwardEventPoints_AwardPoints {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCSignoutAwardAdditionalDrops {
    // message fields
    drops: ::protobuf::RepeatedField<CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops>,
    match_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCSignoutAwardAdditionalDrops {}

impl CMsgServerToGCSignoutAwardAdditionalDrops {
    pub fn new() -> CMsgServerToGCSignoutAwardAdditionalDrops {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCSignoutAwardAdditionalDrops {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCSignoutAwardAdditionalDrops> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCSignoutAwardAdditionalDrops,
        };
        unsafe {
            instance.get(CMsgServerToGCSignoutAwardAdditionalDrops::new)
        }
    }

    // repeated .CMsgServerToGCSignoutAwardAdditionalDrops.AdditionalDrops drops = 1;

    pub fn clear_drops(&mut self) {
        self.drops.clear();
    }

    // Param is passed by value, moved
    pub fn set_drops(&mut self, v: ::protobuf::RepeatedField<CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops>) {
        self.drops = v;
    }

    // Mutable pointer to the field.
    pub fn mut_drops(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops> {
        &mut self.drops
    }

    // Take field
    pub fn take_drops(&mut self) -> ::protobuf::RepeatedField<CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops> {
        ::std::mem::replace(&mut self.drops, ::protobuf::RepeatedField::new())
    }

    pub fn get_drops(&self) -> &[CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops] {
        &self.drops
    }

    fn get_drops_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops> {
        &self.drops
    }

    fn mut_drops_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops> {
        &mut self.drops
    }

    // optional uint64 match_id = 2;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }
}

impl ::protobuf::Message for CMsgServerToGCSignoutAwardAdditionalDrops {
    fn is_initialized(&self) -> bool {
        for v in &self.drops {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.drops)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.drops {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.drops {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCSignoutAwardAdditionalDrops {
    fn new() -> CMsgServerToGCSignoutAwardAdditionalDrops {
        CMsgServerToGCSignoutAwardAdditionalDrops::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCSignoutAwardAdditionalDrops>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops>>(
                    "drops",
                    CMsgServerToGCSignoutAwardAdditionalDrops::get_drops_for_reflect,
                    CMsgServerToGCSignoutAwardAdditionalDrops::mut_drops_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgServerToGCSignoutAwardAdditionalDrops::get_match_id_for_reflect,
                    CMsgServerToGCSignoutAwardAdditionalDrops::mut_match_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCSignoutAwardAdditionalDrops>(
                    "CMsgServerToGCSignoutAwardAdditionalDrops",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCSignoutAwardAdditionalDrops {
    fn clear(&mut self) {
        self.clear_drops();
        self.clear_match_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCSignoutAwardAdditionalDrops {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCSignoutAwardAdditionalDrops {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops {
    // message fields
    loot_list: ::protobuf::SingularField<::std::string::String>,
    player_account_ids: ::std::vec::Vec<u32>,
    no_trade: ::std::option::Option<bool>,
    randomize_reward: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops {}

impl CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops {
    pub fn new() -> CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops,
        };
        unsafe {
            instance.get(CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops::new)
        }
    }

    // optional string loot_list = 1;

    pub fn clear_loot_list(&mut self) {
        self.loot_list.clear();
    }

    pub fn has_loot_list(&self) -> bool {
        self.loot_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loot_list(&mut self, v: ::std::string::String) {
        self.loot_list = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loot_list(&mut self) -> &mut ::std::string::String {
        if self.loot_list.is_none() {
            self.loot_list.set_default();
        }
        self.loot_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_loot_list(&mut self) -> ::std::string::String {
        self.loot_list.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_loot_list(&self) -> &str {
        match self.loot_list.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_loot_list_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.loot_list
    }

    fn mut_loot_list_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.loot_list
    }

    // repeated uint32 player_account_ids = 2;

    pub fn clear_player_account_ids(&mut self) {
        self.player_account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.player_account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.player_account_ids
    }

    // Take field
    pub fn take_player_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.player_account_ids, ::std::vec::Vec::new())
    }

    pub fn get_player_account_ids(&self) -> &[u32] {
        &self.player_account_ids
    }

    fn get_player_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.player_account_ids
    }

    fn mut_player_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.player_account_ids
    }

    // optional bool no_trade = 3;

    pub fn clear_no_trade(&mut self) {
        self.no_trade = ::std::option::Option::None;
    }

    pub fn has_no_trade(&self) -> bool {
        self.no_trade.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_trade(&mut self, v: bool) {
        self.no_trade = ::std::option::Option::Some(v);
    }

    pub fn get_no_trade(&self) -> bool {
        self.no_trade.unwrap_or(false)
    }

    fn get_no_trade_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.no_trade
    }

    fn mut_no_trade_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.no_trade
    }

    // optional bool randomize_reward = 4;

    pub fn clear_randomize_reward(&mut self) {
        self.randomize_reward = ::std::option::Option::None;
    }

    pub fn has_randomize_reward(&self) -> bool {
        self.randomize_reward.is_some()
    }

    // Param is passed by value, moved
    pub fn set_randomize_reward(&mut self, v: bool) {
        self.randomize_reward = ::std::option::Option::Some(v);
    }

    pub fn get_randomize_reward(&self) -> bool {
        self.randomize_reward.unwrap_or(false)
    }

    fn get_randomize_reward_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.randomize_reward
    }

    fn mut_randomize_reward_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.randomize_reward
    }
}

impl ::protobuf::Message for CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loot_list)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.player_account_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_trade = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.randomize_reward = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.loot_list.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.player_account_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.no_trade {
            my_size += 2;
        }
        if let Some(v) = self.randomize_reward {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.loot_list.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.player_account_ids {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.no_trade {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.randomize_reward {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops {
    fn new() -> CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops {
        CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "loot_list",
                    CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops::get_loot_list_for_reflect,
                    CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops::mut_loot_list_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_account_ids",
                    CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops::get_player_account_ids_for_reflect,
                    CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops::mut_player_account_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "no_trade",
                    CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops::get_no_trade_for_reflect,
                    CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops::mut_no_trade_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "randomize_reward",
                    CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops::get_randomize_reward_for_reflect,
                    CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops::mut_randomize_reward_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops>(
                    "CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops {
    fn clear(&mut self) {
        self.clear_loot_list();
        self.clear_player_account_ids();
        self.clear_no_trade();
        self.clear_randomize_reward();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCSignoutAwardAdditionalDrops_AdditionalDrops {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFrostivusTimeElapsed {
    // message fields
    seconds: ::std::option::Option<u32>,
    users: ::protobuf::RepeatedField<CMsgDOTAFrostivusTimeElapsed_User>,
    match_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFrostivusTimeElapsed {}

impl CMsgDOTAFrostivusTimeElapsed {
    pub fn new() -> CMsgDOTAFrostivusTimeElapsed {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFrostivusTimeElapsed {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFrostivusTimeElapsed> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFrostivusTimeElapsed,
        };
        unsafe {
            instance.get(CMsgDOTAFrostivusTimeElapsed::new)
        }
    }

    // optional uint32 seconds = 1;

    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: u32) {
        self.seconds = ::std::option::Option::Some(v);
    }

    pub fn get_seconds(&self) -> u32 {
        self.seconds.unwrap_or(0)
    }

    fn get_seconds_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.seconds
    }

    fn mut_seconds_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.seconds
    }

    // repeated .CMsgDOTAFrostivusTimeElapsed.User users = 2;

    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAFrostivusTimeElapsed_User>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFrostivusTimeElapsed_User> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAFrostivusTimeElapsed_User> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }

    pub fn get_users(&self) -> &[CMsgDOTAFrostivusTimeElapsed_User] {
        &self.users
    }

    fn get_users_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAFrostivusTimeElapsed_User> {
        &self.users
    }

    fn mut_users_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFrostivusTimeElapsed_User> {
        &mut self.users
    }

    // optional uint64 match_id = 3;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }
}

impl ::protobuf::Message for CMsgDOTAFrostivusTimeElapsed {
    fn is_initialized(&self) -> bool {
        for v in &self.users {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seconds {
            os.write_uint32(1, v)?;
        }
        for v in &self.users {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.match_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFrostivusTimeElapsed {
    fn new() -> CMsgDOTAFrostivusTimeElapsed {
        CMsgDOTAFrostivusTimeElapsed::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFrostivusTimeElapsed>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "seconds",
                    CMsgDOTAFrostivusTimeElapsed::get_seconds_for_reflect,
                    CMsgDOTAFrostivusTimeElapsed::mut_seconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFrostivusTimeElapsed_User>>(
                    "users",
                    CMsgDOTAFrostivusTimeElapsed::get_users_for_reflect,
                    CMsgDOTAFrostivusTimeElapsed::mut_users_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgDOTAFrostivusTimeElapsed::get_match_id_for_reflect,
                    CMsgDOTAFrostivusTimeElapsed::mut_match_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFrostivusTimeElapsed>(
                    "CMsgDOTAFrostivusTimeElapsed",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFrostivusTimeElapsed {
    fn clear(&mut self) {
        self.clear_seconds();
        self.clear_users();
        self.clear_match_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFrostivusTimeElapsed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFrostivusTimeElapsed {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFrostivusTimeElapsed_User {
    // message fields
    account_id: ::std::option::Option<u32>,
    time_elapsed_s: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFrostivusTimeElapsed_User {}

impl CMsgDOTAFrostivusTimeElapsed_User {
    pub fn new() -> CMsgDOTAFrostivusTimeElapsed_User {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFrostivusTimeElapsed_User {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFrostivusTimeElapsed_User> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFrostivusTimeElapsed_User,
        };
        unsafe {
            instance.get(CMsgDOTAFrostivusTimeElapsed_User::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 time_elapsed_s = 2;

    pub fn clear_time_elapsed_s(&mut self) {
        self.time_elapsed_s = ::std::option::Option::None;
    }

    pub fn has_time_elapsed_s(&self) -> bool {
        self.time_elapsed_s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_elapsed_s(&mut self, v: u32) {
        self.time_elapsed_s = ::std::option::Option::Some(v);
    }

    pub fn get_time_elapsed_s(&self) -> u32 {
        self.time_elapsed_s.unwrap_or(0)
    }

    fn get_time_elapsed_s_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time_elapsed_s
    }

    fn mut_time_elapsed_s_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time_elapsed_s
    }
}

impl ::protobuf::Message for CMsgDOTAFrostivusTimeElapsed_User {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_elapsed_s = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_elapsed_s {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time_elapsed_s {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFrostivusTimeElapsed_User {
    fn new() -> CMsgDOTAFrostivusTimeElapsed_User {
        CMsgDOTAFrostivusTimeElapsed_User::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFrostivusTimeElapsed_User>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAFrostivusTimeElapsed_User::get_account_id_for_reflect,
                    CMsgDOTAFrostivusTimeElapsed_User::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_elapsed_s",
                    CMsgDOTAFrostivusTimeElapsed_User::get_time_elapsed_s_for_reflect,
                    CMsgDOTAFrostivusTimeElapsed_User::mut_time_elapsed_s_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFrostivusTimeElapsed_User>(
                    "CMsgDOTAFrostivusTimeElapsed_User",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFrostivusTimeElapsed_User {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_time_elapsed_s();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFrostivusTimeElapsed_User {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFrostivusTimeElapsed_User {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToServerPingRequest {
    // message fields
    request_id: ::std::option::Option<u64>,
    request_time: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToServerPingRequest {}

impl CMsgGCToServerPingRequest {
    pub fn new() -> CMsgGCToServerPingRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToServerPingRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToServerPingRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToServerPingRequest,
        };
        unsafe {
            instance.get(CMsgGCToServerPingRequest::new)
        }
    }

    // optional fixed64 request_id = 1;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    fn get_request_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.request_id
    }

    fn mut_request_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.request_id
    }

    // optional uint64 request_time = 2;

    pub fn clear_request_time(&mut self) {
        self.request_time = ::std::option::Option::None;
    }

    pub fn has_request_time(&self) -> bool {
        self.request_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_time(&mut self, v: u64) {
        self.request_time = ::std::option::Option::Some(v);
    }

    pub fn get_request_time(&self) -> u64 {
        self.request_time.unwrap_or(0)
    }

    fn get_request_time_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.request_time
    }

    fn mut_request_time_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.request_time
    }
}

impl ::protobuf::Message for CMsgGCToServerPingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += 9;
        }
        if let Some(v) = self.request_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.request_time {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToServerPingRequest {
    fn new() -> CMsgGCToServerPingRequest {
        CMsgGCToServerPingRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToServerPingRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "request_id",
                    CMsgGCToServerPingRequest::get_request_id_for_reflect,
                    CMsgGCToServerPingRequest::mut_request_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_time",
                    CMsgGCToServerPingRequest::get_request_time_for_reflect,
                    CMsgGCToServerPingRequest::mut_request_time_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToServerPingRequest>(
                    "CMsgGCToServerPingRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToServerPingRequest {
    fn clear(&mut self) {
        self.clear_request_id();
        self.clear_request_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToServerPingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerPingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToServerPingResponse {
    // message fields
    request_id: ::std::option::Option<u64>,
    request_time: ::std::option::Option<u64>,
    cluster: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToServerPingResponse {}

impl CMsgGCToServerPingResponse {
    pub fn new() -> CMsgGCToServerPingResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToServerPingResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToServerPingResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToServerPingResponse,
        };
        unsafe {
            instance.get(CMsgGCToServerPingResponse::new)
        }
    }

    // optional fixed64 request_id = 1;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    fn get_request_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.request_id
    }

    fn mut_request_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.request_id
    }

    // optional uint64 request_time = 2;

    pub fn clear_request_time(&mut self) {
        self.request_time = ::std::option::Option::None;
    }

    pub fn has_request_time(&self) -> bool {
        self.request_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_time(&mut self, v: u64) {
        self.request_time = ::std::option::Option::Some(v);
    }

    pub fn get_request_time(&self) -> u64 {
        self.request_time.unwrap_or(0)
    }

    fn get_request_time_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.request_time
    }

    fn mut_request_time_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.request_time
    }

    // optional uint32 cluster = 3;

    pub fn clear_cluster(&mut self) {
        self.cluster = ::std::option::Option::None;
    }

    pub fn has_cluster(&self) -> bool {
        self.cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: u32) {
        self.cluster = ::std::option::Option::Some(v);
    }

    pub fn get_cluster(&self) -> u32 {
        self.cluster.unwrap_or(0)
    }

    fn get_cluster_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cluster
    }

    fn mut_cluster_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cluster
    }
}

impl ::protobuf::Message for CMsgGCToServerPingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cluster = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += 9;
        }
        if let Some(v) = self.request_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cluster {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.request_time {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.cluster {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToServerPingResponse {
    fn new() -> CMsgGCToServerPingResponse {
        CMsgGCToServerPingResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToServerPingResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "request_id",
                    CMsgGCToServerPingResponse::get_request_id_for_reflect,
                    CMsgGCToServerPingResponse::mut_request_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_time",
                    CMsgGCToServerPingResponse::get_request_time_for_reflect,
                    CMsgGCToServerPingResponse::mut_request_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cluster",
                    CMsgGCToServerPingResponse::get_cluster_for_reflect,
                    CMsgGCToServerPingResponse::mut_cluster_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToServerPingResponse>(
                    "CMsgGCToServerPingResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToServerPingResponse {
    fn clear(&mut self) {
        self.clear_request_id();
        self.clear_request_time();
        self.clear_cluster();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToServerPingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerPingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToServerConsoleCommand {
    // message fields
    console_command: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToServerConsoleCommand {}

impl CMsgGCToServerConsoleCommand {
    pub fn new() -> CMsgGCToServerConsoleCommand {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToServerConsoleCommand {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToServerConsoleCommand> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToServerConsoleCommand,
        };
        unsafe {
            instance.get(CMsgGCToServerConsoleCommand::new)
        }
    }

    // optional string console_command = 1;

    pub fn clear_console_command(&mut self) {
        self.console_command.clear();
    }

    pub fn has_console_command(&self) -> bool {
        self.console_command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_console_command(&mut self, v: ::std::string::String) {
        self.console_command = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_console_command(&mut self) -> &mut ::std::string::String {
        if self.console_command.is_none() {
            self.console_command.set_default();
        }
        self.console_command.as_mut().unwrap()
    }

    // Take field
    pub fn take_console_command(&mut self) -> ::std::string::String {
        self.console_command.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_console_command(&self) -> &str {
        match self.console_command.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_console_command_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.console_command
    }

    fn mut_console_command_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.console_command
    }
}

impl ::protobuf::Message for CMsgGCToServerConsoleCommand {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.console_command)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.console_command.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.console_command.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToServerConsoleCommand {
    fn new() -> CMsgGCToServerConsoleCommand {
        CMsgGCToServerConsoleCommand::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToServerConsoleCommand>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "console_command",
                    CMsgGCToServerConsoleCommand::get_console_command_for_reflect,
                    CMsgGCToServerConsoleCommand::mut_console_command_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToServerConsoleCommand>(
                    "CMsgGCToServerConsoleCommand",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToServerConsoleCommand {
    fn clear(&mut self) {
        self.clear_console_command();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToServerConsoleCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerConsoleCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerGetEventPoints {
    // message fields
    event_id: ::std::option::Option<u32>,
    account_id: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerGetEventPoints {}

impl CMsgServerGetEventPoints {
    pub fn new() -> CMsgServerGetEventPoints {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerGetEventPoints {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerGetEventPoints> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerGetEventPoints,
        };
        unsafe {
            instance.get(CMsgServerGetEventPoints::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // repeated uint32 account_id = 2;

    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_id(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_id
    }

    // Take field
    pub fn take_account_id(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_id, ::std::vec::Vec::new())
    }

    pub fn get_account_id(&self) -> &[u32] {
        &self.account_id
    }

    fn get_account_id_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgServerGetEventPoints {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.account_id {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_id {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerGetEventPoints {
    fn new() -> CMsgServerGetEventPoints {
        CMsgServerGetEventPoints::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerGetEventPoints>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgServerGetEventPoints::get_event_id_for_reflect,
                    CMsgServerGetEventPoints::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgServerGetEventPoints::get_account_id_for_reflect,
                    CMsgServerGetEventPoints::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerGetEventPoints>(
                    "CMsgServerGetEventPoints",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerGetEventPoints {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerGetEventPoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerGetEventPoints {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerGetEventPointsResponse {
    // message fields
    event_id: ::std::option::Option<u32>,
    points: ::protobuf::RepeatedField<CMsgServerGetEventPointsResponse_Points>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerGetEventPointsResponse {}

impl CMsgServerGetEventPointsResponse {
    pub fn new() -> CMsgServerGetEventPointsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerGetEventPointsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerGetEventPointsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerGetEventPointsResponse,
        };
        unsafe {
            instance.get(CMsgServerGetEventPointsResponse::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // repeated .CMsgServerGetEventPointsResponse.Points points = 2;

    pub fn clear_points(&mut self) {
        self.points.clear();
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: ::protobuf::RepeatedField<CMsgServerGetEventPointsResponse_Points>) {
        self.points = v;
    }

    // Mutable pointer to the field.
    pub fn mut_points(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerGetEventPointsResponse_Points> {
        &mut self.points
    }

    // Take field
    pub fn take_points(&mut self) -> ::protobuf::RepeatedField<CMsgServerGetEventPointsResponse_Points> {
        ::std::mem::replace(&mut self.points, ::protobuf::RepeatedField::new())
    }

    pub fn get_points(&self) -> &[CMsgServerGetEventPointsResponse_Points] {
        &self.points
    }

    fn get_points_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgServerGetEventPointsResponse_Points> {
        &self.points
    }

    fn mut_points_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerGetEventPointsResponse_Points> {
        &mut self.points
    }
}

impl ::protobuf::Message for CMsgServerGetEventPointsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.points {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.points)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.points {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerGetEventPointsResponse {
    fn new() -> CMsgServerGetEventPointsResponse {
        CMsgServerGetEventPointsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerGetEventPointsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgServerGetEventPointsResponse::get_event_id_for_reflect,
                    CMsgServerGetEventPointsResponse::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgServerGetEventPointsResponse_Points>>(
                    "points",
                    CMsgServerGetEventPointsResponse::get_points_for_reflect,
                    CMsgServerGetEventPointsResponse::mut_points_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerGetEventPointsResponse>(
                    "CMsgServerGetEventPointsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerGetEventPointsResponse {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_points();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerGetEventPointsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerGetEventPointsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerGetEventPointsResponse_Points {
    // message fields
    account_id: ::std::option::Option<u32>,
    points_total: ::std::option::Option<u32>,
    owned: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerGetEventPointsResponse_Points {}

impl CMsgServerGetEventPointsResponse_Points {
    pub fn new() -> CMsgServerGetEventPointsResponse_Points {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerGetEventPointsResponse_Points {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerGetEventPointsResponse_Points> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerGetEventPointsResponse_Points,
        };
        unsafe {
            instance.get(CMsgServerGetEventPointsResponse_Points::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 points_total = 2;

    pub fn clear_points_total(&mut self) {
        self.points_total = ::std::option::Option::None;
    }

    pub fn has_points_total(&self) -> bool {
        self.points_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_total(&mut self, v: u32) {
        self.points_total = ::std::option::Option::Some(v);
    }

    pub fn get_points_total(&self) -> u32 {
        self.points_total.unwrap_or(0)
    }

    fn get_points_total_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points_total
    }

    fn mut_points_total_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points_total
    }

    // optional bool owned = 4;

    pub fn clear_owned(&mut self) {
        self.owned = ::std::option::Option::None;
    }

    pub fn has_owned(&self) -> bool {
        self.owned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owned(&mut self, v: bool) {
        self.owned = ::std::option::Option::Some(v);
    }

    pub fn get_owned(&self) -> bool {
        self.owned.unwrap_or(false)
    }

    fn get_owned_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.owned
    }

    fn mut_owned_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.owned
    }
}

impl ::protobuf::Message for CMsgServerGetEventPointsResponse_Points {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_total = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.owned = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points_total {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owned {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.points_total {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.owned {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerGetEventPointsResponse_Points {
    fn new() -> CMsgServerGetEventPointsResponse_Points {
        CMsgServerGetEventPointsResponse_Points::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerGetEventPointsResponse_Points>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgServerGetEventPointsResponse_Points::get_account_id_for_reflect,
                    CMsgServerGetEventPointsResponse_Points::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points_total",
                    CMsgServerGetEventPointsResponse_Points::get_points_total_for_reflect,
                    CMsgServerGetEventPointsResponse_Points::mut_points_total_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "owned",
                    CMsgServerGetEventPointsResponse_Points::get_owned_for_reflect,
                    CMsgServerGetEventPointsResponse_Points::mut_owned_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerGetEventPointsResponse_Points>(
                    "CMsgServerGetEventPointsResponse_Points",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerGetEventPointsResponse_Points {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_points_total();
        self.clear_owned();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerGetEventPointsResponse_Points {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerGetEventPointsResponse_Points {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerGrantSurveyPermission {
    // message fields
    surveys: ::protobuf::RepeatedField<CMsgServerGrantSurveyPermission_Survey>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerGrantSurveyPermission {}

impl CMsgServerGrantSurveyPermission {
    pub fn new() -> CMsgServerGrantSurveyPermission {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerGrantSurveyPermission {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerGrantSurveyPermission> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerGrantSurveyPermission,
        };
        unsafe {
            instance.get(CMsgServerGrantSurveyPermission::new)
        }
    }

    // repeated .CMsgServerGrantSurveyPermission.Survey surveys = 1;

    pub fn clear_surveys(&mut self) {
        self.surveys.clear();
    }

    // Param is passed by value, moved
    pub fn set_surveys(&mut self, v: ::protobuf::RepeatedField<CMsgServerGrantSurveyPermission_Survey>) {
        self.surveys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_surveys(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerGrantSurveyPermission_Survey> {
        &mut self.surveys
    }

    // Take field
    pub fn take_surveys(&mut self) -> ::protobuf::RepeatedField<CMsgServerGrantSurveyPermission_Survey> {
        ::std::mem::replace(&mut self.surveys, ::protobuf::RepeatedField::new())
    }

    pub fn get_surveys(&self) -> &[CMsgServerGrantSurveyPermission_Survey] {
        &self.surveys
    }

    fn get_surveys_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgServerGrantSurveyPermission_Survey> {
        &self.surveys
    }

    fn mut_surveys_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerGrantSurveyPermission_Survey> {
        &mut self.surveys
    }
}

impl ::protobuf::Message for CMsgServerGrantSurveyPermission {
    fn is_initialized(&self) -> bool {
        for v in &self.surveys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.surveys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.surveys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.surveys {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerGrantSurveyPermission {
    fn new() -> CMsgServerGrantSurveyPermission {
        CMsgServerGrantSurveyPermission::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerGrantSurveyPermission>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgServerGrantSurveyPermission_Survey>>(
                    "surveys",
                    CMsgServerGrantSurveyPermission::get_surveys_for_reflect,
                    CMsgServerGrantSurveyPermission::mut_surveys_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerGrantSurveyPermission>(
                    "CMsgServerGrantSurveyPermission",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerGrantSurveyPermission {
    fn clear(&mut self) {
        self.clear_surveys();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerGrantSurveyPermission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerGrantSurveyPermission {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerGrantSurveyPermission_Survey {
    // message fields
    account_id: ::std::option::Option<u32>,
    question_id: ::std::option::Option<u32>,
    expire_time: ::std::option::Option<u32>,
    survey_key: ::std::option::Option<u64>,
    extra_data: ::std::option::Option<u64>,
    extra_data_32: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerGrantSurveyPermission_Survey {}

impl CMsgServerGrantSurveyPermission_Survey {
    pub fn new() -> CMsgServerGrantSurveyPermission_Survey {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerGrantSurveyPermission_Survey {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerGrantSurveyPermission_Survey> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerGrantSurveyPermission_Survey,
        };
        unsafe {
            instance.get(CMsgServerGrantSurveyPermission_Survey::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 question_id = 2;

    pub fn clear_question_id(&mut self) {
        self.question_id = ::std::option::Option::None;
    }

    pub fn has_question_id(&self) -> bool {
        self.question_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question_id(&mut self, v: u32) {
        self.question_id = ::std::option::Option::Some(v);
    }

    pub fn get_question_id(&self) -> u32 {
        self.question_id.unwrap_or(0)
    }

    fn get_question_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.question_id
    }

    fn mut_question_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.question_id
    }

    // optional uint32 expire_time = 3;

    pub fn clear_expire_time(&mut self) {
        self.expire_time = ::std::option::Option::None;
    }

    pub fn has_expire_time(&self) -> bool {
        self.expire_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expire_time(&mut self, v: u32) {
        self.expire_time = ::std::option::Option::Some(v);
    }

    pub fn get_expire_time(&self) -> u32 {
        self.expire_time.unwrap_or(0)
    }

    fn get_expire_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.expire_time
    }

    fn mut_expire_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.expire_time
    }

    // optional uint64 survey_key = 4;

    pub fn clear_survey_key(&mut self) {
        self.survey_key = ::std::option::Option::None;
    }

    pub fn has_survey_key(&self) -> bool {
        self.survey_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_key(&mut self, v: u64) {
        self.survey_key = ::std::option::Option::Some(v);
    }

    pub fn get_survey_key(&self) -> u64 {
        self.survey_key.unwrap_or(0)
    }

    fn get_survey_key_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.survey_key
    }

    fn mut_survey_key_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.survey_key
    }

    // optional uint64 extra_data = 5;

    pub fn clear_extra_data(&mut self) {
        self.extra_data = ::std::option::Option::None;
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: u64) {
        self.extra_data = ::std::option::Option::Some(v);
    }

    pub fn get_extra_data(&self) -> u64 {
        self.extra_data.unwrap_or(0)
    }

    fn get_extra_data_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.extra_data
    }

    // optional uint64 extra_data_32 = 6;

    pub fn clear_extra_data_32(&mut self) {
        self.extra_data_32 = ::std::option::Option::None;
    }

    pub fn has_extra_data_32(&self) -> bool {
        self.extra_data_32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data_32(&mut self, v: u64) {
        self.extra_data_32 = ::std::option::Option::Some(v);
    }

    pub fn get_extra_data_32(&self) -> u64 {
        self.extra_data_32.unwrap_or(0)
    }

    fn get_extra_data_32_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.extra_data_32
    }

    fn mut_extra_data_32_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.extra_data_32
    }
}

impl ::protobuf::Message for CMsgServerGrantSurveyPermission_Survey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.question_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expire_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.survey_key = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.extra_data = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.extra_data_32 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.question_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expire_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.survey_key {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.extra_data {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.extra_data_32 {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.question_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.expire_time {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.survey_key {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.extra_data {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.extra_data_32 {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerGrantSurveyPermission_Survey {
    fn new() -> CMsgServerGrantSurveyPermission_Survey {
        CMsgServerGrantSurveyPermission_Survey::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerGrantSurveyPermission_Survey>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgServerGrantSurveyPermission_Survey::get_account_id_for_reflect,
                    CMsgServerGrantSurveyPermission_Survey::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "question_id",
                    CMsgServerGrantSurveyPermission_Survey::get_question_id_for_reflect,
                    CMsgServerGrantSurveyPermission_Survey::mut_question_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "expire_time",
                    CMsgServerGrantSurveyPermission_Survey::get_expire_time_for_reflect,
                    CMsgServerGrantSurveyPermission_Survey::mut_expire_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "survey_key",
                    CMsgServerGrantSurveyPermission_Survey::get_survey_key_for_reflect,
                    CMsgServerGrantSurveyPermission_Survey::mut_survey_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "extra_data",
                    CMsgServerGrantSurveyPermission_Survey::get_extra_data_for_reflect,
                    CMsgServerGrantSurveyPermission_Survey::mut_extra_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "extra_data_32",
                    CMsgServerGrantSurveyPermission_Survey::get_extra_data_32_for_reflect,
                    CMsgServerGrantSurveyPermission_Survey::mut_extra_data_32_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerGrantSurveyPermission_Survey>(
                    "CMsgServerGrantSurveyPermission_Survey",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerGrantSurveyPermission_Survey {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_question_id();
        self.clear_expire_time();
        self.clear_survey_key();
        self.clear_extra_data();
        self.clear_extra_data_32();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerGrantSurveyPermission_Survey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerGrantSurveyPermission_Survey {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerGrantSurveyPermissionResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerGrantSurveyPermissionResponse {}

impl CMsgServerGrantSurveyPermissionResponse {
    pub fn new() -> CMsgServerGrantSurveyPermissionResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerGrantSurveyPermissionResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerGrantSurveyPermissionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerGrantSurveyPermissionResponse,
        };
        unsafe {
            instance.get(CMsgServerGrantSurveyPermissionResponse::new)
        }
    }

    // optional uint32 result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgServerGrantSurveyPermissionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerGrantSurveyPermissionResponse {
    fn new() -> CMsgServerGrantSurveyPermissionResponse {
        CMsgServerGrantSurveyPermissionResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerGrantSurveyPermissionResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "result",
                    CMsgServerGrantSurveyPermissionResponse::get_result_for_reflect,
                    CMsgServerGrantSurveyPermissionResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerGrantSurveyPermissionResponse>(
                    "CMsgServerGrantSurveyPermissionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerGrantSurveyPermissionResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerGrantSurveyPermissionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerGrantSurveyPermissionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCMatchConnectionStats {
    // message fields
    match_id: ::std::option::Option<u64>,
    region_id: ::std::option::Option<u32>,
    league_id: ::std::option::Option<u32>,
    players: ::protobuf::RepeatedField<CMsgServerToGCMatchConnectionStats_Player>,
    cluster_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCMatchConnectionStats {}

impl CMsgServerToGCMatchConnectionStats {
    pub fn new() -> CMsgServerToGCMatchConnectionStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCMatchConnectionStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCMatchConnectionStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCMatchConnectionStats,
        };
        unsafe {
            instance.get(CMsgServerToGCMatchConnectionStats::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 region_id = 2;

    pub fn clear_region_id(&mut self) {
        self.region_id = ::std::option::Option::None;
    }

    pub fn has_region_id(&self) -> bool {
        self.region_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_id(&mut self, v: u32) {
        self.region_id = ::std::option::Option::Some(v);
    }

    pub fn get_region_id(&self) -> u32 {
        self.region_id.unwrap_or(0)
    }

    fn get_region_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.region_id
    }

    fn mut_region_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.region_id
    }

    // optional uint32 league_id = 3;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // repeated .CMsgServerToGCMatchConnectionStats.Player players = 4;

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgServerToGCMatchConnectionStats_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCMatchConnectionStats_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgServerToGCMatchConnectionStats_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    pub fn get_players(&self) -> &[CMsgServerToGCMatchConnectionStats_Player] {
        &self.players
    }

    fn get_players_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgServerToGCMatchConnectionStats_Player> {
        &self.players
    }

    fn mut_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCMatchConnectionStats_Player> {
        &mut self.players
    }

    // optional uint32 cluster_id = 5;

    pub fn clear_cluster_id(&mut self) {
        self.cluster_id = ::std::option::Option::None;
    }

    pub fn has_cluster_id(&self) -> bool {
        self.cluster_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: u32) {
        self.cluster_id = ::std::option::Option::Some(v);
    }

    pub fn get_cluster_id(&self) -> u32 {
        self.cluster_id.unwrap_or(0)
    }

    fn get_cluster_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cluster_id
    }

    fn mut_cluster_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cluster_id
    }
}

impl ::protobuf::Message for CMsgServerToGCMatchConnectionStats {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.region_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cluster_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.region_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.cluster_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.region_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(3, v)?;
        }
        for v in &self.players {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.cluster_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCMatchConnectionStats {
    fn new() -> CMsgServerToGCMatchConnectionStats {
        CMsgServerToGCMatchConnectionStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCMatchConnectionStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgServerToGCMatchConnectionStats::get_match_id_for_reflect,
                    CMsgServerToGCMatchConnectionStats::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "region_id",
                    CMsgServerToGCMatchConnectionStats::get_region_id_for_reflect,
                    CMsgServerToGCMatchConnectionStats::mut_region_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgServerToGCMatchConnectionStats::get_league_id_for_reflect,
                    CMsgServerToGCMatchConnectionStats::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgServerToGCMatchConnectionStats_Player>>(
                    "players",
                    CMsgServerToGCMatchConnectionStats::get_players_for_reflect,
                    CMsgServerToGCMatchConnectionStats::mut_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cluster_id",
                    CMsgServerToGCMatchConnectionStats::get_cluster_id_for_reflect,
                    CMsgServerToGCMatchConnectionStats::mut_cluster_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCMatchConnectionStats>(
                    "CMsgServerToGCMatchConnectionStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCMatchConnectionStats {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_region_id();
        self.clear_league_id();
        self.clear_players();
        self.clear_cluster_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCMatchConnectionStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCMatchConnectionStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCMatchConnectionStats_Player {
    // message fields
    account_id: ::std::option::Option<u32>,
    ip: ::std::option::Option<u32>,
    avg_ping_ms: ::std::option::Option<u32>,
    packet_loss: ::std::option::Option<f32>,
    ping_deviation: ::std::option::Option<f32>,
    full_resends: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCMatchConnectionStats_Player {}

impl CMsgServerToGCMatchConnectionStats_Player {
    pub fn new() -> CMsgServerToGCMatchConnectionStats_Player {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCMatchConnectionStats_Player {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCMatchConnectionStats_Player> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCMatchConnectionStats_Player,
        };
        unsafe {
            instance.get(CMsgServerToGCMatchConnectionStats_Player::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional fixed32 ip = 2;

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    pub fn get_ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    fn get_ip_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ip
    }

    fn mut_ip_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ip
    }

    // optional uint32 avg_ping_ms = 3;

    pub fn clear_avg_ping_ms(&mut self) {
        self.avg_ping_ms = ::std::option::Option::None;
    }

    pub fn has_avg_ping_ms(&self) -> bool {
        self.avg_ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_ping_ms(&mut self, v: u32) {
        self.avg_ping_ms = ::std::option::Option::Some(v);
    }

    pub fn get_avg_ping_ms(&self) -> u32 {
        self.avg_ping_ms.unwrap_or(0)
    }

    fn get_avg_ping_ms_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.avg_ping_ms
    }

    fn mut_avg_ping_ms_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.avg_ping_ms
    }

    // optional float packet_loss = 5;

    pub fn clear_packet_loss(&mut self) {
        self.packet_loss = ::std::option::Option::None;
    }

    pub fn has_packet_loss(&self) -> bool {
        self.packet_loss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_loss(&mut self, v: f32) {
        self.packet_loss = ::std::option::Option::Some(v);
    }

    pub fn get_packet_loss(&self) -> f32 {
        self.packet_loss.unwrap_or(0.)
    }

    fn get_packet_loss_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.packet_loss
    }

    fn mut_packet_loss_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.packet_loss
    }

    // optional float ping_deviation = 6;

    pub fn clear_ping_deviation(&mut self) {
        self.ping_deviation = ::std::option::Option::None;
    }

    pub fn has_ping_deviation(&self) -> bool {
        self.ping_deviation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_deviation(&mut self, v: f32) {
        self.ping_deviation = ::std::option::Option::Some(v);
    }

    pub fn get_ping_deviation(&self) -> f32 {
        self.ping_deviation.unwrap_or(0.)
    }

    fn get_ping_deviation_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.ping_deviation
    }

    fn mut_ping_deviation_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.ping_deviation
    }

    // optional uint32 full_resends = 7;

    pub fn clear_full_resends(&mut self) {
        self.full_resends = ::std::option::Option::None;
    }

    pub fn has_full_resends(&self) -> bool {
        self.full_resends.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_resends(&mut self, v: u32) {
        self.full_resends = ::std::option::Option::Some(v);
    }

    pub fn get_full_resends(&self) -> u32 {
        self.full_resends.unwrap_or(0)
    }

    fn get_full_resends_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.full_resends
    }

    fn mut_full_resends_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.full_resends
    }
}

impl ::protobuf::Message for CMsgServerToGCMatchConnectionStats_Player {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.avg_ping_ms = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.packet_loss = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ping_deviation = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.full_resends = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ip {
            my_size += 5;
        }
        if let Some(v) = self.avg_ping_ms {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packet_loss {
            my_size += 5;
        }
        if let Some(v) = self.ping_deviation {
            my_size += 5;
        }
        if let Some(v) = self.full_resends {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ip {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.avg_ping_ms {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.packet_loss {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.ping_deviation {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.full_resends {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCMatchConnectionStats_Player {
    fn new() -> CMsgServerToGCMatchConnectionStats_Player {
        CMsgServerToGCMatchConnectionStats_Player::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCMatchConnectionStats_Player>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgServerToGCMatchConnectionStats_Player::get_account_id_for_reflect,
                    CMsgServerToGCMatchConnectionStats_Player::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "ip",
                    CMsgServerToGCMatchConnectionStats_Player::get_ip_for_reflect,
                    CMsgServerToGCMatchConnectionStats_Player::mut_ip_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "avg_ping_ms",
                    CMsgServerToGCMatchConnectionStats_Player::get_avg_ping_ms_for_reflect,
                    CMsgServerToGCMatchConnectionStats_Player::mut_avg_ping_ms_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "packet_loss",
                    CMsgServerToGCMatchConnectionStats_Player::get_packet_loss_for_reflect,
                    CMsgServerToGCMatchConnectionStats_Player::mut_packet_loss_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "ping_deviation",
                    CMsgServerToGCMatchConnectionStats_Player::get_ping_deviation_for_reflect,
                    CMsgServerToGCMatchConnectionStats_Player::mut_ping_deviation_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "full_resends",
                    CMsgServerToGCMatchConnectionStats_Player::get_full_resends_for_reflect,
                    CMsgServerToGCMatchConnectionStats_Player::mut_full_resends_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCMatchConnectionStats_Player>(
                    "CMsgServerToGCMatchConnectionStats_Player",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCMatchConnectionStats_Player {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_ip();
        self.clear_avg_ping_ms();
        self.clear_packet_loss();
        self.clear_ping_deviation();
        self.clear_full_resends();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCMatchConnectionStats_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCMatchConnectionStats_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerGCUpdateSpectatorCount {
    // message fields
    spectator_count: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerGCUpdateSpectatorCount {}

impl CMsgServerGCUpdateSpectatorCount {
    pub fn new() -> CMsgServerGCUpdateSpectatorCount {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerGCUpdateSpectatorCount {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerGCUpdateSpectatorCount> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerGCUpdateSpectatorCount,
        };
        unsafe {
            instance.get(CMsgServerGCUpdateSpectatorCount::new)
        }
    }

    // optional uint32 spectator_count = 1;

    pub fn clear_spectator_count(&mut self) {
        self.spectator_count = ::std::option::Option::None;
    }

    pub fn has_spectator_count(&self) -> bool {
        self.spectator_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectator_count(&mut self, v: u32) {
        self.spectator_count = ::std::option::Option::Some(v);
    }

    pub fn get_spectator_count(&self) -> u32 {
        self.spectator_count.unwrap_or(0)
    }

    fn get_spectator_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.spectator_count
    }

    fn mut_spectator_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.spectator_count
    }
}

impl ::protobuf::Message for CMsgServerGCUpdateSpectatorCount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.spectator_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.spectator_count {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.spectator_count {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerGCUpdateSpectatorCount {
    fn new() -> CMsgServerGCUpdateSpectatorCount {
        CMsgServerGCUpdateSpectatorCount::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerGCUpdateSpectatorCount>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "spectator_count",
                    CMsgServerGCUpdateSpectatorCount::get_spectator_count_for_reflect,
                    CMsgServerGCUpdateSpectatorCount::mut_spectator_count_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerGCUpdateSpectatorCount>(
                    "CMsgServerGCUpdateSpectatorCount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerGCUpdateSpectatorCount {
    fn clear(&mut self) {
        self.clear_spectator_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerGCUpdateSpectatorCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerGCUpdateSpectatorCount {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSerializedCombatLog {
    // message fields
    version: ::std::option::Option<u32>,
    dictionary: ::protobuf::SingularPtrField<CSerializedCombatLog_Dictionary>,
    entries: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTACombatLogEntry>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSerializedCombatLog {}

impl CSerializedCombatLog {
    pub fn new() -> CSerializedCombatLog {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSerializedCombatLog {
        static mut instance: ::protobuf::lazy::Lazy<CSerializedCombatLog> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSerializedCombatLog,
        };
        unsafe {
            instance.get(CSerializedCombatLog::new)
        }
    }

    // optional uint32 version = 1;

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    fn get_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.version
    }

    fn mut_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.version
    }

    // optional .CSerializedCombatLog.Dictionary dictionary = 2;

    pub fn clear_dictionary(&mut self) {
        self.dictionary.clear();
    }

    pub fn has_dictionary(&self) -> bool {
        self.dictionary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dictionary(&mut self, v: CSerializedCombatLog_Dictionary) {
        self.dictionary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dictionary(&mut self) -> &mut CSerializedCombatLog_Dictionary {
        if self.dictionary.is_none() {
            self.dictionary.set_default();
        }
        self.dictionary.as_mut().unwrap()
    }

    // Take field
    pub fn take_dictionary(&mut self) -> CSerializedCombatLog_Dictionary {
        self.dictionary.take().unwrap_or_else(|| CSerializedCombatLog_Dictionary::new())
    }

    pub fn get_dictionary(&self) -> &CSerializedCombatLog_Dictionary {
        self.dictionary.as_ref().unwrap_or_else(|| CSerializedCombatLog_Dictionary::default_instance())
    }

    fn get_dictionary_for_reflect(&self) -> &::protobuf::SingularPtrField<CSerializedCombatLog_Dictionary> {
        &self.dictionary
    }

    fn mut_dictionary_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CSerializedCombatLog_Dictionary> {
        &mut self.dictionary
    }

    // repeated .CMsgDOTACombatLogEntry entries = 3;

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTACombatLogEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTACombatLogEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTACombatLogEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }

    pub fn get_entries(&self) -> &[super::dota_gcmessages_common::CMsgDOTACombatLogEntry] {
        &self.entries
    }

    fn get_entries_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTACombatLogEntry> {
        &self.entries
    }

    fn mut_entries_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTACombatLogEntry> {
        &mut self.entries
    }
}

impl ::protobuf::Message for CSerializedCombatLog {
    fn is_initialized(&self) -> bool {
        for v in &self.dictionary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dictionary)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dictionary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.dictionary.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.entries {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSerializedCombatLog {
    fn new() -> CSerializedCombatLog {
        CSerializedCombatLog::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSerializedCombatLog>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    CSerializedCombatLog::get_version_for_reflect,
                    CSerializedCombatLog::mut_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSerializedCombatLog_Dictionary>>(
                    "dictionary",
                    CSerializedCombatLog::get_dictionary_for_reflect,
                    CSerializedCombatLog::mut_dictionary_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMsgDOTACombatLogEntry>>(
                    "entries",
                    CSerializedCombatLog::get_entries_for_reflect,
                    CSerializedCombatLog::mut_entries_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSerializedCombatLog>(
                    "CSerializedCombatLog",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSerializedCombatLog {
    fn clear(&mut self) {
        self.clear_version();
        self.clear_dictionary();
        self.clear_entries();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSerializedCombatLog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSerializedCombatLog {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSerializedCombatLog_Dictionary {
    // message fields
    strings: ::protobuf::RepeatedField<CSerializedCombatLog_Dictionary_DictString>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSerializedCombatLog_Dictionary {}

impl CSerializedCombatLog_Dictionary {
    pub fn new() -> CSerializedCombatLog_Dictionary {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSerializedCombatLog_Dictionary {
        static mut instance: ::protobuf::lazy::Lazy<CSerializedCombatLog_Dictionary> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSerializedCombatLog_Dictionary,
        };
        unsafe {
            instance.get(CSerializedCombatLog_Dictionary::new)
        }
    }

    // repeated .CSerializedCombatLog.Dictionary.DictString strings = 1;

    pub fn clear_strings(&mut self) {
        self.strings.clear();
    }

    // Param is passed by value, moved
    pub fn set_strings(&mut self, v: ::protobuf::RepeatedField<CSerializedCombatLog_Dictionary_DictString>) {
        self.strings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_strings(&mut self) -> &mut ::protobuf::RepeatedField<CSerializedCombatLog_Dictionary_DictString> {
        &mut self.strings
    }

    // Take field
    pub fn take_strings(&mut self) -> ::protobuf::RepeatedField<CSerializedCombatLog_Dictionary_DictString> {
        ::std::mem::replace(&mut self.strings, ::protobuf::RepeatedField::new())
    }

    pub fn get_strings(&self) -> &[CSerializedCombatLog_Dictionary_DictString] {
        &self.strings
    }

    fn get_strings_for_reflect(&self) -> &::protobuf::RepeatedField<CSerializedCombatLog_Dictionary_DictString> {
        &self.strings
    }

    fn mut_strings_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CSerializedCombatLog_Dictionary_DictString> {
        &mut self.strings
    }
}

impl ::protobuf::Message for CSerializedCombatLog_Dictionary {
    fn is_initialized(&self) -> bool {
        for v in &self.strings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.strings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.strings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.strings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSerializedCombatLog_Dictionary {
    fn new() -> CSerializedCombatLog_Dictionary {
        CSerializedCombatLog_Dictionary::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSerializedCombatLog_Dictionary>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSerializedCombatLog_Dictionary_DictString>>(
                    "strings",
                    CSerializedCombatLog_Dictionary::get_strings_for_reflect,
                    CSerializedCombatLog_Dictionary::mut_strings_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSerializedCombatLog_Dictionary>(
                    "CSerializedCombatLog_Dictionary",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSerializedCombatLog_Dictionary {
    fn clear(&mut self) {
        self.clear_strings();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSerializedCombatLog_Dictionary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSerializedCombatLog_Dictionary {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSerializedCombatLog_Dictionary_DictString {
    // message fields
    id: ::std::option::Option<u32>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSerializedCombatLog_Dictionary_DictString {}

impl CSerializedCombatLog_Dictionary_DictString {
    pub fn new() -> CSerializedCombatLog_Dictionary_DictString {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSerializedCombatLog_Dictionary_DictString {
        static mut instance: ::protobuf::lazy::Lazy<CSerializedCombatLog_Dictionary_DictString> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSerializedCombatLog_Dictionary_DictString,
        };
        unsafe {
            instance.get(CSerializedCombatLog_Dictionary_DictString::new)
        }
    }

    // required uint32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.id
    }

    // required string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for CSerializedCombatLog_Dictionary_DictString {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSerializedCombatLog_Dictionary_DictString {
    fn new() -> CSerializedCombatLog_Dictionary_DictString {
        CSerializedCombatLog_Dictionary_DictString::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSerializedCombatLog_Dictionary_DictString>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    CSerializedCombatLog_Dictionary_DictString::get_id_for_reflect,
                    CSerializedCombatLog_Dictionary_DictString::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    CSerializedCombatLog_Dictionary_DictString::get_value_for_reflect,
                    CSerializedCombatLog_Dictionary_DictString::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSerializedCombatLog_Dictionary_DictString>(
                    "CSerializedCombatLog_Dictionary_DictString",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSerializedCombatLog_Dictionary_DictString {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSerializedCombatLog_Dictionary_DictString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSerializedCombatLog_Dictionary_DictString {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCGetAdditionalEquips {
    // message fields
    account_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCGetAdditionalEquips {}

impl CMsgServerToGCGetAdditionalEquips {
    pub fn new() -> CMsgServerToGCGetAdditionalEquips {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCGetAdditionalEquips {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCGetAdditionalEquips> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCGetAdditionalEquips,
        };
        unsafe {
            instance.get(CMsgServerToGCGetAdditionalEquips::new)
        }
    }

    // repeated uint32 account_ids = 1;

    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }

    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }

    fn get_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.account_ids
    }

    fn mut_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }
}

impl ::protobuf::Message for CMsgServerToGCGetAdditionalEquips {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCGetAdditionalEquips {
    fn new() -> CMsgServerToGCGetAdditionalEquips {
        CMsgServerToGCGetAdditionalEquips::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCGetAdditionalEquips>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids",
                    CMsgServerToGCGetAdditionalEquips::get_account_ids_for_reflect,
                    CMsgServerToGCGetAdditionalEquips::mut_account_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCGetAdditionalEquips>(
                    "CMsgServerToGCGetAdditionalEquips",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCGetAdditionalEquips {
    fn clear(&mut self) {
        self.clear_account_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCGetAdditionalEquips {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCGetAdditionalEquips {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCGetAdditionalEquipsResponse {
    // message fields
    equips: ::protobuf::RepeatedField<CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCGetAdditionalEquipsResponse {}

impl CMsgServerToGCGetAdditionalEquipsResponse {
    pub fn new() -> CMsgServerToGCGetAdditionalEquipsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCGetAdditionalEquipsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCGetAdditionalEquipsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCGetAdditionalEquipsResponse,
        };
        unsafe {
            instance.get(CMsgServerToGCGetAdditionalEquipsResponse::new)
        }
    }

    // repeated .CMsgServerToGCGetAdditionalEquipsResponse.CUserEquips equips = 1;

    pub fn clear_equips(&mut self) {
        self.equips.clear();
    }

    // Param is passed by value, moved
    pub fn set_equips(&mut self, v: ::protobuf::RepeatedField<CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips>) {
        self.equips = v;
    }

    // Mutable pointer to the field.
    pub fn mut_equips(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips> {
        &mut self.equips
    }

    // Take field
    pub fn take_equips(&mut self) -> ::protobuf::RepeatedField<CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips> {
        ::std::mem::replace(&mut self.equips, ::protobuf::RepeatedField::new())
    }

    pub fn get_equips(&self) -> &[CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips] {
        &self.equips
    }

    fn get_equips_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips> {
        &self.equips
    }

    fn mut_equips_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips> {
        &mut self.equips
    }
}

impl ::protobuf::Message for CMsgServerToGCGetAdditionalEquipsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.equips {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.equips)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.equips {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.equips {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCGetAdditionalEquipsResponse {
    fn new() -> CMsgServerToGCGetAdditionalEquipsResponse {
        CMsgServerToGCGetAdditionalEquipsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCGetAdditionalEquipsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips>>(
                    "equips",
                    CMsgServerToGCGetAdditionalEquipsResponse::get_equips_for_reflect,
                    CMsgServerToGCGetAdditionalEquipsResponse::mut_equips_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCGetAdditionalEquipsResponse>(
                    "CMsgServerToGCGetAdditionalEquipsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCGetAdditionalEquipsResponse {
    fn clear(&mut self) {
        self.clear_equips();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCGetAdditionalEquipsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCGetAdditionalEquipsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips {
    // message fields
    account_id: ::std::option::Option<u32>,
    equips: ::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips {}

impl CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips {
    pub fn new() -> CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips,
        };
        unsafe {
            instance.get(CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // repeated .CAdditionalEquipSlot equips = 2;

    pub fn clear_equips(&mut self) {
        self.equips.clear();
    }

    // Param is passed by value, moved
    pub fn set_equips(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot>) {
        self.equips = v;
    }

    // Mutable pointer to the field.
    pub fn mut_equips(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot> {
        &mut self.equips
    }

    // Take field
    pub fn take_equips(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot> {
        ::std::mem::replace(&mut self.equips, ::protobuf::RepeatedField::new())
    }

    pub fn get_equips(&self) -> &[super::dota_gcmessages_common::CAdditionalEquipSlot] {
        &self.equips
    }

    fn get_equips_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot> {
        &self.equips
    }

    fn mut_equips_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot> {
        &mut self.equips
    }
}

impl ::protobuf::Message for CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips {
    fn is_initialized(&self) -> bool {
        for v in &self.equips {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.equips)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.equips {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.equips {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips {
    fn new() -> CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips {
        CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips::get_account_id_for_reflect,
                    CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CAdditionalEquipSlot>>(
                    "equips",
                    CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips::get_equips_for_reflect,
                    CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips::mut_equips_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips>(
                    "CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_equips();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCGetAdditionalEquipsResponse_CUserEquips {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCGetProfileCard {
    // message fields
    account_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCGetProfileCard {}

impl CMsgServerToGCGetProfileCard {
    pub fn new() -> CMsgServerToGCGetProfileCard {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCGetProfileCard {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCGetProfileCard> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCGetProfileCard,
        };
        unsafe {
            instance.get(CMsgServerToGCGetProfileCard::new)
        }
    }

    // repeated uint32 account_ids = 1;

    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }

    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }

    fn get_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.account_ids
    }

    fn mut_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }
}

impl ::protobuf::Message for CMsgServerToGCGetProfileCard {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCGetProfileCard {
    fn new() -> CMsgServerToGCGetProfileCard {
        CMsgServerToGCGetProfileCard::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCGetProfileCard>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids",
                    CMsgServerToGCGetProfileCard::get_account_ids_for_reflect,
                    CMsgServerToGCGetProfileCard::mut_account_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCGetProfileCard>(
                    "CMsgServerToGCGetProfileCard",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCGetProfileCard {
    fn clear(&mut self) {
        self.clear_account_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCGetProfileCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCGetProfileCard {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCGetProfileCardResponse {
    // message fields
    cards: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAProfileCard>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCGetProfileCardResponse {}

impl CMsgServerToGCGetProfileCardResponse {
    pub fn new() -> CMsgServerToGCGetProfileCardResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCGetProfileCardResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCGetProfileCardResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCGetProfileCardResponse,
        };
        unsafe {
            instance.get(CMsgServerToGCGetProfileCardResponse::new)
        }
    }

    // repeated .CMsgDOTAProfileCard cards = 1;

    pub fn clear_cards(&mut self) {
        self.cards.clear();
    }

    // Param is passed by value, moved
    pub fn set_cards(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAProfileCard>) {
        self.cards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cards(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAProfileCard> {
        &mut self.cards
    }

    // Take field
    pub fn take_cards(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAProfileCard> {
        ::std::mem::replace(&mut self.cards, ::protobuf::RepeatedField::new())
    }

    pub fn get_cards(&self) -> &[super::dota_gcmessages_common::CMsgDOTAProfileCard] {
        &self.cards
    }

    fn get_cards_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAProfileCard> {
        &self.cards
    }

    fn mut_cards_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAProfileCard> {
        &mut self.cards
    }
}

impl ::protobuf::Message for CMsgServerToGCGetProfileCardResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.cards {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cards)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.cards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.cards {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCGetProfileCardResponse {
    fn new() -> CMsgServerToGCGetProfileCardResponse {
        CMsgServerToGCGetProfileCardResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCGetProfileCardResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMsgDOTAProfileCard>>(
                    "cards",
                    CMsgServerToGCGetProfileCardResponse::get_cards_for_reflect,
                    CMsgServerToGCGetProfileCardResponse::mut_cards_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCGetProfileCardResponse>(
                    "CMsgServerToGCGetProfileCardResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCGetProfileCardResponse {
    fn clear(&mut self) {
        self.clear_cards();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCGetProfileCardResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCGetProfileCardResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCVictoryPredictions {
    // message fields
    records: ::protobuf::RepeatedField<CMsgServerToGCVictoryPredictions_Record>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCVictoryPredictions {}

impl CMsgServerToGCVictoryPredictions {
    pub fn new() -> CMsgServerToGCVictoryPredictions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCVictoryPredictions {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCVictoryPredictions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCVictoryPredictions,
        };
        unsafe {
            instance.get(CMsgServerToGCVictoryPredictions::new)
        }
    }

    // repeated .CMsgServerToGCVictoryPredictions.Record records = 1;

    pub fn clear_records(&mut self) {
        self.records.clear();
    }

    // Param is passed by value, moved
    pub fn set_records(&mut self, v: ::protobuf::RepeatedField<CMsgServerToGCVictoryPredictions_Record>) {
        self.records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_records(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCVictoryPredictions_Record> {
        &mut self.records
    }

    // Take field
    pub fn take_records(&mut self) -> ::protobuf::RepeatedField<CMsgServerToGCVictoryPredictions_Record> {
        ::std::mem::replace(&mut self.records, ::protobuf::RepeatedField::new())
    }

    pub fn get_records(&self) -> &[CMsgServerToGCVictoryPredictions_Record] {
        &self.records
    }

    fn get_records_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgServerToGCVictoryPredictions_Record> {
        &self.records
    }

    fn mut_records_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCVictoryPredictions_Record> {
        &mut self.records
    }
}

impl ::protobuf::Message for CMsgServerToGCVictoryPredictions {
    fn is_initialized(&self) -> bool {
        for v in &self.records {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.records)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.records {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.records {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCVictoryPredictions {
    fn new() -> CMsgServerToGCVictoryPredictions {
        CMsgServerToGCVictoryPredictions::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCVictoryPredictions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgServerToGCVictoryPredictions_Record>>(
                    "records",
                    CMsgServerToGCVictoryPredictions::get_records_for_reflect,
                    CMsgServerToGCVictoryPredictions::mut_records_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCVictoryPredictions>(
                    "CMsgServerToGCVictoryPredictions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCVictoryPredictions {
    fn clear(&mut self) {
        self.clear_records();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCVictoryPredictions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCVictoryPredictions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCVictoryPredictions_Record {
    // message fields
    account_id: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u64>,
    item_ids: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCVictoryPredictions_Record {}

impl CMsgServerToGCVictoryPredictions_Record {
    pub fn new() -> CMsgServerToGCVictoryPredictions_Record {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCVictoryPredictions_Record {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCVictoryPredictions_Record> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCVictoryPredictions_Record,
        };
        unsafe {
            instance.get(CMsgServerToGCVictoryPredictions_Record::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint64 item_id = 2;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }

    // repeated uint64 item_ids = 5;

    pub fn clear_item_ids(&mut self) {
        self.item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }

    // Take field
    pub fn take_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.item_ids, ::std::vec::Vec::new())
    }

    pub fn get_item_ids(&self) -> &[u64] {
        &self.item_ids
    }

    fn get_item_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.item_ids
    }

    fn mut_item_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }
}

impl ::protobuf::Message for CMsgServerToGCVictoryPredictions_Record {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.item_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.item_ids {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.item_ids {
            os.write_uint64(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCVictoryPredictions_Record {
    fn new() -> CMsgServerToGCVictoryPredictions_Record {
        CMsgServerToGCVictoryPredictions_Record::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCVictoryPredictions_Record>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgServerToGCVictoryPredictions_Record::get_account_id_for_reflect,
                    CMsgServerToGCVictoryPredictions_Record::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgServerToGCVictoryPredictions_Record::get_item_id_for_reflect,
                    CMsgServerToGCVictoryPredictions_Record::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_ids",
                    CMsgServerToGCVictoryPredictions_Record::get_item_ids_for_reflect,
                    CMsgServerToGCVictoryPredictions_Record::mut_item_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCVictoryPredictions_Record>(
                    "CMsgServerToGCVictoryPredictions_Record",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCVictoryPredictions_Record {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_item_id();
        self.clear_item_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCVictoryPredictions_Record {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCVictoryPredictions_Record {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSuspiciousActivity {
    // message fields
    account_id: ::std::option::Option<u32>,
    activity: ::std::option::Option<ESuspiciousActivity>,
    intdata1: ::std::option::Option<i32>,
    intdata2: ::std::option::Option<i32>,
    time: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSuspiciousActivity {}

impl CMsgSuspiciousActivity {
    pub fn new() -> CMsgSuspiciousActivity {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSuspiciousActivity {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSuspiciousActivity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSuspiciousActivity,
        };
        unsafe {
            instance.get(CMsgSuspiciousActivity::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional .ESuspiciousActivity activity = 2;

    pub fn clear_activity(&mut self) {
        self.activity = ::std::option::Option::None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: ESuspiciousActivity) {
        self.activity = ::std::option::Option::Some(v);
    }

    pub fn get_activity(&self) -> ESuspiciousActivity {
        self.activity.unwrap_or(ESuspiciousActivity::k_ESuspiciousActivity_VAC_MultipleInstances)
    }

    fn get_activity_for_reflect(&self) -> &::std::option::Option<ESuspiciousActivity> {
        &self.activity
    }

    fn mut_activity_for_reflect(&mut self) -> &mut ::std::option::Option<ESuspiciousActivity> {
        &mut self.activity
    }

    // optional sint32 intdata1 = 3;

    pub fn clear_intdata1(&mut self) {
        self.intdata1 = ::std::option::Option::None;
    }

    pub fn has_intdata1(&self) -> bool {
        self.intdata1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_intdata1(&mut self, v: i32) {
        self.intdata1 = ::std::option::Option::Some(v);
    }

    pub fn get_intdata1(&self) -> i32 {
        self.intdata1.unwrap_or(0)
    }

    fn get_intdata1_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.intdata1
    }

    fn mut_intdata1_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.intdata1
    }

    // optional sint32 intdata2 = 4;

    pub fn clear_intdata2(&mut self) {
        self.intdata2 = ::std::option::Option::None;
    }

    pub fn has_intdata2(&self) -> bool {
        self.intdata2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_intdata2(&mut self, v: i32) {
        self.intdata2 = ::std::option::Option::Some(v);
    }

    pub fn get_intdata2(&self) -> i32 {
        self.intdata2.unwrap_or(0)
    }

    fn get_intdata2_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.intdata2
    }

    fn mut_intdata2_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.intdata2
    }

    // optional uint32 time = 5;

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: u32) {
        self.time = ::std::option::Option::Some(v);
    }

    pub fn get_time(&self) -> u32 {
        self.time.unwrap_or(0)
    }

    fn get_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time
    }

    fn mut_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time
    }
}

impl ::protobuf::Message for CMsgSuspiciousActivity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.activity = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.intdata1 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.intdata2 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.activity {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.intdata1 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        if let Some(v) = self.intdata2 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, v);
        }
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.activity {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.intdata1 {
            os.write_sint32(3, v)?;
        }
        if let Some(v) = self.intdata2 {
            os.write_sint32(4, v)?;
        }
        if let Some(v) = self.time {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSuspiciousActivity {
    fn new() -> CMsgSuspiciousActivity {
        CMsgSuspiciousActivity::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSuspiciousActivity>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgSuspiciousActivity::get_account_id_for_reflect,
                    CMsgSuspiciousActivity::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ESuspiciousActivity>>(
                    "activity",
                    CMsgSuspiciousActivity::get_activity_for_reflect,
                    CMsgSuspiciousActivity::mut_activity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "intdata1",
                    CMsgSuspiciousActivity::get_intdata1_for_reflect,
                    CMsgSuspiciousActivity::mut_intdata1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "intdata2",
                    CMsgSuspiciousActivity::get_intdata2_for_reflect,
                    CMsgSuspiciousActivity::mut_intdata2_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time",
                    CMsgSuspiciousActivity::get_time_for_reflect,
                    CMsgSuspiciousActivity::mut_time_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSuspiciousActivity>(
                    "CMsgSuspiciousActivity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSuspiciousActivity {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_activity();
        self.clear_intdata1();
        self.clear_intdata2();
        self.clear_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSuspiciousActivity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSuspiciousActivity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCRequestStatus {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCRequestStatus {}

impl CMsgServerToGCRequestStatus {
    pub fn new() -> CMsgServerToGCRequestStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCRequestStatus {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCRequestStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCRequestStatus,
        };
        unsafe {
            instance.get(CMsgServerToGCRequestStatus::new)
        }
    }
}

impl ::protobuf::Message for CMsgServerToGCRequestStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCRequestStatus {
    fn new() -> CMsgServerToGCRequestStatus {
        CMsgServerToGCRequestStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCRequestStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCRequestStatus>(
                    "CMsgServerToGCRequestStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCRequestStatus {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCRequestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCRequestStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCRequestStatus_Response {
    // message fields
    response: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCRequestStatus_Response {}

impl CMsgServerToGCRequestStatus_Response {
    pub fn new() -> CMsgServerToGCRequestStatus_Response {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCRequestStatus_Response {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCRequestStatus_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCRequestStatus_Response,
        };
        unsafe {
            instance.get(CMsgServerToGCRequestStatus_Response::new)
        }
    }

    // optional uint32 response = 1;

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: u32) {
        self.response = ::std::option::Option::Some(v);
    }

    pub fn get_response(&self) -> u32 {
        self.response.unwrap_or(0)
    }

    fn get_response_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.response
    }

    fn mut_response_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.response
    }
}

impl ::protobuf::Message for CMsgServerToGCRequestStatus_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.response = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.response {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCRequestStatus_Response {
    fn new() -> CMsgServerToGCRequestStatus_Response {
        CMsgServerToGCRequestStatus_Response::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCRequestStatus_Response>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "response",
                    CMsgServerToGCRequestStatus_Response::get_response_for_reflect,
                    CMsgServerToGCRequestStatus_Response::mut_response_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCRequestStatus_Response>(
                    "CMsgServerToGCRequestStatus_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCRequestStatus_Response {
    fn clear(&mut self) {
        self.clear_response();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCRequestStatus_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCRequestStatus_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSignOutAssassinMiniGameInfo {
    // message fields
    winning_players: ::std::vec::Vec<u64>,
    losing_players: ::std::vec::Vec<u64>,
    arcana_owners: ::std::vec::Vec<u64>,
    assassin_won: ::std::option::Option<bool>,
    target_hero_id: ::std::option::Option<u32>,
    contract_completed: ::std::option::Option<bool>,
    contract_complete_time: ::std::option::Option<f32>,
    pa_is_radiant: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSignOutAssassinMiniGameInfo {}

impl CMsgSignOutAssassinMiniGameInfo {
    pub fn new() -> CMsgSignOutAssassinMiniGameInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSignOutAssassinMiniGameInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSignOutAssassinMiniGameInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSignOutAssassinMiniGameInfo,
        };
        unsafe {
            instance.get(CMsgSignOutAssassinMiniGameInfo::new)
        }
    }

    // repeated fixed64 winning_players = 1;

    pub fn clear_winning_players(&mut self) {
        self.winning_players.clear();
    }

    // Param is passed by value, moved
    pub fn set_winning_players(&mut self, v: ::std::vec::Vec<u64>) {
        self.winning_players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_winning_players(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.winning_players
    }

    // Take field
    pub fn take_winning_players(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.winning_players, ::std::vec::Vec::new())
    }

    pub fn get_winning_players(&self) -> &[u64] {
        &self.winning_players
    }

    fn get_winning_players_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.winning_players
    }

    fn mut_winning_players_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.winning_players
    }

    // repeated fixed64 losing_players = 2;

    pub fn clear_losing_players(&mut self) {
        self.losing_players.clear();
    }

    // Param is passed by value, moved
    pub fn set_losing_players(&mut self, v: ::std::vec::Vec<u64>) {
        self.losing_players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_losing_players(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.losing_players
    }

    // Take field
    pub fn take_losing_players(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.losing_players, ::std::vec::Vec::new())
    }

    pub fn get_losing_players(&self) -> &[u64] {
        &self.losing_players
    }

    fn get_losing_players_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.losing_players
    }

    fn mut_losing_players_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.losing_players
    }

    // repeated fixed64 arcana_owners = 3;

    pub fn clear_arcana_owners(&mut self) {
        self.arcana_owners.clear();
    }

    // Param is passed by value, moved
    pub fn set_arcana_owners(&mut self, v: ::std::vec::Vec<u64>) {
        self.arcana_owners = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arcana_owners(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.arcana_owners
    }

    // Take field
    pub fn take_arcana_owners(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.arcana_owners, ::std::vec::Vec::new())
    }

    pub fn get_arcana_owners(&self) -> &[u64] {
        &self.arcana_owners
    }

    fn get_arcana_owners_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.arcana_owners
    }

    fn mut_arcana_owners_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.arcana_owners
    }

    // optional bool assassin_won = 4;

    pub fn clear_assassin_won(&mut self) {
        self.assassin_won = ::std::option::Option::None;
    }

    pub fn has_assassin_won(&self) -> bool {
        self.assassin_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assassin_won(&mut self, v: bool) {
        self.assassin_won = ::std::option::Option::Some(v);
    }

    pub fn get_assassin_won(&self) -> bool {
        self.assassin_won.unwrap_or(false)
    }

    fn get_assassin_won_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.assassin_won
    }

    fn mut_assassin_won_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.assassin_won
    }

    // optional uint32 target_hero_id = 5;

    pub fn clear_target_hero_id(&mut self) {
        self.target_hero_id = ::std::option::Option::None;
    }

    pub fn has_target_hero_id(&self) -> bool {
        self.target_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_hero_id(&mut self, v: u32) {
        self.target_hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_target_hero_id(&self) -> u32 {
        self.target_hero_id.unwrap_or(0)
    }

    fn get_target_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_hero_id
    }

    fn mut_target_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_hero_id
    }

    // optional bool contract_completed = 6;

    pub fn clear_contract_completed(&mut self) {
        self.contract_completed = ::std::option::Option::None;
    }

    pub fn has_contract_completed(&self) -> bool {
        self.contract_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_completed(&mut self, v: bool) {
        self.contract_completed = ::std::option::Option::Some(v);
    }

    pub fn get_contract_completed(&self) -> bool {
        self.contract_completed.unwrap_or(false)
    }

    fn get_contract_completed_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.contract_completed
    }

    fn mut_contract_completed_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.contract_completed
    }

    // optional float contract_complete_time = 7;

    pub fn clear_contract_complete_time(&mut self) {
        self.contract_complete_time = ::std::option::Option::None;
    }

    pub fn has_contract_complete_time(&self) -> bool {
        self.contract_complete_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_complete_time(&mut self, v: f32) {
        self.contract_complete_time = ::std::option::Option::Some(v);
    }

    pub fn get_contract_complete_time(&self) -> f32 {
        self.contract_complete_time.unwrap_or(0.)
    }

    fn get_contract_complete_time_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.contract_complete_time
    }

    fn mut_contract_complete_time_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.contract_complete_time
    }

    // optional bool pa_is_radiant = 8;

    pub fn clear_pa_is_radiant(&mut self) {
        self.pa_is_radiant = ::std::option::Option::None;
    }

    pub fn has_pa_is_radiant(&self) -> bool {
        self.pa_is_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pa_is_radiant(&mut self, v: bool) {
        self.pa_is_radiant = ::std::option::Option::Some(v);
    }

    pub fn get_pa_is_radiant(&self) -> bool {
        self.pa_is_radiant.unwrap_or(false)
    }

    fn get_pa_is_radiant_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.pa_is_radiant
    }

    fn mut_pa_is_radiant_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.pa_is_radiant
    }
}

impl ::protobuf::Message for CMsgSignOutAssassinMiniGameInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.winning_players)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.losing_players)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.arcana_owners)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.assassin_won = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_hero_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.contract_completed = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.contract_complete_time = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pa_is_radiant = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 9 * self.winning_players.len() as u32;
        my_size += 9 * self.losing_players.len() as u32;
        my_size += 9 * self.arcana_owners.len() as u32;
        if let Some(v) = self.assassin_won {
            my_size += 2;
        }
        if let Some(v) = self.target_hero_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.contract_completed {
            my_size += 2;
        }
        if let Some(v) = self.contract_complete_time {
            my_size += 5;
        }
        if let Some(v) = self.pa_is_radiant {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.winning_players {
            os.write_fixed64(1, *v)?;
        };
        for v in &self.losing_players {
            os.write_fixed64(2, *v)?;
        };
        for v in &self.arcana_owners {
            os.write_fixed64(3, *v)?;
        };
        if let Some(v) = self.assassin_won {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.target_hero_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.contract_completed {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.contract_complete_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.pa_is_radiant {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSignOutAssassinMiniGameInfo {
    fn new() -> CMsgSignOutAssassinMiniGameInfo {
        CMsgSignOutAssassinMiniGameInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSignOutAssassinMiniGameInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "winning_players",
                    CMsgSignOutAssassinMiniGameInfo::get_winning_players_for_reflect,
                    CMsgSignOutAssassinMiniGameInfo::mut_winning_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "losing_players",
                    CMsgSignOutAssassinMiniGameInfo::get_losing_players_for_reflect,
                    CMsgSignOutAssassinMiniGameInfo::mut_losing_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "arcana_owners",
                    CMsgSignOutAssassinMiniGameInfo::get_arcana_owners_for_reflect,
                    CMsgSignOutAssassinMiniGameInfo::mut_arcana_owners_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "assassin_won",
                    CMsgSignOutAssassinMiniGameInfo::get_assassin_won_for_reflect,
                    CMsgSignOutAssassinMiniGameInfo::mut_assassin_won_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_hero_id",
                    CMsgSignOutAssassinMiniGameInfo::get_target_hero_id_for_reflect,
                    CMsgSignOutAssassinMiniGameInfo::mut_target_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "contract_completed",
                    CMsgSignOutAssassinMiniGameInfo::get_contract_completed_for_reflect,
                    CMsgSignOutAssassinMiniGameInfo::mut_contract_completed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "contract_complete_time",
                    CMsgSignOutAssassinMiniGameInfo::get_contract_complete_time_for_reflect,
                    CMsgSignOutAssassinMiniGameInfo::mut_contract_complete_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pa_is_radiant",
                    CMsgSignOutAssassinMiniGameInfo::get_pa_is_radiant_for_reflect,
                    CMsgSignOutAssassinMiniGameInfo::mut_pa_is_radiant_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSignOutAssassinMiniGameInfo>(
                    "CMsgSignOutAssassinMiniGameInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSignOutAssassinMiniGameInfo {
    fn clear(&mut self) {
        self.clear_winning_players();
        self.clear_losing_players();
        self.clear_arcana_owners();
        self.clear_assassin_won();
        self.clear_target_hero_id();
        self.clear_contract_completed();
        self.clear_contract_complete_time();
        self.clear_pa_is_radiant();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSignOutAssassinMiniGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutAssassinMiniGameInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCGetIngameEventData {
    // message fields
    event: ::std::option::Option<super::dota_shared_enums::EEvent>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCGetIngameEventData {}

impl CMsgServerToGCGetIngameEventData {
    pub fn new() -> CMsgServerToGCGetIngameEventData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCGetIngameEventData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCGetIngameEventData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCGetIngameEventData,
        };
        unsafe {
            instance.get(CMsgServerToGCGetIngameEventData::new)
        }
    }

    // optional .EEvent event = 1;

    pub fn clear_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event = ::std::option::Option::Some(v);
    }

    pub fn get_event(&self) -> super::dota_shared_enums::EEvent {
        self.event.unwrap_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE)
    }

    fn get_event_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::EEvent> {
        &self.event
    }

    fn mut_event_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::EEvent> {
        &mut self.event
    }
}

impl ::protobuf::Message for CMsgServerToGCGetIngameEventData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.event = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCGetIngameEventData {
    fn new() -> CMsgServerToGCGetIngameEventData {
        CMsgServerToGCGetIngameEventData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCGetIngameEventData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::EEvent>>(
                    "event",
                    CMsgServerToGCGetIngameEventData::get_event_for_reflect,
                    CMsgServerToGCGetIngameEventData::mut_event_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCGetIngameEventData>(
                    "CMsgServerToGCGetIngameEventData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCGetIngameEventData {
    fn clear(&mut self) {
        self.clear_event();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCGetIngameEventData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCGetIngameEventData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToServerIngameEventDataOraclePA {
    // message fields
    target_hero_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToServerIngameEventDataOraclePA {}

impl CMsgGCToServerIngameEventDataOraclePA {
    pub fn new() -> CMsgGCToServerIngameEventDataOraclePA {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToServerIngameEventDataOraclePA {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToServerIngameEventDataOraclePA> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToServerIngameEventDataOraclePA,
        };
        unsafe {
            instance.get(CMsgGCToServerIngameEventDataOraclePA::new)
        }
    }

    // repeated uint32 target_hero_ids = 1;

    pub fn clear_target_hero_ids(&mut self) {
        self.target_hero_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_target_hero_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.target_hero_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_target_hero_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.target_hero_ids
    }

    // Take field
    pub fn take_target_hero_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.target_hero_ids, ::std::vec::Vec::new())
    }

    pub fn get_target_hero_ids(&self) -> &[u32] {
        &self.target_hero_ids
    }

    fn get_target_hero_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.target_hero_ids
    }

    fn mut_target_hero_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.target_hero_ids
    }
}

impl ::protobuf::Message for CMsgGCToServerIngameEventDataOraclePA {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.target_hero_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.target_hero_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.target_hero_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToServerIngameEventDataOraclePA {
    fn new() -> CMsgGCToServerIngameEventDataOraclePA {
        CMsgGCToServerIngameEventDataOraclePA::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToServerIngameEventDataOraclePA>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_hero_ids",
                    CMsgGCToServerIngameEventDataOraclePA::get_target_hero_ids_for_reflect,
                    CMsgGCToServerIngameEventDataOraclePA::mut_target_hero_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToServerIngameEventDataOraclePA>(
                    "CMsgGCToServerIngameEventDataOraclePA",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToServerIngameEventDataOraclePA {
    fn clear(&mut self) {
        self.clear_target_hero_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToServerIngameEventDataOraclePA {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerIngameEventDataOraclePA {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCKillSummaries {
    // message fields
    ingameevent_id: ::std::option::Option<u32>,
    summaries: ::protobuf::RepeatedField<CMsgServerToGCKillSummaries_KillSummary>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCKillSummaries {}

impl CMsgServerToGCKillSummaries {
    pub fn new() -> CMsgServerToGCKillSummaries {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCKillSummaries {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCKillSummaries> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCKillSummaries,
        };
        unsafe {
            instance.get(CMsgServerToGCKillSummaries::new)
        }
    }

    // optional uint32 ingameevent_id = 1;

    pub fn clear_ingameevent_id(&mut self) {
        self.ingameevent_id = ::std::option::Option::None;
    }

    pub fn has_ingameevent_id(&self) -> bool {
        self.ingameevent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ingameevent_id(&mut self, v: u32) {
        self.ingameevent_id = ::std::option::Option::Some(v);
    }

    pub fn get_ingameevent_id(&self) -> u32 {
        self.ingameevent_id.unwrap_or(0)
    }

    fn get_ingameevent_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ingameevent_id
    }

    fn mut_ingameevent_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ingameevent_id
    }

    // repeated .CMsgServerToGCKillSummaries.KillSummary summaries = 2;

    pub fn clear_summaries(&mut self) {
        self.summaries.clear();
    }

    // Param is passed by value, moved
    pub fn set_summaries(&mut self, v: ::protobuf::RepeatedField<CMsgServerToGCKillSummaries_KillSummary>) {
        self.summaries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_summaries(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCKillSummaries_KillSummary> {
        &mut self.summaries
    }

    // Take field
    pub fn take_summaries(&mut self) -> ::protobuf::RepeatedField<CMsgServerToGCKillSummaries_KillSummary> {
        ::std::mem::replace(&mut self.summaries, ::protobuf::RepeatedField::new())
    }

    pub fn get_summaries(&self) -> &[CMsgServerToGCKillSummaries_KillSummary] {
        &self.summaries
    }

    fn get_summaries_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgServerToGCKillSummaries_KillSummary> {
        &self.summaries
    }

    fn mut_summaries_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCKillSummaries_KillSummary> {
        &mut self.summaries
    }
}

impl ::protobuf::Message for CMsgServerToGCKillSummaries {
    fn is_initialized(&self) -> bool {
        for v in &self.summaries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ingameevent_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.summaries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ingameevent_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.summaries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ingameevent_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.summaries {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCKillSummaries {
    fn new() -> CMsgServerToGCKillSummaries {
        CMsgServerToGCKillSummaries::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCKillSummaries>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ingameevent_id",
                    CMsgServerToGCKillSummaries::get_ingameevent_id_for_reflect,
                    CMsgServerToGCKillSummaries::mut_ingameevent_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgServerToGCKillSummaries_KillSummary>>(
                    "summaries",
                    CMsgServerToGCKillSummaries::get_summaries_for_reflect,
                    CMsgServerToGCKillSummaries::mut_summaries_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCKillSummaries>(
                    "CMsgServerToGCKillSummaries",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCKillSummaries {
    fn clear(&mut self) {
        self.clear_ingameevent_id();
        self.clear_summaries();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCKillSummaries {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCKillSummaries {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCKillSummaries_KillSummary {
    // message fields
    killer_hero_id: ::std::option::Option<u32>,
    victim_hero_id: ::std::option::Option<u32>,
    kill_count: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCKillSummaries_KillSummary {}

impl CMsgServerToGCKillSummaries_KillSummary {
    pub fn new() -> CMsgServerToGCKillSummaries_KillSummary {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCKillSummaries_KillSummary {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCKillSummaries_KillSummary> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCKillSummaries_KillSummary,
        };
        unsafe {
            instance.get(CMsgServerToGCKillSummaries_KillSummary::new)
        }
    }

    // optional uint32 killer_hero_id = 1;

    pub fn clear_killer_hero_id(&mut self) {
        self.killer_hero_id = ::std::option::Option::None;
    }

    pub fn has_killer_hero_id(&self) -> bool {
        self.killer_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_hero_id(&mut self, v: u32) {
        self.killer_hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_killer_hero_id(&self) -> u32 {
        self.killer_hero_id.unwrap_or(0)
    }

    fn get_killer_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.killer_hero_id
    }

    fn mut_killer_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.killer_hero_id
    }

    // optional uint32 victim_hero_id = 2;

    pub fn clear_victim_hero_id(&mut self) {
        self.victim_hero_id = ::std::option::Option::None;
    }

    pub fn has_victim_hero_id(&self) -> bool {
        self.victim_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_hero_id(&mut self, v: u32) {
        self.victim_hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_victim_hero_id(&self) -> u32 {
        self.victim_hero_id.unwrap_or(0)
    }

    fn get_victim_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.victim_hero_id
    }

    fn mut_victim_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.victim_hero_id
    }

    // optional uint32 kill_count = 3;

    pub fn clear_kill_count(&mut self) {
        self.kill_count = ::std::option::Option::None;
    }

    pub fn has_kill_count(&self) -> bool {
        self.kill_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kill_count(&mut self, v: u32) {
        self.kill_count = ::std::option::Option::Some(v);
    }

    pub fn get_kill_count(&self) -> u32 {
        self.kill_count.unwrap_or(0)
    }

    fn get_kill_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.kill_count
    }

    fn mut_kill_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.kill_count
    }
}

impl ::protobuf::Message for CMsgServerToGCKillSummaries_KillSummary {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.killer_hero_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.victim_hero_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kill_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.killer_hero_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.victim_hero_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kill_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.killer_hero_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.victim_hero_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.kill_count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCKillSummaries_KillSummary {
    fn new() -> CMsgServerToGCKillSummaries_KillSummary {
        CMsgServerToGCKillSummaries_KillSummary::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCKillSummaries_KillSummary>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "killer_hero_id",
                    CMsgServerToGCKillSummaries_KillSummary::get_killer_hero_id_for_reflect,
                    CMsgServerToGCKillSummaries_KillSummary::mut_killer_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "victim_hero_id",
                    CMsgServerToGCKillSummaries_KillSummary::get_victim_hero_id_for_reflect,
                    CMsgServerToGCKillSummaries_KillSummary::mut_victim_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "kill_count",
                    CMsgServerToGCKillSummaries_KillSummary::get_kill_count_for_reflect,
                    CMsgServerToGCKillSummaries_KillSummary::mut_kill_count_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCKillSummaries_KillSummary>(
                    "CMsgServerToGCKillSummaries_KillSummary",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCKillSummaries_KillSummary {
    fn clear(&mut self) {
        self.clear_killer_hero_id();
        self.clear_victim_hero_id();
        self.clear_kill_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCKillSummaries_KillSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCKillSummaries_KillSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToServerPredictionResult {
    // message fields
    account_id: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    correct: ::std::option::Option<bool>,
    predictions: ::protobuf::RepeatedField<CMsgGCToServerPredictionResult_Prediction>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToServerPredictionResult {}

impl CMsgGCToServerPredictionResult {
    pub fn new() -> CMsgGCToServerPredictionResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToServerPredictionResult {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToServerPredictionResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToServerPredictionResult,
        };
        unsafe {
            instance.get(CMsgGCToServerPredictionResult::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint64 match_id = 2;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional bool correct = 3;

    pub fn clear_correct(&mut self) {
        self.correct = ::std::option::Option::None;
    }

    pub fn has_correct(&self) -> bool {
        self.correct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correct(&mut self, v: bool) {
        self.correct = ::std::option::Option::Some(v);
    }

    pub fn get_correct(&self) -> bool {
        self.correct.unwrap_or(false)
    }

    fn get_correct_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.correct
    }

    fn mut_correct_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.correct
    }

    // repeated .CMsgGCToServerPredictionResult.Prediction predictions = 4;

    pub fn clear_predictions(&mut self) {
        self.predictions.clear();
    }

    // Param is passed by value, moved
    pub fn set_predictions(&mut self, v: ::protobuf::RepeatedField<CMsgGCToServerPredictionResult_Prediction>) {
        self.predictions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_predictions(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToServerPredictionResult_Prediction> {
        &mut self.predictions
    }

    // Take field
    pub fn take_predictions(&mut self) -> ::protobuf::RepeatedField<CMsgGCToServerPredictionResult_Prediction> {
        ::std::mem::replace(&mut self.predictions, ::protobuf::RepeatedField::new())
    }

    pub fn get_predictions(&self) -> &[CMsgGCToServerPredictionResult_Prediction] {
        &self.predictions
    }

    fn get_predictions_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCToServerPredictionResult_Prediction> {
        &self.predictions
    }

    fn mut_predictions_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToServerPredictionResult_Prediction> {
        &mut self.predictions
    }
}

impl ::protobuf::Message for CMsgGCToServerPredictionResult {
    fn is_initialized(&self) -> bool {
        for v in &self.predictions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.correct = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.predictions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.correct {
            my_size += 2;
        }
        for value in &self.predictions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.correct {
            os.write_bool(3, v)?;
        }
        for v in &self.predictions {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToServerPredictionResult {
    fn new() -> CMsgGCToServerPredictionResult {
        CMsgGCToServerPredictionResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToServerPredictionResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCToServerPredictionResult::get_account_id_for_reflect,
                    CMsgGCToServerPredictionResult::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgGCToServerPredictionResult::get_match_id_for_reflect,
                    CMsgGCToServerPredictionResult::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "correct",
                    CMsgGCToServerPredictionResult::get_correct_for_reflect,
                    CMsgGCToServerPredictionResult::mut_correct_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToServerPredictionResult_Prediction>>(
                    "predictions",
                    CMsgGCToServerPredictionResult::get_predictions_for_reflect,
                    CMsgGCToServerPredictionResult::mut_predictions_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToServerPredictionResult>(
                    "CMsgGCToServerPredictionResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToServerPredictionResult {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_match_id();
        self.clear_correct();
        self.clear_predictions();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToServerPredictionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerPredictionResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToServerPredictionResult_Prediction {
    // message fields
    item_def: ::std::option::Option<u32>,
    num_correct: ::std::option::Option<u32>,
    num_fails: ::std::option::Option<u32>,
    result: ::std::option::Option<CMsgGCToServerPredictionResult_Prediction_EResult>,
    granted_item_defs: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToServerPredictionResult_Prediction {}

impl CMsgGCToServerPredictionResult_Prediction {
    pub fn new() -> CMsgGCToServerPredictionResult_Prediction {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToServerPredictionResult_Prediction {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToServerPredictionResult_Prediction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToServerPredictionResult_Prediction,
        };
        unsafe {
            instance.get(CMsgGCToServerPredictionResult_Prediction::new)
        }
    }

    // optional uint32 item_def = 1;

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    pub fn get_item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    fn get_item_def_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_def
    }

    fn mut_item_def_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_def
    }

    // optional uint32 num_correct = 2;

    pub fn clear_num_correct(&mut self) {
        self.num_correct = ::std::option::Option::None;
    }

    pub fn has_num_correct(&self) -> bool {
        self.num_correct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_correct(&mut self, v: u32) {
        self.num_correct = ::std::option::Option::Some(v);
    }

    pub fn get_num_correct(&self) -> u32 {
        self.num_correct.unwrap_or(0)
    }

    fn get_num_correct_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.num_correct
    }

    fn mut_num_correct_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.num_correct
    }

    // optional uint32 num_fails = 3;

    pub fn clear_num_fails(&mut self) {
        self.num_fails = ::std::option::Option::None;
    }

    pub fn has_num_fails(&self) -> bool {
        self.num_fails.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_fails(&mut self, v: u32) {
        self.num_fails = ::std::option::Option::Some(v);
    }

    pub fn get_num_fails(&self) -> u32 {
        self.num_fails.unwrap_or(0)
    }

    fn get_num_fails_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.num_fails
    }

    fn mut_num_fails_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.num_fails
    }

    // optional .CMsgGCToServerPredictionResult.Prediction.EResult result = 4;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgGCToServerPredictionResult_Prediction_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgGCToServerPredictionResult_Prediction_EResult {
        self.result.unwrap_or(CMsgGCToServerPredictionResult_Prediction_EResult::k_eResult_ItemGranted)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgGCToServerPredictionResult_Prediction_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgGCToServerPredictionResult_Prediction_EResult> {
        &mut self.result
    }

    // repeated uint32 granted_item_defs = 6;

    pub fn clear_granted_item_defs(&mut self) {
        self.granted_item_defs.clear();
    }

    // Param is passed by value, moved
    pub fn set_granted_item_defs(&mut self, v: ::std::vec::Vec<u32>) {
        self.granted_item_defs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_granted_item_defs(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.granted_item_defs
    }

    // Take field
    pub fn take_granted_item_defs(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.granted_item_defs, ::std::vec::Vec::new())
    }

    pub fn get_granted_item_defs(&self) -> &[u32] {
        &self.granted_item_defs
    }

    fn get_granted_item_defs_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.granted_item_defs
    }

    fn mut_granted_item_defs_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.granted_item_defs
    }
}

impl ::protobuf::Message for CMsgGCToServerPredictionResult_Prediction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_correct = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_fails = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.granted_item_defs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_correct {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_fails {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        for value in &self.granted_item_defs {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_correct {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_fails {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(4, v.value())?;
        }
        for v in &self.granted_item_defs {
            os.write_uint32(6, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToServerPredictionResult_Prediction {
    fn new() -> CMsgGCToServerPredictionResult_Prediction {
        CMsgGCToServerPredictionResult_Prediction::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToServerPredictionResult_Prediction>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_def",
                    CMsgGCToServerPredictionResult_Prediction::get_item_def_for_reflect,
                    CMsgGCToServerPredictionResult_Prediction::mut_item_def_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_correct",
                    CMsgGCToServerPredictionResult_Prediction::get_num_correct_for_reflect,
                    CMsgGCToServerPredictionResult_Prediction::mut_num_correct_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_fails",
                    CMsgGCToServerPredictionResult_Prediction::get_num_fails_for_reflect,
                    CMsgGCToServerPredictionResult_Prediction::mut_num_fails_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGCToServerPredictionResult_Prediction_EResult>>(
                    "result",
                    CMsgGCToServerPredictionResult_Prediction::get_result_for_reflect,
                    CMsgGCToServerPredictionResult_Prediction::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "granted_item_defs",
                    CMsgGCToServerPredictionResult_Prediction::get_granted_item_defs_for_reflect,
                    CMsgGCToServerPredictionResult_Prediction::mut_granted_item_defs_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToServerPredictionResult_Prediction>(
                    "CMsgGCToServerPredictionResult_Prediction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToServerPredictionResult_Prediction {
    fn clear(&mut self) {
        self.clear_item_def();
        self.clear_num_correct();
        self.clear_num_fails();
        self.clear_result();
        self.clear_granted_item_defs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToServerPredictionResult_Prediction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerPredictionResult_Prediction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGCToServerPredictionResult_Prediction_EResult {
    k_eResult_ItemGranted = 1,
    k_eResult_Destroyed = 2,
}

impl ::protobuf::ProtobufEnum for CMsgGCToServerPredictionResult_Prediction_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGCToServerPredictionResult_Prediction_EResult> {
        match value {
            1 => ::std::option::Option::Some(CMsgGCToServerPredictionResult_Prediction_EResult::k_eResult_ItemGranted),
            2 => ::std::option::Option::Some(CMsgGCToServerPredictionResult_Prediction_EResult::k_eResult_Destroyed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGCToServerPredictionResult_Prediction_EResult] = &[
            CMsgGCToServerPredictionResult_Prediction_EResult::k_eResult_ItemGranted,
            CMsgGCToServerPredictionResult_Prediction_EResult::k_eResult_Destroyed,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgGCToServerPredictionResult_Prediction_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgGCToServerPredictionResult_Prediction_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgGCToServerPredictionResult_Prediction_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerPredictionResult_Prediction_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCLockCharmTrading {
    // message fields
    account_id: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCLockCharmTrading {}

impl CMsgServerToGCLockCharmTrading {
    pub fn new() -> CMsgServerToGCLockCharmTrading {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCLockCharmTrading {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCLockCharmTrading> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCLockCharmTrading,
        };
        unsafe {
            instance.get(CMsgServerToGCLockCharmTrading::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint64 item_id = 2;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }
}

impl ::protobuf::Message for CMsgServerToGCLockCharmTrading {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCLockCharmTrading {
    fn new() -> CMsgServerToGCLockCharmTrading {
        CMsgServerToGCLockCharmTrading::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCLockCharmTrading>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgServerToGCLockCharmTrading::get_account_id_for_reflect,
                    CMsgServerToGCLockCharmTrading::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgServerToGCLockCharmTrading::get_item_id_for_reflect,
                    CMsgServerToGCLockCharmTrading::mut_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCLockCharmTrading>(
                    "CMsgServerToGCLockCharmTrading",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCLockCharmTrading {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCLockCharmTrading {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCLockCharmTrading {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSignOutUpdatePlayerChallenge {
    // message fields
    account_id: ::std::option::Option<u32>,
    completed: ::protobuf::RepeatedField<CMsgSignOutUpdatePlayerChallenge_Challenge>,
    rerolled: ::protobuf::RepeatedField<CMsgSignOutUpdatePlayerChallenge_Challenge>,
    match_id: ::std::option::Option<u64>,
    hero_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSignOutUpdatePlayerChallenge {}

impl CMsgSignOutUpdatePlayerChallenge {
    pub fn new() -> CMsgSignOutUpdatePlayerChallenge {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSignOutUpdatePlayerChallenge {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSignOutUpdatePlayerChallenge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSignOutUpdatePlayerChallenge,
        };
        unsafe {
            instance.get(CMsgSignOutUpdatePlayerChallenge::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // repeated .CMsgSignOutUpdatePlayerChallenge.Challenge completed = 2;

    pub fn clear_completed(&mut self) {
        self.completed.clear();
    }

    // Param is passed by value, moved
    pub fn set_completed(&mut self, v: ::protobuf::RepeatedField<CMsgSignOutUpdatePlayerChallenge_Challenge>) {
        self.completed = v;
    }

    // Mutable pointer to the field.
    pub fn mut_completed(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSignOutUpdatePlayerChallenge_Challenge> {
        &mut self.completed
    }

    // Take field
    pub fn take_completed(&mut self) -> ::protobuf::RepeatedField<CMsgSignOutUpdatePlayerChallenge_Challenge> {
        ::std::mem::replace(&mut self.completed, ::protobuf::RepeatedField::new())
    }

    pub fn get_completed(&self) -> &[CMsgSignOutUpdatePlayerChallenge_Challenge] {
        &self.completed
    }

    fn get_completed_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgSignOutUpdatePlayerChallenge_Challenge> {
        &self.completed
    }

    fn mut_completed_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSignOutUpdatePlayerChallenge_Challenge> {
        &mut self.completed
    }

    // repeated .CMsgSignOutUpdatePlayerChallenge.Challenge rerolled = 3;

    pub fn clear_rerolled(&mut self) {
        self.rerolled.clear();
    }

    // Param is passed by value, moved
    pub fn set_rerolled(&mut self, v: ::protobuf::RepeatedField<CMsgSignOutUpdatePlayerChallenge_Challenge>) {
        self.rerolled = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rerolled(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSignOutUpdatePlayerChallenge_Challenge> {
        &mut self.rerolled
    }

    // Take field
    pub fn take_rerolled(&mut self) -> ::protobuf::RepeatedField<CMsgSignOutUpdatePlayerChallenge_Challenge> {
        ::std::mem::replace(&mut self.rerolled, ::protobuf::RepeatedField::new())
    }

    pub fn get_rerolled(&self) -> &[CMsgSignOutUpdatePlayerChallenge_Challenge] {
        &self.rerolled
    }

    fn get_rerolled_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgSignOutUpdatePlayerChallenge_Challenge> {
        &self.rerolled
    }

    fn mut_rerolled_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSignOutUpdatePlayerChallenge_Challenge> {
        &mut self.rerolled
    }

    // optional uint64 match_id = 4;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 hero_id = 5;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }
}

impl ::protobuf::Message for CMsgSignOutUpdatePlayerChallenge {
    fn is_initialized(&self) -> bool {
        for v in &self.completed {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rerolled {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.completed)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rerolled)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.completed {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.rerolled {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.completed {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.rerolled {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.match_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSignOutUpdatePlayerChallenge {
    fn new() -> CMsgSignOutUpdatePlayerChallenge {
        CMsgSignOutUpdatePlayerChallenge::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSignOutUpdatePlayerChallenge>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgSignOutUpdatePlayerChallenge::get_account_id_for_reflect,
                    CMsgSignOutUpdatePlayerChallenge::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSignOutUpdatePlayerChallenge_Challenge>>(
                    "completed",
                    CMsgSignOutUpdatePlayerChallenge::get_completed_for_reflect,
                    CMsgSignOutUpdatePlayerChallenge::mut_completed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSignOutUpdatePlayerChallenge_Challenge>>(
                    "rerolled",
                    CMsgSignOutUpdatePlayerChallenge::get_rerolled_for_reflect,
                    CMsgSignOutUpdatePlayerChallenge::mut_rerolled_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgSignOutUpdatePlayerChallenge::get_match_id_for_reflect,
                    CMsgSignOutUpdatePlayerChallenge::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgSignOutUpdatePlayerChallenge::get_hero_id_for_reflect,
                    CMsgSignOutUpdatePlayerChallenge::mut_hero_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSignOutUpdatePlayerChallenge>(
                    "CMsgSignOutUpdatePlayerChallenge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSignOutUpdatePlayerChallenge {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_completed();
        self.clear_rerolled();
        self.clear_match_id();
        self.clear_hero_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSignOutUpdatePlayerChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutUpdatePlayerChallenge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSignOutUpdatePlayerChallenge_Challenge {
    // message fields
    event_id: ::std::option::Option<u32>,
    sequence_id: ::std::option::Option<u32>,
    progress: ::std::option::Option<u32>,
    challenge_rank: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSignOutUpdatePlayerChallenge_Challenge {}

impl CMsgSignOutUpdatePlayerChallenge_Challenge {
    pub fn new() -> CMsgSignOutUpdatePlayerChallenge_Challenge {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSignOutUpdatePlayerChallenge_Challenge {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSignOutUpdatePlayerChallenge_Challenge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSignOutUpdatePlayerChallenge_Challenge,
        };
        unsafe {
            instance.get(CMsgSignOutUpdatePlayerChallenge_Challenge::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // optional uint32 sequence_id = 3;

    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u32) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    pub fn get_sequence_id(&self) -> u32 {
        self.sequence_id.unwrap_or(0)
    }

    fn get_sequence_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.sequence_id
    }

    fn mut_sequence_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.sequence_id
    }

    // optional uint32 progress = 4;

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: u32) {
        self.progress = ::std::option::Option::Some(v);
    }

    pub fn get_progress(&self) -> u32 {
        self.progress.unwrap_or(0)
    }

    fn get_progress_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.progress
    }

    fn mut_progress_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.progress
    }

    // optional uint32 challenge_rank = 5;

    pub fn clear_challenge_rank(&mut self) {
        self.challenge_rank = ::std::option::Option::None;
    }

    pub fn has_challenge_rank(&self) -> bool {
        self.challenge_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_rank(&mut self, v: u32) {
        self.challenge_rank = ::std::option::Option::Some(v);
    }

    pub fn get_challenge_rank(&self) -> u32 {
        self.challenge_rank.unwrap_or(0)
    }

    fn get_challenge_rank_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.challenge_rank
    }

    fn mut_challenge_rank_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.challenge_rank
    }
}

impl ::protobuf::Message for CMsgSignOutUpdatePlayerChallenge_Challenge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sequence_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.progress = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.challenge_rank = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.progress {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.challenge_rank {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.progress {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.challenge_rank {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSignOutUpdatePlayerChallenge_Challenge {
    fn new() -> CMsgSignOutUpdatePlayerChallenge_Challenge {
        CMsgSignOutUpdatePlayerChallenge_Challenge::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSignOutUpdatePlayerChallenge_Challenge>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgSignOutUpdatePlayerChallenge_Challenge::get_event_id_for_reflect,
                    CMsgSignOutUpdatePlayerChallenge_Challenge::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sequence_id",
                    CMsgSignOutUpdatePlayerChallenge_Challenge::get_sequence_id_for_reflect,
                    CMsgSignOutUpdatePlayerChallenge_Challenge::mut_sequence_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "progress",
                    CMsgSignOutUpdatePlayerChallenge_Challenge::get_progress_for_reflect,
                    CMsgSignOutUpdatePlayerChallenge_Challenge::mut_progress_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "challenge_rank",
                    CMsgSignOutUpdatePlayerChallenge_Challenge::get_challenge_rank_for_reflect,
                    CMsgSignOutUpdatePlayerChallenge_Challenge::mut_challenge_rank_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSignOutUpdatePlayerChallenge_Challenge>(
                    "CMsgSignOutUpdatePlayerChallenge_Challenge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSignOutUpdatePlayerChallenge_Challenge {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_sequence_id();
        self.clear_progress();
        self.clear_challenge_rank();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSignOutUpdatePlayerChallenge_Challenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutUpdatePlayerChallenge_Challenge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCRerollPlayerChallenge {
    // message fields
    account_id: ::std::option::Option<u32>,
    reroll_msg: ::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgClientToGCRerollPlayerChallenge>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCRerollPlayerChallenge {}

impl CMsgServerToGCRerollPlayerChallenge {
    pub fn new() -> CMsgServerToGCRerollPlayerChallenge {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCRerollPlayerChallenge {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCRerollPlayerChallenge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCRerollPlayerChallenge,
        };
        unsafe {
            instance.get(CMsgServerToGCRerollPlayerChallenge::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional .CMsgClientToGCRerollPlayerChallenge reroll_msg = 2;

    pub fn clear_reroll_msg(&mut self) {
        self.reroll_msg.clear();
    }

    pub fn has_reroll_msg(&self) -> bool {
        self.reroll_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reroll_msg(&mut self, v: super::dota_gcmessages_common::CMsgClientToGCRerollPlayerChallenge) {
        self.reroll_msg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reroll_msg(&mut self) -> &mut super::dota_gcmessages_common::CMsgClientToGCRerollPlayerChallenge {
        if self.reroll_msg.is_none() {
            self.reroll_msg.set_default();
        }
        self.reroll_msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_reroll_msg(&mut self) -> super::dota_gcmessages_common::CMsgClientToGCRerollPlayerChallenge {
        self.reroll_msg.take().unwrap_or_else(|| super::dota_gcmessages_common::CMsgClientToGCRerollPlayerChallenge::new())
    }

    pub fn get_reroll_msg(&self) -> &super::dota_gcmessages_common::CMsgClientToGCRerollPlayerChallenge {
        self.reroll_msg.as_ref().unwrap_or_else(|| super::dota_gcmessages_common::CMsgClientToGCRerollPlayerChallenge::default_instance())
    }

    fn get_reroll_msg_for_reflect(&self) -> &::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgClientToGCRerollPlayerChallenge> {
        &self.reroll_msg
    }

    fn mut_reroll_msg_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgClientToGCRerollPlayerChallenge> {
        &mut self.reroll_msg
    }
}

impl ::protobuf::Message for CMsgServerToGCRerollPlayerChallenge {
    fn is_initialized(&self) -> bool {
        for v in &self.reroll_msg {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reroll_msg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.reroll_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.reroll_msg.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCRerollPlayerChallenge {
    fn new() -> CMsgServerToGCRerollPlayerChallenge {
        CMsgServerToGCRerollPlayerChallenge::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCRerollPlayerChallenge>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgServerToGCRerollPlayerChallenge::get_account_id_for_reflect,
                    CMsgServerToGCRerollPlayerChallenge::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMsgClientToGCRerollPlayerChallenge>>(
                    "reroll_msg",
                    CMsgServerToGCRerollPlayerChallenge::get_reroll_msg_for_reflect,
                    CMsgServerToGCRerollPlayerChallenge::mut_reroll_msg_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCRerollPlayerChallenge>(
                    "CMsgServerToGCRerollPlayerChallenge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCRerollPlayerChallenge {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_reroll_msg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCRerollPlayerChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCRerollPlayerChallenge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCHoldEventPoints {
    // message fields
    holds: ::protobuf::RepeatedField<CMsgServerToGCHoldEventPoints_HoldRequest>,
    event_id: ::std::option::Option<u32>,
    hold_key: ::std::option::Option<u64>,
    hold_until: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCHoldEventPoints {}

impl CMsgServerToGCHoldEventPoints {
    pub fn new() -> CMsgServerToGCHoldEventPoints {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCHoldEventPoints {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCHoldEventPoints> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCHoldEventPoints,
        };
        unsafe {
            instance.get(CMsgServerToGCHoldEventPoints::new)
        }
    }

    // repeated .CMsgServerToGCHoldEventPoints.HoldRequest holds = 1;

    pub fn clear_holds(&mut self) {
        self.holds.clear();
    }

    // Param is passed by value, moved
    pub fn set_holds(&mut self, v: ::protobuf::RepeatedField<CMsgServerToGCHoldEventPoints_HoldRequest>) {
        self.holds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_holds(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCHoldEventPoints_HoldRequest> {
        &mut self.holds
    }

    // Take field
    pub fn take_holds(&mut self) -> ::protobuf::RepeatedField<CMsgServerToGCHoldEventPoints_HoldRequest> {
        ::std::mem::replace(&mut self.holds, ::protobuf::RepeatedField::new())
    }

    pub fn get_holds(&self) -> &[CMsgServerToGCHoldEventPoints_HoldRequest] {
        &self.holds
    }

    fn get_holds_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgServerToGCHoldEventPoints_HoldRequest> {
        &self.holds
    }

    fn mut_holds_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCHoldEventPoints_HoldRequest> {
        &mut self.holds
    }

    // optional uint32 event_id = 2;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // optional uint64 hold_key = 3;

    pub fn clear_hold_key(&mut self) {
        self.hold_key = ::std::option::Option::None;
    }

    pub fn has_hold_key(&self) -> bool {
        self.hold_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hold_key(&mut self, v: u64) {
        self.hold_key = ::std::option::Option::Some(v);
    }

    pub fn get_hold_key(&self) -> u64 {
        self.hold_key.unwrap_or(0)
    }

    fn get_hold_key_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.hold_key
    }

    fn mut_hold_key_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.hold_key
    }

    // optional uint32 hold_until = 4;

    pub fn clear_hold_until(&mut self) {
        self.hold_until = ::std::option::Option::None;
    }

    pub fn has_hold_until(&self) -> bool {
        self.hold_until.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hold_until(&mut self, v: u32) {
        self.hold_until = ::std::option::Option::Some(v);
    }

    pub fn get_hold_until(&self) -> u32 {
        self.hold_until.unwrap_or(0)
    }

    fn get_hold_until_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hold_until
    }

    fn mut_hold_until_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hold_until
    }
}

impl ::protobuf::Message for CMsgServerToGCHoldEventPoints {
    fn is_initialized(&self) -> bool {
        for v in &self.holds {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.holds)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.hold_key = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hold_until = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.holds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hold_key {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hold_until {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.holds {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hold_key {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.hold_until {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCHoldEventPoints {
    fn new() -> CMsgServerToGCHoldEventPoints {
        CMsgServerToGCHoldEventPoints::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCHoldEventPoints>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgServerToGCHoldEventPoints_HoldRequest>>(
                    "holds",
                    CMsgServerToGCHoldEventPoints::get_holds_for_reflect,
                    CMsgServerToGCHoldEventPoints::mut_holds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgServerToGCHoldEventPoints::get_event_id_for_reflect,
                    CMsgServerToGCHoldEventPoints::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "hold_key",
                    CMsgServerToGCHoldEventPoints::get_hold_key_for_reflect,
                    CMsgServerToGCHoldEventPoints::mut_hold_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hold_until",
                    CMsgServerToGCHoldEventPoints::get_hold_until_for_reflect,
                    CMsgServerToGCHoldEventPoints::mut_hold_until_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCHoldEventPoints>(
                    "CMsgServerToGCHoldEventPoints",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCHoldEventPoints {
    fn clear(&mut self) {
        self.clear_holds();
        self.clear_event_id();
        self.clear_hold_key();
        self.clear_hold_until();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCHoldEventPoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCHoldEventPoints {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCHoldEventPoints_HoldRequest {
    // message fields
    account_id: ::std::option::Option<u32>,
    points_held: ::std::option::Option<u32>,
    premium_held: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCHoldEventPoints_HoldRequest {}

impl CMsgServerToGCHoldEventPoints_HoldRequest {
    pub fn new() -> CMsgServerToGCHoldEventPoints_HoldRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCHoldEventPoints_HoldRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCHoldEventPoints_HoldRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCHoldEventPoints_HoldRequest,
        };
        unsafe {
            instance.get(CMsgServerToGCHoldEventPoints_HoldRequest::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 points_held = 2;

    pub fn clear_points_held(&mut self) {
        self.points_held = ::std::option::Option::None;
    }

    pub fn has_points_held(&self) -> bool {
        self.points_held.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_held(&mut self, v: u32) {
        self.points_held = ::std::option::Option::Some(v);
    }

    pub fn get_points_held(&self) -> u32 {
        self.points_held.unwrap_or(0)
    }

    fn get_points_held_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points_held
    }

    fn mut_points_held_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points_held
    }

    // optional uint32 premium_held = 3;

    pub fn clear_premium_held(&mut self) {
        self.premium_held = ::std::option::Option::None;
    }

    pub fn has_premium_held(&self) -> bool {
        self.premium_held.is_some()
    }

    // Param is passed by value, moved
    pub fn set_premium_held(&mut self, v: u32) {
        self.premium_held = ::std::option::Option::Some(v);
    }

    pub fn get_premium_held(&self) -> u32 {
        self.premium_held.unwrap_or(0)
    }

    fn get_premium_held_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.premium_held
    }

    fn mut_premium_held_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.premium_held
    }
}

impl ::protobuf::Message for CMsgServerToGCHoldEventPoints_HoldRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_held = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.premium_held = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points_held {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.premium_held {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.points_held {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.premium_held {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCHoldEventPoints_HoldRequest {
    fn new() -> CMsgServerToGCHoldEventPoints_HoldRequest {
        CMsgServerToGCHoldEventPoints_HoldRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCHoldEventPoints_HoldRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgServerToGCHoldEventPoints_HoldRequest::get_account_id_for_reflect,
                    CMsgServerToGCHoldEventPoints_HoldRequest::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points_held",
                    CMsgServerToGCHoldEventPoints_HoldRequest::get_points_held_for_reflect,
                    CMsgServerToGCHoldEventPoints_HoldRequest::mut_points_held_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "premium_held",
                    CMsgServerToGCHoldEventPoints_HoldRequest::get_premium_held_for_reflect,
                    CMsgServerToGCHoldEventPoints_HoldRequest::mut_premium_held_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCHoldEventPoints_HoldRequest>(
                    "CMsgServerToGCHoldEventPoints_HoldRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCHoldEventPoints_HoldRequest {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_points_held();
        self.clear_premium_held();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCHoldEventPoints_HoldRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCHoldEventPoints_HoldRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSignOutReleaseEventPointHolds {
    // message fields
    account_ids: ::std::vec::Vec<u32>,
    event_id: ::std::option::Option<u32>,
    hold_key: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSignOutReleaseEventPointHolds {}

impl CMsgSignOutReleaseEventPointHolds {
    pub fn new() -> CMsgSignOutReleaseEventPointHolds {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSignOutReleaseEventPointHolds {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSignOutReleaseEventPointHolds> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSignOutReleaseEventPointHolds,
        };
        unsafe {
            instance.get(CMsgSignOutReleaseEventPointHolds::new)
        }
    }

    // repeated uint32 account_ids = 1;

    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }

    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }

    fn get_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.account_ids
    }

    fn mut_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // optional uint32 event_id = 2;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // optional uint64 hold_key = 3;

    pub fn clear_hold_key(&mut self) {
        self.hold_key = ::std::option::Option::None;
    }

    pub fn has_hold_key(&self) -> bool {
        self.hold_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hold_key(&mut self, v: u64) {
        self.hold_key = ::std::option::Option::Some(v);
    }

    pub fn get_hold_key(&self) -> u64 {
        self.hold_key.unwrap_or(0)
    }

    fn get_hold_key_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.hold_key
    }

    fn mut_hold_key_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.hold_key
    }
}

impl ::protobuf::Message for CMsgSignOutReleaseEventPointHolds {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.hold_key = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hold_key {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hold_key {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSignOutReleaseEventPointHolds {
    fn new() -> CMsgSignOutReleaseEventPointHolds {
        CMsgSignOutReleaseEventPointHolds::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSignOutReleaseEventPointHolds>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids",
                    CMsgSignOutReleaseEventPointHolds::get_account_ids_for_reflect,
                    CMsgSignOutReleaseEventPointHolds::mut_account_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgSignOutReleaseEventPointHolds::get_event_id_for_reflect,
                    CMsgSignOutReleaseEventPointHolds::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "hold_key",
                    CMsgSignOutReleaseEventPointHolds::get_hold_key_for_reflect,
                    CMsgSignOutReleaseEventPointHolds::mut_hold_key_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSignOutReleaseEventPointHolds>(
                    "CMsgSignOutReleaseEventPointHolds",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSignOutReleaseEventPointHolds {
    fn clear(&mut self) {
        self.clear_account_ids();
        self.clear_event_id();
        self.clear_hold_key();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSignOutReleaseEventPointHolds {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutReleaseEventPointHolds {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToServerUpdateBroadcastCheers {
    // message fields
    time_stamp: ::std::option::Option<u32>,
    team_1_cheers: ::std::option::Option<u32>,
    team_2_cheers: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToServerUpdateBroadcastCheers {}

impl CMsgGCToServerUpdateBroadcastCheers {
    pub fn new() -> CMsgGCToServerUpdateBroadcastCheers {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToServerUpdateBroadcastCheers {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToServerUpdateBroadcastCheers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToServerUpdateBroadcastCheers,
        };
        unsafe {
            instance.get(CMsgGCToServerUpdateBroadcastCheers::new)
        }
    }

    // optional uint32 time_stamp = 1;

    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u32) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    pub fn get_time_stamp(&self) -> u32 {
        self.time_stamp.unwrap_or(0)
    }

    fn get_time_stamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time_stamp
    }

    fn mut_time_stamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time_stamp
    }

    // optional uint32 team_1_cheers = 2;

    pub fn clear_team_1_cheers(&mut self) {
        self.team_1_cheers = ::std::option::Option::None;
    }

    pub fn has_team_1_cheers(&self) -> bool {
        self.team_1_cheers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_1_cheers(&mut self, v: u32) {
        self.team_1_cheers = ::std::option::Option::Some(v);
    }

    pub fn get_team_1_cheers(&self) -> u32 {
        self.team_1_cheers.unwrap_or(0)
    }

    fn get_team_1_cheers_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_1_cheers
    }

    fn mut_team_1_cheers_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_1_cheers
    }

    // optional uint32 team_2_cheers = 3;

    pub fn clear_team_2_cheers(&mut self) {
        self.team_2_cheers = ::std::option::Option::None;
    }

    pub fn has_team_2_cheers(&self) -> bool {
        self.team_2_cheers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_2_cheers(&mut self, v: u32) {
        self.team_2_cheers = ::std::option::Option::Some(v);
    }

    pub fn get_team_2_cheers(&self) -> u32 {
        self.team_2_cheers.unwrap_or(0)
    }

    fn get_team_2_cheers_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_2_cheers
    }

    fn mut_team_2_cheers_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_2_cheers
    }
}

impl ::protobuf::Message for CMsgGCToServerUpdateBroadcastCheers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_stamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_1_cheers = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_2_cheers = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.time_stamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_1_cheers {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_2_cheers {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.time_stamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.team_1_cheers {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.team_2_cheers {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToServerUpdateBroadcastCheers {
    fn new() -> CMsgGCToServerUpdateBroadcastCheers {
        CMsgGCToServerUpdateBroadcastCheers::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToServerUpdateBroadcastCheers>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_stamp",
                    CMsgGCToServerUpdateBroadcastCheers::get_time_stamp_for_reflect,
                    CMsgGCToServerUpdateBroadcastCheers::mut_time_stamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_1_cheers",
                    CMsgGCToServerUpdateBroadcastCheers::get_team_1_cheers_for_reflect,
                    CMsgGCToServerUpdateBroadcastCheers::mut_team_1_cheers_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_2_cheers",
                    CMsgGCToServerUpdateBroadcastCheers::get_team_2_cheers_for_reflect,
                    CMsgGCToServerUpdateBroadcastCheers::mut_team_2_cheers_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToServerUpdateBroadcastCheers>(
                    "CMsgGCToServerUpdateBroadcastCheers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToServerUpdateBroadcastCheers {
    fn clear(&mut self) {
        self.clear_time_stamp();
        self.clear_team_1_cheers();
        self.clear_team_2_cheers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToServerUpdateBroadcastCheers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerUpdateBroadcastCheers {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSignOutWagerStats {
    // message fields
    players: ::protobuf::RepeatedField<CMsgSignOutWagerStats_Player>,
    event_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSignOutWagerStats {}

impl CMsgSignOutWagerStats {
    pub fn new() -> CMsgSignOutWagerStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSignOutWagerStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSignOutWagerStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSignOutWagerStats,
        };
        unsafe {
            instance.get(CMsgSignOutWagerStats::new)
        }
    }

    // repeated .CMsgSignOutWagerStats.Player players = 1;

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgSignOutWagerStats_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSignOutWagerStats_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgSignOutWagerStats_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    pub fn get_players(&self) -> &[CMsgSignOutWagerStats_Player] {
        &self.players
    }

    fn get_players_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgSignOutWagerStats_Player> {
        &self.players
    }

    fn mut_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSignOutWagerStats_Player> {
        &mut self.players
    }

    // optional uint32 event_id = 2;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }
}

impl ::protobuf::Message for CMsgSignOutWagerStats {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.players {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSignOutWagerStats {
    fn new() -> CMsgSignOutWagerStats {
        CMsgSignOutWagerStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSignOutWagerStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSignOutWagerStats_Player>>(
                    "players",
                    CMsgSignOutWagerStats::get_players_for_reflect,
                    CMsgSignOutWagerStats::mut_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgSignOutWagerStats::get_event_id_for_reflect,
                    CMsgSignOutWagerStats::mut_event_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSignOutWagerStats>(
                    "CMsgSignOutWagerStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSignOutWagerStats {
    fn clear(&mut self) {
        self.clear_players();
        self.clear_event_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSignOutWagerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutWagerStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSignOutWagerStats_Player {
    // message fields
    account_id: ::std::option::Option<u32>,
    winnings: ::std::option::Option<u32>,
    max_wager: ::std::option::Option<u32>,
    wager: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSignOutWagerStats_Player {}

impl CMsgSignOutWagerStats_Player {
    pub fn new() -> CMsgSignOutWagerStats_Player {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSignOutWagerStats_Player {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSignOutWagerStats_Player> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSignOutWagerStats_Player,
        };
        unsafe {
            instance.get(CMsgSignOutWagerStats_Player::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 winnings = 2;

    pub fn clear_winnings(&mut self) {
        self.winnings = ::std::option::Option::None;
    }

    pub fn has_winnings(&self) -> bool {
        self.winnings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winnings(&mut self, v: u32) {
        self.winnings = ::std::option::Option::Some(v);
    }

    pub fn get_winnings(&self) -> u32 {
        self.winnings.unwrap_or(0)
    }

    fn get_winnings_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.winnings
    }

    fn mut_winnings_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.winnings
    }

    // optional uint32 max_wager = 3;

    pub fn clear_max_wager(&mut self) {
        self.max_wager = ::std::option::Option::None;
    }

    pub fn has_max_wager(&self) -> bool {
        self.max_wager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_wager(&mut self, v: u32) {
        self.max_wager = ::std::option::Option::Some(v);
    }

    pub fn get_max_wager(&self) -> u32 {
        self.max_wager.unwrap_or(0)
    }

    fn get_max_wager_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.max_wager
    }

    fn mut_max_wager_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.max_wager
    }

    // optional uint32 wager = 4;

    pub fn clear_wager(&mut self) {
        self.wager = ::std::option::Option::None;
    }

    pub fn has_wager(&self) -> bool {
        self.wager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wager(&mut self, v: u32) {
        self.wager = ::std::option::Option::Some(v);
    }

    pub fn get_wager(&self) -> u32 {
        self.wager.unwrap_or(0)
    }

    fn get_wager_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.wager
    }

    fn mut_wager_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.wager
    }
}

impl ::protobuf::Message for CMsgSignOutWagerStats_Player {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.winnings = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_wager = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wager = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.winnings {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_wager {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wager {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.winnings {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.max_wager {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.wager {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSignOutWagerStats_Player {
    fn new() -> CMsgSignOutWagerStats_Player {
        CMsgSignOutWagerStats_Player::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSignOutWagerStats_Player>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgSignOutWagerStats_Player::get_account_id_for_reflect,
                    CMsgSignOutWagerStats_Player::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "winnings",
                    CMsgSignOutWagerStats_Player::get_winnings_for_reflect,
                    CMsgSignOutWagerStats_Player::mut_winnings_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_wager",
                    CMsgSignOutWagerStats_Player::get_max_wager_for_reflect,
                    CMsgSignOutWagerStats_Player::mut_max_wager_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wager",
                    CMsgSignOutWagerStats_Player::get_wager_for_reflect,
                    CMsgSignOutWagerStats_Player::mut_wager_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSignOutWagerStats_Player>(
                    "CMsgSignOutWagerStats_Player",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSignOutWagerStats_Player {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_winnings();
        self.clear_max_wager();
        self.clear_wager();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSignOutWagerStats_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutWagerStats_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSpendWager {
    // message fields
    players: ::protobuf::RepeatedField<CMsgSpendWager_Player>,
    event_id: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    server_steam_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSpendWager {}

impl CMsgSpendWager {
    pub fn new() -> CMsgSpendWager {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSpendWager {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSpendWager> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSpendWager,
        };
        unsafe {
            instance.get(CMsgSpendWager::new)
        }
    }

    // repeated .CMsgSpendWager.Player players = 1;

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgSpendWager_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSpendWager_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgSpendWager_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    pub fn get_players(&self) -> &[CMsgSpendWager_Player] {
        &self.players
    }

    fn get_players_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgSpendWager_Player> {
        &self.players
    }

    fn mut_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSpendWager_Player> {
        &mut self.players
    }

    // optional uint32 event_id = 2;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // optional uint32 timestamp = 3;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional uint64 match_id = 4;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint64 server_steam_id = 5;

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    fn get_server_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.server_steam_id
    }

    fn mut_server_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.server_steam_id
    }
}

impl ::protobuf::Message for CMsgSpendWager {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.server_steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_steam_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.players {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.server_steam_id {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSpendWager {
    fn new() -> CMsgSpendWager {
        CMsgSpendWager::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSpendWager>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSpendWager_Player>>(
                    "players",
                    CMsgSpendWager::get_players_for_reflect,
                    CMsgSpendWager::mut_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgSpendWager::get_event_id_for_reflect,
                    CMsgSpendWager::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgSpendWager::get_timestamp_for_reflect,
                    CMsgSpendWager::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgSpendWager::get_match_id_for_reflect,
                    CMsgSpendWager::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "server_steam_id",
                    CMsgSpendWager::get_server_steam_id_for_reflect,
                    CMsgSpendWager::mut_server_steam_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSpendWager>(
                    "CMsgSpendWager",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSpendWager {
    fn clear(&mut self) {
        self.clear_players();
        self.clear_event_id();
        self.clear_timestamp();
        self.clear_match_id();
        self.clear_server_steam_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSpendWager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSpendWager {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSpendWager_Player {
    // message fields
    account_id: ::std::option::Option<u32>,
    wager: ::std::option::Option<u32>,
    wager_token_item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSpendWager_Player {}

impl CMsgSpendWager_Player {
    pub fn new() -> CMsgSpendWager_Player {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSpendWager_Player {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSpendWager_Player> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSpendWager_Player,
        };
        unsafe {
            instance.get(CMsgSpendWager_Player::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 wager = 2;

    pub fn clear_wager(&mut self) {
        self.wager = ::std::option::Option::None;
    }

    pub fn has_wager(&self) -> bool {
        self.wager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wager(&mut self, v: u32) {
        self.wager = ::std::option::Option::Some(v);
    }

    pub fn get_wager(&self) -> u32 {
        self.wager.unwrap_or(0)
    }

    fn get_wager_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.wager
    }

    fn mut_wager_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.wager
    }

    // optional uint64 wager_token_item_id = 3;

    pub fn clear_wager_token_item_id(&mut self) {
        self.wager_token_item_id = ::std::option::Option::None;
    }

    pub fn has_wager_token_item_id(&self) -> bool {
        self.wager_token_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wager_token_item_id(&mut self, v: u64) {
        self.wager_token_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_wager_token_item_id(&self) -> u64 {
        self.wager_token_item_id.unwrap_or(0)
    }

    fn get_wager_token_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.wager_token_item_id
    }

    fn mut_wager_token_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.wager_token_item_id
    }
}

impl ::protobuf::Message for CMsgSpendWager_Player {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wager = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.wager_token_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wager {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wager_token_item_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.wager {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.wager_token_item_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSpendWager_Player {
    fn new() -> CMsgSpendWager_Player {
        CMsgSpendWager_Player::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSpendWager_Player>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgSpendWager_Player::get_account_id_for_reflect,
                    CMsgSpendWager_Player::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wager",
                    CMsgSpendWager_Player::get_wager_for_reflect,
                    CMsgSpendWager_Player::mut_wager_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "wager_token_item_id",
                    CMsgSpendWager_Player::get_wager_token_item_id_for_reflect,
                    CMsgSpendWager_Player::mut_wager_token_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSpendWager_Player>(
                    "CMsgSpendWager_Player",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSpendWager_Player {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_wager();
        self.clear_wager_token_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSpendWager_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSpendWager_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSignOutXPCoins {
    // message fields
    players: ::protobuf::RepeatedField<CMsgSignOutXPCoins_Player>,
    event_id: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    timestamp: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSignOutXPCoins {}

impl CMsgSignOutXPCoins {
    pub fn new() -> CMsgSignOutXPCoins {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSignOutXPCoins {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSignOutXPCoins> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSignOutXPCoins,
        };
        unsafe {
            instance.get(CMsgSignOutXPCoins::new)
        }
    }

    // repeated .CMsgSignOutXPCoins.Player players = 1;

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgSignOutXPCoins_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSignOutXPCoins_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgSignOutXPCoins_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    pub fn get_players(&self) -> &[CMsgSignOutXPCoins_Player] {
        &self.players
    }

    fn get_players_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgSignOutXPCoins_Player> {
        &self.players
    }

    fn mut_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSignOutXPCoins_Player> {
        &mut self.players
    }

    // optional uint32 event_id = 2;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // optional uint64 match_id = 3;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 timestamp = 4;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }
}

impl ::protobuf::Message for CMsgSignOutXPCoins {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.players {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSignOutXPCoins {
    fn new() -> CMsgSignOutXPCoins {
        CMsgSignOutXPCoins::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSignOutXPCoins>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSignOutXPCoins_Player>>(
                    "players",
                    CMsgSignOutXPCoins::get_players_for_reflect,
                    CMsgSignOutXPCoins::mut_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgSignOutXPCoins::get_event_id_for_reflect,
                    CMsgSignOutXPCoins::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgSignOutXPCoins::get_match_id_for_reflect,
                    CMsgSignOutXPCoins::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgSignOutXPCoins::get_timestamp_for_reflect,
                    CMsgSignOutXPCoins::mut_timestamp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSignOutXPCoins>(
                    "CMsgSignOutXPCoins",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSignOutXPCoins {
    fn clear(&mut self) {
        self.clear_players();
        self.clear_event_id();
        self.clear_match_id();
        self.clear_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSignOutXPCoins {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutXPCoins {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSignOutXPCoins_Player {
    // message fields
    account_id: ::std::option::Option<u32>,
    xp_gained: ::std::option::Option<u32>,
    coins_spent: ::std::option::Option<u32>,
    wager_token_item_id: ::std::option::Option<u64>,
    rank_wager: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSignOutXPCoins_Player {}

impl CMsgSignOutXPCoins_Player {
    pub fn new() -> CMsgSignOutXPCoins_Player {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSignOutXPCoins_Player {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSignOutXPCoins_Player> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSignOutXPCoins_Player,
        };
        unsafe {
            instance.get(CMsgSignOutXPCoins_Player::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 xp_gained = 2;

    pub fn clear_xp_gained(&mut self) {
        self.xp_gained = ::std::option::Option::None;
    }

    pub fn has_xp_gained(&self) -> bool {
        self.xp_gained.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_gained(&mut self, v: u32) {
        self.xp_gained = ::std::option::Option::Some(v);
    }

    pub fn get_xp_gained(&self) -> u32 {
        self.xp_gained.unwrap_or(0)
    }

    fn get_xp_gained_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.xp_gained
    }

    fn mut_xp_gained_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.xp_gained
    }

    // optional uint32 coins_spent = 3;

    pub fn clear_coins_spent(&mut self) {
        self.coins_spent = ::std::option::Option::None;
    }

    pub fn has_coins_spent(&self) -> bool {
        self.coins_spent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coins_spent(&mut self, v: u32) {
        self.coins_spent = ::std::option::Option::Some(v);
    }

    pub fn get_coins_spent(&self) -> u32 {
        self.coins_spent.unwrap_or(0)
    }

    fn get_coins_spent_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.coins_spent
    }

    fn mut_coins_spent_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.coins_spent
    }

    // optional uint64 wager_token_item_id = 4;

    pub fn clear_wager_token_item_id(&mut self) {
        self.wager_token_item_id = ::std::option::Option::None;
    }

    pub fn has_wager_token_item_id(&self) -> bool {
        self.wager_token_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wager_token_item_id(&mut self, v: u64) {
        self.wager_token_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_wager_token_item_id(&self) -> u64 {
        self.wager_token_item_id.unwrap_or(0)
    }

    fn get_wager_token_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.wager_token_item_id
    }

    fn mut_wager_token_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.wager_token_item_id
    }

    // optional uint32 rank_wager = 5;

    pub fn clear_rank_wager(&mut self) {
        self.rank_wager = ::std::option::Option::None;
    }

    pub fn has_rank_wager(&self) -> bool {
        self.rank_wager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_wager(&mut self, v: u32) {
        self.rank_wager = ::std::option::Option::Some(v);
    }

    pub fn get_rank_wager(&self) -> u32 {
        self.rank_wager.unwrap_or(0)
    }

    fn get_rank_wager_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rank_wager
    }

    fn mut_rank_wager_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rank_wager
    }
}

impl ::protobuf::Message for CMsgSignOutXPCoins_Player {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xp_gained = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.coins_spent = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.wager_token_item_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rank_wager = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.xp_gained {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.coins_spent {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wager_token_item_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_wager {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.xp_gained {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.coins_spent {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.wager_token_item_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.rank_wager {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSignOutXPCoins_Player {
    fn new() -> CMsgSignOutXPCoins_Player {
        CMsgSignOutXPCoins_Player::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSignOutXPCoins_Player>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgSignOutXPCoins_Player::get_account_id_for_reflect,
                    CMsgSignOutXPCoins_Player::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "xp_gained",
                    CMsgSignOutXPCoins_Player::get_xp_gained_for_reflect,
                    CMsgSignOutXPCoins_Player::mut_xp_gained_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "coins_spent",
                    CMsgSignOutXPCoins_Player::get_coins_spent_for_reflect,
                    CMsgSignOutXPCoins_Player::mut_coins_spent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "wager_token_item_id",
                    CMsgSignOutXPCoins_Player::get_wager_token_item_id_for_reflect,
                    CMsgSignOutXPCoins_Player::mut_wager_token_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rank_wager",
                    CMsgSignOutXPCoins_Player::get_rank_wager_for_reflect,
                    CMsgSignOutXPCoins_Player::mut_rank_wager_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSignOutXPCoins_Player>(
                    "CMsgSignOutXPCoins_Player",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSignOutXPCoins_Player {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_xp_gained();
        self.clear_coins_spent();
        self.clear_wager_token_item_id();
        self.clear_rank_wager();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSignOutXPCoins_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutXPCoins_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSignOutCommunityGoalProgress {
    // message fields
    event_id: ::std::option::Option<u32>,
    event_increments: ::protobuf::RepeatedField<CMsgSignOutCommunityGoalProgress_EventGoalIncrement>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSignOutCommunityGoalProgress {}

impl CMsgSignOutCommunityGoalProgress {
    pub fn new() -> CMsgSignOutCommunityGoalProgress {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSignOutCommunityGoalProgress {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSignOutCommunityGoalProgress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSignOutCommunityGoalProgress,
        };
        unsafe {
            instance.get(CMsgSignOutCommunityGoalProgress::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // repeated .CMsgSignOutCommunityGoalProgress.EventGoalIncrement event_increments = 2;

    pub fn clear_event_increments(&mut self) {
        self.event_increments.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_increments(&mut self, v: ::protobuf::RepeatedField<CMsgSignOutCommunityGoalProgress_EventGoalIncrement>) {
        self.event_increments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_event_increments(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSignOutCommunityGoalProgress_EventGoalIncrement> {
        &mut self.event_increments
    }

    // Take field
    pub fn take_event_increments(&mut self) -> ::protobuf::RepeatedField<CMsgSignOutCommunityGoalProgress_EventGoalIncrement> {
        ::std::mem::replace(&mut self.event_increments, ::protobuf::RepeatedField::new())
    }

    pub fn get_event_increments(&self) -> &[CMsgSignOutCommunityGoalProgress_EventGoalIncrement] {
        &self.event_increments
    }

    fn get_event_increments_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgSignOutCommunityGoalProgress_EventGoalIncrement> {
        &self.event_increments
    }

    fn mut_event_increments_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSignOutCommunityGoalProgress_EventGoalIncrement> {
        &mut self.event_increments
    }
}

impl ::protobuf::Message for CMsgSignOutCommunityGoalProgress {
    fn is_initialized(&self) -> bool {
        for v in &self.event_increments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.event_increments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.event_increments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.event_increments {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSignOutCommunityGoalProgress {
    fn new() -> CMsgSignOutCommunityGoalProgress {
        CMsgSignOutCommunityGoalProgress::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSignOutCommunityGoalProgress>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgSignOutCommunityGoalProgress::get_event_id_for_reflect,
                    CMsgSignOutCommunityGoalProgress::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSignOutCommunityGoalProgress_EventGoalIncrement>>(
                    "event_increments",
                    CMsgSignOutCommunityGoalProgress::get_event_increments_for_reflect,
                    CMsgSignOutCommunityGoalProgress::mut_event_increments_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSignOutCommunityGoalProgress>(
                    "CMsgSignOutCommunityGoalProgress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSignOutCommunityGoalProgress {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_event_increments();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSignOutCommunityGoalProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutCommunityGoalProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSignOutCommunityGoalProgress_EventGoalIncrement {
    // message fields
    event_goal_id: ::std::option::Option<u32>,
    increment_amount: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSignOutCommunityGoalProgress_EventGoalIncrement {}

impl CMsgSignOutCommunityGoalProgress_EventGoalIncrement {
    pub fn new() -> CMsgSignOutCommunityGoalProgress_EventGoalIncrement {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSignOutCommunityGoalProgress_EventGoalIncrement {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSignOutCommunityGoalProgress_EventGoalIncrement> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSignOutCommunityGoalProgress_EventGoalIncrement,
        };
        unsafe {
            instance.get(CMsgSignOutCommunityGoalProgress_EventGoalIncrement::new)
        }
    }

    // optional uint32 event_goal_id = 1;

    pub fn clear_event_goal_id(&mut self) {
        self.event_goal_id = ::std::option::Option::None;
    }

    pub fn has_event_goal_id(&self) -> bool {
        self.event_goal_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_goal_id(&mut self, v: u32) {
        self.event_goal_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_goal_id(&self) -> u32 {
        self.event_goal_id.unwrap_or(0)
    }

    fn get_event_goal_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_goal_id
    }

    fn mut_event_goal_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_goal_id
    }

    // optional uint32 increment_amount = 2;

    pub fn clear_increment_amount(&mut self) {
        self.increment_amount = ::std::option::Option::None;
    }

    pub fn has_increment_amount(&self) -> bool {
        self.increment_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_increment_amount(&mut self, v: u32) {
        self.increment_amount = ::std::option::Option::Some(v);
    }

    pub fn get_increment_amount(&self) -> u32 {
        self.increment_amount.unwrap_or(0)
    }

    fn get_increment_amount_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.increment_amount
    }

    fn mut_increment_amount_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.increment_amount
    }
}

impl ::protobuf::Message for CMsgSignOutCommunityGoalProgress_EventGoalIncrement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_goal_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.increment_amount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_goal_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.increment_amount {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_goal_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.increment_amount {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSignOutCommunityGoalProgress_EventGoalIncrement {
    fn new() -> CMsgSignOutCommunityGoalProgress_EventGoalIncrement {
        CMsgSignOutCommunityGoalProgress_EventGoalIncrement::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSignOutCommunityGoalProgress_EventGoalIncrement>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_goal_id",
                    CMsgSignOutCommunityGoalProgress_EventGoalIncrement::get_event_goal_id_for_reflect,
                    CMsgSignOutCommunityGoalProgress_EventGoalIncrement::mut_event_goal_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "increment_amount",
                    CMsgSignOutCommunityGoalProgress_EventGoalIncrement::get_increment_amount_for_reflect,
                    CMsgSignOutCommunityGoalProgress_EventGoalIncrement::mut_increment_amount_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSignOutCommunityGoalProgress_EventGoalIncrement>(
                    "CMsgSignOutCommunityGoalProgress_EventGoalIncrement",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSignOutCommunityGoalProgress_EventGoalIncrement {
    fn clear(&mut self) {
        self.clear_event_goal_id();
        self.clear_increment_amount();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSignOutCommunityGoalProgress_EventGoalIncrement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSignOutCommunityGoalProgress_EventGoalIncrement {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCPostMatchTip {
    // message fields
    event_id: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    tipper_account_id: ::std::option::Option<u32>,
    recipient_account_id: ::std::option::Option<u32>,
    tip_amount: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCPostMatchTip {}

impl CMsgServerToGCPostMatchTip {
    pub fn new() -> CMsgServerToGCPostMatchTip {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCPostMatchTip {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCPostMatchTip> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCPostMatchTip,
        };
        unsafe {
            instance.get(CMsgServerToGCPostMatchTip::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // optional uint64 match_id = 2;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 tipper_account_id = 3;

    pub fn clear_tipper_account_id(&mut self) {
        self.tipper_account_id = ::std::option::Option::None;
    }

    pub fn has_tipper_account_id(&self) -> bool {
        self.tipper_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tipper_account_id(&mut self, v: u32) {
        self.tipper_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_tipper_account_id(&self) -> u32 {
        self.tipper_account_id.unwrap_or(0)
    }

    fn get_tipper_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tipper_account_id
    }

    fn mut_tipper_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tipper_account_id
    }

    // optional uint32 recipient_account_id = 4;

    pub fn clear_recipient_account_id(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
    }

    pub fn has_recipient_account_id(&self) -> bool {
        self.recipient_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_account_id(&mut self, v: u32) {
        self.recipient_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_recipient_account_id(&self) -> u32 {
        self.recipient_account_id.unwrap_or(0)
    }

    fn get_recipient_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.recipient_account_id
    }

    fn mut_recipient_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.recipient_account_id
    }

    // optional uint32 tip_amount = 5;

    pub fn clear_tip_amount(&mut self) {
        self.tip_amount = ::std::option::Option::None;
    }

    pub fn has_tip_amount(&self) -> bool {
        self.tip_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_amount(&mut self, v: u32) {
        self.tip_amount = ::std::option::Option::Some(v);
    }

    pub fn get_tip_amount(&self) -> u32 {
        self.tip_amount.unwrap_or(0)
    }

    fn get_tip_amount_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tip_amount
    }

    fn mut_tip_amount_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tip_amount
    }
}

impl ::protobuf::Message for CMsgServerToGCPostMatchTip {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tipper_account_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recipient_account_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tip_amount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tipper_account_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.recipient_account_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tip_amount {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.tipper_account_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.recipient_account_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tip_amount {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCPostMatchTip {
    fn new() -> CMsgServerToGCPostMatchTip {
        CMsgServerToGCPostMatchTip::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCPostMatchTip>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgServerToGCPostMatchTip::get_event_id_for_reflect,
                    CMsgServerToGCPostMatchTip::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgServerToGCPostMatchTip::get_match_id_for_reflect,
                    CMsgServerToGCPostMatchTip::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tipper_account_id",
                    CMsgServerToGCPostMatchTip::get_tipper_account_id_for_reflect,
                    CMsgServerToGCPostMatchTip::mut_tipper_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "recipient_account_id",
                    CMsgServerToGCPostMatchTip::get_recipient_account_id_for_reflect,
                    CMsgServerToGCPostMatchTip::mut_recipient_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tip_amount",
                    CMsgServerToGCPostMatchTip::get_tip_amount_for_reflect,
                    CMsgServerToGCPostMatchTip::mut_tip_amount_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCPostMatchTip>(
                    "CMsgServerToGCPostMatchTip",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCPostMatchTip {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_match_id();
        self.clear_tipper_account_id();
        self.clear_recipient_account_id();
        self.clear_tip_amount();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCPostMatchTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCPostMatchTip {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCPostMatchTipResponse {
    // message fields
    match_id: ::std::option::Option<u64>,
    tipper_account_id: ::std::option::Option<u32>,
    recipient_account_id: ::std::option::Option<u32>,
    result: ::std::option::Option<CMsgServerToGCPostMatchTipResponse_Result>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCPostMatchTipResponse {}

impl CMsgServerToGCPostMatchTipResponse {
    pub fn new() -> CMsgServerToGCPostMatchTipResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCPostMatchTipResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCPostMatchTipResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCPostMatchTipResponse,
        };
        unsafe {
            instance.get(CMsgServerToGCPostMatchTipResponse::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 tipper_account_id = 2;

    pub fn clear_tipper_account_id(&mut self) {
        self.tipper_account_id = ::std::option::Option::None;
    }

    pub fn has_tipper_account_id(&self) -> bool {
        self.tipper_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tipper_account_id(&mut self, v: u32) {
        self.tipper_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_tipper_account_id(&self) -> u32 {
        self.tipper_account_id.unwrap_or(0)
    }

    fn get_tipper_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tipper_account_id
    }

    fn mut_tipper_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tipper_account_id
    }

    // optional uint32 recipient_account_id = 3;

    pub fn clear_recipient_account_id(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
    }

    pub fn has_recipient_account_id(&self) -> bool {
        self.recipient_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_account_id(&mut self, v: u32) {
        self.recipient_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_recipient_account_id(&self) -> u32 {
        self.recipient_account_id.unwrap_or(0)
    }

    fn get_recipient_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.recipient_account_id
    }

    fn mut_recipient_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.recipient_account_id
    }

    // optional .CMsgServerToGCPostMatchTipResponse.Result result = 4;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgServerToGCPostMatchTipResponse_Result) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgServerToGCPostMatchTipResponse_Result {
        self.result.unwrap_or(CMsgServerToGCPostMatchTipResponse_Result::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgServerToGCPostMatchTipResponse_Result> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgServerToGCPostMatchTipResponse_Result> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgServerToGCPostMatchTipResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tipper_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recipient_account_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tipper_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.recipient_account_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.tipper_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.recipient_account_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(4, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCPostMatchTipResponse {
    fn new() -> CMsgServerToGCPostMatchTipResponse {
        CMsgServerToGCPostMatchTipResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCPostMatchTipResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgServerToGCPostMatchTipResponse::get_match_id_for_reflect,
                    CMsgServerToGCPostMatchTipResponse::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tipper_account_id",
                    CMsgServerToGCPostMatchTipResponse::get_tipper_account_id_for_reflect,
                    CMsgServerToGCPostMatchTipResponse::mut_tipper_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "recipient_account_id",
                    CMsgServerToGCPostMatchTipResponse::get_recipient_account_id_for_reflect,
                    CMsgServerToGCPostMatchTipResponse::mut_recipient_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgServerToGCPostMatchTipResponse_Result>>(
                    "result",
                    CMsgServerToGCPostMatchTipResponse::get_result_for_reflect,
                    CMsgServerToGCPostMatchTipResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCPostMatchTipResponse>(
                    "CMsgServerToGCPostMatchTipResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCPostMatchTipResponse {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_tipper_account_id();
        self.clear_recipient_account_id();
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCPostMatchTipResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCPostMatchTipResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgServerToGCPostMatchTipResponse_Result {
    SUCCESS = 0,
    FAILURE = 1,
}

impl ::protobuf::ProtobufEnum for CMsgServerToGCPostMatchTipResponse_Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgServerToGCPostMatchTipResponse_Result> {
        match value {
            0 => ::std::option::Option::Some(CMsgServerToGCPostMatchTipResponse_Result::SUCCESS),
            1 => ::std::option::Option::Some(CMsgServerToGCPostMatchTipResponse_Result::FAILURE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgServerToGCPostMatchTipResponse_Result] = &[
            CMsgServerToGCPostMatchTipResponse_Result::SUCCESS,
            CMsgServerToGCPostMatchTipResponse_Result::FAILURE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgServerToGCPostMatchTipResponse_Result>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgServerToGCPostMatchTipResponse_Result", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgServerToGCPostMatchTipResponse_Result {
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCPostMatchTipResponse_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCStartCompendiumInGamePredictions {
    // message fields
    league_id: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    hltv_delay: ::std::option::Option<f32>,
    prediction_ids: ::std::vec::Vec<u32>,
    series_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCStartCompendiumInGamePredictions {}

impl CMsgServerToGCStartCompendiumInGamePredictions {
    pub fn new() -> CMsgServerToGCStartCompendiumInGamePredictions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCStartCompendiumInGamePredictions {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCStartCompendiumInGamePredictions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCStartCompendiumInGamePredictions,
        };
        unsafe {
            instance.get(CMsgServerToGCStartCompendiumInGamePredictions::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional uint64 match_id = 2;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional float hltv_delay = 3;

    pub fn clear_hltv_delay(&mut self) {
        self.hltv_delay = ::std::option::Option::None;
    }

    pub fn has_hltv_delay(&self) -> bool {
        self.hltv_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hltv_delay(&mut self, v: f32) {
        self.hltv_delay = ::std::option::Option::Some(v);
    }

    pub fn get_hltv_delay(&self) -> f32 {
        self.hltv_delay.unwrap_or(0.)
    }

    fn get_hltv_delay_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.hltv_delay
    }

    fn mut_hltv_delay_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.hltv_delay
    }

    // repeated uint32 prediction_ids = 4;

    pub fn clear_prediction_ids(&mut self) {
        self.prediction_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_prediction_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.prediction_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prediction_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.prediction_ids
    }

    // Take field
    pub fn take_prediction_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.prediction_ids, ::std::vec::Vec::new())
    }

    pub fn get_prediction_ids(&self) -> &[u32] {
        &self.prediction_ids
    }

    fn get_prediction_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.prediction_ids
    }

    fn mut_prediction_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.prediction_ids
    }

    // optional uint32 series_id = 5;

    pub fn clear_series_id(&mut self) {
        self.series_id = ::std::option::Option::None;
    }

    pub fn has_series_id(&self) -> bool {
        self.series_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_id(&mut self, v: u32) {
        self.series_id = ::std::option::Option::Some(v);
    }

    pub fn get_series_id(&self) -> u32 {
        self.series_id.unwrap_or(0)
    }

    fn get_series_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.series_id
    }

    fn mut_series_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.series_id
    }
}

impl ::protobuf::Message for CMsgServerToGCStartCompendiumInGamePredictions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.hltv_delay = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.prediction_ids)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.series_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hltv_delay {
            my_size += 5;
        }
        for value in &self.prediction_ids {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.series_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.hltv_delay {
            os.write_float(3, v)?;
        }
        for v in &self.prediction_ids {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.series_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCStartCompendiumInGamePredictions {
    fn new() -> CMsgServerToGCStartCompendiumInGamePredictions {
        CMsgServerToGCStartCompendiumInGamePredictions::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCStartCompendiumInGamePredictions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgServerToGCStartCompendiumInGamePredictions::get_league_id_for_reflect,
                    CMsgServerToGCStartCompendiumInGamePredictions::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgServerToGCStartCompendiumInGamePredictions::get_match_id_for_reflect,
                    CMsgServerToGCStartCompendiumInGamePredictions::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "hltv_delay",
                    CMsgServerToGCStartCompendiumInGamePredictions::get_hltv_delay_for_reflect,
                    CMsgServerToGCStartCompendiumInGamePredictions::mut_hltv_delay_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prediction_ids",
                    CMsgServerToGCStartCompendiumInGamePredictions::get_prediction_ids_for_reflect,
                    CMsgServerToGCStartCompendiumInGamePredictions::mut_prediction_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "series_id",
                    CMsgServerToGCStartCompendiumInGamePredictions::get_series_id_for_reflect,
                    CMsgServerToGCStartCompendiumInGamePredictions::mut_series_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCStartCompendiumInGamePredictions>(
                    "CMsgServerToGCStartCompendiumInGamePredictions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCStartCompendiumInGamePredictions {
    fn clear(&mut self) {
        self.clear_league_id();
        self.clear_match_id();
        self.clear_hltv_delay();
        self.clear_prediction_ids();
        self.clear_series_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCStartCompendiumInGamePredictions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCStartCompendiumInGamePredictions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCStartCompendiumInGamePredictionsResponse {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCStartCompendiumInGamePredictionsResponse {}

impl CMsgServerToGCStartCompendiumInGamePredictionsResponse {
    pub fn new() -> CMsgServerToGCStartCompendiumInGamePredictionsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCStartCompendiumInGamePredictionsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCStartCompendiumInGamePredictionsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCStartCompendiumInGamePredictionsResponse,
        };
        unsafe {
            instance.get(CMsgServerToGCStartCompendiumInGamePredictionsResponse::new)
        }
    }

    // optional bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgServerToGCStartCompendiumInGamePredictionsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCStartCompendiumInGamePredictionsResponse {
    fn new() -> CMsgServerToGCStartCompendiumInGamePredictionsResponse {
        CMsgServerToGCStartCompendiumInGamePredictionsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCStartCompendiumInGamePredictionsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    CMsgServerToGCStartCompendiumInGamePredictionsResponse::get_result_for_reflect,
                    CMsgServerToGCStartCompendiumInGamePredictionsResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCStartCompendiumInGamePredictionsResponse>(
                    "CMsgServerToGCStartCompendiumInGamePredictionsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCStartCompendiumInGamePredictionsResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCStartCompendiumInGamePredictionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCStartCompendiumInGamePredictionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    // message fields
    match_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCCloseCompendiumInGamePredictionVoting {}

impl CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    pub fn new() -> CMsgServerToGCCloseCompendiumInGamePredictionVoting {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCCloseCompendiumInGamePredictionVoting {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCCloseCompendiumInGamePredictionVoting> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCCloseCompendiumInGamePredictionVoting,
        };
        unsafe {
            instance.get(CMsgServerToGCCloseCompendiumInGamePredictionVoting::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }
}

impl ::protobuf::Message for CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    fn new() -> CMsgServerToGCCloseCompendiumInGamePredictionVoting {
        CMsgServerToGCCloseCompendiumInGamePredictionVoting::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCCloseCompendiumInGamePredictionVoting>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgServerToGCCloseCompendiumInGamePredictionVoting::get_match_id_for_reflect,
                    CMsgServerToGCCloseCompendiumInGamePredictionVoting::mut_match_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCCloseCompendiumInGamePredictionVoting>(
                    "CMsgServerToGCCloseCompendiumInGamePredictionVoting",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    fn clear(&mut self) {
        self.clear_match_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {}

impl CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    pub fn new() -> CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse,
        };
        unsafe {
            instance.get(CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse::new)
        }
    }

    // optional bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    fn new() -> CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
        CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse::get_result_for_reflect,
                    CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse>(
                    "CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCEndCompendiumInGamePredictions {
    // message fields
    match_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCEndCompendiumInGamePredictions {}

impl CMsgServerToGCEndCompendiumInGamePredictions {
    pub fn new() -> CMsgServerToGCEndCompendiumInGamePredictions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCEndCompendiumInGamePredictions {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCEndCompendiumInGamePredictions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCEndCompendiumInGamePredictions,
        };
        unsafe {
            instance.get(CMsgServerToGCEndCompendiumInGamePredictions::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }
}

impl ::protobuf::Message for CMsgServerToGCEndCompendiumInGamePredictions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCEndCompendiumInGamePredictions {
    fn new() -> CMsgServerToGCEndCompendiumInGamePredictions {
        CMsgServerToGCEndCompendiumInGamePredictions::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCEndCompendiumInGamePredictions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgServerToGCEndCompendiumInGamePredictions::get_match_id_for_reflect,
                    CMsgServerToGCEndCompendiumInGamePredictions::mut_match_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCEndCompendiumInGamePredictions>(
                    "CMsgServerToGCEndCompendiumInGamePredictions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCEndCompendiumInGamePredictions {
    fn clear(&mut self) {
        self.clear_match_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCEndCompendiumInGamePredictions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCEndCompendiumInGamePredictions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCEndCompendiumInGamePredictionsResponse {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCEndCompendiumInGamePredictionsResponse {}

impl CMsgServerToGCEndCompendiumInGamePredictionsResponse {
    pub fn new() -> CMsgServerToGCEndCompendiumInGamePredictionsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCEndCompendiumInGamePredictionsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCEndCompendiumInGamePredictionsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCEndCompendiumInGamePredictionsResponse,
        };
        unsafe {
            instance.get(CMsgServerToGCEndCompendiumInGamePredictionsResponse::new)
        }
    }

    // optional bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgServerToGCEndCompendiumInGamePredictionsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCEndCompendiumInGamePredictionsResponse {
    fn new() -> CMsgServerToGCEndCompendiumInGamePredictionsResponse {
        CMsgServerToGCEndCompendiumInGamePredictionsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCEndCompendiumInGamePredictionsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    CMsgServerToGCEndCompendiumInGamePredictionsResponse::get_result_for_reflect,
                    CMsgServerToGCEndCompendiumInGamePredictionsResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCEndCompendiumInGamePredictionsResponse>(
                    "CMsgServerToGCEndCompendiumInGamePredictionsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCEndCompendiumInGamePredictionsResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCEndCompendiumInGamePredictionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCEndCompendiumInGamePredictionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCCompendiumInGamePredictionResults {
    // message fields
    match_id: ::std::option::Option<u64>,
    results: ::protobuf::RepeatedField<CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCCompendiumInGamePredictionResults {}

impl CMsgServerToGCCompendiumInGamePredictionResults {
    pub fn new() -> CMsgServerToGCCompendiumInGamePredictionResults {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCCompendiumInGamePredictionResults {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCCompendiumInGamePredictionResults> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCCompendiumInGamePredictionResults,
        };
        unsafe {
            instance.get(CMsgServerToGCCompendiumInGamePredictionResults::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // repeated .CMsgServerToGCCompendiumInGamePredictionResults.PredictionResult results = 2;

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }

    pub fn get_results(&self) -> &[CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult] {
        &self.results
    }

    fn get_results_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult> {
        &self.results
    }

    fn mut_results_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult> {
        &mut self.results
    }
}

impl ::protobuf::Message for CMsgServerToGCCompendiumInGamePredictionResults {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.results {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCCompendiumInGamePredictionResults {
    fn new() -> CMsgServerToGCCompendiumInGamePredictionResults {
        CMsgServerToGCCompendiumInGamePredictionResults::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCCompendiumInGamePredictionResults>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgServerToGCCompendiumInGamePredictionResults::get_match_id_for_reflect,
                    CMsgServerToGCCompendiumInGamePredictionResults::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult>>(
                    "results",
                    CMsgServerToGCCompendiumInGamePredictionResults::get_results_for_reflect,
                    CMsgServerToGCCompendiumInGamePredictionResults::mut_results_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCCompendiumInGamePredictionResults>(
                    "CMsgServerToGCCompendiumInGamePredictionResults",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCCompendiumInGamePredictionResults {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_results();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCCompendiumInGamePredictionResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCCompendiumInGamePredictionResults {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult {
    // message fields
    prediction_id: ::std::option::Option<u32>,
    prediction_value: ::std::option::Option<u32>,
    prediction_value_is_mask: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult {}

impl CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult {
    pub fn new() -> CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult,
        };
        unsafe {
            instance.get(CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult::new)
        }
    }

    // optional uint32 prediction_id = 1;

    pub fn clear_prediction_id(&mut self) {
        self.prediction_id = ::std::option::Option::None;
    }

    pub fn has_prediction_id(&self) -> bool {
        self.prediction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prediction_id(&mut self, v: u32) {
        self.prediction_id = ::std::option::Option::Some(v);
    }

    pub fn get_prediction_id(&self) -> u32 {
        self.prediction_id.unwrap_or(0)
    }

    fn get_prediction_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prediction_id
    }

    fn mut_prediction_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prediction_id
    }

    // optional uint32 prediction_value = 2;

    pub fn clear_prediction_value(&mut self) {
        self.prediction_value = ::std::option::Option::None;
    }

    pub fn has_prediction_value(&self) -> bool {
        self.prediction_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prediction_value(&mut self, v: u32) {
        self.prediction_value = ::std::option::Option::Some(v);
    }

    pub fn get_prediction_value(&self) -> u32 {
        self.prediction_value.unwrap_or(0)
    }

    fn get_prediction_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prediction_value
    }

    fn mut_prediction_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prediction_value
    }

    // optional bool prediction_value_is_mask = 3;

    pub fn clear_prediction_value_is_mask(&mut self) {
        self.prediction_value_is_mask = ::std::option::Option::None;
    }

    pub fn has_prediction_value_is_mask(&self) -> bool {
        self.prediction_value_is_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prediction_value_is_mask(&mut self, v: bool) {
        self.prediction_value_is_mask = ::std::option::Option::Some(v);
    }

    pub fn get_prediction_value_is_mask(&self) -> bool {
        self.prediction_value_is_mask.unwrap_or(false)
    }

    fn get_prediction_value_is_mask_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.prediction_value_is_mask
    }

    fn mut_prediction_value_is_mask_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.prediction_value_is_mask
    }
}

impl ::protobuf::Message for CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prediction_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prediction_value = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prediction_value_is_mask = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.prediction_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prediction_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prediction_value_is_mask {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prediction_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.prediction_value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.prediction_value_is_mask {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult {
    fn new() -> CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult {
        CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prediction_id",
                    CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult::get_prediction_id_for_reflect,
                    CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult::mut_prediction_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prediction_value",
                    CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult::get_prediction_value_for_reflect,
                    CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult::mut_prediction_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "prediction_value_is_mask",
                    CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult::get_prediction_value_is_mask_for_reflect,
                    CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult::mut_prediction_value_is_mask_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult>(
                    "CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult {
    fn clear(&mut self) {
        self.clear_prediction_id();
        self.clear_prediction_value();
        self.clear_prediction_value_is_mask();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCCompendiumInGamePredictionResultsResponse {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCCompendiumInGamePredictionResultsResponse {}

impl CMsgServerToGCCompendiumInGamePredictionResultsResponse {
    pub fn new() -> CMsgServerToGCCompendiumInGamePredictionResultsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCCompendiumInGamePredictionResultsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCCompendiumInGamePredictionResultsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCCompendiumInGamePredictionResultsResponse,
        };
        unsafe {
            instance.get(CMsgServerToGCCompendiumInGamePredictionResultsResponse::new)
        }
    }

    // optional bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgServerToGCCompendiumInGamePredictionResultsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCCompendiumInGamePredictionResultsResponse {
    fn new() -> CMsgServerToGCCompendiumInGamePredictionResultsResponse {
        CMsgServerToGCCompendiumInGamePredictionResultsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCCompendiumInGamePredictionResultsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    CMsgServerToGCCompendiumInGamePredictionResultsResponse::get_result_for_reflect,
                    CMsgServerToGCCompendiumInGamePredictionResultsResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCCompendiumInGamePredictionResultsResponse>(
                    "CMsgServerToGCCompendiumInGamePredictionResultsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCCompendiumInGamePredictionResultsResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCCompendiumInGamePredictionResultsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCCompendiumInGamePredictionResultsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCCompendiumInGamePredictionResults {
    // message fields
    results: ::protobuf::SingularPtrField<CMsgServerToGCCompendiumInGamePredictionResults>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCCompendiumInGamePredictionResults {}

impl CMsgGCToGCCompendiumInGamePredictionResults {
    pub fn new() -> CMsgGCToGCCompendiumInGamePredictionResults {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCCompendiumInGamePredictionResults {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCCompendiumInGamePredictionResults> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCCompendiumInGamePredictionResults,
        };
        unsafe {
            instance.get(CMsgGCToGCCompendiumInGamePredictionResults::new)
        }
    }

    // optional .CMsgServerToGCCompendiumInGamePredictionResults results = 1;

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    pub fn has_results(&self) -> bool {
        self.results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: CMsgServerToGCCompendiumInGamePredictionResults) {
        self.results = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_results(&mut self) -> &mut CMsgServerToGCCompendiumInGamePredictionResults {
        if self.results.is_none() {
            self.results.set_default();
        }
        self.results.as_mut().unwrap()
    }

    // Take field
    pub fn take_results(&mut self) -> CMsgServerToGCCompendiumInGamePredictionResults {
        self.results.take().unwrap_or_else(|| CMsgServerToGCCompendiumInGamePredictionResults::new())
    }

    pub fn get_results(&self) -> &CMsgServerToGCCompendiumInGamePredictionResults {
        self.results.as_ref().unwrap_or_else(|| CMsgServerToGCCompendiumInGamePredictionResults::default_instance())
    }

    fn get_results_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgServerToGCCompendiumInGamePredictionResults> {
        &self.results
    }

    fn mut_results_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgServerToGCCompendiumInGamePredictionResults> {
        &mut self.results
    }
}

impl ::protobuf::Message for CMsgGCToGCCompendiumInGamePredictionResults {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.results.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.results.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCCompendiumInGamePredictionResults {
    fn new() -> CMsgGCToGCCompendiumInGamePredictionResults {
        CMsgGCToGCCompendiumInGamePredictionResults::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCCompendiumInGamePredictionResults>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgServerToGCCompendiumInGamePredictionResults>>(
                    "results",
                    CMsgGCToGCCompendiumInGamePredictionResults::get_results_for_reflect,
                    CMsgGCToGCCompendiumInGamePredictionResults::mut_results_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCCompendiumInGamePredictionResults>(
                    "CMsgGCToGCCompendiumInGamePredictionResults",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCCompendiumInGamePredictionResults {
    fn clear(&mut self) {
        self.clear_results();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCCompendiumInGamePredictionResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCCompendiumInGamePredictionResults {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCMatchPlayerItemPurchaseHistory {
    // message fields
    match_id: ::std::option::Option<u64>,
    mmr: ::std::option::Option<u32>,
    players: ::protobuf::RepeatedField<CMsgServerToGCMatchPlayerItemPurchaseHistory_Player>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCMatchPlayerItemPurchaseHistory {}

impl CMsgServerToGCMatchPlayerItemPurchaseHistory {
    pub fn new() -> CMsgServerToGCMatchPlayerItemPurchaseHistory {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCMatchPlayerItemPurchaseHistory {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCMatchPlayerItemPurchaseHistory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCMatchPlayerItemPurchaseHistory,
        };
        unsafe {
            instance.get(CMsgServerToGCMatchPlayerItemPurchaseHistory::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 mmr = 2;

    pub fn clear_mmr(&mut self) {
        self.mmr = ::std::option::Option::None;
    }

    pub fn has_mmr(&self) -> bool {
        self.mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mmr(&mut self, v: u32) {
        self.mmr = ::std::option::Option::Some(v);
    }

    pub fn get_mmr(&self) -> u32 {
        self.mmr.unwrap_or(0)
    }

    fn get_mmr_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mmr
    }

    fn mut_mmr_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mmr
    }

    // repeated .CMsgServerToGCMatchPlayerItemPurchaseHistory.Player players = 3;

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgServerToGCMatchPlayerItemPurchaseHistory_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCMatchPlayerItemPurchaseHistory_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgServerToGCMatchPlayerItemPurchaseHistory_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    pub fn get_players(&self) -> &[CMsgServerToGCMatchPlayerItemPurchaseHistory_Player] {
        &self.players
    }

    fn get_players_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgServerToGCMatchPlayerItemPurchaseHistory_Player> {
        &self.players
    }

    fn mut_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCMatchPlayerItemPurchaseHistory_Player> {
        &mut self.players
    }
}

impl ::protobuf::Message for CMsgServerToGCMatchPlayerItemPurchaseHistory {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mmr = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mmr {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.mmr {
            os.write_uint32(2, v)?;
        }
        for v in &self.players {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCMatchPlayerItemPurchaseHistory {
    fn new() -> CMsgServerToGCMatchPlayerItemPurchaseHistory {
        CMsgServerToGCMatchPlayerItemPurchaseHistory::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCMatchPlayerItemPurchaseHistory>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgServerToGCMatchPlayerItemPurchaseHistory::get_match_id_for_reflect,
                    CMsgServerToGCMatchPlayerItemPurchaseHistory::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mmr",
                    CMsgServerToGCMatchPlayerItemPurchaseHistory::get_mmr_for_reflect,
                    CMsgServerToGCMatchPlayerItemPurchaseHistory::mut_mmr_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgServerToGCMatchPlayerItemPurchaseHistory_Player>>(
                    "players",
                    CMsgServerToGCMatchPlayerItemPurchaseHistory::get_players_for_reflect,
                    CMsgServerToGCMatchPlayerItemPurchaseHistory::mut_players_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCMatchPlayerItemPurchaseHistory>(
                    "CMsgServerToGCMatchPlayerItemPurchaseHistory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCMatchPlayerItemPurchaseHistory {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_mmr();
        self.clear_players();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCMatchPlayerItemPurchaseHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCMatchPlayerItemPurchaseHistory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase {
    // message fields
    item: ::std::option::Option<u32>,
    gold: ::std::option::Option<u32>,
    net_worth: ::std::option::Option<u32>,
    game_time: ::std::option::Option<u32>,
    inventory_items: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase {}

impl CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase {
    pub fn new() -> CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase,
        };
        unsafe {
            instance.get(CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase::new)
        }
    }

    // optional uint32 item = 1;

    pub fn clear_item(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: u32) {
        self.item = ::std::option::Option::Some(v);
    }

    pub fn get_item(&self) -> u32 {
        self.item.unwrap_or(0)
    }

    fn get_item_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item
    }

    fn mut_item_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item
    }

    // optional uint32 gold = 2;

    pub fn clear_gold(&mut self) {
        self.gold = ::std::option::Option::None;
    }

    pub fn has_gold(&self) -> bool {
        self.gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold(&mut self, v: u32) {
        self.gold = ::std::option::Option::Some(v);
    }

    pub fn get_gold(&self) -> u32 {
        self.gold.unwrap_or(0)
    }

    fn get_gold_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gold
    }

    fn mut_gold_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gold
    }

    // optional uint32 net_worth = 3;

    pub fn clear_net_worth(&mut self) {
        self.net_worth = ::std::option::Option::None;
    }

    pub fn has_net_worth(&self) -> bool {
        self.net_worth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_worth(&mut self, v: u32) {
        self.net_worth = ::std::option::Option::Some(v);
    }

    pub fn get_net_worth(&self) -> u32 {
        self.net_worth.unwrap_or(0)
    }

    fn get_net_worth_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.net_worth
    }

    fn mut_net_worth_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.net_worth
    }

    // optional uint32 game_time = 4;

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: u32) {
        self.game_time = ::std::option::Option::Some(v);
    }

    pub fn get_game_time(&self) -> u32 {
        self.game_time.unwrap_or(0)
    }

    fn get_game_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.game_time
    }

    fn mut_game_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.game_time
    }

    // repeated uint32 inventory_items = 5;

    pub fn clear_inventory_items(&mut self) {
        self.inventory_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_inventory_items(&mut self, v: ::std::vec::Vec<u32>) {
        self.inventory_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inventory_items(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.inventory_items
    }

    // Take field
    pub fn take_inventory_items(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.inventory_items, ::std::vec::Vec::new())
    }

    pub fn get_inventory_items(&self) -> &[u32] {
        &self.inventory_items
    }

    fn get_inventory_items_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.inventory_items
    }

    fn mut_inventory_items_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.inventory_items
    }
}

impl ::protobuf::Message for CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gold = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.net_worth = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_time = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.inventory_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gold {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.net_worth {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_time {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.inventory_items {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gold {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.net_worth {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_time {
            os.write_uint32(4, v)?;
        }
        for v in &self.inventory_items {
            os.write_uint32(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase {
    fn new() -> CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase {
        CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item",
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase::get_item_for_reflect,
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase::mut_item_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gold",
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase::get_gold_for_reflect,
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase::mut_gold_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "net_worth",
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase::get_net_worth_for_reflect,
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase::mut_net_worth_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_time",
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase::get_game_time_for_reflect,
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase::mut_game_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "inventory_items",
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase::get_inventory_items_for_reflect,
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase::mut_inventory_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase>(
                    "CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase {
    fn clear(&mut self) {
        self.clear_item();
        self.clear_gold();
        self.clear_net_worth();
        self.clear_game_time();
        self.clear_inventory_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCMatchPlayerItemPurchaseHistory_Player {
    // message fields
    player_slot: ::std::option::Option<u32>,
    account_id: ::std::option::Option<u32>,
    hero_id: ::std::option::Option<u32>,
    allied_hero_ids: ::std::vec::Vec<u32>,
    enemy_hero_ids: ::std::vec::Vec<u32>,
    item_purchases: ::protobuf::RepeatedField<CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCMatchPlayerItemPurchaseHistory_Player {}

impl CMsgServerToGCMatchPlayerItemPurchaseHistory_Player {
    pub fn new() -> CMsgServerToGCMatchPlayerItemPurchaseHistory_Player {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCMatchPlayerItemPurchaseHistory_Player {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCMatchPlayerItemPurchaseHistory_Player> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCMatchPlayerItemPurchaseHistory_Player,
        };
        unsafe {
            instance.get(CMsgServerToGCMatchPlayerItemPurchaseHistory_Player::new)
        }
    }

    // optional uint32 player_slot = 1;

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: u32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    pub fn get_player_slot(&self) -> u32 {
        self.player_slot.unwrap_or(0)
    }

    fn get_player_slot_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_slot
    }

    fn mut_player_slot_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_slot
    }

    // optional uint32 account_id = 2;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 hero_id = 3;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // repeated uint32 allied_hero_ids = 4;

    pub fn clear_allied_hero_ids(&mut self) {
        self.allied_hero_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_allied_hero_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.allied_hero_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allied_hero_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.allied_hero_ids
    }

    // Take field
    pub fn take_allied_hero_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.allied_hero_ids, ::std::vec::Vec::new())
    }

    pub fn get_allied_hero_ids(&self) -> &[u32] {
        &self.allied_hero_ids
    }

    fn get_allied_hero_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.allied_hero_ids
    }

    fn mut_allied_hero_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.allied_hero_ids
    }

    // repeated uint32 enemy_hero_ids = 5;

    pub fn clear_enemy_hero_ids(&mut self) {
        self.enemy_hero_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_enemy_hero_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.enemy_hero_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enemy_hero_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.enemy_hero_ids
    }

    // Take field
    pub fn take_enemy_hero_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.enemy_hero_ids, ::std::vec::Vec::new())
    }

    pub fn get_enemy_hero_ids(&self) -> &[u32] {
        &self.enemy_hero_ids
    }

    fn get_enemy_hero_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.enemy_hero_ids
    }

    fn mut_enemy_hero_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.enemy_hero_ids
    }

    // repeated .CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase item_purchases = 6;

    pub fn clear_item_purchases(&mut self) {
        self.item_purchases.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_purchases(&mut self, v: ::protobuf::RepeatedField<CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase>) {
        self.item_purchases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_purchases(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase> {
        &mut self.item_purchases
    }

    // Take field
    pub fn take_item_purchases(&mut self) -> ::protobuf::RepeatedField<CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase> {
        ::std::mem::replace(&mut self.item_purchases, ::protobuf::RepeatedField::new())
    }

    pub fn get_item_purchases(&self) -> &[CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase] {
        &self.item_purchases
    }

    fn get_item_purchases_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase> {
        &self.item_purchases
    }

    fn mut_item_purchases_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase> {
        &mut self.item_purchases
    }
}

impl ::protobuf::Message for CMsgServerToGCMatchPlayerItemPurchaseHistory_Player {
    fn is_initialized(&self) -> bool {
        for v in &self.item_purchases {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_slot = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.allied_hero_ids)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.enemy_hero_ids)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.item_purchases)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_slot {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.allied_hero_ids {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.enemy_hero_ids {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.item_purchases {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_slot {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(3, v)?;
        }
        for v in &self.allied_hero_ids {
            os.write_uint32(4, *v)?;
        };
        for v in &self.enemy_hero_ids {
            os.write_uint32(5, *v)?;
        };
        for v in &self.item_purchases {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCMatchPlayerItemPurchaseHistory_Player {
    fn new() -> CMsgServerToGCMatchPlayerItemPurchaseHistory_Player {
        CMsgServerToGCMatchPlayerItemPurchaseHistory_Player::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCMatchPlayerItemPurchaseHistory_Player>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_slot",
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_Player::get_player_slot_for_reflect,
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_Player::mut_player_slot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_Player::get_account_id_for_reflect,
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_Player::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_Player::get_hero_id_for_reflect,
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_Player::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "allied_hero_ids",
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_Player::get_allied_hero_ids_for_reflect,
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_Player::mut_allied_hero_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "enemy_hero_ids",
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_Player::get_enemy_hero_ids_for_reflect,
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_Player::mut_enemy_hero_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase>>(
                    "item_purchases",
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_Player::get_item_purchases_for_reflect,
                    CMsgServerToGCMatchPlayerItemPurchaseHistory_Player::mut_item_purchases_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCMatchPlayerItemPurchaseHistory_Player>(
                    "CMsgServerToGCMatchPlayerItemPurchaseHistory_Player",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCMatchPlayerItemPurchaseHistory_Player {
    fn clear(&mut self) {
        self.clear_player_slot();
        self.clear_account_id();
        self.clear_hero_id();
        self.clear_allied_hero_ids();
        self.clear_enemy_hero_ids();
        self.clear_item_purchases();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCMatchPlayerItemPurchaseHistory_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCMatchPlayerItemPurchaseHistory_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EPoorNetworkConditionsType {
    k_EPoorNetworkConditions_None = 0,
    k_EPoorNetworkConditions_Unknown = 1,
    k_EPoorNetworkConditions_MassDisconnect = 2,
    k_EPoorNetworkConditions_ExcessBadQosIntervals = 3,
}

impl ::protobuf::ProtobufEnum for EPoorNetworkConditionsType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPoorNetworkConditionsType> {
        match value {
            0 => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_None),
            1 => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_Unknown),
            2 => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_MassDisconnect),
            3 => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_ExcessBadQosIntervals),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EPoorNetworkConditionsType] = &[
            EPoorNetworkConditionsType::k_EPoorNetworkConditions_None,
            EPoorNetworkConditionsType::k_EPoorNetworkConditions_Unknown,
            EPoorNetworkConditionsType::k_EPoorNetworkConditions_MassDisconnect,
            EPoorNetworkConditionsType::k_EPoorNetworkConditions_ExcessBadQosIntervals,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EPoorNetworkConditionsType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EPoorNetworkConditionsType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EPoorNetworkConditionsType {
}

impl ::protobuf::reflect::ProtobufValue for EPoorNetworkConditionsType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EAbilityAbuseType {
    k_EAbilityAbuseType_None = 0,
    k_EAbilityAbuseType_Io_Relocate = 1,
    k_EAbilityAbuseType_Chen_Test_Of_Faith = 2,
    k_EAbilityAbuseType_Bane_Nightmare = 3,
    k_EAbilityAbuseType_Bloodseeker_Bloodrage = 4,
    k_EAbilityAbuseType_Outworld_Astral_Imprisonment = 5,
    k_EAbilityAbuseType_Shadow_Demon_Disruption = 6,
}

impl ::protobuf::ProtobufEnum for EAbilityAbuseType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EAbilityAbuseType> {
        match value {
            0 => ::std::option::Option::Some(EAbilityAbuseType::k_EAbilityAbuseType_None),
            1 => ::std::option::Option::Some(EAbilityAbuseType::k_EAbilityAbuseType_Io_Relocate),
            2 => ::std::option::Option::Some(EAbilityAbuseType::k_EAbilityAbuseType_Chen_Test_Of_Faith),
            3 => ::std::option::Option::Some(EAbilityAbuseType::k_EAbilityAbuseType_Bane_Nightmare),
            4 => ::std::option::Option::Some(EAbilityAbuseType::k_EAbilityAbuseType_Bloodseeker_Bloodrage),
            5 => ::std::option::Option::Some(EAbilityAbuseType::k_EAbilityAbuseType_Outworld_Astral_Imprisonment),
            6 => ::std::option::Option::Some(EAbilityAbuseType::k_EAbilityAbuseType_Shadow_Demon_Disruption),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EAbilityAbuseType] = &[
            EAbilityAbuseType::k_EAbilityAbuseType_None,
            EAbilityAbuseType::k_EAbilityAbuseType_Io_Relocate,
            EAbilityAbuseType::k_EAbilityAbuseType_Chen_Test_Of_Faith,
            EAbilityAbuseType::k_EAbilityAbuseType_Bane_Nightmare,
            EAbilityAbuseType::k_EAbilityAbuseType_Bloodseeker_Bloodrage,
            EAbilityAbuseType::k_EAbilityAbuseType_Outworld_Astral_Imprisonment,
            EAbilityAbuseType::k_EAbilityAbuseType_Shadow_Demon_Disruption,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EAbilityAbuseType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EAbilityAbuseType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EAbilityAbuseType {
}

impl ::protobuf::reflect::ProtobufValue for EAbilityAbuseType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EIntentionalFeedingType {
    k_EIntentionalFeedingType_None = 0,
    k_EIntentionalFeedingType_ExcessiveDeaths = 1,
    k_EIntentionalFeedingType_MultipleCourierPurchases = 2,
    k_EIntentionalFeedingType_MultipleCourierDeaths = 4,
    k_EIntentionalFeedingType_LowActivity = 8,
    k_EIntentionalFeedingType_LowDamage = 16,
    k_EIntentionalFeedingType_HighUnspentGold = 32,
    k_EIntentionalFeedingType_SoldTooMuchItemValue = 64,
    k_EIntentionalFeedingType_TooManyDroppedItems = 128,
    k_EIntentionalFeedingType_ExcessiveTowerDamage = 256,
}

impl ::protobuf::ProtobufEnum for EIntentionalFeedingType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EIntentionalFeedingType> {
        match value {
            0 => ::std::option::Option::Some(EIntentionalFeedingType::k_EIntentionalFeedingType_None),
            1 => ::std::option::Option::Some(EIntentionalFeedingType::k_EIntentionalFeedingType_ExcessiveDeaths),
            2 => ::std::option::Option::Some(EIntentionalFeedingType::k_EIntentionalFeedingType_MultipleCourierPurchases),
            4 => ::std::option::Option::Some(EIntentionalFeedingType::k_EIntentionalFeedingType_MultipleCourierDeaths),
            8 => ::std::option::Option::Some(EIntentionalFeedingType::k_EIntentionalFeedingType_LowActivity),
            16 => ::std::option::Option::Some(EIntentionalFeedingType::k_EIntentionalFeedingType_LowDamage),
            32 => ::std::option::Option::Some(EIntentionalFeedingType::k_EIntentionalFeedingType_HighUnspentGold),
            64 => ::std::option::Option::Some(EIntentionalFeedingType::k_EIntentionalFeedingType_SoldTooMuchItemValue),
            128 => ::std::option::Option::Some(EIntentionalFeedingType::k_EIntentionalFeedingType_TooManyDroppedItems),
            256 => ::std::option::Option::Some(EIntentionalFeedingType::k_EIntentionalFeedingType_ExcessiveTowerDamage),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EIntentionalFeedingType] = &[
            EIntentionalFeedingType::k_EIntentionalFeedingType_None,
            EIntentionalFeedingType::k_EIntentionalFeedingType_ExcessiveDeaths,
            EIntentionalFeedingType::k_EIntentionalFeedingType_MultipleCourierPurchases,
            EIntentionalFeedingType::k_EIntentionalFeedingType_MultipleCourierDeaths,
            EIntentionalFeedingType::k_EIntentionalFeedingType_LowActivity,
            EIntentionalFeedingType::k_EIntentionalFeedingType_LowDamage,
            EIntentionalFeedingType::k_EIntentionalFeedingType_HighUnspentGold,
            EIntentionalFeedingType::k_EIntentionalFeedingType_SoldTooMuchItemValue,
            EIntentionalFeedingType::k_EIntentionalFeedingType_TooManyDroppedItems,
            EIntentionalFeedingType::k_EIntentionalFeedingType_ExcessiveTowerDamage,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EIntentionalFeedingType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EIntentionalFeedingType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EIntentionalFeedingType {
}

impl ::protobuf::reflect::ProtobufValue for EIntentionalFeedingType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ESuspiciousActivity {
    k_ESuspiciousActivity_VAC_MultipleInstances = 1,
    k_ESuspiciousActivity_IntentionalFeeding = 100,
    k_ESuspiciousActivity_SuspectedBotFarming = 101,
}

impl ::protobuf::ProtobufEnum for ESuspiciousActivity {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESuspiciousActivity> {
        match value {
            1 => ::std::option::Option::Some(ESuspiciousActivity::k_ESuspiciousActivity_VAC_MultipleInstances),
            100 => ::std::option::Option::Some(ESuspiciousActivity::k_ESuspiciousActivity_IntentionalFeeding),
            101 => ::std::option::Option::Some(ESuspiciousActivity::k_ESuspiciousActivity_SuspectedBotFarming),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ESuspiciousActivity] = &[
            ESuspiciousActivity::k_ESuspiciousActivity_VAC_MultipleInstances,
            ESuspiciousActivity::k_ESuspiciousActivity_IntentionalFeeding,
            ESuspiciousActivity::k_ESuspiciousActivity_SuspectedBotFarming,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<ESuspiciousActivity>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ESuspiciousActivity", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ESuspiciousActivity {
}

impl ::protobuf::reflect::ProtobufValue for ESuspiciousActivity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ESuspiciousBuildType {
    k_ESuspiciousBuildType_None = 0,
    k_ESuspiciousBuildType_NoGoldSpent = 1,
    k_ESuspiciousBuildType_NoItems = 2,
    k_ESuspiciousBuildType_NoSignificantItems = 3,
    k_ESuspiciousBuildType_TooManyBoots = 4,
    k_ESuspiciousBuildType_Bot1 = 101,
    k_ESuspiciousBuildType_Bot2 = 102,
    k_ESuspiciousBuildType_Bot3 = 103,
    k_ESuspiciousBuildType_Bot4 = 104,
    k_ESuspiciousBuildType_Bot5 = 105,
}

impl ::protobuf::ProtobufEnum for ESuspiciousBuildType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESuspiciousBuildType> {
        match value {
            0 => ::std::option::Option::Some(ESuspiciousBuildType::k_ESuspiciousBuildType_None),
            1 => ::std::option::Option::Some(ESuspiciousBuildType::k_ESuspiciousBuildType_NoGoldSpent),
            2 => ::std::option::Option::Some(ESuspiciousBuildType::k_ESuspiciousBuildType_NoItems),
            3 => ::std::option::Option::Some(ESuspiciousBuildType::k_ESuspiciousBuildType_NoSignificantItems),
            4 => ::std::option::Option::Some(ESuspiciousBuildType::k_ESuspiciousBuildType_TooManyBoots),
            101 => ::std::option::Option::Some(ESuspiciousBuildType::k_ESuspiciousBuildType_Bot1),
            102 => ::std::option::Option::Some(ESuspiciousBuildType::k_ESuspiciousBuildType_Bot2),
            103 => ::std::option::Option::Some(ESuspiciousBuildType::k_ESuspiciousBuildType_Bot3),
            104 => ::std::option::Option::Some(ESuspiciousBuildType::k_ESuspiciousBuildType_Bot4),
            105 => ::std::option::Option::Some(ESuspiciousBuildType::k_ESuspiciousBuildType_Bot5),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ESuspiciousBuildType] = &[
            ESuspiciousBuildType::k_ESuspiciousBuildType_None,
            ESuspiciousBuildType::k_ESuspiciousBuildType_NoGoldSpent,
            ESuspiciousBuildType::k_ESuspiciousBuildType_NoItems,
            ESuspiciousBuildType::k_ESuspiciousBuildType_NoSignificantItems,
            ESuspiciousBuildType::k_ESuspiciousBuildType_TooManyBoots,
            ESuspiciousBuildType::k_ESuspiciousBuildType_Bot1,
            ESuspiciousBuildType::k_ESuspiciousBuildType_Bot2,
            ESuspiciousBuildType::k_ESuspiciousBuildType_Bot3,
            ESuspiciousBuildType::k_ESuspiciousBuildType_Bot4,
            ESuspiciousBuildType::k_ESuspiciousBuildType_Bot5,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<ESuspiciousBuildType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ESuspiciousBuildType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ESuspiciousBuildType {
}

impl ::protobuf::reflect::ProtobufValue for ESuspiciousBuildType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cdota_gcmessages_server.proto\x1a\x13steammessages.proto\x1a\x17dot\
    a_shared_enums.proto\x1a\x1cdota_gcmessages_common.proto\x1a\x15econ_gcm\
    essages.proto\x1a\x18network_connection.proto\x1a-dota_gcmessages_common\
    _match_management.proto\"\x9c\x03\n\x19CMsgPoorNetworkConditions\x12a\n\
    \x0edetection_type\x18\x01\x20\x01(\x0e2\x1b.EPoorNetworkConditionsType:\
    \x1dk_EPoorNetworkConditions_NoneR\rdetectionType\x12;\n\x07players\x18\
    \x02\x20\x03(\x0b2!.CMsgPoorNetworkConditions.PlayerR\x07players\x1a\xde\
    \x01\n\x06Player\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\
    \x12e\n\x11disconnect_reason\x18\x02\x20\x01(\x0e2\x1c.ENetworkDisconnec\
    tionReason:\x1aNETWORK_DISCONNECT_INVALIDR\x10disconnectReason\x12*\n\
    \x11num_bad_intervals\x18\x03\x20\x01(\rR\x0fnumBadIntervals\x12\"\n\rpe\
    ak_loss_pct\x18\x04\x20\x01(\rR\x0bpeakLossPct\"\xdc\x03\n\x13CMsgGamese\
    rverCrash\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\x19\
    \n\x08lobby_id\x18\x02\x20\x01(\x06R\x07lobbyId\x12I\n\ngame_state\x18\
    \x03\x20\x01(\x0e2\x0f.DOTA_GameState:\x19DOTA_GAMERULES_STATE_INITR\tga\
    meState\x12,\n\x12sentinel_save_time\x18\x04\x20\x01(\x07R\x10sentinelSa\
    veTime\x12$\n\x0ecustom_game_id\x18\x0b\x20\x01(\x06R\x0ccustomGameId\
    \x12#\n\rtournament_id\x18\x0c\x20\x01(\rR\x0ctournamentId\x12&\n\x0fser\
    ver_steam_id\x18\x05\x20\x01(\x06R\rserverSteamId\x121\n\x15server_publi\
    c_ip_addr\x18\x06\x20\x01(\x07R\x12serverPublicIpAddr\x12\x1f\n\x0bserve\
    r_port\x18\x07\x20\x01(\rR\nserverPort\x12%\n\x0eserver_cluster\x18\x08\
    \x20\x01(\rR\rserverCluster\x12\x10\n\x03pid\x18\t\x20\x01(\rR\x03pid\
    \x12\x16\n\x06engine\x18\n\x20\x01(\rR\x06engine\"\xfa\x08\n\x14CMsgConn\
    ectedPlayers\x12I\n\x11connected_players\x18\x01\x20\x03(\x0b2\x1c.CMsgC\
    onnectedPlayers.PlayerR\x10connectedPlayers\x12O\n\x14disconnected_playe\
    rs\x18\x07\x20\x03(\x0b2\x1c.CMsgConnectedPlayers.PlayerR\x13disconnecte\
    dPlayers\x12I\n\ngame_state\x18\x02\x20\x01(\x0e2\x0f.DOTA_GameState:\
    \x19DOTA_GAMERULES_STATE_INITR\tgameState\x120\n\x14first_blood_happened\
    \x18\x06\x20\x01(\x08R\x12firstBloodHappened\x124\n\x16legacy_mass_disco\
    nnect\x18\t\x20\x01(\x08R\x14legacyMassDisconnect\x12R\n\x17poor_network\
    _conditions\x18\n\x20\x01(\x0b2\x1a.CMsgPoorNetworkConditionsR\x15poorNe\
    tworkConditions\x12J\n\x0bsend_reason\x18\x08\x20\x01(\x0e2\x20.CMsgConn\
    ectedPlayers.SendReason:\x07INVALIDR\nsendReason\x12#\n\rradiant_kills\
    \x18\x0b\x20\x01(\rR\x0cradiantKills\x12\x1d\n\ndire_kills\x18\x0c\x20\
    \x01(\rR\tdireKills\x12!\n\x0cradiant_lead\x18\x0e\x20\x01(\x05R\x0bradi\
    antLead\x12%\n\x0ebuilding_state\x18\x0f\x20\x01(\rR\rbuildingState\x1a\
    \xd8\x01\n\x06Player\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07stea\
    mId\x12\x17\n\x07hero_id\x18\x02\x20\x01(\rR\x06heroId\x123\n\x0cleaver_\
    state\x18\x03\x20\x01(\x0b2\x10.CMsgLeaverStateR\x0bleaverState\x12e\n\
    \x11disconnect_reason\x18\x04\x20\x01(\x0e2\x1c.ENetworkDisconnectionRea\
    son:\x1aNETWORK_DISCONNECT_INVALIDR\x10disconnectReason\"\x89\x02\n\nSen\
    dReason\x12\x0b\n\x07INVALID\x10\0\x12\r\n\tHEARTBEAT\x10\x01\x12\x0e\n\
    \nGAME_STATE\x10\x02\x12\x0f\n\x0bFIRST_BLOOD\x10\x03\x12\x14\n\x10PLAYE\
    R_CONNECTED\x10\x04\x12\x0f\n\x0bPLAYER_HERO\x10\x05\x12$\n\x20PLAYER_DI\
    SCONNECTED_CONSEQUENCES\x10\x06\x12&\n\"PLAYER_DISCONNECTED_NOCONSEQUENC\
    ES\x10\x07\x12\x15\n\x11GAMESTATE_TIMEOUT\x10\n\x12\x13\n\x0fMASS_DISCON\
    NECT\x10\x0b\x12\t\n\x05KILLS\x10\r\x12\x12\n\x0eBUILDING_STATE\x10\x0e\
    \"\xea\t\n\x12CMsgGameServerInfo\x121\n\x15server_public_ip_addr\x18\x01\
    \x20\x01(\x07R\x12serverPublicIpAddr\x123\n\x16server_private_ip_addr\
    \x18\x02\x20\x01(\x07R\x13serverPrivateIpAddr\x12\x1f\n\x0bserver_port\
    \x18\x03\x20\x01(\rR\nserverPort\x12$\n\x0eserver_tv_port\x18\x04\x20\
    \x01(\rR\x0cserverTvPort\x125\n\x17assigned_server_tv_port\x18\x16\x20\
    \x01(\rR\x14assignedServerTvPort\x12:\n\x19server_steamdatagram_port\x18\
    \x15\x20\x01(\rR\x17serverSteamdatagramPort\x12\x1d\n\nserver_key\x18\
    \x05\x20\x01(\tR\tserverKey\x12-\n\x12server_hibernation\x18\x06\x20\x01\
    (\x08R\x11serverHibernation\x12L\n\x0bserver_type\x18\x07\x20\x01(\x0e2\
    \x1e.CMsgGameServerInfo.ServerType:\x0bUNSPECIFIEDR\nserverType\x12#\n\r\
    server_region\x18\x08\x20\x01(\rR\x0cserverRegion\x12%\n\x0eserver_loada\
    vg\x18\t\x20\x01(\x02R\rserverLoadavg\x127\n\x18server_tv_broadcast_time\
    \x18\n\x20\x01(\x02R\x15serverTvBroadcastTime\x12(\n\x10server_game_time\
    \x18\x0b\x20\x01(\x02R\x0eserverGameTime\x12D\n\x1fserver_relay_connecte\
    d_steam_id\x18\x0c\x20\x01(\x06R\x1bserverRelayConnectedSteamId\x12&\n\
    \x0frelay_slots_max\x18\r\x20\x01(\rR\rrelaySlotsMax\x12)\n\x10relays_co\
    nnected\x18\x0e\x20\x01(\x05R\x0frelaysConnected\x126\n\x17relay_clients\
    _connected\x18\x0f\x20\x01(\x05R\x15relayClientsConnected\x12>\n\x1crela\
    yed_game_server_steam_id\x18\x10\x20\x01(\x06R\x18relayedGameServerSteam\
    Id\x12,\n\x12parent_relay_count\x18\x11\x20\x01(\rR\x10parentRelayCount\
    \x12$\n\x0etv_secret_code\x18\x12\x20\x01(\x06R\x0ctvSecretCode\x12%\n\
    \x0eserver_version\x18\x13\x20\x01(\rR\rserverVersion\x12%\n\x0eserver_c\
    luster\x18\x14\x20\x01(\rR\rserverCluster\x12S\n\x12allow_custom_games\
    \x18\x17\x20\x01(\x0e2\x1f.CMsgGameServerInfo.CustomGames:\x04BOTHR\x10a\
    llowCustomGames\"2\n\nServerType\x12\x0f\n\x0bUNSPECIFIED\x10\0\x12\x08\
    \n\x04GAME\x10\x01\x12\t\n\x05PROXY\x10\x02\"+\n\x0bCustomGames\x12\x08\
    \n\x04BOTH\x10\0\x12\x08\n\x04NONE\x10\x01\x12\x08\n\x04ONLY\x10\x02\"\
    \x92\x03\n\x12CMsgLeaverDetected\x12\x19\n\x08steam_id\x18\x01\x20\x01(\
    \x06R\x07steamId\x12J\n\rleaver_status\x18\x02\x20\x01(\x0e2\x13.DOTALea\
    verStatus_t:\x10DOTA_LEAVER_NONER\x0cleaverStatus\x123\n\x0cleaver_state\
    \x18\x04\x20\x01(\x0b2\x10.CMsgLeaverStateR\x0bleaverState\x12%\n\x0eser\
    ver_cluster\x18\x05\x20\x01(\rR\rserverCluster\x12e\n\x11disconnect_reas\
    on\x18\x06\x20\x01(\x0e2\x1c.ENetworkDisconnectionReason:\x1aNETWORK_DIS\
    CONNECT_INVALIDR\x10disconnectReason\x12R\n\x17poor_network_conditions\
    \x18\x07\x20\x01(\x0b2\x1a.CMsgPoorNetworkConditionsR\x15poorNetworkCond\
    itions\"4\n\x1aCMsgLeaverDetectedResponse\x12\x16\n\x06result\x18\x01\
    \x20\x01(\rR\x06result\"T\n\x1fCMsgDOTAFantasyFinalPlayerStats\x121\n\
    \x05stats\x18\x02\x20\x03(\x0b2\x1b.CMsgDOTAFantasyPlayerStatsR\x05stats\
    \"S\n\x1eCMsgDOTAFantasyLivePlayerStats\x121\n\x05stats\x18\x02\x20\x03(\
    \x0b2\x1b.CMsgDOTAFantasyPlayerStatsR\x05stats\"\xd9\x01\n\x14CMsgDOTAFa\
    ntasyMatch\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\
    \x1b\n\tleague_id\x18\x02\x20\x01(\rR\x08leagueId\x12\x1b\n\tseries_id\
    \x18\x03\x20\x01(\rR\x08seriesId\x12\x1d\n\nstart_time\x18\x04\x20\x01(\
    \rR\tstartTime\x12\x1f\n\x0bseries_type\x18\x05\x20\x01(\rR\nseriesType\
    \x12\x15\n\x06team_1\x18\x06\x20\x01(\rR\x05team1\x12\x15\n\x06team_2\
    \x18\x07\x20\x01(\rR\x05team2\"\x8e\x01\n\x1bCMsgServerToGCRealtimeStats\
    \x129\n\x07delayed\x18\x01\x20\x01(\x0b2\x1f.CMsgDOTARealtimeGameStatsTe\
    rseR\x07delayed\x124\n\x07current\x18\x02\x20\x01(\x0b2\x1a.CMsgDOTAReal\
    timeGameStatsR\x07current\"Z\n$CMsgGCToServerRealtimeStatsStartStop\x12\
    \x18\n\x07delayed\x18\x01\x20\x01(\x08R\x07delayed\x12\x18\n\x07current\
    \x18\x02\x20\x01(\x08R\x07current\"\xeb!\n\x14CMsgGameMatchSignOut\x12\
    \x1f\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchIdB\x04\x80\xa6\x1d\x01\
    \x12\x1a\n\x08duration\x18\x02\x20\x01(\rR\x08duration\x12\"\n\rgood_guy\
    s_win\x18\x03\x20\x01(\x08R\x0bgoodGuysWin\x12\x12\n\x04date\x18\x04\x20\
    \x01(\x07R\x04date\x12\x1f\n\x0bnum_players\x18\x05\x20\x03(\rR\nnumPlay\
    ers\x121\n\x05teams\x18\x06\x20\x03(\x0b2\x1b.CMsgGameMatchSignOut.CTeam\
    R\x05teams\x12!\n\x0ctower_status\x18\x08\x20\x03(\rR\x0btowerStatus\x12\
    '\n\x0fbarracks_status\x18\t\x20\x03(\rR\x0ebarracksStatus\x12\x18\n\x07\
    cluster\x18\n\x20\x01(\rR\x07cluster\x12\x1f\n\x0bserver_addr\x18\x0b\
    \x20\x01(\tR\nserverAddr\x12(\n\x10first_blood_time\x18\x0c\x20\x01(\rR\
    \x0efirstBloodTime\x12!\n\x0cgame_balance\x18\r\x20\x01(\x02R\x0bgameBal\
    ance\x12\x1f\n\x0bevent_score\x18\x0e\x20\x01(\rR\neventScore\x125\n\npi\
    cks_bans\x18\x0f\x20\x03(\x0b2\x16.CMatchHeroSelectEventR\tpicksBans\x12\
    @\n\rfantasy_stats\x18)\x20\x03(\x0b2\x1b.CMsgDOTAFantasyPlayerStatsR\
    \x0cfantasyStats\x12n\n\x20player_strange_count_adjustments\x18\x11\x20\
    \x03(\x0b2%.CMsgEconPlayerStrangeCountAdjustmentR\x1dplayerStrangeCountA\
    djustments\x12/\n\x13automatic_surrender\x18\x12\x20\x01(\x08R\x12automa\
    ticSurrender\x12%\n\x0eserver_version\x18\x13\x20\x01(\rR\rserverVersion\
    \x124\n\x16legacy_mass_disconnect\x18\x15\x20\x01(\x08R\x14legacyMassDis\
    connect\x12R\n\x17poor_network_conditions\x18#\x20\x01(\x0b2\x1a.CMsgPoo\
    rNetworkConditionsR\x15poorNetworkConditions\x12T\n\x0fadditional_msgs\
    \x18\x14\x20\x03(\x0b2+.CMsgGameMatchSignOut.CAdditionalSignoutMsgR\x0ea\
    dditionalMsgs\x12Y\n\x12social_feed_events\x18$\x20\x03(\x0b2+.CMsgGameM\
    atchSignOut.CSocialFeedMatchEventR\x10socialFeedEvents\x124\n\x16average\
    _networth_delta\x18\x16\x20\x01(\x11R\x14averageNetworthDelta\x120\n\x14\
    networth_delta_min10\x18\x17\x20\x01(\x11R\x12networthDeltaMin10\x120\n\
    \x14networth_delta_min20\x18\x18\x20\x01(\x11R\x12networthDeltaMin20\x12\
    ?\n\x1cmaximum_losing_networth_lead\x18\x19\x20\x01(\x11R\x19maximumLosi\
    ngNetworthLead\x128\n\x18average_experience_delta\x18\x1a\x20\x01(\x11R\
    \x16averageExperienceDelta\x124\n\x16experience_delta_min10\x18\x1b\x20\
    \x01(\x11R\x14experienceDeltaMin10\x124\n\x16experience_delta_min20\x18\
    \x1c\x20\x01(\x11R\x14experienceDeltaMin20\x125\n\x17bonus_gold_winner_m\
    in10\x18\x1d\x20\x01(\x11R\x14bonusGoldWinnerMin10\x125\n\x17bonus_gold_\
    winner_min20\x18\x1e\x20\x01(\x11R\x14bonusGoldWinnerMin20\x125\n\x17bon\
    us_gold_winner_total\x18\x1f\x20\x01(\rR\x14bonusGoldWinnerTotal\x123\n\
    \x16bonus_gold_loser_min10\x18\x20\x20\x01(\x11R\x13bonusGoldLoserMin10\
    \x123\n\x16bonus_gold_loser_min20\x18!\x20\x01(\x11R\x13bonusGoldLoserMi\
    n20\x123\n\x16bonus_gold_loser_total\x18\"\x20\x01(\rR\x13bonusGoldLoser\
    Total\x12O\n\x10custom_game_data\x18%\x20\x01(\x0b2%.CMsgGameMatchSignOu\
    t.CCustomGameDataR\x0ecustomGameData\x12\x1f\n\x0bmatch_flags\x18&\x20\
    \x01(\rR\nmatchFlags\x12\x1f\n\x0bteam_scores\x18'\x20\x03(\rR\nteamScor\
    es\x12*\n\x11pre_game_duration\x18(\x20\x01(\rR\x0fpreGameDuration\x12t\
    \n\x1eevent_game_leaderboard_entries\x18*\x20\x03(\x0b2/.CMsgGameMatchSi\
    gnOut.EventGameLeaderboardEntryR\x1beventGameLeaderboardEntries\x1a\xe6\
    \x0c\n\x05CTeam\x12=\n\x07players\x18\x01\x20\x03(\x0b2#.CMsgGameMatchSi\
    gnOut.CTeam.CPlayerR\x07players\x1a\x9d\x0c\n\x07CPlayer\x12\x19\n\x08st\
    eam_id\x18\x01\x20\x01(\x06R\x07steamId\x12\x17\n\x07hero_id\x18\x03\x20\
    \x01(\rR\x06heroId\x12\x14\n\x05items\x18\x04\x20\x03(\rR\x05items\x12\
    \x12\n\x04gold\x18\x05\x20\x01(\rR\x04gold\x12\x14\n\x05kills\x18\x06\
    \x20\x01(\rR\x05kills\x12\x16\n\x06deaths\x18\x07\x20\x01(\rR\x06deaths\
    \x12\x18\n\x07assists\x18\x08\x20\x01(\rR\x07assists\x12#\n\rleaver_stat\
    us\x18\t\x20\x01(\rR\x0cleaverStatus\x12\x1b\n\tlast_hits\x18\n\x20\x01(\
    \rR\x08lastHits\x12\x16\n\x06denies\x18\x0b\x20\x01(\rR\x06denies\x12\
    \x20\n\x0cgold_per_min\x18\x0c\x20\x01(\rR\ngoldPerMin\x12\"\n\rxp_per_m\
    inute\x18\r\x20\x01(\rR\x0bxpPerMinute\x12\x1d\n\ngold_spent\x18\x0e\x20\
    \x01(\rR\tgoldSpent\x12\x14\n\x05level\x18\x0f\x20\x01(\rR\x05level\x12,\
    \n\x12scaled_hero_damage\x18\x10\x20\x01(\rR\x10scaledHeroDamage\x12.\n\
    \x13scaled_tower_damage\x18\x11\x20\x01(\rR\x11scaledTowerDamage\x12.\n\
    \x13scaled_hero_healing\x18\x12\x20\x01(\rR\x11scaledHeroHealing\x12$\n\
    \x0etime_last_seen\x18\x13\x20\x01(\rR\x0ctimeLastSeen\x122\n\x15support\
    _ability_value\x18\x14\x20\x01(\rR\x13supportAbilityValue\x12\x19\n\x08p\
    arty_id\x18\x15\x20\x01(\x04R\x07partyId\x12!\n\x0cscaled_kills\x18\x18\
    \x20\x01(\x02R\x0bscaledKills\x12#\n\rscaled_deaths\x18\x19\x20\x01(\x02\
    R\x0cscaledDeaths\x12%\n\x0escaled_assists\x18\x1a\x20\x01(\x02R\rscaled\
    Assists\x12*\n\x11claimed_farm_gold\x18\x1b\x20\x01(\rR\x0fclaimedFarmGo\
    ld\x12!\n\x0csupport_gold\x18\x1c\x20\x01(\rR\x0bsupportGold\x12%\n\x0ec\
    laimed_denies\x18\x1d\x20\x01(\rR\rclaimedDenies\x12%\n\x0eclaimed_misse\
    s\x18\x1e\x20\x01(\rR\rclaimedMisses\x12\x16\n\x06misses\x18\x1f\x20\x01\
    (\rR\x06misses\x12\x1b\n\tnet_worth\x18\"\x20\x01(\rR\x08netWorth\x12\
    \x1f\n\x0bhero_damage\x18%\x20\x01(\rR\nheroDamage\x12!\n\x0ctower_damag\
    e\x18&\x20\x01(\rR\x0btowerDamage\x12!\n\x0chero_healing\x18'\x20\x01(\r\
    R\x0bheroHealing\x12F\n\x10ability_upgrades\x18\x20\x20\x03(\x0b2\x1b.CM\
    atchPlayerAbilityUpgradeR\x0fabilityUpgrades\x12\\\n\x1aadditional_units\
    _inventory\x18!\x20\x03(\x0b2\x1e.CMatchAdditionalUnitInventoryR\x18addi\
    tionalUnitsInventory\x12C\n\x0fpermanent_buffs\x18(\x20\x03(\x0b2\x1a.CM\
    atchPlayerPermanentBuffR\x0epermanentBuffs\x12]\n\x10custom_game_data\
    \x18#\x20\x01(\x0b23.CMsgGameMatchSignOut.CTeam.CPlayer.CCustomGameDataR\
    \x0ecustomGameData\x12,\n\x12match_player_flags\x18$\x20\x01(\rR\x10matc\
    hPlayerFlags\x12,\n\x12talent_ability_ids\x18)\x20\x03(\rR\x10talentAbil\
    ityIds\x1aF\n\x0fCCustomGameData\x12\x1b\n\tdota_team\x18\x01\x20\x01(\r\
    R\x08dotaTeam\x12\x16\n\x06winner\x18\x02\x20\x01(\x08R\x06winner\x1aC\n\
    \x15CAdditionalSignoutMsg\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\
    \x1a\n\x08contents\x18\x02\x20\x01(\x0cR\x08contents\x1a\xb1\x01\n\x15CS\
    ocialFeedMatchEvent\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\
    \x12\x1c\n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\x12\x1d\n\nevent_ty\
    pe\x18\x03\x20\x01(\rR\teventType\x12\x1b\n\tgame_time\x18\x04\x20\x01(\
    \x05R\x08gameTime\x12\x1f\n\x0breplay_time\x18\x05\x20\x01(\rR\nreplayTi\
    me\x1a>\n\x0fCCustomGameData\x12+\n\x11publish_timestamp\x18\x01\x20\x01\
    (\rR\x10publishTimestamp\x1a\xfc\x01\n\x19EventGameLeaderboardEntry\x12\
    \x1f\n\x0bname_suffix\x18\x01\x20\x01(\tR\nnameSuffix\x12\x14\n\x05score\
    \x18\x02\x20\x01(\x05R\x05score\x12\x20\n\x0cextra_data_1\x18\x03\x20\
    \x01(\rR\nextraData1\x12\x20\n\x0cextra_data_2\x18\x04\x20\x01(\rR\nextr\
    aData2\x12\x20\n\x0cextra_data_3\x18\x05\x20\x01(\rR\nextraData3\x12\x20\
    \n\x0cextra_data_4\x18\x06\x20\x01(\rR\nextraData4\x12\x20\n\x0cextra_da\
    ta_5\x18\x07\x20\x01(\rR\nextraData5\"\xc1\x01\n\x14CMsgSignOutDraftInfo\
    \x12;\n\x1aradiant_captain_account_id\x18\x01\x20\x01(\rR\x17radiantCapt\
    ainAccountId\x125\n\x17dire_captain_account_id\x18\x02\x20\x01(\rR\x14di\
    reCaptainAccountId\x125\n\npicks_bans\x18\x03\x20\x03(\x0b2\x16.CMatchHe\
    roSelectEventR\tpicksBans\"\x9a\x02\n\x12CMsgSignOutBotInfo\x12!\n\x0cal\
    low_cheats\x18\x01\x20\x01(\x08R\x0ballowCheats\x12`\n\x16bot_difficulty\
    _radiant\x18\x02\x20\x01(\x0e2\x12.DOTABotDifficulty:\x16BOT_DIFFICULTY_\
    PASSIVER\x14botDifficultyRadiant\x12#\n\rcreated_lobby\x18\x03\x20\x01(\
    \x08R\x0ccreatedLobby\x12Z\n\x13bot_difficulty_dire\x18\x05\x20\x01(\x0e\
    2\x12.DOTABotDifficulty:\x16BOT_DIFFICULTY_PASSIVER\x11botDifficultyDire\
    \"\xe1\x05\n\x16CMsgSignOutPlayerStats\x12\x1d\n\naccount_id\x18\x01\x20\
    \x01(\x05R\taccountId\x12\x19\n\x08match_id\x18\x02\x20\x01(\x04R\x07mat\
    chId\x12\x12\n\x04rank\x18\x03\x20\x01(\rR\x04rank\x12\x17\n\x07hero_id\
    \x18\x04\x20\x01(\rR\x06heroId\x12\x1a\n\x08rampages\x18\x05\x20\x01(\rR\
    \x08rampages\x12!\n\x0ctriple_kills\x18\x06\x20\x01(\rR\x0btripleKills\
    \x12.\n\x13first_blood_claimed\x18\x07\x20\x01(\rR\x11firstBloodClaimed\
    \x12*\n\x11first_blood_given\x18\x08\x20\x01(\rR\x0ffirstBloodGiven\x12'\
    \n\x0fcouriers_killed\x18\t\x20\x01(\rR\x0ecouriersKilled\x12)\n\x10aegi\
    ses_snatched\x18\n\x20\x01(\rR\x0faegisesSnatched\x12#\n\rcheeses_eaten\
    \x18\x0b\x20\x01(\rR\x0ccheesesEaten\x12%\n\x0ecreeps_stacked\x18\x0c\
    \x20\x01(\rR\rcreepsStacked\x12\x1f\n\x0bfight_score\x18\r\x20\x01(\x02R\
    \nfightScore\x12\x1d\n\nfarm_score\x18\x0e\x20\x01(\x02R\tfarmScore\x12#\
    \n\rsupport_score\x18\x0f\x20\x01(\x02R\x0csupportScore\x12\x1d\n\npush_\
    score\x18\x10\x20\x01(\x02R\tpushScore\x12\x14\n\x05kills\x18\x11\x20\
    \x01(\rR\x05kills\x12\x16\n\x06deaths\x18\x12\x20\x01(\rR\x06deaths\x12\
    \x18\n\x07assists\x18\x13\x20\x01(\rR\x07assists\x12\x1b\n\tlast_hits\
    \x18\x14\x20\x01(\rR\x08lastHits\x12\x16\n\x06denies\x18\x15\x20\x01(\rR\
    \x06denies\x12\x10\n\x03gpm\x18\x16\x20\x01(\x02R\x03gpm\x12\x12\n\x04xp\
    pm\x18\x17\x20\x01(\x02R\x04xppm\"\xad\x05\n\x1fCMsgSignOutCommunication\
    Summary\x12N\n\x07players\x18\x01\x20\x03(\x0b24.CMsgSignOutCommunicatio\
    nSummary.PlayerCommunicationR\x07players\x1a\xb9\x04\n\x13PlayerCommunic\
    ation\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x14\n\x05\
    pings\x18\x02\x20\x01(\rR\x05pings\x123\n\x16max_pings_per_interval\x18\
    \x03\x20\x01(\rR\x13maxPingsPerInterval\x12%\n\x0eteammate_pings\x18\x04\
    \x20\x01(\rR\rteammatePings\x12D\n\x1fmax_teammate_pings_per_interval\
    \x18\x05\x20\x01(\rR\x1bmaxTeammatePingsPerInterval\x12,\n\x12team_chat_\
    messages\x18\x06\x20\x01(\rR\x10teamChatMessages\x12*\n\x11all_chat_mess\
    ages\x18\x07\x20\x01(\rR\x0fallChatMessages\x12.\n\x13chat_wheel_message\
    s\x18\x08\x20\x01(\rR\x11chatWheelMessages\x12\x16\n\x06pauses\x18\t\x20\
    \x01(\rR\x06pauses\x12\x1a\n\x08unpauses\x18\n\x20\x01(\rR\x08unpauses\
    \x12\x1f\n\x0blines_drawn\x18\x0b\x20\x01(\rR\nlinesDrawn\x12,\n\x12voic\
    e_chat_seconds\x18\x0c\x20\x01(\rR\x10voiceChatSeconds\x12\x1d\n\nchat_m\
    utes\x18\r\x20\x01(\rR\tchatMutes\x12\x1f\n\x0bvoice_mutes\x18\x0e\x20\
    \x01(\rR\nvoiceMutes\"\xc1\x08\n\x1cCMsgGameMatchSignoutResponse\x12\x19\
    \n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\x1f\n\x0breplay_salt\
    \x18\x02\x20\x01(\x07R\nreplaySalt\x12K\n\x14timed_reward_details\x18\
    \x03\x20\x03(\x0b2\x19.CLobbyTimedRewardDetailsR\x12timedRewardDetails\
    \x12=\n\x11xp_reward_details\x18\x04\x20\x03(\x0b2\x11.CDOTALobbyMemberR\
    \x0fxpRewardDetails\x12\x1a\n\x08leagueid\x18\x05\x20\x01(\rR\x08leaguei\
    d\x12\\\n\x0fadditional_msgs\x18\x06\x20\x03(\x0b23.CMsgGameMatchSignout\
    Response.CAdditionalSignoutMsgR\x0eadditionalMsgs\x120\n\x14metadata_pri\
    vate_key\x18\x07\x20\x01(\x07R\x12metadataPrivateKey\x123\n\rmatch_detai\
    ls\x18\x08\x20\x01(\x0b2\x0e.CMsgDOTAMatchR\x0cmatchDetails\x12W\n\x10pl\
    ayers_metadata\x18\t\x20\x03(\x0b2,.CMsgGameMatchSignoutResponse.PlayerM\
    etadataR\x0fplayersMetadata\x1aC\n\x15CAdditionalSignoutMsg\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\rR\x02id\x12\x1a\n\x08contents\x18\x02\x20\x01(\
    \x0cR\x08contents\x1a\xd9\x03\n\x0ePlayerMetadata\x12\x17\n\x07hero_id\
    \x18\x01\x20\x01(\rR\x06heroId\x12\"\n\ravg_kills_x16\x18\x02\x20\x01(\r\
    R\x0bavgKillsX16\x12$\n\x0eavg_deaths_x16\x18\x03\x20\x01(\rR\x0cavgDeat\
    hsX16\x12&\n\x0favg_assists_x16\x18\x04\x20\x01(\rR\ravgAssistsX16\x12\
    \x1e\n\x0bavg_gpm_x16\x18\x05\x20\x01(\rR\tavgGpmX16\x12\x1e\n\x0bavg_xp\
    m_x16\x18\x06\x20\x01(\rR\tavgXpmX16\x12$\n\x0ebest_kills_x16\x18\x07\
    \x20\x01(\rR\x0cbestKillsX16\x12(\n\x10best_assists_x16\x18\x08\x20\x01(\
    \rR\x0ebestAssistsX16\x12\x20\n\x0cbest_gpm_x16\x18\t\x20\x01(\rR\nbestG\
    pmX16\x12\x20\n\x0cbest_xpm_x16\x18\n\x20\x01(\rR\nbestXpmX16\x12\x1d\n\
    \nwin_streak\x18\x0b\x20\x01(\rR\twinStreak\x12&\n\x0fbest_win_streak\
    \x18\x0c\x20\x01(\rR\rbestWinStreak\x12!\n\x0cgames_played\x18\r\x20\x01\
    (\rR\x0bgamesPlayed\"g\n\x18CMsgTimedRewardContainer\x12K\n\x14timed_rew\
    ard_details\x18\x01\x20\x03(\x0b2\x19.CLobbyTimedRewardDetailsR\x12timed\
    RewardDetails\"\xbf\x01\n%CMsgGameMatchSignOutPermissionRequest\x12%\n\
    \x0eserver_version\x18\x01\x20\x01(\rR\rserverVersion\x12#\n\rlocal_atte\
    mpt\x18\x02\x20\x01(\rR\x0clocalAttempt\x12#\n\rtotal_attempt\x18\x03\
    \x20\x01(\rR\x0ctotalAttempt\x12%\n\x0eseconds_waited\x18\x04\x20\x01(\r\
    R\rsecondsWaited\"\xc1\x01\n&CMsgGameMatchSignOutPermissionResponse\x124\
    \n\x12permission_granted\x18\x01\x20\x01(\x08:\x05falseR\x11permissionGr\
    anted\x12.\n\x0fabandon_signout\x18\x02\x20\x01(\x08:\x05falseR\x0eaband\
    onSignout\x121\n\x13retry_delay_seconds\x18\x03\x20\x01(\r:\x010R\x11ret\
    ryDelaySeconds\"\xb6\x01\n!CMsgGameMatchSignOutEventGameData\x121\n\x08e\
    vent_id\x18\x01\x20\x01(\x0e2\x07.EEvent:\rEVENT_ID_NONER\x07eventId\x12\
    \x1b\n\tgame_name\x18\x02\x20\x01(\tR\x08gameName\x12\x19\n\x08map_name\
    \x18\x03\x20\x01(\tR\x07mapName\x12&\n\x0fevent_game_data\x18\x04\x20\
    \x01(\x0cR\reventGameData\"\x83\x0e\n\x1cCMsgDOTALiveScoreboardUpdate\
    \x12#\n\rtournament_id\x18\x01\x20\x01(\rR\x0ctournamentId\x12,\n\x12tou\
    rnament_game_id\x18\x02\x20\x01(\rR\x10tournamentGameId\x12\x1a\n\x08dur\
    ation\x18\x03\x20\x01(\x02R\x08duration\x12\x1d\n\nhltv_delay\x18\x04\
    \x20\x01(\x05R\thltvDelay\x12?\n\tteam_good\x18\x05\x20\x01(\x0b2\".CMsg\
    DOTALiveScoreboardUpdate.TeamR\x08teamGood\x12=\n\x08team_bad\x18\x06\
    \x20\x01(\x0b2\".CMsgDOTALiveScoreboardUpdate.TeamR\x07teamBad\x120\n\
    \x14roshan_respawn_timer\x18\x07\x20\x01(\rR\x12roshanRespawnTimer\x12\
    \x1b\n\tleague_id\x18\x08\x20\x01(\rR\x08leagueId\x12\x19\n\x08match_id\
    \x18\t\x20\x01(\x04R\x07matchId\x1a\xea\n\n\x04Team\x12C\n\x07players\
    \x18\x01\x20\x03(\x0b2).CMsgDOTALiveScoreboardUpdate.Team.PlayerR\x07pla\
    yers\x12\x14\n\x05score\x18\x02\x20\x01(\rR\x05score\x12\x1f\n\x0btower_\
    state\x18\x03\x20\x01(\rR\ntowerState\x12%\n\x0ebarracks_state\x18\x04\
    \x20\x01(\rR\rbarracksState\x12\x1d\n\nhero_picks\x18\x05\x20\x03(\rR\th\
    eroPicks\x12\x1b\n\thero_bans\x18\x06\x20\x03(\rR\x08heroBans\x1a\x82\t\
    \n\x06Player\x12\x1f\n\x0bplayer_slot\x18\x01\x20\x01(\rR\nplayerSlot\
    \x12\x1f\n\x0bplayer_name\x18\x02\x20\x01(\tR\nplayerName\x12\x1b\n\ther\
    o_name\x18\x03\x20\x01(\tR\x08heroName\x12\x17\n\x07hero_id\x18\x04\x20\
    \x01(\rR\x06heroId\x12\x14\n\x05kills\x18\x05\x20\x01(\rR\x05kills\x12\
    \x16\n\x06deaths\x18\x06\x20\x01(\rR\x06deaths\x12\x18\n\x07assists\x18\
    \x07\x20\x01(\rR\x07assists\x12\x1b\n\tlast_hits\x18\x08\x20\x01(\rR\x08\
    lastHits\x12\x16\n\x06denies\x18\t\x20\x01(\rR\x06denies\x12\x12\n\x04go\
    ld\x18\n\x20\x01(\rR\x04gold\x12\x14\n\x05level\x18\x0b\x20\x01(\rR\x05l\
    evel\x12\x20\n\x0cgold_per_min\x18\x0c\x20\x01(\x02R\ngoldPerMin\x12\x1c\
    \n\nxp_per_min\x18\r\x20\x01(\x02R\x08xpPerMin\x12\x82\x01\n\x0eultimate\
    _state\x18\x0e\x20\x01(\x0e2;.CMsgDOTALiveScoreboardUpdate.Team.Player.D\
    OTAUltimateState:\x1ek_EDOTAUltimateStateNotLearnedR\rultimateState\x12+\
    \n\x11ultimate_cooldown\x18\x0f\x20\x01(\x02R\x10ultimateCooldown\x12\
    \x14\n\x05item0\x18\x10\x20\x01(\rR\x05item0\x12\x14\n\x05item1\x18\x11\
    \x20\x01(\rR\x05item1\x12\x14\n\x05item2\x18\x12\x20\x01(\rR\x05item2\
    \x12\x14\n\x05item3\x18\x13\x20\x01(\rR\x05item3\x12\x14\n\x05item4\x18\
    \x14\x20\x01(\rR\x05item4\x12\x14\n\x05item5\x18\x15\x20\x01(\rR\x05item\
    5\x12#\n\rrespawn_timer\x18\x16\x20\x01(\rR\x0crespawnTimer\x12\x1d\n\na\
    ccount_id\x18\x17\x20\x01(\rR\taccountId\x12\x1d\n\nposition_x\x18\x18\
    \x20\x01(\x02R\tpositionX\x12\x1d\n\nposition_y\x18\x19\x20\x01(\x02R\tp\
    ositionY\x12\x1b\n\tnet_worth\x18\x1a\x20\x01(\rR\x08netWorth\x12S\n\tab\
    ilities\x18\x1b\x20\x03(\x0b25.CMsgDOTALiveScoreboardUpdate.Team.Player.\
    HeroAbilityR\tabilities\x1aQ\n\x0bHeroAbility\x12\x1d\n\nability_id\x18\
    \x01\x20\x01(\rR\tabilityId\x12#\n\rability_level\x18\x02\x20\x01(\rR\
    \x0cabilityLevel\"\x9b\x01\n\x11DOTAUltimateState\x12\"\n\x1ek_EDOTAUlti\
    mateStateNotLearned\x10\0\x12\x20\n\x1ck_EDOTAUltimateStateCooldown\x10\
    \x01\x12!\n\x1dk_EDOTAUltimateStateNeedsMana\x10\x02\x12\x1d\n\x19k_EDOT\
    AUltimateStateReady\x10\x03\"X\n\x1eCMsgDOTARequestPlayerResources\x12\
    \x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12\x1b\n\tplayer_id\
    \x18\x02\x20\x01(\rR\x08playerId\"\xf1\x01\n&CMsgDOTARequestPlayerResour\
    cesResponse\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12\
    \x12\n\x04rank\x18\x02\x20\x01(\rR\x04rank\x12\x1b\n\tplayer_id\x18\x03\
    \x20\x01(\rR\x08playerId\x12*\n\x11prevent_text_chat\x18\x04\x20\x01(\
    \x08R\x0fpreventTextChat\x12,\n\x12prevent_voice_chat\x18\x05\x20\x01(\
    \x08R\x10preventVoiceChat\x12!\n\x0clow_priority\x18\x06\x20\x01(\x08R\
    \x0blowPriority\"m\n#CMsgDOTARequestBatchPlayerResources\x12#\n\x0baccou\
    nt_ids\x18\x01\x20\x03(\rR\naccountIdsB\x02\x10\x01\x12!\n\nrank_types\
    \x18\x04\x20\x03(\rR\trankTypesB\x02\x10\x01\"\xe0\x02\n+CMsgDOTARequest\
    BatchPlayerResourcesResponse\x12M\n\x07results\x18\x06\x20\x03(\x0b23.CM\
    sgDOTARequestBatchPlayerResourcesResponse.ResultR\x07results\x1a\xe1\x01\
    \n\x06Result\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12*\n\
    \x11prevent_text_chat\x18\x02\x20\x01(\x08R\x0fpreventTextChat\x12,\n\
    \x12prevent_voice_chat\x18\x03\x20\x01(\x08R\x10preventVoiceChat\x12\x12\
    \n\x04rank\x18\x04\x20\x01(\rR\x04rank\x12'\n\x0frank_calibrated\x18\x05\
    \x20\x01(\x08R\x0erankCalibrated\x12!\n\x0clow_priority\x18\x06\x20\x01(\
    \x08R\x0blowPriority\"s\n\x1dCMsgDOTAPlayerFailedToConnect\x12%\n\x0efai\
    led_loaders\x18\x01\x20\x03(\x06R\rfailedLoaders\x12+\n\x11abandoned_loa\
    ders\x18\x02\x20\x03(\x06R\x10abandonedLoaders\"\xd7\x02\n\x14CMsgGCToRe\
    layConnect\x121\n\x15source_tv_public_addr\x18\x01\x20\x01(\rR\x12source\
    TvPublicAddr\x123\n\x16source_tv_private_addr\x18\x02\x20\x01(\rR\x13sou\
    rceTvPrivateAddr\x12$\n\x0esource_tv_port\x18\x03\x20\x01(\rR\x0csourceT\
    vPort\x12/\n\x14game_server_steam_id\x18\x04\x20\x01(\x04R\x11gameServer\
    SteamId\x12!\n\x0cparent_count\x18\x05\x20\x01(\rR\x0bparentCount\x121\n\
    \x15tv_unique_secret_code\x18\x06\x20\x01(\x06R\x12tvUniqueSecretCode\
    \x12*\n\x11source_tv_steamid\x18\x07\x20\x01(\x06R\x0fsourceTvSteamid\"F\
    \n\x1fCMsgGCGCToLANServerRelayConnect\x12#\n\rrelay_steamid\x18\x01\x20\
    \x01(\x06R\x0crelaySteamid\"\x1e\n\x1cCMsgGCToRelayConnectResponse\"7\n\
    \x16CMsgGCBanStatusRequest\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\tac\
    countId\"\xaa\x01\n\x17CMsgGCBanStatusResponse\x12\x16\n\x06result\x18\
    \x01\x20\x01(\rR\x06result\x12!\n\x0clow_priority\x18\x02\x20\x01(\x08R\
    \x0blowPriority\x12(\n\x10text_chat_banned\x18\x03\x20\x01(\x08R\x0etext\
    ChatBanned\x12*\n\x11voice_chat_banned\x18\x04\x20\x01(\x08R\x0fvoiceCha\
    tBanned\"\xf5\x03\n\x17CMsgTournamentItemEvent\x12*\n\x11killer_account_\
    id\x18\x01\x20\x01(\x07R\x0fkillerAccountId\x12*\n\x11victim_account_id\
    \x18\x02\x20\x01(\x07R\x0fvictimAccountId\x12E\n\nevent_type\x18\x03\x20\
    \x01(\x0e2\x16.DOTA_TournamentEvents:\x0eTE_FIRST_BLOODR\teventType\x12\
    \x19\n\x08tv_delay\x18\x04\x20\x01(\x05R\x07tvDelay\x12\x1b\n\tdota_time\
    \x18\x05\x20\x01(\x05R\x08dotaTime\x12\x1f\n\x0breplay_time\x18\x06\x20\
    \x01(\x02R\nreplayTime\x12\x1b\n\tloot_list\x18\x07\x20\x01(\tR\x08lootL\
    ist\x12\x1d\n\nevent_team\x18\x08\x20\x01(\rR\teventTeam\x12(\n\x10multi\
    _kill_count\x18\t\x20\x01(\rR\x0emultiKillCount\x12!\n\x0cwinner_score\
    \x18\n\x20\x01(\rR\x0bwinnerScore\x12\x1f\n\x0bloser_score\x18\x0b\x20\
    \x01(\rR\nloserScore\x128\n\x0chero_statues\x18\x0c\x20\x03(\x0b2\x15.CP\
    rotoItemHeroStatueR\x0bheroStatues\"\x91\x01\n\x1fCMsgTournamentItemEven\
    tResponse\x12E\n\nevent_type\x18\x01\x20\x01(\x0e2\x16.DOTA_TournamentEv\
    ents:\x0eTE_FIRST_BLOODR\teventType\x12'\n\x0fviewers_granted\x18\x06\
    \x20\x01(\rR\x0eviewersGranted\",\n\x0fCMsgTeamFanfare\x12\x19\n\x08matc\
    h_id\x18\x01\x20\x01(\x04R\x07matchId\"m\n\x17CMsgResponseTeamFanfare\
    \x12)\n\x10fanfare_goodguys\x18\x01\x20\x01(\rR\x0ffanfareGoodguys\x12'\
    \n\x0ffanfare_badguys\x18\x02\x20\x01(\rR\x0efanfareBadguys\"\xa6\x01\n\
    \x1cCMsgGameServerUploadSaveGame\x12\x1b\n\tgame_time\x18\x01\x20\x01(\r\
    R\x08gameTime\x12$\n\x0esave_game_data\x18\x02\x20\x01(\x0cR\x0csaveGame\
    Data\x12\x19\n\x08lobby_id\x18\x03\x20\x01(\x04R\x07lobbyId\x12(\n\x10pl\
    ayer_steam_ids\x18\x04\x20\x03(\x04R\x0eplayerSteamIds\"\xbe\x01\n\x1cCM\
    sgGameServerSaveGameResult\x12L\n\x06result\x18\x01\x20\x01(\x0e2$.CMsgG\
    ameServerSaveGameResult.Result:\x0eSaveSuccessfulR\x06result\"P\n\x06Res\
    ult\x12\x12\n\x0eSaveSuccessful\x10\0\x12\x13\n\x0fSessionNotFound\x10\
    \x01\x12\x11\n\rDatabaseError\x10\x02\x12\n\n\x06TooBig\x10\x03\"4\n\x19\
    CMsgGameServerGetLoadGame\x12\x17\n\x07save_id\x18\x01\x20\x01(\rR\x06sa\
    veId\"G\n\x1fCMsgGameServerGetLoadGameResult\x12$\n\x0esave_game_data\
    \x18\x01\x20\x01(\x0cR\x0csaveGameData\"t\n!CMsgDOTAGenerateDiretidePriz\
    eList\x12\x1d\n\nprize_list\x18\x01\x20\x01(\rR\tprizeList\x120\n\x14hig\
    hest_roshan_level\x18\x02\x20\x01(\rR\x12highestRoshanLevel\"\x84\x01\n)\
    CMsgDOTAGenerateDiretidePrizeListResponse\x12\x1b\n\titem_defs\x18\x01\
    \x20\x03(\rR\x08itemDefs\x12\x1b\n\tsteam_ids\x18\x02\x20\x03(\x06R\x08s\
    teamIds\x12\x1d\n\nprize_list\x18\x03\x20\x01(\rR\tprizeList\"Q\n\x1cCMs\
    gDOTARewardDiretidePrizes\x12\x12\n\x04team\x18\x01\x20\x01(\rR\x04team\
    \x12\x1d\n\nprize_list\x18\x02\x20\x01(\rR\tprizeList\"G\n&CMsgDOTADiret\
    idePrizesRewardedResponse\x12\x1d\n\nprize_list\x18\x01\x20\x01(\rR\tpri\
    zeList\"\xef\x02\n\x18CMsgDOTAAwardEventPoints\x12H\n\x0caward_points\
    \x18\x01\x20\x03(\x0b2%.CMsgDOTAAwardEventPoints.AwardPointsR\x0bawardPo\
    ints\x12\x19\n\x08match_id\x18\x02\x20\x01(\x04R\x07matchId\x12\x19\n\
    \x08event_id\x18\x04\x20\x01(\rR\x07eventId\x12\x1c\n\ttimestamp\x18\x05\
    \x20\x01(\rR\ttimestamp\x12!\n\x0caudit_action\x18\x06\x20\x01(\rR\x0bau\
    ditAction\x1a\x91\x01\n\x0bAwardPoints\x12\x1d\n\naccount_id\x18\x01\x20\
    \x01(\rR\taccountId\x12\x16\n\x06points\x18\x02\x20\x01(\x05R\x06points\
    \x12%\n\x0epremium_points\x18\x03\x20\x01(\x05R\rpremiumPoints\x12$\n\
    \x0etrade_ban_time\x18\x05\x20\x01(\rR\x0ctradeBanTime\"\xbd\x02\n)CMsgS\
    erverToGCSignoutAwardAdditionalDrops\x12P\n\x05drops\x18\x01\x20\x03(\
    \x0b2:.CMsgServerToGCSignoutAwardAdditionalDrops.AdditionalDropsR\x05dro\
    ps\x12\x19\n\x08match_id\x18\x02\x20\x01(\x04R\x07matchId\x1a\xa2\x01\n\
    \x0fAdditionalDrops\x12\x1b\n\tloot_list\x18\x01\x20\x01(\tR\x08lootList\
    \x12,\n\x12player_account_ids\x18\x02\x20\x03(\rR\x10playerAccountIds\
    \x12\x19\n\x08no_trade\x18\x03\x20\x01(\x08R\x07noTrade\x12)\n\x10random\
    ize_reward\x18\x04\x20\x01(\x08R\x0frandomizeReward\"\xda\x01\n\x1cCMsgD\
    OTAFrostivusTimeElapsed\x12\x18\n\x07seconds\x18\x01\x20\x01(\rR\x07seco\
    nds\x128\n\x05users\x18\x02\x20\x03(\x0b2\".CMsgDOTAFrostivusTimeElapsed\
    .UserR\x05users\x12\x19\n\x08match_id\x18\x03\x20\x01(\x04R\x07matchId\
    \x1aK\n\x04User\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\
    $\n\x0etime_elapsed_s\x18\x02\x20\x01(\rR\x0ctimeElapsedS\"]\n\x19CMsgGC\
    ToServerPingRequest\x12\x1d\n\nrequest_id\x18\x01\x20\x01(\x06R\trequest\
    Id\x12!\n\x0crequest_time\x18\x02\x20\x01(\x04R\x0brequestTime\"x\n\x1aC\
    MsgGCToServerPingResponse\x12\x1d\n\nrequest_id\x18\x01\x20\x01(\x06R\tr\
    equestId\x12!\n\x0crequest_time\x18\x02\x20\x01(\x04R\x0brequestTime\x12\
    \x18\n\x07cluster\x18\x03\x20\x01(\rR\x07cluster\"G\n\x1cCMsgGCToServerC\
    onsoleCommand\x12'\n\x0fconsole_command\x18\x01\x20\x01(\tR\x0econsoleCo\
    mmand\"T\n\x18CMsgServerGetEventPoints\x12\x19\n\x08event_id\x18\x01\x20\
    \x01(\rR\x07eventId\x12\x1d\n\naccount_id\x18\x02\x20\x03(\rR\taccountId\
    \"\xe1\x01\n\x20CMsgServerGetEventPointsResponse\x12\x19\n\x08event_id\
    \x18\x01\x20\x01(\rR\x07eventId\x12@\n\x06points\x18\x02\x20\x03(\x0b2(.\
    CMsgServerGetEventPointsResponse.PointsR\x06points\x1a`\n\x06Points\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12!\n\x0cpoints_total\
    \x18\x02\x20\x01(\rR\x0bpointsTotal\x12\x14\n\x05owned\x18\x04\x20\x01(\
    \x08R\x05owned\"\xb2\x02\n\x1fCMsgServerGrantSurveyPermission\x12A\n\x07\
    surveys\x18\x01\x20\x03(\x0b2'.CMsgServerGrantSurveyPermission.SurveyR\
    \x07surveys\x1a\xcb\x01\n\x06Survey\x12\x1d\n\naccount_id\x18\x01\x20\
    \x01(\rR\taccountId\x12\x1f\n\x0bquestion_id\x18\x02\x20\x01(\rR\nquesti\
    onId\x12\x1f\n\x0bexpire_time\x18\x03\x20\x01(\rR\nexpireTime\x12\x1d\n\
    \nsurvey_key\x18\x04\x20\x01(\x04R\tsurveyKey\x12\x1d\n\nextra_data\x18\
    \x05\x20\x01(\x04R\textraData\x12\"\n\rextra_data_32\x18\x06\x20\x01(\
    \x04R\x0bextraData32\"A\n'CMsgServerGrantSurveyPermissionResponse\x12\
    \x16\n\x06result\x18\x01\x20\x01(\rR\x06result\"\xa3\x03\n\"CMsgServerTo\
    GCMatchConnectionStats\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07ma\
    tchId\x12\x1b\n\tregion_id\x18\x02\x20\x01(\rR\x08regionId\x12\x1b\n\tle\
    ague_id\x18\x03\x20\x01(\rR\x08leagueId\x12D\n\x07players\x18\x04\x20\
    \x03(\x0b2*.CMsgServerToGCMatchConnectionStats.PlayerR\x07players\x12\
    \x1d\n\ncluster_id\x18\x05\x20\x01(\rR\tclusterId\x1a\xc2\x01\n\x06Playe\
    r\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x0e\n\x02ip\
    \x18\x02\x20\x01(\x07R\x02ip\x12\x1e\n\x0bavg_ping_ms\x18\x03\x20\x01(\r\
    R\tavgPingMs\x12\x1f\n\x0bpacket_loss\x18\x05\x20\x01(\x02R\npacketLoss\
    \x12%\n\x0eping_deviation\x18\x06\x20\x01(\x02R\rpingDeviation\x12!\n\
    \x0cfull_resends\x18\x07\x20\x01(\rR\x0bfullResends\"K\n\x20CMsgServerGC\
    UpdateSpectatorCount\x12'\n\x0fspectator_count\x18\x01\x20\x01(\rR\x0esp\
    ectatorCount\"\xaf\x02\n\x14CSerializedCombatLog\x12\x18\n\x07version\
    \x18\x01\x20\x01(\rR\x07version\x12@\n\ndictionary\x18\x02\x20\x01(\x0b2\
    \x20.CSerializedCombatLog.DictionaryR\ndictionary\x121\n\x07entries\x18\
    \x03\x20\x03(\x0b2\x17.CMsgDOTACombatLogEntryR\x07entries\x1a\x87\x01\n\
    \nDictionary\x12E\n\x07strings\x18\x01\x20\x03(\x0b2+.CSerializedCombatL\
    og.Dictionary.DictStringR\x07strings\x1a2\n\nDictString\x12\x0e\n\x02id\
    \x18\x01\x20\x02(\rR\x02id\x12\x14\n\x05value\x18\x02\x20\x02(\tR\x05val\
    ue\"D\n!CMsgServerToGCGetAdditionalEquips\x12\x1f\n\x0baccount_ids\x18\
    \x01\x20\x03(\rR\naccountIds\"\xd8\x01\n)CMsgServerToGCGetAdditionalEqui\
    psResponse\x12N\n\x06equips\x18\x01\x20\x03(\x0b26.CMsgServerToGCGetAddi\
    tionalEquipsResponse.CUserEquipsR\x06equips\x1a[\n\x0bCUserEquips\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12-\n\x06equips\x18\
    \x02\x20\x03(\x0b2\x15.CAdditionalEquipSlotR\x06equips\"?\n\x1cCMsgServe\
    rToGCGetProfileCard\x12\x1f\n\x0baccount_ids\x18\x01\x20\x03(\rR\naccoun\
    tIds\"R\n$CMsgServerToGCGetProfileCardResponse\x12*\n\x05cards\x18\x01\
    \x20\x03(\x0b2\x14.CMsgDOTAProfileCardR\x05cards\"\xc3\x01\n\x20CMsgServ\
    erToGCVictoryPredictions\x12B\n\x07records\x18\x01\x20\x03(\x0b2(.CMsgSe\
    rverToGCVictoryPredictions.RecordR\x07records\x1a[\n\x06Record\x12\x1d\n\
    \naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x17\n\x07item_id\x18\x02\
    \x20\x01(\x04R\x06itemId\x12\x19\n\x08item_ids\x18\x05\x20\x03(\x04R\x07\
    itemIds\"\xe2\x01\n\x16CMsgSuspiciousActivity\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12]\n\x08activity\x18\x02\x20\x01(\x0e2\x14\
    .ESuspiciousActivity:+k_ESuspiciousActivity_VAC_MultipleInstancesR\x08ac\
    tivity\x12\x1a\n\x08intdata1\x18\x03\x20\x01(\x11R\x08intdata1\x12\x1a\n\
    \x08intdata2\x18\x04\x20\x01(\x11R\x08intdata2\x12\x12\n\x04time\x18\x05\
    \x20\x01(\rR\x04time\"\x1d\n\x1bCMsgServerToGCRequestStatus\"B\n$CMsgSer\
    verToGCRequestStatus_Response\x12\x1a\n\x08response\x18\x01\x20\x01(\rR\
    \x08response\"\xe8\x02\n\x1fCMsgSignOutAssassinMiniGameInfo\x12'\n\x0fwi\
    nning_players\x18\x01\x20\x03(\x06R\x0ewinningPlayers\x12%\n\x0elosing_p\
    layers\x18\x02\x20\x03(\x06R\rlosingPlayers\x12#\n\rarcana_owners\x18\
    \x03\x20\x03(\x06R\x0carcanaOwners\x12!\n\x0cassassin_won\x18\x04\x20\
    \x01(\x08R\x0bassassinWon\x12$\n\x0etarget_hero_id\x18\x05\x20\x01(\rR\
    \x0ctargetHeroId\x12-\n\x12contract_completed\x18\x06\x20\x01(\x08R\x11c\
    ontractCompleted\x124\n\x16contract_complete_time\x18\x07\x20\x01(\x02R\
    \x14contractCompleteTime\x12\"\n\rpa_is_radiant\x18\x08\x20\x01(\x08R\
    \x0bpaIsRadiant\"P\n\x20CMsgServerToGCGetIngameEventData\x12,\n\x05event\
    \x18\x01\x20\x01(\x0e2\x07.EEvent:\rEVENT_ID_NONER\x05event\"O\n%CMsgGCT\
    oServerIngameEventDataOraclePA\x12&\n\x0ftarget_hero_ids\x18\x01\x20\x03\
    (\rR\rtargetHeroIds\"\x86\x02\n\x1bCMsgServerToGCKillSummaries\x12%\n\
    \x0eingameevent_id\x18\x01\x20\x01(\rR\ringameeventId\x12F\n\tsummaries\
    \x18\x02\x20\x03(\x0b2(.CMsgServerToGCKillSummaries.KillSummaryR\tsummar\
    ies\x1ax\n\x0bKillSummary\x12$\n\x0ekiller_hero_id\x18\x01\x20\x01(\rR\
    \x0ckillerHeroId\x12$\n\x0evictim_hero_id\x18\x02\x20\x01(\rR\x0cvictimH\
    eroId\x12\x1d\n\nkill_count\x18\x03\x20\x01(\rR\tkillCount\"\xf8\x03\n\
    \x1eCMsgGCToServerPredictionResult\x12\x1d\n\naccount_id\x18\x01\x20\x01\
    (\rR\taccountId\x12\x19\n\x08match_id\x18\x02\x20\x01(\x04R\x07matchId\
    \x12\x18\n\x07correct\x18\x03\x20\x01(\x08R\x07correct\x12L\n\x0bpredict\
    ions\x18\x04\x20\x03(\x0b2*.CMsgGCToServerPredictionResult.PredictionR\
    \x0bpredictions\x1a\xb3\x02\n\nPrediction\x12\x19\n\x08item_def\x18\x01\
    \x20\x01(\rR\x07itemDef\x12\x1f\n\x0bnum_correct\x18\x02\x20\x01(\rR\nnu\
    mCorrect\x12\x1b\n\tnum_fails\x18\x03\x20\x01(\rR\x08numFails\x12a\n\x06\
    result\x18\x04\x20\x01(\x0e22.CMsgGCToServerPredictionResult.Prediction.\
    EResult:\x15k_eResult_ItemGrantedR\x06result\x12*\n\x11granted_item_defs\
    \x18\x06\x20\x03(\rR\x0fgrantedItemDefs\"=\n\x07EResult\x12\x19\n\x15k_e\
    Result_ItemGranted\x10\x01\x12\x17\n\x13k_eResult_Destroyed\x10\x02\"X\n\
    \x1eCMsgServerToGCLockCharmTrading\x12\x1d\n\naccount_id\x18\x01\x20\x01\
    (\rR\taccountId\x12\x17\n\x07item_id\x18\x02\x20\x01(\x04R\x06itemId\"\
    \x96\x03\n\x20CMsgSignOutUpdatePlayerChallenge\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12I\n\tcompleted\x18\x02\x20\x03(\x0b2+.CMs\
    gSignOutUpdatePlayerChallenge.ChallengeR\tcompleted\x12G\n\x08rerolled\
    \x18\x03\x20\x03(\x0b2+.CMsgSignOutUpdatePlayerChallenge.ChallengeR\x08r\
    erolled\x12\x19\n\x08match_id\x18\x04\x20\x01(\x04R\x07matchId\x12\x17\n\
    \x07hero_id\x18\x05\x20\x01(\rR\x06heroId\x1a\x8a\x01\n\tChallenge\x12\
    \x19\n\x08event_id\x18\x01\x20\x01(\rR\x07eventId\x12\x1f\n\x0bsequence_\
    id\x18\x03\x20\x01(\rR\nsequenceId\x12\x1a\n\x08progress\x18\x04\x20\x01\
    (\rR\x08progress\x12%\n\x0echallenge_rank\x18\x05\x20\x01(\rR\rchallenge\
    Rank\"\x89\x01\n#CMsgServerToGCRerollPlayerChallenge\x12\x1d\n\naccount_\
    id\x18\x01\x20\x01(\rR\taccountId\x12C\n\nreroll_msg\x18\x02\x20\x01(\
    \x0b2$.CMsgClientToGCRerollPlayerChallengeR\trerollMsg\"\xa8\x02\n\x1dCM\
    sgServerToGCHoldEventPoints\x12@\n\x05holds\x18\x01\x20\x03(\x0b2*.CMsgS\
    erverToGCHoldEventPoints.HoldRequestR\x05holds\x12\x19\n\x08event_id\x18\
    \x02\x20\x01(\rR\x07eventId\x12\x19\n\x08hold_key\x18\x03\x20\x01(\x04R\
    \x07holdKey\x12\x1d\n\nhold_until\x18\x04\x20\x01(\rR\tholdUntil\x1ap\n\
    \x0bHoldRequest\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\
    \x1f\n\x0bpoints_held\x18\x02\x20\x01(\rR\npointsHeld\x12!\n\x0cpremium_\
    held\x18\x03\x20\x01(\rR\x0bpremiumHeld\"z\n!CMsgSignOutReleaseEventPoin\
    tHolds\x12\x1f\n\x0baccount_ids\x18\x01\x20\x03(\rR\naccountIds\x12\x19\
    \n\x08event_id\x18\x02\x20\x01(\rR\x07eventId\x12\x19\n\x08hold_key\x18\
    \x03\x20\x01(\x04R\x07holdKey\"\x8c\x01\n#CMsgGCToServerUpdateBroadcastC\
    heers\x12\x1d\n\ntime_stamp\x18\x01\x20\x01(\rR\ttimeStamp\x12\"\n\rteam\
    _1_cheers\x18\x02\x20\x01(\rR\x0bteam1Cheers\x12\"\n\rteam_2_cheers\x18\
    \x03\x20\x01(\rR\x0bteam2Cheers\"\xe3\x01\n\x15CMsgSignOutWagerStats\x12\
    7\n\x07players\x18\x01\x20\x03(\x0b2\x1d.CMsgSignOutWagerStats.PlayerR\
    \x07players\x12\x19\n\x08event_id\x18\x02\x20\x01(\rR\x07eventId\x1av\n\
    \x06Player\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1a\
    \n\x08winnings\x18\x02\x20\x01(\rR\x08winnings\x12\x1b\n\tmax_wager\x18\
    \x03\x20\x01(\rR\x08maxWager\x12\x14\n\x05wager\x18\x04\x20\x01(\rR\x05w\
    ager\"\xac\x02\n\x0eCMsgSpendWager\x120\n\x07players\x18\x01\x20\x03(\
    \x0b2\x16.CMsgSpendWager.PlayerR\x07players\x12\x19\n\x08event_id\x18\
    \x02\x20\x01(\rR\x07eventId\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\rR\tti\
    mestamp\x12\x19\n\x08match_id\x18\x04\x20\x01(\x04R\x07matchId\x12&\n\
    \x0fserver_steam_id\x18\x05\x20\x01(\x04R\rserverSteamId\x1al\n\x06Playe\
    r\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x14\n\x05wage\
    r\x18\x02\x20\x01(\rR\x05wager\x12-\n\x13wager_token_item_id\x18\x03\x20\
    \x01(\x04R\x10wagerTokenItemId\"\xd4\x02\n\x12CMsgSignOutXPCoins\x124\n\
    \x07players\x18\x01\x20\x03(\x0b2\x1a.CMsgSignOutXPCoins.PlayerR\x07play\
    ers\x12\x19\n\x08event_id\x18\x02\x20\x01(\rR\x07eventId\x12\x19\n\x08ma\
    tch_id\x18\x03\x20\x01(\x04R\x07matchId\x12\x1c\n\ttimestamp\x18\x04\x20\
    \x01(\rR\ttimestamp\x1a\xb3\x01\n\x06Player\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12\x1b\n\txp_gained\x18\x02\x20\x01(\rR\x08\
    xpGained\x12\x1f\n\x0bcoins_spent\x18\x03\x20\x01(\rR\ncoinsSpent\x12-\n\
    \x13wager_token_item_id\x18\x04\x20\x01(\x04R\x10wagerTokenItemId\x12\
    \x1d\n\nrank_wager\x18\x05\x20\x01(\rR\trankWager\"\x83\x02\n\x20CMsgSig\
    nOutCommunityGoalProgress\x12\x19\n\x08event_id\x18\x01\x20\x01(\rR\x07e\
    ventId\x12_\n\x10event_increments\x18\x02\x20\x03(\x0b24.CMsgSignOutComm\
    unityGoalProgress.EventGoalIncrementR\x0feventIncrements\x1ac\n\x12Event\
    GoalIncrement\x12\"\n\revent_goal_id\x18\x01\x20\x01(\rR\x0beventGoalId\
    \x12)\n\x10increment_amount\x18\x02\x20\x01(\rR\x0fincrementAmount\"\xcf\
    \x01\n\x1aCMsgServerToGCPostMatchTip\x12\x19\n\x08event_id\x18\x01\x20\
    \x01(\rR\x07eventId\x12\x19\n\x08match_id\x18\x02\x20\x01(\x04R\x07match\
    Id\x12*\n\x11tipper_account_id\x18\x03\x20\x01(\rR\x0ftipperAccountId\
    \x120\n\x14recipient_account_id\x18\x04\x20\x01(\rR\x12recipientAccountI\
    d\x12\x1d\n\ntip_amount\x18\x05\x20\x01(\rR\ttipAmount\"\x8e\x02\n\"CMsg\
    ServerToGCPostMatchTipResponse\x12\x19\n\x08match_id\x18\x01\x20\x01(\
    \x04R\x07matchId\x12*\n\x11tipper_account_id\x18\x02\x20\x01(\rR\x0ftipp\
    erAccountId\x120\n\x14recipient_account_id\x18\x03\x20\x01(\rR\x12recipi\
    entAccountId\x12K\n\x06result\x18\x04\x20\x01(\x0e2*.CMsgServerToGCPostM\
    atchTipResponse.Result:\x07SUCCESSR\x06result\"\"\n\x06Result\x12\x0b\n\
    \x07SUCCESS\x10\0\x12\x0b\n\x07FAILURE\x10\x01\"\xcb\x01\n.CMsgServerToG\
    CStartCompendiumInGamePredictions\x12\x1b\n\tleague_id\x18\x01\x20\x01(\
    \rR\x08leagueId\x12\x19\n\x08match_id\x18\x02\x20\x01(\x04R\x07matchId\
    \x12\x1d\n\nhltv_delay\x18\x03\x20\x01(\x02R\thltvDelay\x12%\n\x0epredic\
    tion_ids\x18\x04\x20\x03(\rR\rpredictionIds\x12\x1b\n\tseries_id\x18\x05\
    \x20\x01(\rR\x08seriesId\"P\n6CMsgServerToGCStartCompendiumInGamePredict\
    ionsResponse\x12\x16\n\x06result\x18\x01\x20\x01(\x08R\x06result\"P\n3CM\
    sgServerToGCCloseCompendiumInGamePredictionVoting\x12\x19\n\x08match_id\
    \x18\x01\x20\x01(\x04R\x07matchId\"U\n;CMsgServerToGCCloseCompendiumInGa\
    mePredictionVotingResponse\x12\x16\n\x06result\x18\x01\x20\x01(\x08R\x06\
    result\"I\n,CMsgServerToGCEndCompendiumInGamePredictions\x12\x19\n\x08ma\
    tch_id\x18\x01\x20\x01(\x04R\x07matchId\"N\n4CMsgServerToGCEndCompendium\
    InGamePredictionsResponse\x12\x16\n\x06result\x18\x01\x20\x01(\x08R\x06r\
    esult\"\xc7\x02\n/CMsgServerToGCCompendiumInGamePredictionResults\x12\
    \x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12[\n\x07results\
    \x18\x02\x20\x03(\x0b2A.CMsgServerToGCCompendiumInGamePredictionResults.\
    PredictionResultR\x07results\x1a\x9b\x01\n\x10PredictionResult\x12#\n\rp\
    rediction_id\x18\x01\x20\x01(\rR\x0cpredictionId\x12)\n\x10prediction_va\
    lue\x18\x02\x20\x01(\rR\x0fpredictionValue\x127\n\x18prediction_value_is\
    _mask\x18\x03\x20\x01(\x08R\x15predictionValueIsMask\"Q\n7CMsgServerToGC\
    CompendiumInGamePredictionResultsResponse\x12\x16\n\x06result\x18\x01\
    \x20\x01(\x08R\x06result\"y\n+CMsgGCToGCCompendiumInGamePredictionResult\
    s\x12J\n\x07results\x18\x01\x20\x01(\x0b20.CMsgServerToGCCompendiumInGam\
    ePredictionResultsR\x07results\"\xdc\x04\n,CMsgServerToGCMatchPlayerItem\
    PurchaseHistory\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\
    \x12\x10\n\x03mmr\x18\x02\x20\x01(\rR\x03mmr\x12N\n\x07players\x18\x03\
    \x20\x03(\x0b24.CMsgServerToGCMatchPlayerItemPurchaseHistory.PlayerR\x07\
    players\x1a\x99\x01\n\x0cItemPurchase\x12\x12\n\x04item\x18\x01\x20\x01(\
    \rR\x04item\x12\x12\n\x04gold\x18\x02\x20\x01(\rR\x04gold\x12\x1b\n\tnet\
    _worth\x18\x03\x20\x01(\rR\x08netWorth\x12\x1b\n\tgame_time\x18\x04\x20\
    \x01(\rR\x08gameTime\x12'\n\x0finventory_items\x18\x05\x20\x03(\rR\x0ein\
    ventoryItems\x1a\x92\x02\n\x06Player\x12\x1f\n\x0bplayer_slot\x18\x01\
    \x20\x01(\rR\nplayerSlot\x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\tacco\
    untId\x12\x17\n\x07hero_id\x18\x03\x20\x01(\rR\x06heroId\x12&\n\x0fallie\
    d_hero_ids\x18\x04\x20\x03(\rR\ralliedHeroIds\x12$\n\x0eenemy_hero_ids\
    \x18\x05\x20\x03(\rR\x0cenemyHeroIds\x12a\n\x0eitem_purchases\x18\x06\
    \x20\x03(\x0b2:.CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchas\
    eR\ritemPurchases*\xc6\x01\n\x1aEPoorNetworkConditionsType\x12!\n\x1dk_E\
    PoorNetworkConditions_None\x10\0\x12$\n\x20k_EPoorNetworkConditions_Unkn\
    own\x10\x01\x12+\n'k_EPoorNetworkConditions_MassDisconnect\x10\x02\x122\
    \n.k_EPoorNetworkConditions_ExcessBadQosIntervals\x10\x03*\xc0\x02\n\x11\
    EAbilityAbuseType\x12\x1c\n\x18k_EAbilityAbuseType_None\x10\0\x12#\n\x1f\
    k_EAbilityAbuseType_Io_Relocate\x10\x01\x12*\n&k_EAbilityAbuseType_Chen_\
    Test_Of_Faith\x10\x02\x12&\n\"k_EAbilityAbuseType_Bane_Nightmare\x10\x03\
    \x12-\n)k_EAbilityAbuseType_Bloodseeker_Bloodrage\x10\x04\x124\n0k_EAbil\
    ityAbuseType_Outworld_Astral_Imprisonment\x10\x05\x12/\n+k_EAbilityAbuse\
    Type_Shadow_Demon_Disruption\x10\x06*\xf9\x03\n\x17EIntentionalFeedingTy\
    pe\x12\"\n\x1ek_EIntentionalFeedingType_None\x10\0\x12-\n)k_EIntentional\
    FeedingType_ExcessiveDeaths\x10\x01\x126\n2k_EIntentionalFeedingType_Mul\
    tipleCourierPurchases\x10\x02\x123\n/k_EIntentionalFeedingType_MultipleC\
    ourierDeaths\x10\x04\x12)\n%k_EIntentionalFeedingType_LowActivity\x10\
    \x08\x12'\n#k_EIntentionalFeedingType_LowDamage\x10\x10\x12-\n)k_EIntent\
    ionalFeedingType_HighUnspentGold\x10\x20\x122\n.k_EIntentionalFeedingTyp\
    e_SoldTooMuchItemValue\x10@\x122\n-k_EIntentionalFeedingType_TooManyDrop\
    pedItems\x10\x80\x01\x123\n.k_EIntentionalFeedingType_ExcessiveTowerDama\
    ge\x10\x80\x02*\xa3\x01\n\x13ESuspiciousActivity\x12/\n+k_ESuspiciousAct\
    ivity_VAC_MultipleInstances\x10\x01\x12,\n(k_ESuspiciousActivity_Intenti\
    onalFeeding\x10d\x12-\n)k_ESuspiciousActivity_SuspectedBotFarming\x10e*\
    \x80\x03\n\x14ESuspiciousBuildType\x12\x1f\n\x1bk_ESuspiciousBuildType_N\
    one\x10\0\x12&\n\"k_ESuspiciousBuildType_NoGoldSpent\x10\x01\x12\"\n\x1e\
    k_ESuspiciousBuildType_NoItems\x10\x02\x12-\n)k_ESuspiciousBuildType_NoS\
    ignificantItems\x10\x03\x12'\n#k_ESuspiciousBuildType_TooManyBoots\x10\
    \x04\x12\x1f\n\x1bk_ESuspiciousBuildType_Bot1\x10e\x12\x1f\n\x1bk_ESuspi\
    ciousBuildType_Bot2\x10f\x12\x1f\n\x1bk_ESuspiciousBuildType_Bot3\x10g\
    \x12\x1f\n\x1bk_ESuspiciousBuildType_Bot4\x10h\x12\x1f\n\x1bk_ESuspiciou\
    sBuildType_Bot5\x10iB\x05H\x01\x80\x01\0\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
