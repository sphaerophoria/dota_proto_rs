// This file is generated. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCPlayerInfo {
    // message fields
    player_infos: ::protobuf::RepeatedField<CMsgGCPlayerInfo_PlayerInfo>,
    leaderboards: ::protobuf::RepeatedField<CMsgGCPlayerInfo_RegionLeaderboard>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCPlayerInfo {}

impl CMsgGCPlayerInfo {
    pub fn new() -> CMsgGCPlayerInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCPlayerInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCPlayerInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCPlayerInfo,
        };
        unsafe {
            instance.get(CMsgGCPlayerInfo::new)
        }
    }

    // repeated .CMsgGCPlayerInfo.PlayerInfo player_infos = 1;

    pub fn clear_player_infos(&mut self) {
        self.player_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_infos(&mut self, v: ::protobuf::RepeatedField<CMsgGCPlayerInfo_PlayerInfo>) {
        self.player_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_infos(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCPlayerInfo_PlayerInfo> {
        &mut self.player_infos
    }

    // Take field
    pub fn take_player_infos(&mut self) -> ::protobuf::RepeatedField<CMsgGCPlayerInfo_PlayerInfo> {
        ::std::mem::replace(&mut self.player_infos, ::protobuf::RepeatedField::new())
    }

    pub fn get_player_infos(&self) -> &[CMsgGCPlayerInfo_PlayerInfo] {
        &self.player_infos
    }

    fn get_player_infos_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCPlayerInfo_PlayerInfo> {
        &self.player_infos
    }

    fn mut_player_infos_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCPlayerInfo_PlayerInfo> {
        &mut self.player_infos
    }

    // repeated .CMsgGCPlayerInfo.RegionLeaderboard leaderboards = 2;

    pub fn clear_leaderboards(&mut self) {
        self.leaderboards.clear();
    }

    // Param is passed by value, moved
    pub fn set_leaderboards(&mut self, v: ::protobuf::RepeatedField<CMsgGCPlayerInfo_RegionLeaderboard>) {
        self.leaderboards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_leaderboards(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCPlayerInfo_RegionLeaderboard> {
        &mut self.leaderboards
    }

    // Take field
    pub fn take_leaderboards(&mut self) -> ::protobuf::RepeatedField<CMsgGCPlayerInfo_RegionLeaderboard> {
        ::std::mem::replace(&mut self.leaderboards, ::protobuf::RepeatedField::new())
    }

    pub fn get_leaderboards(&self) -> &[CMsgGCPlayerInfo_RegionLeaderboard] {
        &self.leaderboards
    }

    fn get_leaderboards_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCPlayerInfo_RegionLeaderboard> {
        &self.leaderboards
    }

    fn mut_leaderboards_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCPlayerInfo_RegionLeaderboard> {
        &mut self.leaderboards
    }
}

impl ::protobuf::Message for CMsgGCPlayerInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.player_infos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.leaderboards {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_infos)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.leaderboards)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.player_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.leaderboards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.player_infos {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.leaderboards {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCPlayerInfo {
    fn new() -> CMsgGCPlayerInfo {
        CMsgGCPlayerInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCPlayerInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCPlayerInfo_PlayerInfo>>(
                    "player_infos",
                    CMsgGCPlayerInfo::get_player_infos_for_reflect,
                    CMsgGCPlayerInfo::mut_player_infos_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCPlayerInfo_RegionLeaderboard>>(
                    "leaderboards",
                    CMsgGCPlayerInfo::get_leaderboards_for_reflect,
                    CMsgGCPlayerInfo::mut_leaderboards_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCPlayerInfo>(
                    "CMsgGCPlayerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCPlayerInfo {
    fn clear(&mut self) {
        self.clear_player_infos();
        self.clear_leaderboards();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCPlayerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCPlayerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCPlayerInfo_PlayerInfo {
    // message fields
    account_id: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    country_code: ::protobuf::SingularField<::std::string::String>,
    fantasy_role: ::std::option::Option<u32>,
    team_id: ::std::option::Option<u32>,
    team_name: ::protobuf::SingularField<::std::string::String>,
    team_tag: ::protobuf::SingularField<::std::string::String>,
    sponsor: ::protobuf::SingularField<::std::string::String>,
    is_locked: ::std::option::Option<bool>,
    is_pro: ::std::option::Option<bool>,
    locked_until: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCPlayerInfo_PlayerInfo {}

impl CMsgGCPlayerInfo_PlayerInfo {
    pub fn new() -> CMsgGCPlayerInfo_PlayerInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCPlayerInfo_PlayerInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCPlayerInfo_PlayerInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCPlayerInfo_PlayerInfo,
        };
        unsafe {
            instance.get(CMsgGCPlayerInfo_PlayerInfo::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string country_code = 3;

    pub fn clear_country_code(&mut self) {
        self.country_code.clear();
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code.set_default();
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_country_code_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.country_code
    }

    fn mut_country_code_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.country_code
    }

    // optional uint32 fantasy_role = 4;

    pub fn clear_fantasy_role(&mut self) {
        self.fantasy_role = ::std::option::Option::None;
    }

    pub fn has_fantasy_role(&self) -> bool {
        self.fantasy_role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_role(&mut self, v: u32) {
        self.fantasy_role = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_role(&self) -> u32 {
        self.fantasy_role.unwrap_or(0)
    }

    fn get_fantasy_role_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_role
    }

    fn mut_fantasy_role_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_role
    }

    // optional uint32 team_id = 5;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_id
    }

    // optional string team_name = 6;

    pub fn clear_team_name(&mut self) {
        self.team_name.clear();
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name.set_default();
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_name
    }

    fn mut_team_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_name
    }

    // optional string team_tag = 7;

    pub fn clear_team_tag(&mut self) {
        self.team_tag.clear();
    }

    pub fn has_team_tag(&self) -> bool {
        self.team_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_tag(&mut self, v: ::std::string::String) {
        self.team_tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_tag(&mut self) -> &mut ::std::string::String {
        if self.team_tag.is_none() {
            self.team_tag.set_default();
        }
        self.team_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_tag(&mut self) -> ::std::string::String {
        self.team_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_tag(&self) -> &str {
        match self.team_tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_tag_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_tag
    }

    fn mut_team_tag_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_tag
    }

    // optional string sponsor = 8;

    pub fn clear_sponsor(&mut self) {
        self.sponsor.clear();
    }

    pub fn has_sponsor(&self) -> bool {
        self.sponsor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sponsor(&mut self, v: ::std::string::String) {
        self.sponsor = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sponsor(&mut self) -> &mut ::std::string::String {
        if self.sponsor.is_none() {
            self.sponsor.set_default();
        }
        self.sponsor.as_mut().unwrap()
    }

    // Take field
    pub fn take_sponsor(&mut self) -> ::std::string::String {
        self.sponsor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_sponsor(&self) -> &str {
        match self.sponsor.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_sponsor_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.sponsor
    }

    fn mut_sponsor_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.sponsor
    }

    // optional bool is_locked = 9;

    pub fn clear_is_locked(&mut self) {
        self.is_locked = ::std::option::Option::None;
    }

    pub fn has_is_locked(&self) -> bool {
        self.is_locked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_locked(&mut self, v: bool) {
        self.is_locked = ::std::option::Option::Some(v);
    }

    pub fn get_is_locked(&self) -> bool {
        self.is_locked.unwrap_or(false)
    }

    fn get_is_locked_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_locked
    }

    fn mut_is_locked_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_locked
    }

    // optional bool is_pro = 10;

    pub fn clear_is_pro(&mut self) {
        self.is_pro = ::std::option::Option::None;
    }

    pub fn has_is_pro(&self) -> bool {
        self.is_pro.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_pro(&mut self, v: bool) {
        self.is_pro = ::std::option::Option::Some(v);
    }

    pub fn get_is_pro(&self) -> bool {
        self.is_pro.unwrap_or(false)
    }

    fn get_is_pro_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_pro
    }

    fn mut_is_pro_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_pro
    }

    // optional uint32 locked_until = 11;

    pub fn clear_locked_until(&mut self) {
        self.locked_until = ::std::option::Option::None;
    }

    pub fn has_locked_until(&self) -> bool {
        self.locked_until.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locked_until(&mut self, v: u32) {
        self.locked_until = ::std::option::Option::Some(v);
    }

    pub fn get_locked_until(&self) -> u32 {
        self.locked_until.unwrap_or(0)
    }

    fn get_locked_until_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.locked_until
    }

    fn mut_locked_until_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.locked_until
    }

    // optional uint32 timestamp = 12;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }
}

impl ::protobuf::Message for CMsgGCPlayerInfo_PlayerInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country_code)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_role = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_name)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_tag)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sponsor)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_locked = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_pro = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.locked_until = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.fantasy_role {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.team_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.sponsor.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.is_locked {
            my_size += 2;
        }
        if let Some(v) = self.is_pro {
            my_size += 2;
        }
        if let Some(v) = self.locked_until {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.country_code.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.fantasy_role {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.team_name.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.team_tag.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.sponsor.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.is_locked {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.is_pro {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.locked_until {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCPlayerInfo_PlayerInfo {
    fn new() -> CMsgGCPlayerInfo_PlayerInfo {
        CMsgGCPlayerInfo_PlayerInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCPlayerInfo_PlayerInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCPlayerInfo_PlayerInfo::get_account_id_for_reflect,
                    CMsgGCPlayerInfo_PlayerInfo::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgGCPlayerInfo_PlayerInfo::get_name_for_reflect,
                    CMsgGCPlayerInfo_PlayerInfo::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "country_code",
                    CMsgGCPlayerInfo_PlayerInfo::get_country_code_for_reflect,
                    CMsgGCPlayerInfo_PlayerInfo::mut_country_code_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_role",
                    CMsgGCPlayerInfo_PlayerInfo::get_fantasy_role_for_reflect,
                    CMsgGCPlayerInfo_PlayerInfo::mut_fantasy_role_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_id",
                    CMsgGCPlayerInfo_PlayerInfo::get_team_id_for_reflect,
                    CMsgGCPlayerInfo_PlayerInfo::mut_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_name",
                    CMsgGCPlayerInfo_PlayerInfo::get_team_name_for_reflect,
                    CMsgGCPlayerInfo_PlayerInfo::mut_team_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_tag",
                    CMsgGCPlayerInfo_PlayerInfo::get_team_tag_for_reflect,
                    CMsgGCPlayerInfo_PlayerInfo::mut_team_tag_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sponsor",
                    CMsgGCPlayerInfo_PlayerInfo::get_sponsor_for_reflect,
                    CMsgGCPlayerInfo_PlayerInfo::mut_sponsor_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_locked",
                    CMsgGCPlayerInfo_PlayerInfo::get_is_locked_for_reflect,
                    CMsgGCPlayerInfo_PlayerInfo::mut_is_locked_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_pro",
                    CMsgGCPlayerInfo_PlayerInfo::get_is_pro_for_reflect,
                    CMsgGCPlayerInfo_PlayerInfo::mut_is_pro_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "locked_until",
                    CMsgGCPlayerInfo_PlayerInfo::get_locked_until_for_reflect,
                    CMsgGCPlayerInfo_PlayerInfo::mut_locked_until_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgGCPlayerInfo_PlayerInfo::get_timestamp_for_reflect,
                    CMsgGCPlayerInfo_PlayerInfo::mut_timestamp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCPlayerInfo_PlayerInfo>(
                    "CMsgGCPlayerInfo_PlayerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCPlayerInfo_PlayerInfo {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_name();
        self.clear_country_code();
        self.clear_fantasy_role();
        self.clear_team_id();
        self.clear_team_name();
        self.clear_team_tag();
        self.clear_sponsor();
        self.clear_is_locked();
        self.clear_is_pro();
        self.clear_locked_until();
        self.clear_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCPlayerInfo_PlayerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCPlayerInfo_PlayerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCPlayerInfo_RegionLeaderboard {
    // message fields
    division: ::std::option::Option<u32>,
    account_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCPlayerInfo_RegionLeaderboard {}

impl CMsgGCPlayerInfo_RegionLeaderboard {
    pub fn new() -> CMsgGCPlayerInfo_RegionLeaderboard {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCPlayerInfo_RegionLeaderboard {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCPlayerInfo_RegionLeaderboard> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCPlayerInfo_RegionLeaderboard,
        };
        unsafe {
            instance.get(CMsgGCPlayerInfo_RegionLeaderboard::new)
        }
    }

    // optional uint32 division = 1;

    pub fn clear_division(&mut self) {
        self.division = ::std::option::Option::None;
    }

    pub fn has_division(&self) -> bool {
        self.division.is_some()
    }

    // Param is passed by value, moved
    pub fn set_division(&mut self, v: u32) {
        self.division = ::std::option::Option::Some(v);
    }

    pub fn get_division(&self) -> u32 {
        self.division.unwrap_or(0)
    }

    fn get_division_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.division
    }

    fn mut_division_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.division
    }

    // repeated uint32 account_ids = 2;

    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }

    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }

    fn get_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.account_ids
    }

    fn mut_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }
}

impl ::protobuf::Message for CMsgGCPlayerInfo_RegionLeaderboard {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.division = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.division {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.division {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_ids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCPlayerInfo_RegionLeaderboard {
    fn new() -> CMsgGCPlayerInfo_RegionLeaderboard {
        CMsgGCPlayerInfo_RegionLeaderboard::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCPlayerInfo_RegionLeaderboard>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "division",
                    CMsgGCPlayerInfo_RegionLeaderboard::get_division_for_reflect,
                    CMsgGCPlayerInfo_RegionLeaderboard::mut_division_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids",
                    CMsgGCPlayerInfo_RegionLeaderboard::get_account_ids_for_reflect,
                    CMsgGCPlayerInfo_RegionLeaderboard::mut_account_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCPlayerInfo_RegionLeaderboard>(
                    "CMsgGCPlayerInfo_RegionLeaderboard",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCPlayerInfo_RegionLeaderboard {
    fn clear(&mut self) {
        self.clear_division();
        self.clear_account_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCPlayerInfo_RegionLeaderboard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCPlayerInfo_RegionLeaderboard {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTACreateFantasyLeagueRequest {
    // message fields
    league_name: ::protobuf::SingularField<::std::string::String>,
    league_logo: ::std::option::Option<u64>,
    selection_mode: ::std::option::Option<super::dota_shared_enums::Fantasy_Selection_Mode>,
    team_count: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTACreateFantasyLeagueRequest {}

impl CMsgDOTACreateFantasyLeagueRequest {
    pub fn new() -> CMsgDOTACreateFantasyLeagueRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTACreateFantasyLeagueRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTACreateFantasyLeagueRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTACreateFantasyLeagueRequest,
        };
        unsafe {
            instance.get(CMsgDOTACreateFantasyLeagueRequest::new)
        }
    }

    // optional string league_name = 1;

    pub fn clear_league_name(&mut self) {
        self.league_name.clear();
    }

    pub fn has_league_name(&self) -> bool {
        self.league_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_name(&mut self, v: ::std::string::String) {
        self.league_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_league_name(&mut self) -> &mut ::std::string::String {
        if self.league_name.is_none() {
            self.league_name.set_default();
        }
        self.league_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_league_name(&mut self) -> ::std::string::String {
        self.league_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_league_name(&self) -> &str {
        match self.league_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_league_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.league_name
    }

    fn mut_league_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.league_name
    }

    // optional uint64 league_logo = 2;

    pub fn clear_league_logo(&mut self) {
        self.league_logo = ::std::option::Option::None;
    }

    pub fn has_league_logo(&self) -> bool {
        self.league_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_logo(&mut self, v: u64) {
        self.league_logo = ::std::option::Option::Some(v);
    }

    pub fn get_league_logo(&self) -> u64 {
        self.league_logo.unwrap_or(0)
    }

    fn get_league_logo_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.league_logo
    }

    fn mut_league_logo_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.league_logo
    }

    // optional .Fantasy_Selection_Mode selection_mode = 3;

    pub fn clear_selection_mode(&mut self) {
        self.selection_mode = ::std::option::Option::None;
    }

    pub fn has_selection_mode(&self) -> bool {
        self.selection_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_mode(&mut self, v: super::dota_shared_enums::Fantasy_Selection_Mode) {
        self.selection_mode = ::std::option::Option::Some(v);
    }

    pub fn get_selection_mode(&self) -> super::dota_shared_enums::Fantasy_Selection_Mode {
        self.selection_mode.unwrap_or(super::dota_shared_enums::Fantasy_Selection_Mode::FANTASY_SELECTION_INVALID)
    }

    fn get_selection_mode_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::Fantasy_Selection_Mode> {
        &self.selection_mode
    }

    fn mut_selection_mode_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::Fantasy_Selection_Mode> {
        &mut self.selection_mode
    }

    // optional uint32 team_count = 4;

    pub fn clear_team_count(&mut self) {
        self.team_count = ::std::option::Option::None;
    }

    pub fn has_team_count(&self) -> bool {
        self.team_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_count(&mut self, v: u32) {
        self.team_count = ::std::option::Option::Some(v);
    }

    pub fn get_team_count(&self) -> u32 {
        self.team_count.unwrap_or(0)
    }

    fn get_team_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_count
    }

    fn mut_team_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_count
    }
}

impl ::protobuf::Message for CMsgDOTACreateFantasyLeagueRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.league_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.league_logo = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.selection_mode = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.league_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.league_logo {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.selection_mode {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.team_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.league_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.league_logo {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.selection_mode {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.team_count {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTACreateFantasyLeagueRequest {
    fn new() -> CMsgDOTACreateFantasyLeagueRequest {
        CMsgDOTACreateFantasyLeagueRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTACreateFantasyLeagueRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "league_name",
                    CMsgDOTACreateFantasyLeagueRequest::get_league_name_for_reflect,
                    CMsgDOTACreateFantasyLeagueRequest::mut_league_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "league_logo",
                    CMsgDOTACreateFantasyLeagueRequest::get_league_logo_for_reflect,
                    CMsgDOTACreateFantasyLeagueRequest::mut_league_logo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::Fantasy_Selection_Mode>>(
                    "selection_mode",
                    CMsgDOTACreateFantasyLeagueRequest::get_selection_mode_for_reflect,
                    CMsgDOTACreateFantasyLeagueRequest::mut_selection_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_count",
                    CMsgDOTACreateFantasyLeagueRequest::get_team_count_for_reflect,
                    CMsgDOTACreateFantasyLeagueRequest::mut_team_count_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTACreateFantasyLeagueRequest>(
                    "CMsgDOTACreateFantasyLeagueRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTACreateFantasyLeagueRequest {
    fn clear(&mut self) {
        self.clear_league_name();
        self.clear_league_logo();
        self.clear_selection_mode();
        self.clear_team_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTACreateFantasyLeagueRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTACreateFantasyLeagueRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTACreateFantasyLeagueResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTACreateFantasyLeagueResponse_EResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTACreateFantasyLeagueResponse {}

impl CMsgDOTACreateFantasyLeagueResponse {
    pub fn new() -> CMsgDOTACreateFantasyLeagueResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTACreateFantasyLeagueResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTACreateFantasyLeagueResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTACreateFantasyLeagueResponse,
        };
        unsafe {
            instance.get(CMsgDOTACreateFantasyLeagueResponse::new)
        }
    }

    // optional .CMsgDOTACreateFantasyLeagueResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTACreateFantasyLeagueResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTACreateFantasyLeagueResponse_EResult {
        self.result.unwrap_or(CMsgDOTACreateFantasyLeagueResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTACreateFantasyLeagueResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTACreateFantasyLeagueResponse_EResult> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgDOTACreateFantasyLeagueResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTACreateFantasyLeagueResponse {
    fn new() -> CMsgDOTACreateFantasyLeagueResponse {
        CMsgDOTACreateFantasyLeagueResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTACreateFantasyLeagueResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTACreateFantasyLeagueResponse_EResult>>(
                    "result",
                    CMsgDOTACreateFantasyLeagueResponse::get_result_for_reflect,
                    CMsgDOTACreateFantasyLeagueResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTACreateFantasyLeagueResponse>(
                    "CMsgDOTACreateFantasyLeagueResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTACreateFantasyLeagueResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTACreateFantasyLeagueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTACreateFantasyLeagueResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTACreateFantasyLeagueResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_TOO_MANY_LEAGUES = 2,
    ERROR_INVALID_TEAM_COUNT = 3,
    ERROR_CREATION_DISABLED = 4,
}

impl ::protobuf::ProtobufEnum for CMsgDOTACreateFantasyLeagueResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTACreateFantasyLeagueResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTACreateFantasyLeagueResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTACreateFantasyLeagueResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTACreateFantasyLeagueResponse_EResult::ERROR_TOO_MANY_LEAGUES),
            3 => ::std::option::Option::Some(CMsgDOTACreateFantasyLeagueResponse_EResult::ERROR_INVALID_TEAM_COUNT),
            4 => ::std::option::Option::Some(CMsgDOTACreateFantasyLeagueResponse_EResult::ERROR_CREATION_DISABLED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTACreateFantasyLeagueResponse_EResult] = &[
            CMsgDOTACreateFantasyLeagueResponse_EResult::SUCCESS,
            CMsgDOTACreateFantasyLeagueResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTACreateFantasyLeagueResponse_EResult::ERROR_TOO_MANY_LEAGUES,
            CMsgDOTACreateFantasyLeagueResponse_EResult::ERROR_INVALID_TEAM_COUNT,
            CMsgDOTACreateFantasyLeagueResponse_EResult::ERROR_CREATION_DISABLED,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTACreateFantasyLeagueResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTACreateFantasyLeagueResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTACreateFantasyLeagueResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTACreateFantasyLeagueResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgFantasyLeagueScoring {
    // message fields
    level: ::std::option::Option<f32>,
    kills: ::std::option::Option<f32>,
    deaths: ::std::option::Option<f32>,
    assists: ::std::option::Option<f32>,
    last_hits: ::std::option::Option<f32>,
    denies: ::std::option::Option<f32>,
    gpm: ::std::option::Option<f32>,
    xppm: ::std::option::Option<f32>,
    stuns: ::std::option::Option<f32>,
    healing: ::std::option::Option<f32>,
    tower_kills: ::std::option::Option<f32>,
    roshan_kills: ::std::option::Option<f32>,
    multiplier_premium: ::std::option::Option<f32>,
    multiplier_professional: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgFantasyLeagueScoring {}

impl CMsgFantasyLeagueScoring {
    pub fn new() -> CMsgFantasyLeagueScoring {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgFantasyLeagueScoring {
        static mut instance: ::protobuf::lazy::Lazy<CMsgFantasyLeagueScoring> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgFantasyLeagueScoring,
        };
        unsafe {
            instance.get(CMsgFantasyLeagueScoring::new)
        }
    }

    // optional float level = 1;

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: f32) {
        self.level = ::std::option::Option::Some(v);
    }

    pub fn get_level(&self) -> f32 {
        self.level.unwrap_or(0.)
    }

    fn get_level_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.level
    }

    fn mut_level_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.level
    }

    // optional float kills = 2;

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: f32) {
        self.kills = ::std::option::Option::Some(v);
    }

    pub fn get_kills(&self) -> f32 {
        self.kills.unwrap_or(0.)
    }

    fn get_kills_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.kills
    }

    fn mut_kills_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.kills
    }

    // optional float deaths = 3;

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: f32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    pub fn get_deaths(&self) -> f32 {
        self.deaths.unwrap_or(0.)
    }

    fn get_deaths_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.deaths
    }

    fn mut_deaths_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.deaths
    }

    // optional float assists = 4;

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: f32) {
        self.assists = ::std::option::Option::Some(v);
    }

    pub fn get_assists(&self) -> f32 {
        self.assists.unwrap_or(0.)
    }

    fn get_assists_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.assists
    }

    fn mut_assists_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.assists
    }

    // optional float last_hits = 5;

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: f32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    pub fn get_last_hits(&self) -> f32 {
        self.last_hits.unwrap_or(0.)
    }

    fn get_last_hits_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.last_hits
    }

    fn mut_last_hits_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.last_hits
    }

    // optional float denies = 6;

    pub fn clear_denies(&mut self) {
        self.denies = ::std::option::Option::None;
    }

    pub fn has_denies(&self) -> bool {
        self.denies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denies(&mut self, v: f32) {
        self.denies = ::std::option::Option::Some(v);
    }

    pub fn get_denies(&self) -> f32 {
        self.denies.unwrap_or(0.)
    }

    fn get_denies_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.denies
    }

    fn mut_denies_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.denies
    }

    // optional float gpm = 7;

    pub fn clear_gpm(&mut self) {
        self.gpm = ::std::option::Option::None;
    }

    pub fn has_gpm(&self) -> bool {
        self.gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpm(&mut self, v: f32) {
        self.gpm = ::std::option::Option::Some(v);
    }

    pub fn get_gpm(&self) -> f32 {
        self.gpm.unwrap_or(0.)
    }

    fn get_gpm_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.gpm
    }

    fn mut_gpm_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.gpm
    }

    // optional float xppm = 8;

    pub fn clear_xppm(&mut self) {
        self.xppm = ::std::option::Option::None;
    }

    pub fn has_xppm(&self) -> bool {
        self.xppm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xppm(&mut self, v: f32) {
        self.xppm = ::std::option::Option::Some(v);
    }

    pub fn get_xppm(&self) -> f32 {
        self.xppm.unwrap_or(0.)
    }

    fn get_xppm_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.xppm
    }

    fn mut_xppm_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.xppm
    }

    // optional float stuns = 9;

    pub fn clear_stuns(&mut self) {
        self.stuns = ::std::option::Option::None;
    }

    pub fn has_stuns(&self) -> bool {
        self.stuns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stuns(&mut self, v: f32) {
        self.stuns = ::std::option::Option::Some(v);
    }

    pub fn get_stuns(&self) -> f32 {
        self.stuns.unwrap_or(0.)
    }

    fn get_stuns_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.stuns
    }

    fn mut_stuns_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.stuns
    }

    // optional float healing = 10;

    pub fn clear_healing(&mut self) {
        self.healing = ::std::option::Option::None;
    }

    pub fn has_healing(&self) -> bool {
        self.healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing(&mut self, v: f32) {
        self.healing = ::std::option::Option::Some(v);
    }

    pub fn get_healing(&self) -> f32 {
        self.healing.unwrap_or(0.)
    }

    fn get_healing_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.healing
    }

    fn mut_healing_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.healing
    }

    // optional float tower_kills = 11;

    pub fn clear_tower_kills(&mut self) {
        self.tower_kills = ::std::option::Option::None;
    }

    pub fn has_tower_kills(&self) -> bool {
        self.tower_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_kills(&mut self, v: f32) {
        self.tower_kills = ::std::option::Option::Some(v);
    }

    pub fn get_tower_kills(&self) -> f32 {
        self.tower_kills.unwrap_or(0.)
    }

    fn get_tower_kills_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.tower_kills
    }

    fn mut_tower_kills_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.tower_kills
    }

    // optional float roshan_kills = 12;

    pub fn clear_roshan_kills(&mut self) {
        self.roshan_kills = ::std::option::Option::None;
    }

    pub fn has_roshan_kills(&self) -> bool {
        self.roshan_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roshan_kills(&mut self, v: f32) {
        self.roshan_kills = ::std::option::Option::Some(v);
    }

    pub fn get_roshan_kills(&self) -> f32 {
        self.roshan_kills.unwrap_or(0.)
    }

    fn get_roshan_kills_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.roshan_kills
    }

    fn mut_roshan_kills_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.roshan_kills
    }

    // optional float multiplier_premium = 13;

    pub fn clear_multiplier_premium(&mut self) {
        self.multiplier_premium = ::std::option::Option::None;
    }

    pub fn has_multiplier_premium(&self) -> bool {
        self.multiplier_premium.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multiplier_premium(&mut self, v: f32) {
        self.multiplier_premium = ::std::option::Option::Some(v);
    }

    pub fn get_multiplier_premium(&self) -> f32 {
        self.multiplier_premium.unwrap_or(0.)
    }

    fn get_multiplier_premium_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.multiplier_premium
    }

    fn mut_multiplier_premium_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.multiplier_premium
    }

    // optional float multiplier_professional = 14;

    pub fn clear_multiplier_professional(&mut self) {
        self.multiplier_professional = ::std::option::Option::None;
    }

    pub fn has_multiplier_professional(&self) -> bool {
        self.multiplier_professional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multiplier_professional(&mut self, v: f32) {
        self.multiplier_professional = ::std::option::Option::Some(v);
    }

    pub fn get_multiplier_professional(&self) -> f32 {
        self.multiplier_professional.unwrap_or(0.)
    }

    fn get_multiplier_professional_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.multiplier_professional
    }

    fn mut_multiplier_professional_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.multiplier_professional
    }
}

impl ::protobuf::Message for CMsgFantasyLeagueScoring {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.kills = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.deaths = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.assists = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.last_hits = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.denies = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.gpm = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.xppm = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.stuns = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.healing = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.tower_kills = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.roshan_kills = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.multiplier_premium = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.multiplier_professional = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.level {
            my_size += 5;
        }
        if let Some(v) = self.kills {
            my_size += 5;
        }
        if let Some(v) = self.deaths {
            my_size += 5;
        }
        if let Some(v) = self.assists {
            my_size += 5;
        }
        if let Some(v) = self.last_hits {
            my_size += 5;
        }
        if let Some(v) = self.denies {
            my_size += 5;
        }
        if let Some(v) = self.gpm {
            my_size += 5;
        }
        if let Some(v) = self.xppm {
            my_size += 5;
        }
        if let Some(v) = self.stuns {
            my_size += 5;
        }
        if let Some(v) = self.healing {
            my_size += 5;
        }
        if let Some(v) = self.tower_kills {
            my_size += 5;
        }
        if let Some(v) = self.roshan_kills {
            my_size += 5;
        }
        if let Some(v) = self.multiplier_premium {
            my_size += 5;
        }
        if let Some(v) = self.multiplier_professional {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.level {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.kills {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.assists {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.last_hits {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.denies {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.gpm {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.xppm {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.stuns {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.healing {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.tower_kills {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.roshan_kills {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.multiplier_premium {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.multiplier_professional {
            os.write_float(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgFantasyLeagueScoring {
    fn new() -> CMsgFantasyLeagueScoring {
        CMsgFantasyLeagueScoring::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgFantasyLeagueScoring>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "level",
                    CMsgFantasyLeagueScoring::get_level_for_reflect,
                    CMsgFantasyLeagueScoring::mut_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "kills",
                    CMsgFantasyLeagueScoring::get_kills_for_reflect,
                    CMsgFantasyLeagueScoring::mut_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "deaths",
                    CMsgFantasyLeagueScoring::get_deaths_for_reflect,
                    CMsgFantasyLeagueScoring::mut_deaths_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "assists",
                    CMsgFantasyLeagueScoring::get_assists_for_reflect,
                    CMsgFantasyLeagueScoring::mut_assists_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "last_hits",
                    CMsgFantasyLeagueScoring::get_last_hits_for_reflect,
                    CMsgFantasyLeagueScoring::mut_last_hits_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "denies",
                    CMsgFantasyLeagueScoring::get_denies_for_reflect,
                    CMsgFantasyLeagueScoring::mut_denies_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "gpm",
                    CMsgFantasyLeagueScoring::get_gpm_for_reflect,
                    CMsgFantasyLeagueScoring::mut_gpm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "xppm",
                    CMsgFantasyLeagueScoring::get_xppm_for_reflect,
                    CMsgFantasyLeagueScoring::mut_xppm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "stuns",
                    CMsgFantasyLeagueScoring::get_stuns_for_reflect,
                    CMsgFantasyLeagueScoring::mut_stuns_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "healing",
                    CMsgFantasyLeagueScoring::get_healing_for_reflect,
                    CMsgFantasyLeagueScoring::mut_healing_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "tower_kills",
                    CMsgFantasyLeagueScoring::get_tower_kills_for_reflect,
                    CMsgFantasyLeagueScoring::mut_tower_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "roshan_kills",
                    CMsgFantasyLeagueScoring::get_roshan_kills_for_reflect,
                    CMsgFantasyLeagueScoring::mut_roshan_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "multiplier_premium",
                    CMsgFantasyLeagueScoring::get_multiplier_premium_for_reflect,
                    CMsgFantasyLeagueScoring::mut_multiplier_premium_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "multiplier_professional",
                    CMsgFantasyLeagueScoring::get_multiplier_professional_for_reflect,
                    CMsgFantasyLeagueScoring::mut_multiplier_professional_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgFantasyLeagueScoring>(
                    "CMsgFantasyLeagueScoring",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgFantasyLeagueScoring {
    fn clear(&mut self) {
        self.clear_level();
        self.clear_kills();
        self.clear_deaths();
        self.clear_assists();
        self.clear_last_hits();
        self.clear_denies();
        self.clear_gpm();
        self.clear_xppm();
        self.clear_stuns();
        self.clear_healing();
        self.clear_tower_kills();
        self.clear_roshan_kills();
        self.clear_multiplier_premium();
        self.clear_multiplier_professional();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFantasyLeagueScoring {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFantasyLeagueScoring {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueInfo {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    commissioner_account_id: ::std::option::Option<u32>,
    fantasy_league_name: ::protobuf::SingularField<::std::string::String>,
    selection_mode: ::std::option::Option<super::dota_shared_enums::Fantasy_Selection_Mode>,
    team_count: ::std::option::Option<u32>,
    logo: ::std::option::Option<u64>,
    scoring: ::protobuf::SingularPtrField<CMsgFantasyLeagueScoring>,
    draft_time: ::std::option::Option<u32>,
    draft_pick_time: ::std::option::Option<u32>,
    season_start: ::std::option::Option<u32>,
    season_length: ::std::option::Option<u32>,
    veto_votes: ::std::option::Option<u32>,
    acquisitions: ::std::option::Option<u32>,
    slot_1: ::std::option::Option<u32>,
    slot_2: ::std::option::Option<u32>,
    slot_3: ::std::option::Option<u32>,
    slot_4: ::std::option::Option<u32>,
    slot_5: ::std::option::Option<u32>,
    bench_slots: ::std::option::Option<u32>,
    owner_info: ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueInfo_OwnerInfo>,
    players: ::std::vec::Vec<u32>,
    time_zone: ::std::option::Option<u32>,
    season: ::std::option::Option<u32>,
    password: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueInfo {}

impl CMsgDOTAFantasyLeagueInfo {
    pub fn new() -> CMsgDOTAFantasyLeagueInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueInfo,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueInfo::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 commissioner_account_id = 2;

    pub fn clear_commissioner_account_id(&mut self) {
        self.commissioner_account_id = ::std::option::Option::None;
    }

    pub fn has_commissioner_account_id(&self) -> bool {
        self.commissioner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commissioner_account_id(&mut self, v: u32) {
        self.commissioner_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_commissioner_account_id(&self) -> u32 {
        self.commissioner_account_id.unwrap_or(0)
    }

    fn get_commissioner_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.commissioner_account_id
    }

    fn mut_commissioner_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.commissioner_account_id
    }

    // optional string fantasy_league_name = 3;

    pub fn clear_fantasy_league_name(&mut self) {
        self.fantasy_league_name.clear();
    }

    pub fn has_fantasy_league_name(&self) -> bool {
        self.fantasy_league_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_name(&mut self, v: ::std::string::String) {
        self.fantasy_league_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fantasy_league_name(&mut self) -> &mut ::std::string::String {
        if self.fantasy_league_name.is_none() {
            self.fantasy_league_name.set_default();
        }
        self.fantasy_league_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_fantasy_league_name(&mut self) -> ::std::string::String {
        self.fantasy_league_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fantasy_league_name(&self) -> &str {
        match self.fantasy_league_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fantasy_league_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fantasy_league_name
    }

    fn mut_fantasy_league_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fantasy_league_name
    }

    // optional .Fantasy_Selection_Mode selection_mode = 4;

    pub fn clear_selection_mode(&mut self) {
        self.selection_mode = ::std::option::Option::None;
    }

    pub fn has_selection_mode(&self) -> bool {
        self.selection_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_mode(&mut self, v: super::dota_shared_enums::Fantasy_Selection_Mode) {
        self.selection_mode = ::std::option::Option::Some(v);
    }

    pub fn get_selection_mode(&self) -> super::dota_shared_enums::Fantasy_Selection_Mode {
        self.selection_mode.unwrap_or(super::dota_shared_enums::Fantasy_Selection_Mode::FANTASY_SELECTION_INVALID)
    }

    fn get_selection_mode_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::Fantasy_Selection_Mode> {
        &self.selection_mode
    }

    fn mut_selection_mode_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::Fantasy_Selection_Mode> {
        &mut self.selection_mode
    }

    // optional uint32 team_count = 5;

    pub fn clear_team_count(&mut self) {
        self.team_count = ::std::option::Option::None;
    }

    pub fn has_team_count(&self) -> bool {
        self.team_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_count(&mut self, v: u32) {
        self.team_count = ::std::option::Option::Some(v);
    }

    pub fn get_team_count(&self) -> u32 {
        self.team_count.unwrap_or(0)
    }

    fn get_team_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_count
    }

    fn mut_team_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_count
    }

    // optional uint64 logo = 6;

    pub fn clear_logo(&mut self) {
        self.logo = ::std::option::Option::None;
    }

    pub fn has_logo(&self) -> bool {
        self.logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logo(&mut self, v: u64) {
        self.logo = ::std::option::Option::Some(v);
    }

    pub fn get_logo(&self) -> u64 {
        self.logo.unwrap_or(0)
    }

    fn get_logo_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.logo
    }

    fn mut_logo_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.logo
    }

    // optional .CMsgFantasyLeagueScoring scoring = 7;

    pub fn clear_scoring(&mut self) {
        self.scoring.clear();
    }

    pub fn has_scoring(&self) -> bool {
        self.scoring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scoring(&mut self, v: CMsgFantasyLeagueScoring) {
        self.scoring = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scoring(&mut self) -> &mut CMsgFantasyLeagueScoring {
        if self.scoring.is_none() {
            self.scoring.set_default();
        }
        self.scoring.as_mut().unwrap()
    }

    // Take field
    pub fn take_scoring(&mut self) -> CMsgFantasyLeagueScoring {
        self.scoring.take().unwrap_or_else(|| CMsgFantasyLeagueScoring::new())
    }

    pub fn get_scoring(&self) -> &CMsgFantasyLeagueScoring {
        self.scoring.as_ref().unwrap_or_else(|| CMsgFantasyLeagueScoring::default_instance())
    }

    fn get_scoring_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgFantasyLeagueScoring> {
        &self.scoring
    }

    fn mut_scoring_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgFantasyLeagueScoring> {
        &mut self.scoring
    }

    // optional uint32 draft_time = 12;

    pub fn clear_draft_time(&mut self) {
        self.draft_time = ::std::option::Option::None;
    }

    pub fn has_draft_time(&self) -> bool {
        self.draft_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_draft_time(&mut self, v: u32) {
        self.draft_time = ::std::option::Option::Some(v);
    }

    pub fn get_draft_time(&self) -> u32 {
        self.draft_time.unwrap_or(0)
    }

    fn get_draft_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.draft_time
    }

    fn mut_draft_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.draft_time
    }

    // optional uint32 draft_pick_time = 13;

    pub fn clear_draft_pick_time(&mut self) {
        self.draft_pick_time = ::std::option::Option::None;
    }

    pub fn has_draft_pick_time(&self) -> bool {
        self.draft_pick_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_draft_pick_time(&mut self, v: u32) {
        self.draft_pick_time = ::std::option::Option::Some(v);
    }

    pub fn get_draft_pick_time(&self) -> u32 {
        self.draft_pick_time.unwrap_or(0)
    }

    fn get_draft_pick_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.draft_pick_time
    }

    fn mut_draft_pick_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.draft_pick_time
    }

    // optional uint32 season_start = 15;

    pub fn clear_season_start(&mut self) {
        self.season_start = ::std::option::Option::None;
    }

    pub fn has_season_start(&self) -> bool {
        self.season_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_season_start(&mut self, v: u32) {
        self.season_start = ::std::option::Option::Some(v);
    }

    pub fn get_season_start(&self) -> u32 {
        self.season_start.unwrap_or(0)
    }

    fn get_season_start_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.season_start
    }

    fn mut_season_start_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.season_start
    }

    // optional uint32 season_length = 16;

    pub fn clear_season_length(&mut self) {
        self.season_length = ::std::option::Option::None;
    }

    pub fn has_season_length(&self) -> bool {
        self.season_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_season_length(&mut self, v: u32) {
        self.season_length = ::std::option::Option::Some(v);
    }

    pub fn get_season_length(&self) -> u32 {
        self.season_length.unwrap_or(0)
    }

    fn get_season_length_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.season_length
    }

    fn mut_season_length_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.season_length
    }

    // optional uint32 veto_votes = 17;

    pub fn clear_veto_votes(&mut self) {
        self.veto_votes = ::std::option::Option::None;
    }

    pub fn has_veto_votes(&self) -> bool {
        self.veto_votes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_veto_votes(&mut self, v: u32) {
        self.veto_votes = ::std::option::Option::Some(v);
    }

    pub fn get_veto_votes(&self) -> u32 {
        self.veto_votes.unwrap_or(0)
    }

    fn get_veto_votes_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.veto_votes
    }

    fn mut_veto_votes_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.veto_votes
    }

    // optional uint32 acquisitions = 18;

    pub fn clear_acquisitions(&mut self) {
        self.acquisitions = ::std::option::Option::None;
    }

    pub fn has_acquisitions(&self) -> bool {
        self.acquisitions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acquisitions(&mut self, v: u32) {
        self.acquisitions = ::std::option::Option::Some(v);
    }

    pub fn get_acquisitions(&self) -> u32 {
        self.acquisitions.unwrap_or(0)
    }

    fn get_acquisitions_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.acquisitions
    }

    fn mut_acquisitions_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.acquisitions
    }

    // optional uint32 slot_1 = 19;

    pub fn clear_slot_1(&mut self) {
        self.slot_1 = ::std::option::Option::None;
    }

    pub fn has_slot_1(&self) -> bool {
        self.slot_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_1(&mut self, v: u32) {
        self.slot_1 = ::std::option::Option::Some(v);
    }

    pub fn get_slot_1(&self) -> u32 {
        self.slot_1.unwrap_or(0)
    }

    fn get_slot_1_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_1
    }

    fn mut_slot_1_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_1
    }

    // optional uint32 slot_2 = 20;

    pub fn clear_slot_2(&mut self) {
        self.slot_2 = ::std::option::Option::None;
    }

    pub fn has_slot_2(&self) -> bool {
        self.slot_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_2(&mut self, v: u32) {
        self.slot_2 = ::std::option::Option::Some(v);
    }

    pub fn get_slot_2(&self) -> u32 {
        self.slot_2.unwrap_or(0)
    }

    fn get_slot_2_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_2
    }

    fn mut_slot_2_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_2
    }

    // optional uint32 slot_3 = 21;

    pub fn clear_slot_3(&mut self) {
        self.slot_3 = ::std::option::Option::None;
    }

    pub fn has_slot_3(&self) -> bool {
        self.slot_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_3(&mut self, v: u32) {
        self.slot_3 = ::std::option::Option::Some(v);
    }

    pub fn get_slot_3(&self) -> u32 {
        self.slot_3.unwrap_or(0)
    }

    fn get_slot_3_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_3
    }

    fn mut_slot_3_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_3
    }

    // optional uint32 slot_4 = 22;

    pub fn clear_slot_4(&mut self) {
        self.slot_4 = ::std::option::Option::None;
    }

    pub fn has_slot_4(&self) -> bool {
        self.slot_4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_4(&mut self, v: u32) {
        self.slot_4 = ::std::option::Option::Some(v);
    }

    pub fn get_slot_4(&self) -> u32 {
        self.slot_4.unwrap_or(0)
    }

    fn get_slot_4_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_4
    }

    fn mut_slot_4_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_4
    }

    // optional uint32 slot_5 = 23;

    pub fn clear_slot_5(&mut self) {
        self.slot_5 = ::std::option::Option::None;
    }

    pub fn has_slot_5(&self) -> bool {
        self.slot_5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_5(&mut self, v: u32) {
        self.slot_5 = ::std::option::Option::Some(v);
    }

    pub fn get_slot_5(&self) -> u32 {
        self.slot_5.unwrap_or(0)
    }

    fn get_slot_5_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_5
    }

    fn mut_slot_5_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_5
    }

    // optional uint32 bench_slots = 24;

    pub fn clear_bench_slots(&mut self) {
        self.bench_slots = ::std::option::Option::None;
    }

    pub fn has_bench_slots(&self) -> bool {
        self.bench_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bench_slots(&mut self, v: u32) {
        self.bench_slots = ::std::option::Option::Some(v);
    }

    pub fn get_bench_slots(&self) -> u32 {
        self.bench_slots.unwrap_or(0)
    }

    fn get_bench_slots_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.bench_slots
    }

    fn mut_bench_slots_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.bench_slots
    }

    // repeated .CMsgDOTAFantasyLeagueInfo.OwnerInfo owner_info = 25;

    pub fn clear_owner_info(&mut self) {
        self.owner_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_info(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueInfo_OwnerInfo>) {
        self.owner_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_owner_info(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueInfo_OwnerInfo> {
        &mut self.owner_info
    }

    // Take field
    pub fn take_owner_info(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueInfo_OwnerInfo> {
        ::std::mem::replace(&mut self.owner_info, ::protobuf::RepeatedField::new())
    }

    pub fn get_owner_info(&self) -> &[CMsgDOTAFantasyLeagueInfo_OwnerInfo] {
        &self.owner_info
    }

    fn get_owner_info_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAFantasyLeagueInfo_OwnerInfo> {
        &self.owner_info
    }

    fn mut_owner_info_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueInfo_OwnerInfo> {
        &mut self.owner_info
    }

    // repeated uint32 players = 26;

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::std::vec::Vec<u32>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.players, ::std::vec::Vec::new())
    }

    pub fn get_players(&self) -> &[u32] {
        &self.players
    }

    fn get_players_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.players
    }

    fn mut_players_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.players
    }

    // optional uint32 time_zone = 27;

    pub fn clear_time_zone(&mut self) {
        self.time_zone = ::std::option::Option::None;
    }

    pub fn has_time_zone(&self) -> bool {
        self.time_zone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_zone(&mut self, v: u32) {
        self.time_zone = ::std::option::Option::Some(v);
    }

    pub fn get_time_zone(&self) -> u32 {
        self.time_zone.unwrap_or(0)
    }

    fn get_time_zone_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time_zone
    }

    fn mut_time_zone_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time_zone
    }

    // optional uint32 season = 28;

    pub fn clear_season(&mut self) {
        self.season = ::std::option::Option::None;
    }

    pub fn has_season(&self) -> bool {
        self.season.is_some()
    }

    // Param is passed by value, moved
    pub fn set_season(&mut self, v: u32) {
        self.season = ::std::option::Option::Some(v);
    }

    pub fn get_season(&self) -> u32 {
        self.season.unwrap_or(0)
    }

    fn get_season_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.season
    }

    fn mut_season_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.season
    }

    // optional string password = 29;

    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        if self.password.is_none() {
            self.password.set_default();
        }
        self.password.as_mut().unwrap()
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        self.password.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_password(&self) -> &str {
        match self.password.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_password_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.password
    }

    fn mut_password_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.password
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.scoring {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.owner_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.commissioner_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fantasy_league_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.selection_mode = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_count = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.logo = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scoring)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.draft_time = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.draft_pick_time = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.season_start = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.season_length = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.veto_votes = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.acquisitions = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_1 = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_2 = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_3 = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_4 = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_5 = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bench_slots = ::std::option::Option::Some(tmp);
                },
                25 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.owner_info)?;
                },
                26 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.players)?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_zone = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.season = ::std::option::Option::Some(tmp);
                },
                29 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.commissioner_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fantasy_league_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.selection_mode {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.team_count {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.logo {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.scoring.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.draft_time {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.draft_pick_time {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.season_start {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.season_length {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.veto_votes {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.acquisitions {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_1 {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_2 {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_3 {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_4 {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_5 {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bench_slots {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.owner_info {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.players {
            my_size += ::protobuf::rt::value_size(26, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.time_zone {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.season {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.password.as_ref() {
            my_size += ::protobuf::rt::string_size(29, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.commissioner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.fantasy_league_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.selection_mode {
            os.write_enum(4, v.value())?;
        }
        if let Some(v) = self.team_count {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.logo {
            os.write_uint64(6, v)?;
        }
        if let Some(ref v) = self.scoring.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.draft_time {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.draft_pick_time {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.season_start {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.season_length {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.veto_votes {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.acquisitions {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.slot_1 {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.slot_2 {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.slot_3 {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.slot_4 {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.slot_5 {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.bench_slots {
            os.write_uint32(24, v)?;
        }
        for v in &self.owner_info {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.players {
            os.write_uint32(26, *v)?;
        };
        if let Some(v) = self.time_zone {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.season {
            os.write_uint32(28, v)?;
        }
        if let Some(ref v) = self.password.as_ref() {
            os.write_string(29, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueInfo {
    fn new() -> CMsgDOTAFantasyLeagueInfo {
        CMsgDOTAFantasyLeagueInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyLeagueInfo::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "commissioner_account_id",
                    CMsgDOTAFantasyLeagueInfo::get_commissioner_account_id_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_commissioner_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fantasy_league_name",
                    CMsgDOTAFantasyLeagueInfo::get_fantasy_league_name_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_fantasy_league_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::Fantasy_Selection_Mode>>(
                    "selection_mode",
                    CMsgDOTAFantasyLeagueInfo::get_selection_mode_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_selection_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_count",
                    CMsgDOTAFantasyLeagueInfo::get_team_count_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_team_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "logo",
                    CMsgDOTAFantasyLeagueInfo::get_logo_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_logo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgFantasyLeagueScoring>>(
                    "scoring",
                    CMsgDOTAFantasyLeagueInfo::get_scoring_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_scoring_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "draft_time",
                    CMsgDOTAFantasyLeagueInfo::get_draft_time_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_draft_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "draft_pick_time",
                    CMsgDOTAFantasyLeagueInfo::get_draft_pick_time_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_draft_pick_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "season_start",
                    CMsgDOTAFantasyLeagueInfo::get_season_start_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_season_start_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "season_length",
                    CMsgDOTAFantasyLeagueInfo::get_season_length_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_season_length_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "veto_votes",
                    CMsgDOTAFantasyLeagueInfo::get_veto_votes_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_veto_votes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "acquisitions",
                    CMsgDOTAFantasyLeagueInfo::get_acquisitions_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_acquisitions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_1",
                    CMsgDOTAFantasyLeagueInfo::get_slot_1_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_slot_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_2",
                    CMsgDOTAFantasyLeagueInfo::get_slot_2_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_slot_2_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_3",
                    CMsgDOTAFantasyLeagueInfo::get_slot_3_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_slot_3_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_4",
                    CMsgDOTAFantasyLeagueInfo::get_slot_4_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_slot_4_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_5",
                    CMsgDOTAFantasyLeagueInfo::get_slot_5_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_slot_5_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bench_slots",
                    CMsgDOTAFantasyLeagueInfo::get_bench_slots_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_bench_slots_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFantasyLeagueInfo_OwnerInfo>>(
                    "owner_info",
                    CMsgDOTAFantasyLeagueInfo::get_owner_info_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_owner_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "players",
                    CMsgDOTAFantasyLeagueInfo::get_players_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_zone",
                    CMsgDOTAFantasyLeagueInfo::get_time_zone_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_time_zone_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "season",
                    CMsgDOTAFantasyLeagueInfo::get_season_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_season_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    CMsgDOTAFantasyLeagueInfo::get_password_for_reflect,
                    CMsgDOTAFantasyLeagueInfo::mut_password_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueInfo>(
                    "CMsgDOTAFantasyLeagueInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueInfo {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_commissioner_account_id();
        self.clear_fantasy_league_name();
        self.clear_selection_mode();
        self.clear_team_count();
        self.clear_logo();
        self.clear_scoring();
        self.clear_draft_time();
        self.clear_draft_pick_time();
        self.clear_season_start();
        self.clear_season_length();
        self.clear_veto_votes();
        self.clear_acquisitions();
        self.clear_slot_1();
        self.clear_slot_2();
        self.clear_slot_3();
        self.clear_slot_4();
        self.clear_slot_5();
        self.clear_bench_slots();
        self.clear_owner_info();
        self.clear_players();
        self.clear_time_zone();
        self.clear_season();
        self.clear_password();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueInfo_OwnerInfo {
    // message fields
    owner_account_id: ::std::option::Option<u32>,
    left_league: ::std::option::Option<bool>,
    player_account_id: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueInfo_OwnerInfo {}

impl CMsgDOTAFantasyLeagueInfo_OwnerInfo {
    pub fn new() -> CMsgDOTAFantasyLeagueInfo_OwnerInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueInfo_OwnerInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueInfo_OwnerInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueInfo_OwnerInfo,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueInfo_OwnerInfo::new)
        }
    }

    // optional uint32 owner_account_id = 1;

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    fn get_owner_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.owner_account_id
    }

    fn mut_owner_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.owner_account_id
    }

    // optional bool left_league = 2;

    pub fn clear_left_league(&mut self) {
        self.left_league = ::std::option::Option::None;
    }

    pub fn has_left_league(&self) -> bool {
        self.left_league.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_league(&mut self, v: bool) {
        self.left_league = ::std::option::Option::Some(v);
    }

    pub fn get_left_league(&self) -> bool {
        self.left_league.unwrap_or(false)
    }

    fn get_left_league_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.left_league
    }

    fn mut_left_league_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.left_league
    }

    // repeated uint32 player_account_id = 3;

    pub fn clear_player_account_id(&mut self) {
        self.player_account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_account_id(&mut self, v: ::std::vec::Vec<u32>) {
        self.player_account_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_account_id(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.player_account_id
    }

    // Take field
    pub fn take_player_account_id(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.player_account_id, ::std::vec::Vec::new())
    }

    pub fn get_player_account_id(&self) -> &[u32] {
        &self.player_account_id
    }

    fn get_player_account_id_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.player_account_id
    }

    fn mut_player_account_id_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.player_account_id
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueInfo_OwnerInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.left_league = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.player_account_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.left_league {
            my_size += 2;
        }
        for value in &self.player_account_id {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.owner_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.left_league {
            os.write_bool(2, v)?;
        }
        for v in &self.player_account_id {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueInfo_OwnerInfo {
    fn new() -> CMsgDOTAFantasyLeagueInfo_OwnerInfo {
        CMsgDOTAFantasyLeagueInfo_OwnerInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueInfo_OwnerInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "owner_account_id",
                    CMsgDOTAFantasyLeagueInfo_OwnerInfo::get_owner_account_id_for_reflect,
                    CMsgDOTAFantasyLeagueInfo_OwnerInfo::mut_owner_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "left_league",
                    CMsgDOTAFantasyLeagueInfo_OwnerInfo::get_left_league_for_reflect,
                    CMsgDOTAFantasyLeagueInfo_OwnerInfo::mut_left_league_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_account_id",
                    CMsgDOTAFantasyLeagueInfo_OwnerInfo::get_player_account_id_for_reflect,
                    CMsgDOTAFantasyLeagueInfo_OwnerInfo::mut_player_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueInfo_OwnerInfo>(
                    "CMsgDOTAFantasyLeagueInfo_OwnerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueInfo_OwnerInfo {
    fn clear(&mut self) {
        self.clear_owner_account_id();
        self.clear_left_league();
        self.clear_player_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueInfo_OwnerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueInfo_OwnerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueEditInfoRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    edit_info: ::protobuf::SingularPtrField<CMsgDOTAFantasyLeagueInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueEditInfoRequest {}

impl CMsgDOTAFantasyLeagueEditInfoRequest {
    pub fn new() -> CMsgDOTAFantasyLeagueEditInfoRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueEditInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueEditInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueEditInfoRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueEditInfoRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional .CMsgDOTAFantasyLeagueInfo edit_info = 2;

    pub fn clear_edit_info(&mut self) {
        self.edit_info.clear();
    }

    pub fn has_edit_info(&self) -> bool {
        self.edit_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edit_info(&mut self, v: CMsgDOTAFantasyLeagueInfo) {
        self.edit_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_edit_info(&mut self) -> &mut CMsgDOTAFantasyLeagueInfo {
        if self.edit_info.is_none() {
            self.edit_info.set_default();
        }
        self.edit_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_edit_info(&mut self) -> CMsgDOTAFantasyLeagueInfo {
        self.edit_info.take().unwrap_or_else(|| CMsgDOTAFantasyLeagueInfo::new())
    }

    pub fn get_edit_info(&self) -> &CMsgDOTAFantasyLeagueInfo {
        self.edit_info.as_ref().unwrap_or_else(|| CMsgDOTAFantasyLeagueInfo::default_instance())
    }

    fn get_edit_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAFantasyLeagueInfo> {
        &self.edit_info
    }

    fn mut_edit_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAFantasyLeagueInfo> {
        &mut self.edit_info
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueEditInfoRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.edit_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.edit_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.edit_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.edit_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueEditInfoRequest {
    fn new() -> CMsgDOTAFantasyLeagueEditInfoRequest {
        CMsgDOTAFantasyLeagueEditInfoRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueEditInfoRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyLeagueEditInfoRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyLeagueEditInfoRequest::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFantasyLeagueInfo>>(
                    "edit_info",
                    CMsgDOTAFantasyLeagueEditInfoRequest::get_edit_info_for_reflect,
                    CMsgDOTAFantasyLeagueEditInfoRequest::mut_edit_info_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueEditInfoRequest>(
                    "CMsgDOTAFantasyLeagueEditInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueEditInfoRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_edit_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueEditInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueEditInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueEditInfoResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyLeagueEditInfoResponse_EResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueEditInfoResponse {}

impl CMsgDOTAFantasyLeagueEditInfoResponse {
    pub fn new() -> CMsgDOTAFantasyLeagueEditInfoResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueEditInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueEditInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueEditInfoResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueEditInfoResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyLeagueEditInfoResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyLeagueEditInfoResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyLeagueEditInfoResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyLeagueEditInfoResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyLeagueEditInfoResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyLeagueEditInfoResponse_EResult> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueEditInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueEditInfoResponse {
    fn new() -> CMsgDOTAFantasyLeagueEditInfoResponse {
        CMsgDOTAFantasyLeagueEditInfoResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueEditInfoResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyLeagueEditInfoResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyLeagueEditInfoResponse::get_result_for_reflect,
                    CMsgDOTAFantasyLeagueEditInfoResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueEditInfoResponse>(
                    "CMsgDOTAFantasyLeagueEditInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueEditInfoResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueEditInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueEditInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyLeagueEditInfoResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_NO_PERMISSION = 2,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyLeagueEditInfoResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyLeagueEditInfoResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueEditInfoResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueEditInfoResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueEditInfoResponse_EResult::ERROR_NO_PERMISSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyLeagueEditInfoResponse_EResult] = &[
            CMsgDOTAFantasyLeagueEditInfoResponse_EResult::SUCCESS,
            CMsgDOTAFantasyLeagueEditInfoResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyLeagueEditInfoResponse_EResult::ERROR_NO_PERMISSION,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueEditInfoResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyLeagueEditInfoResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyLeagueEditInfoResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueEditInfoResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueFindRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    password: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueFindRequest {}

impl CMsgDOTAFantasyLeagueFindRequest {
    pub fn new() -> CMsgDOTAFantasyLeagueFindRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueFindRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueFindRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueFindRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueFindRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional string password = 2;

    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        if self.password.is_none() {
            self.password.set_default();
        }
        self.password.as_mut().unwrap()
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        self.password.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_password(&self) -> &str {
        match self.password.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_password_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.password
    }

    fn mut_password_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.password
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueFindRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.password.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.password.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueFindRequest {
    fn new() -> CMsgDOTAFantasyLeagueFindRequest {
        CMsgDOTAFantasyLeagueFindRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueFindRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyLeagueFindRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyLeagueFindRequest::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    CMsgDOTAFantasyLeagueFindRequest::get_password_for_reflect,
                    CMsgDOTAFantasyLeagueFindRequest::mut_password_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueFindRequest>(
                    "CMsgDOTAFantasyLeagueFindRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueFindRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_password();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueFindRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueFindRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueFindResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyLeagueFindResponse_EResult>,
    fantasy_league_name: ::protobuf::SingularField<::std::string::String>,
    commissioner_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueFindResponse {}

impl CMsgDOTAFantasyLeagueFindResponse {
    pub fn new() -> CMsgDOTAFantasyLeagueFindResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueFindResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueFindResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueFindResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueFindResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyLeagueFindResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyLeagueFindResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyLeagueFindResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyLeagueFindResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyLeagueFindResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyLeagueFindResponse_EResult> {
        &mut self.result
    }

    // optional string fantasy_league_name = 2;

    pub fn clear_fantasy_league_name(&mut self) {
        self.fantasy_league_name.clear();
    }

    pub fn has_fantasy_league_name(&self) -> bool {
        self.fantasy_league_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_name(&mut self, v: ::std::string::String) {
        self.fantasy_league_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fantasy_league_name(&mut self) -> &mut ::std::string::String {
        if self.fantasy_league_name.is_none() {
            self.fantasy_league_name.set_default();
        }
        self.fantasy_league_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_fantasy_league_name(&mut self) -> ::std::string::String {
        self.fantasy_league_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fantasy_league_name(&self) -> &str {
        match self.fantasy_league_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fantasy_league_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fantasy_league_name
    }

    fn mut_fantasy_league_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fantasy_league_name
    }

    // optional string commissioner_name = 3;

    pub fn clear_commissioner_name(&mut self) {
        self.commissioner_name.clear();
    }

    pub fn has_commissioner_name(&self) -> bool {
        self.commissioner_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commissioner_name(&mut self, v: ::std::string::String) {
        self.commissioner_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commissioner_name(&mut self) -> &mut ::std::string::String {
        if self.commissioner_name.is_none() {
            self.commissioner_name.set_default();
        }
        self.commissioner_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_commissioner_name(&mut self) -> ::std::string::String {
        self.commissioner_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_commissioner_name(&self) -> &str {
        match self.commissioner_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_commissioner_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.commissioner_name
    }

    fn mut_commissioner_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.commissioner_name
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueFindResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fantasy_league_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.commissioner_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.fantasy_league_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.commissioner_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.fantasy_league_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.commissioner_name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueFindResponse {
    fn new() -> CMsgDOTAFantasyLeagueFindResponse {
        CMsgDOTAFantasyLeagueFindResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueFindResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyLeagueFindResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyLeagueFindResponse::get_result_for_reflect,
                    CMsgDOTAFantasyLeagueFindResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fantasy_league_name",
                    CMsgDOTAFantasyLeagueFindResponse::get_fantasy_league_name_for_reflect,
                    CMsgDOTAFantasyLeagueFindResponse::mut_fantasy_league_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "commissioner_name",
                    CMsgDOTAFantasyLeagueFindResponse::get_commissioner_name_for_reflect,
                    CMsgDOTAFantasyLeagueFindResponse::mut_commissioner_name_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueFindResponse>(
                    "CMsgDOTAFantasyLeagueFindResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueFindResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_fantasy_league_name();
        self.clear_commissioner_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueFindResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueFindResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyLeagueFindResponse_EResult {
    SUCCESS = 0,
    ERROR_LEAGUE_NOT_FOUND = 1,
    ERROR_BAD_PASSWORD = 2,
    ERROR_UNSPECIFIED = 3,
    ERROR_FULL = 4,
    ERROR_ALREADY_MEMBER = 5,
    ERROR_LEAGUE_LOCKED = 6,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyLeagueFindResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyLeagueFindResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueFindResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueFindResponse_EResult::ERROR_LEAGUE_NOT_FOUND),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueFindResponse_EResult::ERROR_BAD_PASSWORD),
            3 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueFindResponse_EResult::ERROR_UNSPECIFIED),
            4 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueFindResponse_EResult::ERROR_FULL),
            5 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueFindResponse_EResult::ERROR_ALREADY_MEMBER),
            6 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueFindResponse_EResult::ERROR_LEAGUE_LOCKED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyLeagueFindResponse_EResult] = &[
            CMsgDOTAFantasyLeagueFindResponse_EResult::SUCCESS,
            CMsgDOTAFantasyLeagueFindResponse_EResult::ERROR_LEAGUE_NOT_FOUND,
            CMsgDOTAFantasyLeagueFindResponse_EResult::ERROR_BAD_PASSWORD,
            CMsgDOTAFantasyLeagueFindResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyLeagueFindResponse_EResult::ERROR_FULL,
            CMsgDOTAFantasyLeagueFindResponse_EResult::ERROR_ALREADY_MEMBER,
            CMsgDOTAFantasyLeagueFindResponse_EResult::ERROR_LEAGUE_LOCKED,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueFindResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyLeagueFindResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyLeagueFindResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueFindResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueInfoRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueInfoRequest {}

impl CMsgDOTAFantasyLeagueInfoRequest {
    pub fn new() -> CMsgDOTAFantasyLeagueInfoRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueInfoRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueInfoRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueInfoRequest {
    fn new() -> CMsgDOTAFantasyLeagueInfoRequest {
        CMsgDOTAFantasyLeagueInfoRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueInfoRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyLeagueInfoRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyLeagueInfoRequest::mut_fantasy_league_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueInfoRequest>(
                    "CMsgDOTAFantasyLeagueInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueInfoRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueInfoResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyLeagueInfoResponse_EResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueInfoResponse {}

impl CMsgDOTAFantasyLeagueInfoResponse {
    pub fn new() -> CMsgDOTAFantasyLeagueInfoResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueInfoResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueInfoResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyLeagueInfoResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyLeagueInfoResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyLeagueInfoResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyLeagueInfoResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyLeagueInfoResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyLeagueInfoResponse_EResult> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueInfoResponse {
    fn new() -> CMsgDOTAFantasyLeagueInfoResponse {
        CMsgDOTAFantasyLeagueInfoResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueInfoResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyLeagueInfoResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyLeagueInfoResponse::get_result_for_reflect,
                    CMsgDOTAFantasyLeagueInfoResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueInfoResponse>(
                    "CMsgDOTAFantasyLeagueInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueInfoResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyLeagueInfoResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_BAD_LEAGUE_ID = 2,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyLeagueInfoResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyLeagueInfoResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueInfoResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueInfoResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueInfoResponse_EResult::ERROR_BAD_LEAGUE_ID),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyLeagueInfoResponse_EResult] = &[
            CMsgDOTAFantasyLeagueInfoResponse_EResult::SUCCESS,
            CMsgDOTAFantasyLeagueInfoResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyLeagueInfoResponse_EResult::ERROR_BAD_LEAGUE_ID,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueInfoResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyLeagueInfoResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyLeagueInfoResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueInfoResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueMatchupsRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueMatchupsRequest {}

impl CMsgDOTAFantasyLeagueMatchupsRequest {
    pub fn new() -> CMsgDOTAFantasyLeagueMatchupsRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueMatchupsRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueMatchupsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueMatchupsRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueMatchupsRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueMatchupsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueMatchupsRequest {
    fn new() -> CMsgDOTAFantasyLeagueMatchupsRequest {
        CMsgDOTAFantasyLeagueMatchupsRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueMatchupsRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyLeagueMatchupsRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyLeagueMatchupsRequest::mut_fantasy_league_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueMatchupsRequest>(
                    "CMsgDOTAFantasyLeagueMatchupsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueMatchupsRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueMatchupsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueMatchupsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueMatchupsResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyLeagueMatchupsResponse_EResult>,
    fantasy_league_id: ::std::option::Option<u32>,
    weekly_matchups: ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueMatchupsResponse {}

impl CMsgDOTAFantasyLeagueMatchupsResponse {
    pub fn new() -> CMsgDOTAFantasyLeagueMatchupsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueMatchupsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueMatchupsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueMatchupsResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueMatchupsResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyLeagueMatchupsResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyLeagueMatchupsResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyLeagueMatchupsResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyLeagueMatchupsResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyLeagueMatchupsResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyLeagueMatchupsResponse_EResult> {
        &mut self.result
    }

    // optional uint32 fantasy_league_id = 2;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // repeated .CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchups weekly_matchups = 3;

    pub fn clear_weekly_matchups(&mut self) {
        self.weekly_matchups.clear();
    }

    // Param is passed by value, moved
    pub fn set_weekly_matchups(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups>) {
        self.weekly_matchups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_weekly_matchups(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups> {
        &mut self.weekly_matchups
    }

    // Take field
    pub fn take_weekly_matchups(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups> {
        ::std::mem::replace(&mut self.weekly_matchups, ::protobuf::RepeatedField::new())
    }

    pub fn get_weekly_matchups(&self) -> &[CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups] {
        &self.weekly_matchups
    }

    fn get_weekly_matchups_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups> {
        &self.weekly_matchups
    }

    fn mut_weekly_matchups_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups> {
        &mut self.weekly_matchups
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueMatchupsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.weekly_matchups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.weekly_matchups)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.weekly_matchups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(2, v)?;
        }
        for v in &self.weekly_matchups {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueMatchupsResponse {
    fn new() -> CMsgDOTAFantasyLeagueMatchupsResponse {
        CMsgDOTAFantasyLeagueMatchupsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueMatchupsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyLeagueMatchupsResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyLeagueMatchupsResponse::get_result_for_reflect,
                    CMsgDOTAFantasyLeagueMatchupsResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyLeagueMatchupsResponse::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyLeagueMatchupsResponse::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups>>(
                    "weekly_matchups",
                    CMsgDOTAFantasyLeagueMatchupsResponse::get_weekly_matchups_for_reflect,
                    CMsgDOTAFantasyLeagueMatchupsResponse::mut_weekly_matchups_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueMatchupsResponse>(
                    "CMsgDOTAFantasyLeagueMatchupsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueMatchupsResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_fantasy_league_id();
        self.clear_weekly_matchups();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueMatchupsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueMatchupsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueMatchupsResponse_Matchup {
    // message fields
    owner_account_id_1: ::std::option::Option<u32>,
    owner_account_id_2: ::std::option::Option<u32>,
    score_1: ::std::option::Option<f32>,
    score_2: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueMatchupsResponse_Matchup {}

impl CMsgDOTAFantasyLeagueMatchupsResponse_Matchup {
    pub fn new() -> CMsgDOTAFantasyLeagueMatchupsResponse_Matchup {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueMatchupsResponse_Matchup {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueMatchupsResponse_Matchup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueMatchupsResponse_Matchup,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::new)
        }
    }

    // optional uint32 owner_account_id_1 = 1;

    pub fn clear_owner_account_id_1(&mut self) {
        self.owner_account_id_1 = ::std::option::Option::None;
    }

    pub fn has_owner_account_id_1(&self) -> bool {
        self.owner_account_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id_1(&mut self, v: u32) {
        self.owner_account_id_1 = ::std::option::Option::Some(v);
    }

    pub fn get_owner_account_id_1(&self) -> u32 {
        self.owner_account_id_1.unwrap_or(0)
    }

    fn get_owner_account_id_1_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.owner_account_id_1
    }

    fn mut_owner_account_id_1_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.owner_account_id_1
    }

    // optional uint32 owner_account_id_2 = 2;

    pub fn clear_owner_account_id_2(&mut self) {
        self.owner_account_id_2 = ::std::option::Option::None;
    }

    pub fn has_owner_account_id_2(&self) -> bool {
        self.owner_account_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id_2(&mut self, v: u32) {
        self.owner_account_id_2 = ::std::option::Option::Some(v);
    }

    pub fn get_owner_account_id_2(&self) -> u32 {
        self.owner_account_id_2.unwrap_or(0)
    }

    fn get_owner_account_id_2_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.owner_account_id_2
    }

    fn mut_owner_account_id_2_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.owner_account_id_2
    }

    // optional float score_1 = 3;

    pub fn clear_score_1(&mut self) {
        self.score_1 = ::std::option::Option::None;
    }

    pub fn has_score_1(&self) -> bool {
        self.score_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_1(&mut self, v: f32) {
        self.score_1 = ::std::option::Option::Some(v);
    }

    pub fn get_score_1(&self) -> f32 {
        self.score_1.unwrap_or(0.)
    }

    fn get_score_1_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.score_1
    }

    fn mut_score_1_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.score_1
    }

    // optional float score_2 = 4;

    pub fn clear_score_2(&mut self) {
        self.score_2 = ::std::option::Option::None;
    }

    pub fn has_score_2(&self) -> bool {
        self.score_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_2(&mut self, v: f32) {
        self.score_2 = ::std::option::Option::Some(v);
    }

    pub fn get_score_2(&self) -> f32 {
        self.score_2.unwrap_or(0.)
    }

    fn get_score_2_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.score_2
    }

    fn mut_score_2_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.score_2
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueMatchupsResponse_Matchup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id_1 = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id_2 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score_1 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score_2 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.owner_account_id_1 {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_account_id_2 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score_1 {
            my_size += 5;
        }
        if let Some(v) = self.score_2 {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.owner_account_id_1 {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owner_account_id_2 {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.score_1 {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.score_2 {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueMatchupsResponse_Matchup {
    fn new() -> CMsgDOTAFantasyLeagueMatchupsResponse_Matchup {
        CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueMatchupsResponse_Matchup>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "owner_account_id_1",
                    CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::get_owner_account_id_1_for_reflect,
                    CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::mut_owner_account_id_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "owner_account_id_2",
                    CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::get_owner_account_id_2_for_reflect,
                    CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::mut_owner_account_id_2_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "score_1",
                    CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::get_score_1_for_reflect,
                    CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::mut_score_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "score_2",
                    CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::get_score_2_for_reflect,
                    CMsgDOTAFantasyLeagueMatchupsResponse_Matchup::mut_score_2_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueMatchupsResponse_Matchup>(
                    "CMsgDOTAFantasyLeagueMatchupsResponse_Matchup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueMatchupsResponse_Matchup {
    fn clear(&mut self) {
        self.clear_owner_account_id_1();
        self.clear_owner_account_id_2();
        self.clear_score_1();
        self.clear_score_2();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueMatchupsResponse_Matchup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueMatchupsResponse_Matchup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups {
    // message fields
    matchup: ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueMatchupsResponse_Matchup>,
    start_time: ::std::option::Option<u32>,
    end_time: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups {}

impl CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups {
    pub fn new() -> CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::new)
        }
    }

    // repeated .CMsgDOTAFantasyLeagueMatchupsResponse.Matchup matchup = 1;

    pub fn clear_matchup(&mut self) {
        self.matchup.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchup(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueMatchupsResponse_Matchup>) {
        self.matchup = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchup(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueMatchupsResponse_Matchup> {
        &mut self.matchup
    }

    // Take field
    pub fn take_matchup(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueMatchupsResponse_Matchup> {
        ::std::mem::replace(&mut self.matchup, ::protobuf::RepeatedField::new())
    }

    pub fn get_matchup(&self) -> &[CMsgDOTAFantasyLeagueMatchupsResponse_Matchup] {
        &self.matchup
    }

    fn get_matchup_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAFantasyLeagueMatchupsResponse_Matchup> {
        &self.matchup
    }

    fn mut_matchup_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueMatchupsResponse_Matchup> {
        &mut self.matchup
    }

    // optional uint32 start_time = 2;

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    pub fn get_start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    fn get_start_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.start_time
    }

    fn mut_start_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.start_time
    }

    // optional uint32 end_time = 3;

    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: u32) {
        self.end_time = ::std::option::Option::Some(v);
    }

    pub fn get_end_time(&self) -> u32 {
        self.end_time.unwrap_or(0)
    }

    fn get_end_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.end_time
    }

    fn mut_end_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.end_time
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups {
    fn is_initialized(&self) -> bool {
        for v in &self.matchup {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matchup)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.end_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.matchup {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.matchup {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.start_time {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups {
    fn new() -> CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups {
        CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFantasyLeagueMatchupsResponse_Matchup>>(
                    "matchup",
                    CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::get_matchup_for_reflect,
                    CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::mut_matchup_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "start_time",
                    CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::get_start_time_for_reflect,
                    CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::mut_start_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "end_time",
                    CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::get_end_time_for_reflect,
                    CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups::mut_end_time_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups>(
                    "CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups {
    fn clear(&mut self) {
        self.clear_matchup();
        self.clear_start_time();
        self.clear_end_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueMatchupsResponse_WeeklyMatchups {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyLeagueMatchupsResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_BAD_LEAGUE_ID = 2,
    ERROR_NO_PERMISSION = 3,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyLeagueMatchupsResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyLeagueMatchupsResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueMatchupsResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueMatchupsResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueMatchupsResponse_EResult::ERROR_BAD_LEAGUE_ID),
            3 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueMatchupsResponse_EResult::ERROR_NO_PERMISSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyLeagueMatchupsResponse_EResult] = &[
            CMsgDOTAFantasyLeagueMatchupsResponse_EResult::SUCCESS,
            CMsgDOTAFantasyLeagueMatchupsResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyLeagueMatchupsResponse_EResult::ERROR_BAD_LEAGUE_ID,
            CMsgDOTAFantasyLeagueMatchupsResponse_EResult::ERROR_NO_PERMISSION,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueMatchupsResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyLeagueMatchupsResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyLeagueMatchupsResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueMatchupsResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAEditFantasyTeamRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    team_index: ::std::option::Option<u32>,
    team_name: ::protobuf::SingularField<::std::string::String>,
    team_logo: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAEditFantasyTeamRequest {}

impl CMsgDOTAEditFantasyTeamRequest {
    pub fn new() -> CMsgDOTAEditFantasyTeamRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAEditFantasyTeamRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAEditFantasyTeamRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAEditFantasyTeamRequest,
        };
        unsafe {
            instance.get(CMsgDOTAEditFantasyTeamRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 team_index = 2;

    pub fn clear_team_index(&mut self) {
        self.team_index = ::std::option::Option::None;
    }

    pub fn has_team_index(&self) -> bool {
        self.team_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_index(&mut self, v: u32) {
        self.team_index = ::std::option::Option::Some(v);
    }

    pub fn get_team_index(&self) -> u32 {
        self.team_index.unwrap_or(0)
    }

    fn get_team_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_index
    }

    fn mut_team_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_index
    }

    // optional string team_name = 3;

    pub fn clear_team_name(&mut self) {
        self.team_name.clear();
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name.set_default();
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_name
    }

    fn mut_team_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_name
    }

    // optional uint64 team_logo = 4;

    pub fn clear_team_logo(&mut self) {
        self.team_logo = ::std::option::Option::None;
    }

    pub fn has_team_logo(&self) -> bool {
        self.team_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_logo(&mut self, v: u64) {
        self.team_logo = ::std::option::Option::Some(v);
    }

    pub fn get_team_logo(&self) -> u64 {
        self.team_logo.unwrap_or(0)
    }

    fn get_team_logo_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.team_logo
    }

    fn mut_team_logo_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.team_logo
    }
}

impl ::protobuf::Message for CMsgDOTAEditFantasyTeamRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.team_logo = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.team_logo {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.team_index {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.team_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.team_logo {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAEditFantasyTeamRequest {
    fn new() -> CMsgDOTAEditFantasyTeamRequest {
        CMsgDOTAEditFantasyTeamRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAEditFantasyTeamRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAEditFantasyTeamRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAEditFantasyTeamRequest::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_index",
                    CMsgDOTAEditFantasyTeamRequest::get_team_index_for_reflect,
                    CMsgDOTAEditFantasyTeamRequest::mut_team_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_name",
                    CMsgDOTAEditFantasyTeamRequest::get_team_name_for_reflect,
                    CMsgDOTAEditFantasyTeamRequest::mut_team_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "team_logo",
                    CMsgDOTAEditFantasyTeamRequest::get_team_logo_for_reflect,
                    CMsgDOTAEditFantasyTeamRequest::mut_team_logo_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAEditFantasyTeamRequest>(
                    "CMsgDOTAEditFantasyTeamRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAEditFantasyTeamRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_team_index();
        self.clear_team_name();
        self.clear_team_logo();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAEditFantasyTeamRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAEditFantasyTeamRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAEditFantasyTeamResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAEditFantasyTeamResponse_EResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAEditFantasyTeamResponse {}

impl CMsgDOTAEditFantasyTeamResponse {
    pub fn new() -> CMsgDOTAEditFantasyTeamResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAEditFantasyTeamResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAEditFantasyTeamResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAEditFantasyTeamResponse,
        };
        unsafe {
            instance.get(CMsgDOTAEditFantasyTeamResponse::new)
        }
    }

    // optional .CMsgDOTAEditFantasyTeamResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAEditFantasyTeamResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAEditFantasyTeamResponse_EResult {
        self.result.unwrap_or(CMsgDOTAEditFantasyTeamResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAEditFantasyTeamResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAEditFantasyTeamResponse_EResult> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgDOTAEditFantasyTeamResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAEditFantasyTeamResponse {
    fn new() -> CMsgDOTAEditFantasyTeamResponse {
        CMsgDOTAEditFantasyTeamResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAEditFantasyTeamResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAEditFantasyTeamResponse_EResult>>(
                    "result",
                    CMsgDOTAEditFantasyTeamResponse::get_result_for_reflect,
                    CMsgDOTAEditFantasyTeamResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAEditFantasyTeamResponse>(
                    "CMsgDOTAEditFantasyTeamResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAEditFantasyTeamResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAEditFantasyTeamResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAEditFantasyTeamResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAEditFantasyTeamResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_INVALID_TEAM_INFO = 2,
    ERROR_NAME_ALREADY_TAKEN = 3,
    ERROR_NO_PERMISSION = 4,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAEditFantasyTeamResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAEditFantasyTeamResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAEditFantasyTeamResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAEditFantasyTeamResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAEditFantasyTeamResponse_EResult::ERROR_INVALID_TEAM_INFO),
            3 => ::std::option::Option::Some(CMsgDOTAEditFantasyTeamResponse_EResult::ERROR_NAME_ALREADY_TAKEN),
            4 => ::std::option::Option::Some(CMsgDOTAEditFantasyTeamResponse_EResult::ERROR_NO_PERMISSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAEditFantasyTeamResponse_EResult] = &[
            CMsgDOTAEditFantasyTeamResponse_EResult::SUCCESS,
            CMsgDOTAEditFantasyTeamResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAEditFantasyTeamResponse_EResult::ERROR_INVALID_TEAM_INFO,
            CMsgDOTAEditFantasyTeamResponse_EResult::ERROR_NAME_ALREADY_TAKEN,
            CMsgDOTAEditFantasyTeamResponse_EResult::ERROR_NO_PERMISSION,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAEditFantasyTeamResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAEditFantasyTeamResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAEditFantasyTeamResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAEditFantasyTeamResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID {}

impl CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID {
    pub fn new() -> CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID {
    fn new() -> CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID {
        CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID::mut_fantasy_league_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID>(
                    "CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamInfoRequestByFantasyLeagueID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID {
    // message fields
    owner_account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID {}

impl CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID {
    pub fn new() -> CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID::new)
        }
    }

    // optional uint32 owner_account_id = 1;

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    fn get_owner_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.owner_account_id
    }

    fn mut_owner_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.owner_account_id
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.owner_account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID {
    fn new() -> CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID {
        CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "owner_account_id",
                    CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID::get_owner_account_id_for_reflect,
                    CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID::mut_owner_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID>(
                    "CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID {
    fn clear(&mut self) {
        self.clear_owner_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamInfoRequestByOwnerAccountID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamInfoResponse {
    // message fields
    results: ::protobuf::RepeatedField<CMsgDOTAFantasyTeamInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamInfoResponse {}

impl CMsgDOTAFantasyTeamInfoResponse {
    pub fn new() -> CMsgDOTAFantasyTeamInfoResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamInfoResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamInfoResponse::new)
        }
    }

    // repeated .CMsgDOTAFantasyTeamInfo results = 1;

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAFantasyTeamInfo>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyTeamInfo> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAFantasyTeamInfo> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }

    pub fn get_results(&self) -> &[CMsgDOTAFantasyTeamInfo] {
        &self.results
    }

    fn get_results_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAFantasyTeamInfo> {
        &self.results
    }

    fn mut_results_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyTeamInfo> {
        &mut self.results
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.results {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamInfoResponse {
    fn new() -> CMsgDOTAFantasyTeamInfoResponse {
        CMsgDOTAFantasyTeamInfoResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamInfoResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFantasyTeamInfo>>(
                    "results",
                    CMsgDOTAFantasyTeamInfoResponse::get_results_for_reflect,
                    CMsgDOTAFantasyTeamInfoResponse::mut_results_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamInfoResponse>(
                    "CMsgDOTAFantasyTeamInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamInfoResponse {
    fn clear(&mut self) {
        self.clear_results();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamInfo {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    owner_account_id: ::std::option::Option<u32>,
    fantasy_team_index: ::std::option::Option<u32>,
    team_name: ::protobuf::SingularField<::std::string::String>,
    team_logo: ::std::option::Option<u64>,
    wins: ::std::option::Option<u32>,
    losses: ::std::option::Option<u32>,
    current_roster: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamInfo {}

impl CMsgDOTAFantasyTeamInfo {
    pub fn new() -> CMsgDOTAFantasyTeamInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamInfo,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamInfo::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 owner_account_id = 2;

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    fn get_owner_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.owner_account_id
    }

    fn mut_owner_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.owner_account_id
    }

    // optional uint32 fantasy_team_index = 3;

    pub fn clear_fantasy_team_index(&mut self) {
        self.fantasy_team_index = ::std::option::Option::None;
    }

    pub fn has_fantasy_team_index(&self) -> bool {
        self.fantasy_team_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_team_index(&mut self, v: u32) {
        self.fantasy_team_index = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_team_index(&self) -> u32 {
        self.fantasy_team_index.unwrap_or(0)
    }

    fn get_fantasy_team_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_team_index
    }

    fn mut_fantasy_team_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_team_index
    }

    // optional string team_name = 4;

    pub fn clear_team_name(&mut self) {
        self.team_name.clear();
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name.set_default();
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_name
    }

    fn mut_team_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_name
    }

    // optional uint64 team_logo = 5;

    pub fn clear_team_logo(&mut self) {
        self.team_logo = ::std::option::Option::None;
    }

    pub fn has_team_logo(&self) -> bool {
        self.team_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_logo(&mut self, v: u64) {
        self.team_logo = ::std::option::Option::Some(v);
    }

    pub fn get_team_logo(&self) -> u64 {
        self.team_logo.unwrap_or(0)
    }

    fn get_team_logo_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.team_logo
    }

    fn mut_team_logo_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.team_logo
    }

    // optional uint32 wins = 6;

    pub fn clear_wins(&mut self) {
        self.wins = ::std::option::Option::None;
    }

    pub fn has_wins(&self) -> bool {
        self.wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: u32) {
        self.wins = ::std::option::Option::Some(v);
    }

    pub fn get_wins(&self) -> u32 {
        self.wins.unwrap_or(0)
    }

    fn get_wins_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.wins
    }

    fn mut_wins_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.wins
    }

    // optional uint32 losses = 7;

    pub fn clear_losses(&mut self) {
        self.losses = ::std::option::Option::None;
    }

    pub fn has_losses(&self) -> bool {
        self.losses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_losses(&mut self, v: u32) {
        self.losses = ::std::option::Option::Some(v);
    }

    pub fn get_losses(&self) -> u32 {
        self.losses.unwrap_or(0)
    }

    fn get_losses_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.losses
    }

    fn mut_losses_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.losses
    }

    // repeated uint32 current_roster = 8;

    pub fn clear_current_roster(&mut self) {
        self.current_roster.clear();
    }

    // Param is passed by value, moved
    pub fn set_current_roster(&mut self, v: ::std::vec::Vec<u32>) {
        self.current_roster = v;
    }

    // Mutable pointer to the field.
    pub fn mut_current_roster(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.current_roster
    }

    // Take field
    pub fn take_current_roster(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.current_roster, ::std::vec::Vec::new())
    }

    pub fn get_current_roster(&self) -> &[u32] {
        &self.current_roster
    }

    fn get_current_roster_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.current_roster
    }

    fn mut_current_roster_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.current_roster
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_team_index = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_name)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.team_logo = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wins = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.losses = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.current_roster)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fantasy_team_index {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.team_logo {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wins {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.losses {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.current_roster {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.fantasy_team_index {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.team_name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.team_logo {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.wins {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.losses {
            os.write_uint32(7, v)?;
        }
        for v in &self.current_roster {
            os.write_uint32(8, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamInfo {
    fn new() -> CMsgDOTAFantasyTeamInfo {
        CMsgDOTAFantasyTeamInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyTeamInfo::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyTeamInfo::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "owner_account_id",
                    CMsgDOTAFantasyTeamInfo::get_owner_account_id_for_reflect,
                    CMsgDOTAFantasyTeamInfo::mut_owner_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_team_index",
                    CMsgDOTAFantasyTeamInfo::get_fantasy_team_index_for_reflect,
                    CMsgDOTAFantasyTeamInfo::mut_fantasy_team_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_name",
                    CMsgDOTAFantasyTeamInfo::get_team_name_for_reflect,
                    CMsgDOTAFantasyTeamInfo::mut_team_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "team_logo",
                    CMsgDOTAFantasyTeamInfo::get_team_logo_for_reflect,
                    CMsgDOTAFantasyTeamInfo::mut_team_logo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wins",
                    CMsgDOTAFantasyTeamInfo::get_wins_for_reflect,
                    CMsgDOTAFantasyTeamInfo::mut_wins_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "losses",
                    CMsgDOTAFantasyTeamInfo::get_losses_for_reflect,
                    CMsgDOTAFantasyTeamInfo::mut_losses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "current_roster",
                    CMsgDOTAFantasyTeamInfo::get_current_roster_for_reflect,
                    CMsgDOTAFantasyTeamInfo::mut_current_roster_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamInfo>(
                    "CMsgDOTAFantasyTeamInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamInfo {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_owner_account_id();
        self.clear_fantasy_team_index();
        self.clear_team_name();
        self.clear_team_logo();
        self.clear_wins();
        self.clear_losses();
        self.clear_current_roster();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamScoreRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    owner_account_id: ::std::option::Option<u32>,
    fantasy_team_index: ::std::option::Option<u32>,
    filter_match_id: ::std::option::Option<u64>,
    filter_start_time: ::std::option::Option<u32>,
    filter_end_time: ::std::option::Option<u32>,
    include_bench: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamScoreRequest {}

impl CMsgDOTAFantasyTeamScoreRequest {
    pub fn new() -> CMsgDOTAFantasyTeamScoreRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamScoreRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamScoreRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamScoreRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamScoreRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 owner_account_id = 2;

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    fn get_owner_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.owner_account_id
    }

    fn mut_owner_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.owner_account_id
    }

    // optional uint32 fantasy_team_index = 3;

    pub fn clear_fantasy_team_index(&mut self) {
        self.fantasy_team_index = ::std::option::Option::None;
    }

    pub fn has_fantasy_team_index(&self) -> bool {
        self.fantasy_team_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_team_index(&mut self, v: u32) {
        self.fantasy_team_index = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_team_index(&self) -> u32 {
        self.fantasy_team_index.unwrap_or(0)
    }

    fn get_fantasy_team_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_team_index
    }

    fn mut_fantasy_team_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_team_index
    }

    // optional uint64 filter_match_id = 4;

    pub fn clear_filter_match_id(&mut self) {
        self.filter_match_id = ::std::option::Option::None;
    }

    pub fn has_filter_match_id(&self) -> bool {
        self.filter_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_match_id(&mut self, v: u64) {
        self.filter_match_id = ::std::option::Option::Some(v);
    }

    pub fn get_filter_match_id(&self) -> u64 {
        self.filter_match_id.unwrap_or(0)
    }

    fn get_filter_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.filter_match_id
    }

    fn mut_filter_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.filter_match_id
    }

    // optional uint32 filter_start_time = 5;

    pub fn clear_filter_start_time(&mut self) {
        self.filter_start_time = ::std::option::Option::None;
    }

    pub fn has_filter_start_time(&self) -> bool {
        self.filter_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_start_time(&mut self, v: u32) {
        self.filter_start_time = ::std::option::Option::Some(v);
    }

    pub fn get_filter_start_time(&self) -> u32 {
        self.filter_start_time.unwrap_or(0)
    }

    fn get_filter_start_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.filter_start_time
    }

    fn mut_filter_start_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.filter_start_time
    }

    // optional uint32 filter_end_time = 6;

    pub fn clear_filter_end_time(&mut self) {
        self.filter_end_time = ::std::option::Option::None;
    }

    pub fn has_filter_end_time(&self) -> bool {
        self.filter_end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_end_time(&mut self, v: u32) {
        self.filter_end_time = ::std::option::Option::Some(v);
    }

    pub fn get_filter_end_time(&self) -> u32 {
        self.filter_end_time.unwrap_or(0)
    }

    fn get_filter_end_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.filter_end_time
    }

    fn mut_filter_end_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.filter_end_time
    }

    // optional bool include_bench = 7;

    pub fn clear_include_bench(&mut self) {
        self.include_bench = ::std::option::Option::None;
    }

    pub fn has_include_bench(&self) -> bool {
        self.include_bench.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_bench(&mut self, v: bool) {
        self.include_bench = ::std::option::Option::Some(v);
    }

    pub fn get_include_bench(&self) -> bool {
        self.include_bench.unwrap_or(false)
    }

    fn get_include_bench_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.include_bench
    }

    fn mut_include_bench_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.include_bench
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamScoreRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_team_index = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.filter_match_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.filter_start_time = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.filter_end_time = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_bench = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fantasy_team_index {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filter_match_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filter_start_time {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filter_end_time {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.include_bench {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.fantasy_team_index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filter_match_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.filter_start_time {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.filter_end_time {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.include_bench {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamScoreRequest {
    fn new() -> CMsgDOTAFantasyTeamScoreRequest {
        CMsgDOTAFantasyTeamScoreRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamScoreRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyTeamScoreRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyTeamScoreRequest::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "owner_account_id",
                    CMsgDOTAFantasyTeamScoreRequest::get_owner_account_id_for_reflect,
                    CMsgDOTAFantasyTeamScoreRequest::mut_owner_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_team_index",
                    CMsgDOTAFantasyTeamScoreRequest::get_fantasy_team_index_for_reflect,
                    CMsgDOTAFantasyTeamScoreRequest::mut_fantasy_team_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "filter_match_id",
                    CMsgDOTAFantasyTeamScoreRequest::get_filter_match_id_for_reflect,
                    CMsgDOTAFantasyTeamScoreRequest::mut_filter_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "filter_start_time",
                    CMsgDOTAFantasyTeamScoreRequest::get_filter_start_time_for_reflect,
                    CMsgDOTAFantasyTeamScoreRequest::mut_filter_start_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "filter_end_time",
                    CMsgDOTAFantasyTeamScoreRequest::get_filter_end_time_for_reflect,
                    CMsgDOTAFantasyTeamScoreRequest::mut_filter_end_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "include_bench",
                    CMsgDOTAFantasyTeamScoreRequest::get_include_bench_for_reflect,
                    CMsgDOTAFantasyTeamScoreRequest::mut_include_bench_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamScoreRequest>(
                    "CMsgDOTAFantasyTeamScoreRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamScoreRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_owner_account_id();
        self.clear_fantasy_team_index();
        self.clear_filter_match_id();
        self.clear_filter_start_time();
        self.clear_filter_end_time();
        self.clear_include_bench();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamScoreRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamScoreRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamScoreResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyTeamScoreResponse_EResult>,
    fantasy_team_score: ::std::option::Option<f32>,
    fantasy_player_score: ::protobuf::RepeatedField<CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamScoreResponse {}

impl CMsgDOTAFantasyTeamScoreResponse {
    pub fn new() -> CMsgDOTAFantasyTeamScoreResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamScoreResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamScoreResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamScoreResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamScoreResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyTeamScoreResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyTeamScoreResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyTeamScoreResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyTeamScoreResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyTeamScoreResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyTeamScoreResponse_EResult> {
        &mut self.result
    }

    // optional float fantasy_team_score = 2;

    pub fn clear_fantasy_team_score(&mut self) {
        self.fantasy_team_score = ::std::option::Option::None;
    }

    pub fn has_fantasy_team_score(&self) -> bool {
        self.fantasy_team_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_team_score(&mut self, v: f32) {
        self.fantasy_team_score = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_team_score(&self) -> f32 {
        self.fantasy_team_score.unwrap_or(0.)
    }

    fn get_fantasy_team_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.fantasy_team_score
    }

    fn mut_fantasy_team_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.fantasy_team_score
    }

    // repeated .CMsgDOTAFantasyTeamScoreResponse.CMsgPlayerScore fantasy_player_score = 3;

    pub fn clear_fantasy_player_score(&mut self) {
        self.fantasy_player_score.clear();
    }

    // Param is passed by value, moved
    pub fn set_fantasy_player_score(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore>) {
        self.fantasy_player_score = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fantasy_player_score(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore> {
        &mut self.fantasy_player_score
    }

    // Take field
    pub fn take_fantasy_player_score(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore> {
        ::std::mem::replace(&mut self.fantasy_player_score, ::protobuf::RepeatedField::new())
    }

    pub fn get_fantasy_player_score(&self) -> &[CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore] {
        &self.fantasy_player_score
    }

    fn get_fantasy_player_score_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore> {
        &self.fantasy_player_score
    }

    fn mut_fantasy_player_score_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore> {
        &mut self.fantasy_player_score
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamScoreResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.fantasy_player_score {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.fantasy_team_score = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fantasy_player_score)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.fantasy_team_score {
            my_size += 5;
        }
        for value in &self.fantasy_player_score {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.fantasy_team_score {
            os.write_float(2, v)?;
        }
        for v in &self.fantasy_player_score {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamScoreResponse {
    fn new() -> CMsgDOTAFantasyTeamScoreResponse {
        CMsgDOTAFantasyTeamScoreResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamScoreResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyTeamScoreResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyTeamScoreResponse::get_result_for_reflect,
                    CMsgDOTAFantasyTeamScoreResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "fantasy_team_score",
                    CMsgDOTAFantasyTeamScoreResponse::get_fantasy_team_score_for_reflect,
                    CMsgDOTAFantasyTeamScoreResponse::mut_fantasy_team_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore>>(
                    "fantasy_player_score",
                    CMsgDOTAFantasyTeamScoreResponse::get_fantasy_player_score_for_reflect,
                    CMsgDOTAFantasyTeamScoreResponse::mut_fantasy_player_score_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamScoreResponse>(
                    "CMsgDOTAFantasyTeamScoreResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamScoreResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_fantasy_team_score();
        self.clear_fantasy_player_score();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamScoreResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamScoreResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore {
    // message fields
    account_id: ::std::option::Option<u32>,
    score: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore {}

impl CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore {
    pub fn new() -> CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional float score = 2;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score(&self) -> f32 {
        self.score.unwrap_or(0.)
    }

    fn get_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.score
    }

    fn mut_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.score
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.score {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore {
    fn new() -> CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore {
        CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::get_account_id_for_reflect,
                    CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "score",
                    CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::get_score_for_reflect,
                    CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore::mut_score_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore>(
                    "CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_score();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamScoreResponse_CMsgPlayerScore {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyTeamScoreResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_NO_PERMISSION = 2,
    ERROR_OWNER_NOT_IN_LEAGUE = 3,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyTeamScoreResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyTeamScoreResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyTeamScoreResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyTeamScoreResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyTeamScoreResponse_EResult::ERROR_NO_PERMISSION),
            3 => ::std::option::Option::Some(CMsgDOTAFantasyTeamScoreResponse_EResult::ERROR_OWNER_NOT_IN_LEAGUE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyTeamScoreResponse_EResult] = &[
            CMsgDOTAFantasyTeamScoreResponse_EResult::SUCCESS,
            CMsgDOTAFantasyTeamScoreResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyTeamScoreResponse_EResult::ERROR_NO_PERMISSION,
            CMsgDOTAFantasyTeamScoreResponse_EResult::ERROR_OWNER_NOT_IN_LEAGUE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamScoreResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyTeamScoreResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyTeamScoreResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamScoreResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamStandingsRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    count: ::std::option::Option<u32>,
    filter_start_time: ::std::option::Option<u32>,
    filter_end_time: ::std::option::Option<u32>,
    filter_match_id: ::std::option::Option<u64>,
    filter_last_match: ::std::option::Option<bool>,
    filter_in_hall: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamStandingsRequest {}

impl CMsgDOTAFantasyTeamStandingsRequest {
    pub fn new() -> CMsgDOTAFantasyTeamStandingsRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamStandingsRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamStandingsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamStandingsRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamStandingsRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 count = 2;

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    pub fn get_count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    fn get_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.count
    }

    fn mut_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.count
    }

    // optional uint32 filter_start_time = 3;

    pub fn clear_filter_start_time(&mut self) {
        self.filter_start_time = ::std::option::Option::None;
    }

    pub fn has_filter_start_time(&self) -> bool {
        self.filter_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_start_time(&mut self, v: u32) {
        self.filter_start_time = ::std::option::Option::Some(v);
    }

    pub fn get_filter_start_time(&self) -> u32 {
        self.filter_start_time.unwrap_or(0)
    }

    fn get_filter_start_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.filter_start_time
    }

    fn mut_filter_start_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.filter_start_time
    }

    // optional uint32 filter_end_time = 4;

    pub fn clear_filter_end_time(&mut self) {
        self.filter_end_time = ::std::option::Option::None;
    }

    pub fn has_filter_end_time(&self) -> bool {
        self.filter_end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_end_time(&mut self, v: u32) {
        self.filter_end_time = ::std::option::Option::Some(v);
    }

    pub fn get_filter_end_time(&self) -> u32 {
        self.filter_end_time.unwrap_or(0)
    }

    fn get_filter_end_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.filter_end_time
    }

    fn mut_filter_end_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.filter_end_time
    }

    // optional uint64 filter_match_id = 5;

    pub fn clear_filter_match_id(&mut self) {
        self.filter_match_id = ::std::option::Option::None;
    }

    pub fn has_filter_match_id(&self) -> bool {
        self.filter_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_match_id(&mut self, v: u64) {
        self.filter_match_id = ::std::option::Option::Some(v);
    }

    pub fn get_filter_match_id(&self) -> u64 {
        self.filter_match_id.unwrap_or(0)
    }

    fn get_filter_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.filter_match_id
    }

    fn mut_filter_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.filter_match_id
    }

    // optional bool filter_last_match = 6;

    pub fn clear_filter_last_match(&mut self) {
        self.filter_last_match = ::std::option::Option::None;
    }

    pub fn has_filter_last_match(&self) -> bool {
        self.filter_last_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_last_match(&mut self, v: bool) {
        self.filter_last_match = ::std::option::Option::Some(v);
    }

    pub fn get_filter_last_match(&self) -> bool {
        self.filter_last_match.unwrap_or(false)
    }

    fn get_filter_last_match_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.filter_last_match
    }

    fn mut_filter_last_match_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.filter_last_match
    }

    // optional bool filter_in_hall = 7;

    pub fn clear_filter_in_hall(&mut self) {
        self.filter_in_hall = ::std::option::Option::None;
    }

    pub fn has_filter_in_hall(&self) -> bool {
        self.filter_in_hall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_in_hall(&mut self, v: bool) {
        self.filter_in_hall = ::std::option::Option::Some(v);
    }

    pub fn get_filter_in_hall(&self) -> bool {
        self.filter_in_hall.unwrap_or(false)
    }

    fn get_filter_in_hall_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.filter_in_hall
    }

    fn mut_filter_in_hall_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.filter_in_hall
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamStandingsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.filter_start_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.filter_end_time = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.filter_match_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.filter_last_match = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.filter_in_hall = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filter_start_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filter_end_time {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filter_match_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filter_last_match {
            my_size += 2;
        }
        if let Some(v) = self.filter_in_hall {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filter_start_time {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filter_end_time {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.filter_match_id {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.filter_last_match {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.filter_in_hall {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamStandingsRequest {
    fn new() -> CMsgDOTAFantasyTeamStandingsRequest {
        CMsgDOTAFantasyTeamStandingsRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamStandingsRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyTeamStandingsRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyTeamStandingsRequest::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "count",
                    CMsgDOTAFantasyTeamStandingsRequest::get_count_for_reflect,
                    CMsgDOTAFantasyTeamStandingsRequest::mut_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "filter_start_time",
                    CMsgDOTAFantasyTeamStandingsRequest::get_filter_start_time_for_reflect,
                    CMsgDOTAFantasyTeamStandingsRequest::mut_filter_start_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "filter_end_time",
                    CMsgDOTAFantasyTeamStandingsRequest::get_filter_end_time_for_reflect,
                    CMsgDOTAFantasyTeamStandingsRequest::mut_filter_end_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "filter_match_id",
                    CMsgDOTAFantasyTeamStandingsRequest::get_filter_match_id_for_reflect,
                    CMsgDOTAFantasyTeamStandingsRequest::mut_filter_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "filter_last_match",
                    CMsgDOTAFantasyTeamStandingsRequest::get_filter_last_match_for_reflect,
                    CMsgDOTAFantasyTeamStandingsRequest::mut_filter_last_match_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "filter_in_hall",
                    CMsgDOTAFantasyTeamStandingsRequest::get_filter_in_hall_for_reflect,
                    CMsgDOTAFantasyTeamStandingsRequest::mut_filter_in_hall_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamStandingsRequest>(
                    "CMsgDOTAFantasyTeamStandingsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamStandingsRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_count();
        self.clear_filter_start_time();
        self.clear_filter_end_time();
        self.clear_filter_match_id();
        self.clear_filter_last_match();
        self.clear_filter_in_hall();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamStandingsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamStandingsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamStandingsResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyTeamStandingsResponse_EResult>,
    team_scores: ::protobuf::RepeatedField<CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamStandingsResponse {}

impl CMsgDOTAFantasyTeamStandingsResponse {
    pub fn new() -> CMsgDOTAFantasyTeamStandingsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamStandingsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamStandingsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamStandingsResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamStandingsResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyTeamStandingsResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyTeamStandingsResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyTeamStandingsResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyTeamStandingsResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyTeamStandingsResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyTeamStandingsResponse_EResult> {
        &mut self.result
    }

    // repeated .CMsgDOTAFantasyTeamStandingsResponse.CMsgTeamScore team_scores = 3;

    pub fn clear_team_scores(&mut self) {
        self.team_scores.clear();
    }

    // Param is passed by value, moved
    pub fn set_team_scores(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore>) {
        self.team_scores = v;
    }

    // Mutable pointer to the field.
    pub fn mut_team_scores(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore> {
        &mut self.team_scores
    }

    // Take field
    pub fn take_team_scores(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore> {
        ::std::mem::replace(&mut self.team_scores, ::protobuf::RepeatedField::new())
    }

    pub fn get_team_scores(&self) -> &[CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore] {
        &self.team_scores
    }

    fn get_team_scores_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore> {
        &self.team_scores
    }

    fn mut_team_scores_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore> {
        &mut self.team_scores
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamStandingsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.team_scores {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.team_scores)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.team_scores {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        for v in &self.team_scores {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamStandingsResponse {
    fn new() -> CMsgDOTAFantasyTeamStandingsResponse {
        CMsgDOTAFantasyTeamStandingsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamStandingsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyTeamStandingsResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyTeamStandingsResponse::get_result_for_reflect,
                    CMsgDOTAFantasyTeamStandingsResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore>>(
                    "team_scores",
                    CMsgDOTAFantasyTeamStandingsResponse::get_team_scores_for_reflect,
                    CMsgDOTAFantasyTeamStandingsResponse::mut_team_scores_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamStandingsResponse>(
                    "CMsgDOTAFantasyTeamStandingsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamStandingsResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_team_scores();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamStandingsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamStandingsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    owner_account_id: ::std::option::Option<u32>,
    fantasy_team_index: ::std::option::Option<u32>,
    fantasy_team_logo: ::std::option::Option<u64>,
    owner_name: ::protobuf::SingularField<::std::string::String>,
    fantasy_team_name: ::protobuf::SingularField<::std::string::String>,
    score: ::std::option::Option<f32>,
    score_against: ::std::option::Option<f32>,
    wins: ::std::option::Option<u32>,
    losses: ::std::option::Option<u32>,
    streak: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore {}

impl CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore {
    pub fn new() -> CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 owner_account_id = 2;

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    fn get_owner_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.owner_account_id
    }

    fn mut_owner_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.owner_account_id
    }

    // optional uint32 fantasy_team_index = 3;

    pub fn clear_fantasy_team_index(&mut self) {
        self.fantasy_team_index = ::std::option::Option::None;
    }

    pub fn has_fantasy_team_index(&self) -> bool {
        self.fantasy_team_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_team_index(&mut self, v: u32) {
        self.fantasy_team_index = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_team_index(&self) -> u32 {
        self.fantasy_team_index.unwrap_or(0)
    }

    fn get_fantasy_team_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_team_index
    }

    fn mut_fantasy_team_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_team_index
    }

    // optional uint64 fantasy_team_logo = 4;

    pub fn clear_fantasy_team_logo(&mut self) {
        self.fantasy_team_logo = ::std::option::Option::None;
    }

    pub fn has_fantasy_team_logo(&self) -> bool {
        self.fantasy_team_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_team_logo(&mut self, v: u64) {
        self.fantasy_team_logo = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_team_logo(&self) -> u64 {
        self.fantasy_team_logo.unwrap_or(0)
    }

    fn get_fantasy_team_logo_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fantasy_team_logo
    }

    fn mut_fantasy_team_logo_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fantasy_team_logo
    }

    // optional string owner_name = 5;

    pub fn clear_owner_name(&mut self) {
        self.owner_name.clear();
    }

    pub fn has_owner_name(&self) -> bool {
        self.owner_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_name(&mut self, v: ::std::string::String) {
        self.owner_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_name(&mut self) -> &mut ::std::string::String {
        if self.owner_name.is_none() {
            self.owner_name.set_default();
        }
        self.owner_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner_name(&mut self) -> ::std::string::String {
        self.owner_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_owner_name(&self) -> &str {
        match self.owner_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_owner_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.owner_name
    }

    fn mut_owner_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.owner_name
    }

    // optional string fantasy_team_name = 6;

    pub fn clear_fantasy_team_name(&mut self) {
        self.fantasy_team_name.clear();
    }

    pub fn has_fantasy_team_name(&self) -> bool {
        self.fantasy_team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_team_name(&mut self, v: ::std::string::String) {
        self.fantasy_team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fantasy_team_name(&mut self) -> &mut ::std::string::String {
        if self.fantasy_team_name.is_none() {
            self.fantasy_team_name.set_default();
        }
        self.fantasy_team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_fantasy_team_name(&mut self) -> ::std::string::String {
        self.fantasy_team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fantasy_team_name(&self) -> &str {
        match self.fantasy_team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fantasy_team_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fantasy_team_name
    }

    fn mut_fantasy_team_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fantasy_team_name
    }

    // optional float score = 7;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score(&self) -> f32 {
        self.score.unwrap_or(0.)
    }

    fn get_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.score
    }

    fn mut_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.score
    }

    // optional float score_against = 8;

    pub fn clear_score_against(&mut self) {
        self.score_against = ::std::option::Option::None;
    }

    pub fn has_score_against(&self) -> bool {
        self.score_against.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_against(&mut self, v: f32) {
        self.score_against = ::std::option::Option::Some(v);
    }

    pub fn get_score_against(&self) -> f32 {
        self.score_against.unwrap_or(0.)
    }

    fn get_score_against_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.score_against
    }

    fn mut_score_against_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.score_against
    }

    // optional uint32 wins = 9;

    pub fn clear_wins(&mut self) {
        self.wins = ::std::option::Option::None;
    }

    pub fn has_wins(&self) -> bool {
        self.wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: u32) {
        self.wins = ::std::option::Option::Some(v);
    }

    pub fn get_wins(&self) -> u32 {
        self.wins.unwrap_or(0)
    }

    fn get_wins_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.wins
    }

    fn mut_wins_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.wins
    }

    // optional uint32 losses = 10;

    pub fn clear_losses(&mut self) {
        self.losses = ::std::option::Option::None;
    }

    pub fn has_losses(&self) -> bool {
        self.losses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_losses(&mut self, v: u32) {
        self.losses = ::std::option::Option::Some(v);
    }

    pub fn get_losses(&self) -> u32 {
        self.losses.unwrap_or(0)
    }

    fn get_losses_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.losses
    }

    fn mut_losses_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.losses
    }

    // optional int32 streak = 11;

    pub fn clear_streak(&mut self) {
        self.streak = ::std::option::Option::None;
    }

    pub fn has_streak(&self) -> bool {
        self.streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streak(&mut self, v: i32) {
        self.streak = ::std::option::Option::Some(v);
    }

    pub fn get_streak(&self) -> i32 {
        self.streak.unwrap_or(0)
    }

    fn get_streak_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.streak
    }

    fn mut_streak_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.streak
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_team_index = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fantasy_team_logo = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.owner_name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fantasy_team_name)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score_against = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wins = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.losses = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.streak = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fantasy_team_index {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fantasy_team_logo {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.owner_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.fantasy_team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.score {
            my_size += 5;
        }
        if let Some(v) = self.score_against {
            my_size += 5;
        }
        if let Some(v) = self.wins {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.losses {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.streak {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.fantasy_team_index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.fantasy_team_logo {
            os.write_uint64(4, v)?;
        }
        if let Some(ref v) = self.owner_name.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.fantasy_team_name.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.score {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.score_against {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.wins {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.losses {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.streak {
            os.write_int32(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore {
    fn new() -> CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore {
        CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "owner_account_id",
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::get_owner_account_id_for_reflect,
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::mut_owner_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_team_index",
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::get_fantasy_team_index_for_reflect,
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::mut_fantasy_team_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fantasy_team_logo",
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::get_fantasy_team_logo_for_reflect,
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::mut_fantasy_team_logo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "owner_name",
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::get_owner_name_for_reflect,
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::mut_owner_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fantasy_team_name",
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::get_fantasy_team_name_for_reflect,
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::mut_fantasy_team_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "score",
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::get_score_for_reflect,
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::mut_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "score_against",
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::get_score_against_for_reflect,
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::mut_score_against_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wins",
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::get_wins_for_reflect,
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::mut_wins_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "losses",
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::get_losses_for_reflect,
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::mut_losses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "streak",
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::get_streak_for_reflect,
                    CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore::mut_streak_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore>(
                    "CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_owner_account_id();
        self.clear_fantasy_team_index();
        self.clear_fantasy_team_logo();
        self.clear_owner_name();
        self.clear_fantasy_team_name();
        self.clear_score();
        self.clear_score_against();
        self.clear_wins();
        self.clear_losses();
        self.clear_streak();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamStandingsResponse_CMsgTeamScore {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyTeamStandingsResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_NO_PERMISSION = 2,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyTeamStandingsResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyTeamStandingsResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyTeamStandingsResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyTeamStandingsResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyTeamStandingsResponse_EResult::ERROR_NO_PERMISSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyTeamStandingsResponse_EResult] = &[
            CMsgDOTAFantasyTeamStandingsResponse_EResult::SUCCESS,
            CMsgDOTAFantasyTeamStandingsResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyTeamStandingsResponse_EResult::ERROR_NO_PERMISSION,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamStandingsResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyTeamStandingsResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyTeamStandingsResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamStandingsResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyPlayerScoreRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    player_account_id: ::std::option::Option<u32>,
    filter_start_time: ::std::option::Option<u32>,
    filter_end_time: ::std::option::Option<u32>,
    filter_match_id: ::std::option::Option<u64>,
    filter_last_match: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyPlayerScoreRequest {}

impl CMsgDOTAFantasyPlayerScoreRequest {
    pub fn new() -> CMsgDOTAFantasyPlayerScoreRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyPlayerScoreRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyPlayerScoreRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyPlayerScoreRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyPlayerScoreRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 player_account_id = 2;

    pub fn clear_player_account_id(&mut self) {
        self.player_account_id = ::std::option::Option::None;
    }

    pub fn has_player_account_id(&self) -> bool {
        self.player_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_account_id(&mut self, v: u32) {
        self.player_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_account_id(&self) -> u32 {
        self.player_account_id.unwrap_or(0)
    }

    fn get_player_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_account_id
    }

    fn mut_player_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_account_id
    }

    // optional uint32 filter_start_time = 3;

    pub fn clear_filter_start_time(&mut self) {
        self.filter_start_time = ::std::option::Option::None;
    }

    pub fn has_filter_start_time(&self) -> bool {
        self.filter_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_start_time(&mut self, v: u32) {
        self.filter_start_time = ::std::option::Option::Some(v);
    }

    pub fn get_filter_start_time(&self) -> u32 {
        self.filter_start_time.unwrap_or(0)
    }

    fn get_filter_start_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.filter_start_time
    }

    fn mut_filter_start_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.filter_start_time
    }

    // optional uint32 filter_end_time = 4;

    pub fn clear_filter_end_time(&mut self) {
        self.filter_end_time = ::std::option::Option::None;
    }

    pub fn has_filter_end_time(&self) -> bool {
        self.filter_end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_end_time(&mut self, v: u32) {
        self.filter_end_time = ::std::option::Option::Some(v);
    }

    pub fn get_filter_end_time(&self) -> u32 {
        self.filter_end_time.unwrap_or(0)
    }

    fn get_filter_end_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.filter_end_time
    }

    fn mut_filter_end_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.filter_end_time
    }

    // optional uint64 filter_match_id = 5;

    pub fn clear_filter_match_id(&mut self) {
        self.filter_match_id = ::std::option::Option::None;
    }

    pub fn has_filter_match_id(&self) -> bool {
        self.filter_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_match_id(&mut self, v: u64) {
        self.filter_match_id = ::std::option::Option::Some(v);
    }

    pub fn get_filter_match_id(&self) -> u64 {
        self.filter_match_id.unwrap_or(0)
    }

    fn get_filter_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.filter_match_id
    }

    fn mut_filter_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.filter_match_id
    }

    // optional bool filter_last_match = 6;

    pub fn clear_filter_last_match(&mut self) {
        self.filter_last_match = ::std::option::Option::None;
    }

    pub fn has_filter_last_match(&self) -> bool {
        self.filter_last_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_last_match(&mut self, v: bool) {
        self.filter_last_match = ::std::option::Option::Some(v);
    }

    pub fn get_filter_last_match(&self) -> bool {
        self.filter_last_match.unwrap_or(false)
    }

    fn get_filter_last_match_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.filter_last_match
    }

    fn mut_filter_last_match_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.filter_last_match
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerScoreRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.filter_start_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.filter_end_time = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.filter_match_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.filter_last_match = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filter_start_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filter_end_time {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filter_match_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filter_last_match {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filter_start_time {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filter_end_time {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.filter_match_id {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.filter_last_match {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyPlayerScoreRequest {
    fn new() -> CMsgDOTAFantasyPlayerScoreRequest {
        CMsgDOTAFantasyPlayerScoreRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerScoreRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyPlayerScoreRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyPlayerScoreRequest::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_account_id",
                    CMsgDOTAFantasyPlayerScoreRequest::get_player_account_id_for_reflect,
                    CMsgDOTAFantasyPlayerScoreRequest::mut_player_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "filter_start_time",
                    CMsgDOTAFantasyPlayerScoreRequest::get_filter_start_time_for_reflect,
                    CMsgDOTAFantasyPlayerScoreRequest::mut_filter_start_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "filter_end_time",
                    CMsgDOTAFantasyPlayerScoreRequest::get_filter_end_time_for_reflect,
                    CMsgDOTAFantasyPlayerScoreRequest::mut_filter_end_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "filter_match_id",
                    CMsgDOTAFantasyPlayerScoreRequest::get_filter_match_id_for_reflect,
                    CMsgDOTAFantasyPlayerScoreRequest::mut_filter_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "filter_last_match",
                    CMsgDOTAFantasyPlayerScoreRequest::get_filter_last_match_for_reflect,
                    CMsgDOTAFantasyPlayerScoreRequest::mut_filter_last_match_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyPlayerScoreRequest>(
                    "CMsgDOTAFantasyPlayerScoreRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyPlayerScoreRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_player_account_id();
        self.clear_filter_start_time();
        self.clear_filter_end_time();
        self.clear_filter_match_id();
        self.clear_filter_last_match();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyPlayerScoreRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerScoreRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyPlayerScoreResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyPlayerScoreResponse_EResult>,
    fantasy_league_id: ::std::option::Option<u32>,
    player_account_id: ::std::option::Option<u32>,
    player_name: ::protobuf::SingularField<::std::string::String>,
    score: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyPlayerScoreResponse {}

impl CMsgDOTAFantasyPlayerScoreResponse {
    pub fn new() -> CMsgDOTAFantasyPlayerScoreResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyPlayerScoreResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyPlayerScoreResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyPlayerScoreResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyPlayerScoreResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyPlayerScoreResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyPlayerScoreResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyPlayerScoreResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyPlayerScoreResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyPlayerScoreResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyPlayerScoreResponse_EResult> {
        &mut self.result
    }

    // optional uint32 fantasy_league_id = 2;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 player_account_id = 3;

    pub fn clear_player_account_id(&mut self) {
        self.player_account_id = ::std::option::Option::None;
    }

    pub fn has_player_account_id(&self) -> bool {
        self.player_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_account_id(&mut self, v: u32) {
        self.player_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_account_id(&self) -> u32 {
        self.player_account_id.unwrap_or(0)
    }

    fn get_player_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_account_id
    }

    fn mut_player_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_account_id
    }

    // optional string player_name = 4;

    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_player_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.player_name
    }

    fn mut_player_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.player_name
    }

    // optional float score = 5;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score(&self) -> f32 {
        self.score.unwrap_or(0.)
    }

    fn get_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.score
    }

    fn mut_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.score
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerScoreResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_account_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_account_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.score {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.player_account_id {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.player_name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.score {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyPlayerScoreResponse {
    fn new() -> CMsgDOTAFantasyPlayerScoreResponse {
        CMsgDOTAFantasyPlayerScoreResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerScoreResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyPlayerScoreResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyPlayerScoreResponse::get_result_for_reflect,
                    CMsgDOTAFantasyPlayerScoreResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyPlayerScoreResponse::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyPlayerScoreResponse::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_account_id",
                    CMsgDOTAFantasyPlayerScoreResponse::get_player_account_id_for_reflect,
                    CMsgDOTAFantasyPlayerScoreResponse::mut_player_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "player_name",
                    CMsgDOTAFantasyPlayerScoreResponse::get_player_name_for_reflect,
                    CMsgDOTAFantasyPlayerScoreResponse::mut_player_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "score",
                    CMsgDOTAFantasyPlayerScoreResponse::get_score_for_reflect,
                    CMsgDOTAFantasyPlayerScoreResponse::mut_score_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyPlayerScoreResponse>(
                    "CMsgDOTAFantasyPlayerScoreResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyPlayerScoreResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_fantasy_league_id();
        self.clear_player_account_id();
        self.clear_player_name();
        self.clear_score();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyPlayerScoreResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerScoreResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyPlayerScoreResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_NO_PERMISSION = 2,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyPlayerScoreResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyPlayerScoreResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyPlayerScoreResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyPlayerScoreResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyPlayerScoreResponse_EResult::ERROR_NO_PERMISSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyPlayerScoreResponse_EResult] = &[
            CMsgDOTAFantasyPlayerScoreResponse_EResult::SUCCESS,
            CMsgDOTAFantasyPlayerScoreResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyPlayerScoreResponse_EResult::ERROR_NO_PERMISSION,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerScoreResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyPlayerScoreResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyPlayerScoreResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerScoreResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyPlayerStandingsRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    count: ::std::option::Option<u32>,
    role: ::std::option::Option<u32>,
    filter_start_time: ::std::option::Option<u32>,
    filter_end_time: ::std::option::Option<u32>,
    filter_match_id: ::std::option::Option<u64>,
    filter_last_match: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyPlayerStandingsRequest {}

impl CMsgDOTAFantasyPlayerStandingsRequest {
    pub fn new() -> CMsgDOTAFantasyPlayerStandingsRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyPlayerStandingsRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyPlayerStandingsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyPlayerStandingsRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyPlayerStandingsRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 count = 2;

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    pub fn get_count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    fn get_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.count
    }

    fn mut_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.count
    }

    // optional uint32 role = 3;

    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: u32) {
        self.role = ::std::option::Option::Some(v);
    }

    pub fn get_role(&self) -> u32 {
        self.role.unwrap_or(0)
    }

    fn get_role_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.role
    }

    fn mut_role_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.role
    }

    // optional uint32 filter_start_time = 4;

    pub fn clear_filter_start_time(&mut self) {
        self.filter_start_time = ::std::option::Option::None;
    }

    pub fn has_filter_start_time(&self) -> bool {
        self.filter_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_start_time(&mut self, v: u32) {
        self.filter_start_time = ::std::option::Option::Some(v);
    }

    pub fn get_filter_start_time(&self) -> u32 {
        self.filter_start_time.unwrap_or(0)
    }

    fn get_filter_start_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.filter_start_time
    }

    fn mut_filter_start_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.filter_start_time
    }

    // optional uint32 filter_end_time = 5;

    pub fn clear_filter_end_time(&mut self) {
        self.filter_end_time = ::std::option::Option::None;
    }

    pub fn has_filter_end_time(&self) -> bool {
        self.filter_end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_end_time(&mut self, v: u32) {
        self.filter_end_time = ::std::option::Option::Some(v);
    }

    pub fn get_filter_end_time(&self) -> u32 {
        self.filter_end_time.unwrap_or(0)
    }

    fn get_filter_end_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.filter_end_time
    }

    fn mut_filter_end_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.filter_end_time
    }

    // optional uint64 filter_match_id = 6;

    pub fn clear_filter_match_id(&mut self) {
        self.filter_match_id = ::std::option::Option::None;
    }

    pub fn has_filter_match_id(&self) -> bool {
        self.filter_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_match_id(&mut self, v: u64) {
        self.filter_match_id = ::std::option::Option::Some(v);
    }

    pub fn get_filter_match_id(&self) -> u64 {
        self.filter_match_id.unwrap_or(0)
    }

    fn get_filter_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.filter_match_id
    }

    fn mut_filter_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.filter_match_id
    }

    // optional bool filter_last_match = 7;

    pub fn clear_filter_last_match(&mut self) {
        self.filter_last_match = ::std::option::Option::None;
    }

    pub fn has_filter_last_match(&self) -> bool {
        self.filter_last_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_last_match(&mut self, v: bool) {
        self.filter_last_match = ::std::option::Option::Some(v);
    }

    pub fn get_filter_last_match(&self) -> bool {
        self.filter_last_match.unwrap_or(false)
    }

    fn get_filter_last_match_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.filter_last_match
    }

    fn mut_filter_last_match_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.filter_last_match
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerStandingsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.role = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.filter_start_time = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.filter_end_time = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.filter_match_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.filter_last_match = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.role {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filter_start_time {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filter_end_time {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filter_match_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filter_last_match {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.role {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filter_start_time {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.filter_end_time {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.filter_match_id {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.filter_last_match {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyPlayerStandingsRequest {
    fn new() -> CMsgDOTAFantasyPlayerStandingsRequest {
        CMsgDOTAFantasyPlayerStandingsRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerStandingsRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyPlayerStandingsRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyPlayerStandingsRequest::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "count",
                    CMsgDOTAFantasyPlayerStandingsRequest::get_count_for_reflect,
                    CMsgDOTAFantasyPlayerStandingsRequest::mut_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "role",
                    CMsgDOTAFantasyPlayerStandingsRequest::get_role_for_reflect,
                    CMsgDOTAFantasyPlayerStandingsRequest::mut_role_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "filter_start_time",
                    CMsgDOTAFantasyPlayerStandingsRequest::get_filter_start_time_for_reflect,
                    CMsgDOTAFantasyPlayerStandingsRequest::mut_filter_start_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "filter_end_time",
                    CMsgDOTAFantasyPlayerStandingsRequest::get_filter_end_time_for_reflect,
                    CMsgDOTAFantasyPlayerStandingsRequest::mut_filter_end_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "filter_match_id",
                    CMsgDOTAFantasyPlayerStandingsRequest::get_filter_match_id_for_reflect,
                    CMsgDOTAFantasyPlayerStandingsRequest::mut_filter_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "filter_last_match",
                    CMsgDOTAFantasyPlayerStandingsRequest::get_filter_last_match_for_reflect,
                    CMsgDOTAFantasyPlayerStandingsRequest::mut_filter_last_match_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyPlayerStandingsRequest>(
                    "CMsgDOTAFantasyPlayerStandingsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyPlayerStandingsRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_count();
        self.clear_role();
        self.clear_filter_start_time();
        self.clear_filter_end_time();
        self.clear_filter_match_id();
        self.clear_filter_last_match();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyPlayerStandingsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerStandingsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyPlayerStandingsResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyPlayerStandingsResponse_EResult>,
    fantasy_league_id: ::std::option::Option<u32>,
    role: ::std::option::Option<u32>,
    player_scores: ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyPlayerStandingsResponse {}

impl CMsgDOTAFantasyPlayerStandingsResponse {
    pub fn new() -> CMsgDOTAFantasyPlayerStandingsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyPlayerStandingsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyPlayerStandingsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyPlayerStandingsResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyPlayerStandingsResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyPlayerStandingsResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyPlayerStandingsResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyPlayerStandingsResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyPlayerStandingsResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyPlayerStandingsResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyPlayerStandingsResponse_EResult> {
        &mut self.result
    }

    // optional uint32 fantasy_league_id = 2;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 role = 3;

    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: u32) {
        self.role = ::std::option::Option::Some(v);
    }

    pub fn get_role(&self) -> u32 {
        self.role.unwrap_or(0)
    }

    fn get_role_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.role
    }

    fn mut_role_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.role
    }

    // repeated .CMsgDOTAFantasyPlayerStandingsResponse.CMsgPlayerScore player_scores = 4;

    pub fn clear_player_scores(&mut self) {
        self.player_scores.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_scores(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore>) {
        self.player_scores = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_scores(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore> {
        &mut self.player_scores
    }

    // Take field
    pub fn take_player_scores(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore> {
        ::std::mem::replace(&mut self.player_scores, ::protobuf::RepeatedField::new())
    }

    pub fn get_player_scores(&self) -> &[CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore] {
        &self.player_scores
    }

    fn get_player_scores_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore> {
        &self.player_scores
    }

    fn mut_player_scores_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore> {
        &mut self.player_scores
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerStandingsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.player_scores {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.role = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_scores)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.role {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.player_scores {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.role {
            os.write_uint32(3, v)?;
        }
        for v in &self.player_scores {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyPlayerStandingsResponse {
    fn new() -> CMsgDOTAFantasyPlayerStandingsResponse {
        CMsgDOTAFantasyPlayerStandingsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerStandingsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyPlayerStandingsResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyPlayerStandingsResponse::get_result_for_reflect,
                    CMsgDOTAFantasyPlayerStandingsResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyPlayerStandingsResponse::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyPlayerStandingsResponse::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "role",
                    CMsgDOTAFantasyPlayerStandingsResponse::get_role_for_reflect,
                    CMsgDOTAFantasyPlayerStandingsResponse::mut_role_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore>>(
                    "player_scores",
                    CMsgDOTAFantasyPlayerStandingsResponse::get_player_scores_for_reflect,
                    CMsgDOTAFantasyPlayerStandingsResponse::mut_player_scores_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyPlayerStandingsResponse>(
                    "CMsgDOTAFantasyPlayerStandingsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyPlayerStandingsResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_fantasy_league_id();
        self.clear_role();
        self.clear_player_scores();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyPlayerStandingsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerStandingsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore {
    // message fields
    player_account_id: ::std::option::Option<u32>,
    player_name: ::protobuf::SingularField<::std::string::String>,
    score: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore {}

impl CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore {
    pub fn new() -> CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::new)
        }
    }

    // optional uint32 player_account_id = 1;

    pub fn clear_player_account_id(&mut self) {
        self.player_account_id = ::std::option::Option::None;
    }

    pub fn has_player_account_id(&self) -> bool {
        self.player_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_account_id(&mut self, v: u32) {
        self.player_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_account_id(&self) -> u32 {
        self.player_account_id.unwrap_or(0)
    }

    fn get_player_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_account_id
    }

    fn mut_player_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_account_id
    }

    // optional string player_name = 2;

    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_player_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.player_name
    }

    fn mut_player_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.player_name
    }

    // optional float score = 3;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score(&self) -> f32 {
        self.score.unwrap_or(0.)
    }

    fn get_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.score
    }

    fn mut_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.score
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.score {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.player_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.score {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore {
    fn new() -> CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore {
        CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_account_id",
                    CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::get_player_account_id_for_reflect,
                    CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::mut_player_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "player_name",
                    CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::get_player_name_for_reflect,
                    CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::mut_player_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "score",
                    CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::get_score_for_reflect,
                    CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore::mut_score_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore>(
                    "CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore {
    fn clear(&mut self) {
        self.clear_player_account_id();
        self.clear_player_name();
        self.clear_score();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerStandingsResponse_CMsgPlayerScore {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyPlayerStandingsResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_NO_PERMISSION = 2,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyPlayerStandingsResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyPlayerStandingsResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyPlayerStandingsResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyPlayerStandingsResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyPlayerStandingsResponse_EResult::ERROR_NO_PERMISSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyPlayerStandingsResponse_EResult] = &[
            CMsgDOTAFantasyPlayerStandingsResponse_EResult::SUCCESS,
            CMsgDOTAFantasyPlayerStandingsResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyPlayerStandingsResponse_EResult::ERROR_NO_PERMISSION,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerStandingsResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyPlayerStandingsResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyPlayerStandingsResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerStandingsResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyPlayerInfoRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyPlayerInfoRequest {}

impl CMsgDOTAFantasyPlayerInfoRequest {
    pub fn new() -> CMsgDOTAFantasyPlayerInfoRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyPlayerInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyPlayerInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyPlayerInfoRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyPlayerInfoRequest::new)
        }
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyPlayerInfoRequest {
    fn new() -> CMsgDOTAFantasyPlayerInfoRequest {
        CMsgDOTAFantasyPlayerInfoRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerInfoRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyPlayerInfoRequest>(
                    "CMsgDOTAFantasyPlayerInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyPlayerInfoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyPlayerInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyPlayerInfoResponse {
    // message fields
    msg: ::protobuf::SingularPtrField<CMsgGCPlayerInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyPlayerInfoResponse {}

impl CMsgDOTAFantasyPlayerInfoResponse {
    pub fn new() -> CMsgDOTAFantasyPlayerInfoResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyPlayerInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyPlayerInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyPlayerInfoResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyPlayerInfoResponse::new)
        }
    }

    // optional .CMsgGCPlayerInfo msg = 1;

    pub fn clear_msg(&mut self) {
        self.msg.clear();
    }

    pub fn has_msg(&self) -> bool {
        self.msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: CMsgGCPlayerInfo) {
        self.msg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut CMsgGCPlayerInfo {
        if self.msg.is_none() {
            self.msg.set_default();
        }
        self.msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg(&mut self) -> CMsgGCPlayerInfo {
        self.msg.take().unwrap_or_else(|| CMsgGCPlayerInfo::new())
    }

    pub fn get_msg(&self) -> &CMsgGCPlayerInfo {
        self.msg.as_ref().unwrap_or_else(|| CMsgGCPlayerInfo::default_instance())
    }

    fn get_msg_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCPlayerInfo> {
        &self.msg
    }

    fn mut_msg_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCPlayerInfo> {
        &mut self.msg
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.msg {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.msg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.msg.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyPlayerInfoResponse {
    fn new() -> CMsgDOTAFantasyPlayerInfoResponse {
        CMsgDOTAFantasyPlayerInfoResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerInfoResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCPlayerInfo>>(
                    "msg",
                    CMsgDOTAFantasyPlayerInfoResponse::get_msg_for_reflect,
                    CMsgDOTAFantasyPlayerInfoResponse::mut_msg_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyPlayerInfoResponse>(
                    "CMsgDOTAFantasyPlayerInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyPlayerInfoResponse {
    fn clear(&mut self) {
        self.clear_msg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyPlayerInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueCreateRequest {
    // message fields
    season_id: ::std::option::Option<u32>,
    fantasy_league_name: ::protobuf::SingularField<::std::string::String>,
    password: ::protobuf::SingularField<::std::string::String>,
    team_name: ::protobuf::SingularField<::std::string::String>,
    logo: ::std::option::Option<u64>,
    ticket_item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueCreateRequest {}

impl CMsgDOTAFantasyLeagueCreateRequest {
    pub fn new() -> CMsgDOTAFantasyLeagueCreateRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueCreateRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueCreateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueCreateRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueCreateRequest::new)
        }
    }

    // optional uint32 season_id = 1;

    pub fn clear_season_id(&mut self) {
        self.season_id = ::std::option::Option::None;
    }

    pub fn has_season_id(&self) -> bool {
        self.season_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_season_id(&mut self, v: u32) {
        self.season_id = ::std::option::Option::Some(v);
    }

    pub fn get_season_id(&self) -> u32 {
        self.season_id.unwrap_or(0)
    }

    fn get_season_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.season_id
    }

    fn mut_season_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.season_id
    }

    // optional string fantasy_league_name = 2;

    pub fn clear_fantasy_league_name(&mut self) {
        self.fantasy_league_name.clear();
    }

    pub fn has_fantasy_league_name(&self) -> bool {
        self.fantasy_league_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_name(&mut self, v: ::std::string::String) {
        self.fantasy_league_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fantasy_league_name(&mut self) -> &mut ::std::string::String {
        if self.fantasy_league_name.is_none() {
            self.fantasy_league_name.set_default();
        }
        self.fantasy_league_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_fantasy_league_name(&mut self) -> ::std::string::String {
        self.fantasy_league_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fantasy_league_name(&self) -> &str {
        match self.fantasy_league_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fantasy_league_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fantasy_league_name
    }

    fn mut_fantasy_league_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fantasy_league_name
    }

    // optional string password = 3;

    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        if self.password.is_none() {
            self.password.set_default();
        }
        self.password.as_mut().unwrap()
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        self.password.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_password(&self) -> &str {
        match self.password.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_password_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.password
    }

    fn mut_password_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.password
    }

    // optional string team_name = 4;

    pub fn clear_team_name(&mut self) {
        self.team_name.clear();
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name.set_default();
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_name
    }

    fn mut_team_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_name
    }

    // optional uint64 logo = 5;

    pub fn clear_logo(&mut self) {
        self.logo = ::std::option::Option::None;
    }

    pub fn has_logo(&self) -> bool {
        self.logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logo(&mut self, v: u64) {
        self.logo = ::std::option::Option::Some(v);
    }

    pub fn get_logo(&self) -> u64 {
        self.logo.unwrap_or(0)
    }

    fn get_logo_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.logo
    }

    fn mut_logo_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.logo
    }

    // optional uint64 ticket_item_id = 6;

    pub fn clear_ticket_item_id(&mut self) {
        self.ticket_item_id = ::std::option::Option::None;
    }

    pub fn has_ticket_item_id(&self) -> bool {
        self.ticket_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_item_id(&mut self, v: u64) {
        self.ticket_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_ticket_item_id(&self) -> u64 {
        self.ticket_item_id.unwrap_or(0)
    }

    fn get_ticket_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.ticket_item_id
    }

    fn mut_ticket_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.ticket_item_id
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueCreateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.season_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fantasy_league_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.password)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_name)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.logo = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ticket_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.season_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fantasy_league_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.password.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.logo {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ticket_item_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.season_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.fantasy_league_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.password.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.team_name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.logo {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.ticket_item_id {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueCreateRequest {
    fn new() -> CMsgDOTAFantasyLeagueCreateRequest {
        CMsgDOTAFantasyLeagueCreateRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueCreateRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "season_id",
                    CMsgDOTAFantasyLeagueCreateRequest::get_season_id_for_reflect,
                    CMsgDOTAFantasyLeagueCreateRequest::mut_season_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fantasy_league_name",
                    CMsgDOTAFantasyLeagueCreateRequest::get_fantasy_league_name_for_reflect,
                    CMsgDOTAFantasyLeagueCreateRequest::mut_fantasy_league_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    CMsgDOTAFantasyLeagueCreateRequest::get_password_for_reflect,
                    CMsgDOTAFantasyLeagueCreateRequest::mut_password_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_name",
                    CMsgDOTAFantasyLeagueCreateRequest::get_team_name_for_reflect,
                    CMsgDOTAFantasyLeagueCreateRequest::mut_team_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "logo",
                    CMsgDOTAFantasyLeagueCreateRequest::get_logo_for_reflect,
                    CMsgDOTAFantasyLeagueCreateRequest::mut_logo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ticket_item_id",
                    CMsgDOTAFantasyLeagueCreateRequest::get_ticket_item_id_for_reflect,
                    CMsgDOTAFantasyLeagueCreateRequest::mut_ticket_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueCreateRequest>(
                    "CMsgDOTAFantasyLeagueCreateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueCreateRequest {
    fn clear(&mut self) {
        self.clear_season_id();
        self.clear_fantasy_league_name();
        self.clear_password();
        self.clear_team_name();
        self.clear_logo();
        self.clear_ticket_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueCreateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueCreateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueCreateResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyLeagueCreateResponse_EResult>,
    fantasy_league_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueCreateResponse {}

impl CMsgDOTAFantasyLeagueCreateResponse {
    pub fn new() -> CMsgDOTAFantasyLeagueCreateResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueCreateResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueCreateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueCreateResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueCreateResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyLeagueCreateResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyLeagueCreateResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyLeagueCreateResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyLeagueCreateResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyLeagueCreateResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyLeagueCreateResponse_EResult> {
        &mut self.result
    }

    // optional uint32 fantasy_league_id = 2;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueCreateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueCreateResponse {
    fn new() -> CMsgDOTAFantasyLeagueCreateResponse {
        CMsgDOTAFantasyLeagueCreateResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueCreateResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyLeagueCreateResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyLeagueCreateResponse::get_result_for_reflect,
                    CMsgDOTAFantasyLeagueCreateResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyLeagueCreateResponse::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyLeagueCreateResponse::mut_fantasy_league_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueCreateResponse>(
                    "CMsgDOTAFantasyLeagueCreateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueCreateResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_fantasy_league_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueCreateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueCreateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyLeagueCreateResponse_EResult {
    SUCCESS = 0,
    ERROR_NO_PERMISSION = 1,
    ERROR_BAD_SEASON_ID = 2,
    ERROR_BAD_LEAGUE_NAME = 3,
    ERROR_BAD_TEAM_NAME = 4,
    ERROR_UNSPECIFIED = 5,
    ERROR_FAILED_LOGO_UPLOAD = 6,
    ERROR_NO_TICKET = 7,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyLeagueCreateResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyLeagueCreateResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueCreateResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueCreateResponse_EResult::ERROR_NO_PERMISSION),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueCreateResponse_EResult::ERROR_BAD_SEASON_ID),
            3 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueCreateResponse_EResult::ERROR_BAD_LEAGUE_NAME),
            4 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueCreateResponse_EResult::ERROR_BAD_TEAM_NAME),
            5 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueCreateResponse_EResult::ERROR_UNSPECIFIED),
            6 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueCreateResponse_EResult::ERROR_FAILED_LOGO_UPLOAD),
            7 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueCreateResponse_EResult::ERROR_NO_TICKET),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyLeagueCreateResponse_EResult] = &[
            CMsgDOTAFantasyLeagueCreateResponse_EResult::SUCCESS,
            CMsgDOTAFantasyLeagueCreateResponse_EResult::ERROR_NO_PERMISSION,
            CMsgDOTAFantasyLeagueCreateResponse_EResult::ERROR_BAD_SEASON_ID,
            CMsgDOTAFantasyLeagueCreateResponse_EResult::ERROR_BAD_LEAGUE_NAME,
            CMsgDOTAFantasyLeagueCreateResponse_EResult::ERROR_BAD_TEAM_NAME,
            CMsgDOTAFantasyLeagueCreateResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyLeagueCreateResponse_EResult::ERROR_FAILED_LOGO_UPLOAD,
            CMsgDOTAFantasyLeagueCreateResponse_EResult::ERROR_NO_TICKET,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueCreateResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyLeagueCreateResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyLeagueCreateResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueCreateResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamCreateRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    password: ::protobuf::SingularField<::std::string::String>,
    team_name: ::protobuf::SingularField<::std::string::String>,
    logo: ::std::option::Option<u64>,
    ticket_item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamCreateRequest {}

impl CMsgDOTAFantasyTeamCreateRequest {
    pub fn new() -> CMsgDOTAFantasyTeamCreateRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamCreateRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamCreateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamCreateRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamCreateRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional string password = 2;

    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        if self.password.is_none() {
            self.password.set_default();
        }
        self.password.as_mut().unwrap()
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        self.password.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_password(&self) -> &str {
        match self.password.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_password_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.password
    }

    fn mut_password_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.password
    }

    // optional string team_name = 3;

    pub fn clear_team_name(&mut self) {
        self.team_name.clear();
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name.set_default();
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_name
    }

    fn mut_team_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_name
    }

    // optional uint64 logo = 4;

    pub fn clear_logo(&mut self) {
        self.logo = ::std::option::Option::None;
    }

    pub fn has_logo(&self) -> bool {
        self.logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logo(&mut self, v: u64) {
        self.logo = ::std::option::Option::Some(v);
    }

    pub fn get_logo(&self) -> u64 {
        self.logo.unwrap_or(0)
    }

    fn get_logo_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.logo
    }

    fn mut_logo_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.logo
    }

    // optional uint64 ticket_item_id = 5;

    pub fn clear_ticket_item_id(&mut self) {
        self.ticket_item_id = ::std::option::Option::None;
    }

    pub fn has_ticket_item_id(&self) -> bool {
        self.ticket_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_item_id(&mut self, v: u64) {
        self.ticket_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_ticket_item_id(&self) -> u64 {
        self.ticket_item_id.unwrap_or(0)
    }

    fn get_ticket_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.ticket_item_id
    }

    fn mut_ticket_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.ticket_item_id
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamCreateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.password)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.logo = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ticket_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.password.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.logo {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ticket_item_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.password.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.team_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.logo {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.ticket_item_id {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamCreateRequest {
    fn new() -> CMsgDOTAFantasyTeamCreateRequest {
        CMsgDOTAFantasyTeamCreateRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamCreateRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyTeamCreateRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyTeamCreateRequest::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    CMsgDOTAFantasyTeamCreateRequest::get_password_for_reflect,
                    CMsgDOTAFantasyTeamCreateRequest::mut_password_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_name",
                    CMsgDOTAFantasyTeamCreateRequest::get_team_name_for_reflect,
                    CMsgDOTAFantasyTeamCreateRequest::mut_team_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "logo",
                    CMsgDOTAFantasyTeamCreateRequest::get_logo_for_reflect,
                    CMsgDOTAFantasyTeamCreateRequest::mut_logo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ticket_item_id",
                    CMsgDOTAFantasyTeamCreateRequest::get_ticket_item_id_for_reflect,
                    CMsgDOTAFantasyTeamCreateRequest::mut_ticket_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamCreateRequest>(
                    "CMsgDOTAFantasyTeamCreateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamCreateRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_password();
        self.clear_team_name();
        self.clear_logo();
        self.clear_ticket_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamCreateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamCreateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamCreateResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyTeamCreateResponse_EResult>,
    fantasy_team_index: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamCreateResponse {}

impl CMsgDOTAFantasyTeamCreateResponse {
    pub fn new() -> CMsgDOTAFantasyTeamCreateResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamCreateResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamCreateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamCreateResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamCreateResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyTeamCreateResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyTeamCreateResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyTeamCreateResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyTeamCreateResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyTeamCreateResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyTeamCreateResponse_EResult> {
        &mut self.result
    }

    // optional uint32 fantasy_team_index = 2;

    pub fn clear_fantasy_team_index(&mut self) {
        self.fantasy_team_index = ::std::option::Option::None;
    }

    pub fn has_fantasy_team_index(&self) -> bool {
        self.fantasy_team_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_team_index(&mut self, v: u32) {
        self.fantasy_team_index = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_team_index(&self) -> u32 {
        self.fantasy_team_index.unwrap_or(0)
    }

    fn get_fantasy_team_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_team_index
    }

    fn mut_fantasy_team_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_team_index
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamCreateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_team_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.fantasy_team_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.fantasy_team_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamCreateResponse {
    fn new() -> CMsgDOTAFantasyTeamCreateResponse {
        CMsgDOTAFantasyTeamCreateResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamCreateResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyTeamCreateResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyTeamCreateResponse::get_result_for_reflect,
                    CMsgDOTAFantasyTeamCreateResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_team_index",
                    CMsgDOTAFantasyTeamCreateResponse::get_fantasy_team_index_for_reflect,
                    CMsgDOTAFantasyTeamCreateResponse::mut_fantasy_team_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamCreateResponse>(
                    "CMsgDOTAFantasyTeamCreateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamCreateResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_fantasy_team_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamCreateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamCreateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyTeamCreateResponse_EResult {
    SUCCESS = 0,
    ERROR_NO_PERMISSION = 1,
    ERROR_FAILED_LOGO_UPLOAD = 2,
    ERROR_BAD_FANTASY_LEAGUE_ID = 3,
    ERROR_BAD_NAME = 4,
    ERROR_FULL = 5,
    ERROR_ALREADY_MEMBER = 6,
    ERROR_BAD_PASSWORD = 7,
    ERROR_UNSPECIFIED = 8,
    ERROR_NO_TICKET = 9,
    ERROR_LEAGUE_LOCKED = 10,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyTeamCreateResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyTeamCreateResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyTeamCreateResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_NO_PERMISSION),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_FAILED_LOGO_UPLOAD),
            3 => ::std::option::Option::Some(CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_BAD_FANTASY_LEAGUE_ID),
            4 => ::std::option::Option::Some(CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_BAD_NAME),
            5 => ::std::option::Option::Some(CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_FULL),
            6 => ::std::option::Option::Some(CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_ALREADY_MEMBER),
            7 => ::std::option::Option::Some(CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_BAD_PASSWORD),
            8 => ::std::option::Option::Some(CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_UNSPECIFIED),
            9 => ::std::option::Option::Some(CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_NO_TICKET),
            10 => ::std::option::Option::Some(CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_LEAGUE_LOCKED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyTeamCreateResponse_EResult] = &[
            CMsgDOTAFantasyTeamCreateResponse_EResult::SUCCESS,
            CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_NO_PERMISSION,
            CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_FAILED_LOGO_UPLOAD,
            CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_BAD_FANTASY_LEAGUE_ID,
            CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_BAD_NAME,
            CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_FULL,
            CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_ALREADY_MEMBER,
            CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_BAD_PASSWORD,
            CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_NO_TICKET,
            CMsgDOTAFantasyTeamCreateResponse_EResult::ERROR_LEAGUE_LOCKED,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamCreateResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyTeamCreateResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyTeamCreateResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamCreateResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueEditInvitesRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    password: ::protobuf::SingularField<::std::string::String>,
    invite_change: ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueEditInvitesRequest {}

impl CMsgDOTAFantasyLeagueEditInvitesRequest {
    pub fn new() -> CMsgDOTAFantasyLeagueEditInvitesRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueEditInvitesRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueEditInvitesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueEditInvitesRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueEditInvitesRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional string password = 2;

    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        if self.password.is_none() {
            self.password.set_default();
        }
        self.password.as_mut().unwrap()
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        self.password.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_password(&self) -> &str {
        match self.password.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_password_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.password
    }

    fn mut_password_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.password
    }

    // repeated .CMsgDOTAFantasyLeagueEditInvitesRequest.InviteChange invite_change = 3;

    pub fn clear_invite_change(&mut self) {
        self.invite_change.clear();
    }

    // Param is passed by value, moved
    pub fn set_invite_change(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange>) {
        self.invite_change = v;
    }

    // Mutable pointer to the field.
    pub fn mut_invite_change(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange> {
        &mut self.invite_change
    }

    // Take field
    pub fn take_invite_change(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange> {
        ::std::mem::replace(&mut self.invite_change, ::protobuf::RepeatedField::new())
    }

    pub fn get_invite_change(&self) -> &[CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange] {
        &self.invite_change
    }

    fn get_invite_change_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange> {
        &self.invite_change
    }

    fn mut_invite_change_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange> {
        &mut self.invite_change
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueEditInvitesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.invite_change {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.password)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.invite_change)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.password.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.invite_change {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.password.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.invite_change {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueEditInvitesRequest {
    fn new() -> CMsgDOTAFantasyLeagueEditInvitesRequest {
        CMsgDOTAFantasyLeagueEditInvitesRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueEditInvitesRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyLeagueEditInvitesRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyLeagueEditInvitesRequest::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    CMsgDOTAFantasyLeagueEditInvitesRequest::get_password_for_reflect,
                    CMsgDOTAFantasyLeagueEditInvitesRequest::mut_password_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange>>(
                    "invite_change",
                    CMsgDOTAFantasyLeagueEditInvitesRequest::get_invite_change_for_reflect,
                    CMsgDOTAFantasyLeagueEditInvitesRequest::mut_invite_change_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueEditInvitesRequest>(
                    "CMsgDOTAFantasyLeagueEditInvitesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueEditInvitesRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_password();
        self.clear_invite_change();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueEditInvitesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueEditInvitesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange {
    // message fields
    account_id: ::std::option::Option<u32>,
    invited: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange {}

impl CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange {
    pub fn new() -> CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional bool invited = 2;

    pub fn clear_invited(&mut self) {
        self.invited = ::std::option::Option::None;
    }

    pub fn has_invited(&self) -> bool {
        self.invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invited(&mut self, v: bool) {
        self.invited = ::std::option::Option::Some(v);
    }

    pub fn get_invited(&self) -> bool {
        self.invited.unwrap_or(false)
    }

    fn get_invited_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.invited
    }

    fn mut_invited_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.invited
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.invited = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.invited {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.invited {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange {
    fn new() -> CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange {
        CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::get_account_id_for_reflect,
                    CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "invited",
                    CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::get_invited_for_reflect,
                    CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange::mut_invited_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange>(
                    "CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_invited();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueEditInvitesRequest_InviteChange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueEditInvitesResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyLeagueEditInvitesResponse_EResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueEditInvitesResponse {}

impl CMsgDOTAFantasyLeagueEditInvitesResponse {
    pub fn new() -> CMsgDOTAFantasyLeagueEditInvitesResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueEditInvitesResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueEditInvitesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueEditInvitesResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueEditInvitesResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyLeagueEditInvitesResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyLeagueEditInvitesResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyLeagueEditInvitesResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyLeagueEditInvitesResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyLeagueEditInvitesResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyLeagueEditInvitesResponse_EResult> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueEditInvitesResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueEditInvitesResponse {
    fn new() -> CMsgDOTAFantasyLeagueEditInvitesResponse {
        CMsgDOTAFantasyLeagueEditInvitesResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueEditInvitesResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyLeagueEditInvitesResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyLeagueEditInvitesResponse::get_result_for_reflect,
                    CMsgDOTAFantasyLeagueEditInvitesResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueEditInvitesResponse>(
                    "CMsgDOTAFantasyLeagueEditInvitesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueEditInvitesResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueEditInvitesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueEditInvitesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyLeagueEditInvitesResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyLeagueEditInvitesResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyLeagueEditInvitesResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueEditInvitesResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueEditInvitesResponse_EResult::ERROR_UNSPECIFIED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyLeagueEditInvitesResponse_EResult] = &[
            CMsgDOTAFantasyLeagueEditInvitesResponse_EResult::SUCCESS,
            CMsgDOTAFantasyLeagueEditInvitesResponse_EResult::ERROR_UNSPECIFIED,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueEditInvitesResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyLeagueEditInvitesResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyLeagueEditInvitesResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueEditInvitesResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueDraftStatusRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueDraftStatusRequest {}

impl CMsgDOTAFantasyLeagueDraftStatusRequest {
    pub fn new() -> CMsgDOTAFantasyLeagueDraftStatusRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueDraftStatusRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueDraftStatusRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueDraftStatusRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueDraftStatusRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueDraftStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueDraftStatusRequest {
    fn new() -> CMsgDOTAFantasyLeagueDraftStatusRequest {
        CMsgDOTAFantasyLeagueDraftStatusRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueDraftStatusRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyLeagueDraftStatusRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyLeagueDraftStatusRequest::mut_fantasy_league_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueDraftStatusRequest>(
                    "CMsgDOTAFantasyLeagueDraftStatusRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueDraftStatusRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueDraftStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueDraftStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueDraftStatus {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    draft_order: ::std::vec::Vec<u32>,
    current_pick: ::std::option::Option<u32>,
    time_remaining: ::std::option::Option<u32>,
    pending_resume: ::std::option::Option<bool>,
    completed: ::std::option::Option<bool>,
    available_players: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueDraftStatus {}

impl CMsgDOTAFantasyLeagueDraftStatus {
    pub fn new() -> CMsgDOTAFantasyLeagueDraftStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueDraftStatus {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueDraftStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueDraftStatus,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueDraftStatus::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // repeated uint32 draft_order = 2;

    pub fn clear_draft_order(&mut self) {
        self.draft_order.clear();
    }

    // Param is passed by value, moved
    pub fn set_draft_order(&mut self, v: ::std::vec::Vec<u32>) {
        self.draft_order = v;
    }

    // Mutable pointer to the field.
    pub fn mut_draft_order(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.draft_order
    }

    // Take field
    pub fn take_draft_order(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.draft_order, ::std::vec::Vec::new())
    }

    pub fn get_draft_order(&self) -> &[u32] {
        &self.draft_order
    }

    fn get_draft_order_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.draft_order
    }

    fn mut_draft_order_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.draft_order
    }

    // optional uint32 current_pick = 3;

    pub fn clear_current_pick(&mut self) {
        self.current_pick = ::std::option::Option::None;
    }

    pub fn has_current_pick(&self) -> bool {
        self.current_pick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_pick(&mut self, v: u32) {
        self.current_pick = ::std::option::Option::Some(v);
    }

    pub fn get_current_pick(&self) -> u32 {
        self.current_pick.unwrap_or(0)
    }

    fn get_current_pick_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.current_pick
    }

    fn mut_current_pick_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.current_pick
    }

    // optional uint32 time_remaining = 4;

    pub fn clear_time_remaining(&mut self) {
        self.time_remaining = ::std::option::Option::None;
    }

    pub fn has_time_remaining(&self) -> bool {
        self.time_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_remaining(&mut self, v: u32) {
        self.time_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_time_remaining(&self) -> u32 {
        self.time_remaining.unwrap_or(0)
    }

    fn get_time_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time_remaining
    }

    fn mut_time_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time_remaining
    }

    // optional bool pending_resume = 5;

    pub fn clear_pending_resume(&mut self) {
        self.pending_resume = ::std::option::Option::None;
    }

    pub fn has_pending_resume(&self) -> bool {
        self.pending_resume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_resume(&mut self, v: bool) {
        self.pending_resume = ::std::option::Option::Some(v);
    }

    pub fn get_pending_resume(&self) -> bool {
        self.pending_resume.unwrap_or(false)
    }

    fn get_pending_resume_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.pending_resume
    }

    fn mut_pending_resume_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.pending_resume
    }

    // optional bool completed = 6;

    pub fn clear_completed(&mut self) {
        self.completed = ::std::option::Option::None;
    }

    pub fn has_completed(&self) -> bool {
        self.completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed(&mut self, v: bool) {
        self.completed = ::std::option::Option::Some(v);
    }

    pub fn get_completed(&self) -> bool {
        self.completed.unwrap_or(false)
    }

    fn get_completed_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.completed
    }

    fn mut_completed_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.completed
    }

    // repeated uint32 available_players = 7;

    pub fn clear_available_players(&mut self) {
        self.available_players.clear();
    }

    // Param is passed by value, moved
    pub fn set_available_players(&mut self, v: ::std::vec::Vec<u32>) {
        self.available_players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_available_players(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.available_players
    }

    // Take field
    pub fn take_available_players(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.available_players, ::std::vec::Vec::new())
    }

    pub fn get_available_players(&self) -> &[u32] {
        &self.available_players
    }

    fn get_available_players_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.available_players
    }

    fn mut_available_players_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.available_players
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueDraftStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.draft_order)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.current_pick = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_remaining = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pending_resume = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.completed = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.available_players)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.draft_order {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.current_pick {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_remaining {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pending_resume {
            my_size += 2;
        }
        if let Some(v) = self.completed {
            my_size += 2;
        }
        for value in &self.available_players {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.draft_order {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.current_pick {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.time_remaining {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.pending_resume {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.completed {
            os.write_bool(6, v)?;
        }
        for v in &self.available_players {
            os.write_uint32(7, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueDraftStatus {
    fn new() -> CMsgDOTAFantasyLeagueDraftStatus {
        CMsgDOTAFantasyLeagueDraftStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueDraftStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyLeagueDraftStatus::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyLeagueDraftStatus::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "draft_order",
                    CMsgDOTAFantasyLeagueDraftStatus::get_draft_order_for_reflect,
                    CMsgDOTAFantasyLeagueDraftStatus::mut_draft_order_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "current_pick",
                    CMsgDOTAFantasyLeagueDraftStatus::get_current_pick_for_reflect,
                    CMsgDOTAFantasyLeagueDraftStatus::mut_current_pick_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_remaining",
                    CMsgDOTAFantasyLeagueDraftStatus::get_time_remaining_for_reflect,
                    CMsgDOTAFantasyLeagueDraftStatus::mut_time_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pending_resume",
                    CMsgDOTAFantasyLeagueDraftStatus::get_pending_resume_for_reflect,
                    CMsgDOTAFantasyLeagueDraftStatus::mut_pending_resume_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "completed",
                    CMsgDOTAFantasyLeagueDraftStatus::get_completed_for_reflect,
                    CMsgDOTAFantasyLeagueDraftStatus::mut_completed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "available_players",
                    CMsgDOTAFantasyLeagueDraftStatus::get_available_players_for_reflect,
                    CMsgDOTAFantasyLeagueDraftStatus::mut_available_players_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueDraftStatus>(
                    "CMsgDOTAFantasyLeagueDraftStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueDraftStatus {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_draft_order();
        self.clear_current_pick();
        self.clear_time_remaining();
        self.clear_pending_resume();
        self.clear_completed();
        self.clear_available_players();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueDraftStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueDraftStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueDraftPlayerRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    team_index: ::std::option::Option<u32>,
    player_account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueDraftPlayerRequest {}

impl CMsgDOTAFantasyLeagueDraftPlayerRequest {
    pub fn new() -> CMsgDOTAFantasyLeagueDraftPlayerRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueDraftPlayerRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueDraftPlayerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueDraftPlayerRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueDraftPlayerRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 team_index = 2;

    pub fn clear_team_index(&mut self) {
        self.team_index = ::std::option::Option::None;
    }

    pub fn has_team_index(&self) -> bool {
        self.team_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_index(&mut self, v: u32) {
        self.team_index = ::std::option::Option::Some(v);
    }

    pub fn get_team_index(&self) -> u32 {
        self.team_index.unwrap_or(0)
    }

    fn get_team_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_index
    }

    fn mut_team_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_index
    }

    // optional uint32 player_account_id = 3;

    pub fn clear_player_account_id(&mut self) {
        self.player_account_id = ::std::option::Option::None;
    }

    pub fn has_player_account_id(&self) -> bool {
        self.player_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_account_id(&mut self, v: u32) {
        self.player_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_account_id(&self) -> u32 {
        self.player_account_id.unwrap_or(0)
    }

    fn get_player_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_account_id
    }

    fn mut_player_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_account_id
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueDraftPlayerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_account_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.team_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.player_account_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueDraftPlayerRequest {
    fn new() -> CMsgDOTAFantasyLeagueDraftPlayerRequest {
        CMsgDOTAFantasyLeagueDraftPlayerRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueDraftPlayerRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyLeagueDraftPlayerRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyLeagueDraftPlayerRequest::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_index",
                    CMsgDOTAFantasyLeagueDraftPlayerRequest::get_team_index_for_reflect,
                    CMsgDOTAFantasyLeagueDraftPlayerRequest::mut_team_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_account_id",
                    CMsgDOTAFantasyLeagueDraftPlayerRequest::get_player_account_id_for_reflect,
                    CMsgDOTAFantasyLeagueDraftPlayerRequest::mut_player_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueDraftPlayerRequest>(
                    "CMsgDOTAFantasyLeagueDraftPlayerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueDraftPlayerRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_team_index();
        self.clear_player_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueDraftPlayerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueDraftPlayerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeagueDraftPlayerResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeagueDraftPlayerResponse {}

impl CMsgDOTAFantasyLeagueDraftPlayerResponse {
    pub fn new() -> CMsgDOTAFantasyLeagueDraftPlayerResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeagueDraftPlayerResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeagueDraftPlayerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeagueDraftPlayerResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeagueDraftPlayerResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyLeagueDraftPlayerResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeagueDraftPlayerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeagueDraftPlayerResponse {
    fn new() -> CMsgDOTAFantasyLeagueDraftPlayerResponse {
        CMsgDOTAFantasyLeagueDraftPlayerResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueDraftPlayerResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyLeagueDraftPlayerResponse::get_result_for_reflect,
                    CMsgDOTAFantasyLeagueDraftPlayerResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeagueDraftPlayerResponse>(
                    "CMsgDOTAFantasyLeagueDraftPlayerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeagueDraftPlayerResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeagueDraftPlayerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueDraftPlayerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_INVALID_FANTASY_LEAGUE = 2,
    ERROR_FANTASY_LEAGUE_NOT_DRAFTING = 3,
    ERROR_OWNER_NOT_IN_LEAGUE = 4,
    ERROR_NOT_OWNERS_TURN = 5,
    ERROR_PLAYER_INVALID = 6,
    ERROR_PLAYER_UNAVAILABLE = 7,
    ERROR_PLAYER_NO_VALID_SLOTS = 8,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::ERROR_INVALID_FANTASY_LEAGUE),
            3 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::ERROR_FANTASY_LEAGUE_NOT_DRAFTING),
            4 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::ERROR_OWNER_NOT_IN_LEAGUE),
            5 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::ERROR_NOT_OWNERS_TURN),
            6 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::ERROR_PLAYER_INVALID),
            7 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::ERROR_PLAYER_UNAVAILABLE),
            8 => ::std::option::Option::Some(CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::ERROR_PLAYER_NO_VALID_SLOTS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult] = &[
            CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::SUCCESS,
            CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::ERROR_INVALID_FANTASY_LEAGUE,
            CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::ERROR_FANTASY_LEAGUE_NOT_DRAFTING,
            CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::ERROR_OWNER_NOT_IN_LEAGUE,
            CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::ERROR_NOT_OWNERS_TURN,
            CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::ERROR_PLAYER_INVALID,
            CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::ERROR_PLAYER_UNAVAILABLE,
            CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult::ERROR_PLAYER_NO_VALID_SLOTS,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeagueDraftPlayerResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamRosterSwapRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    team_index: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    slot_1: ::std::option::Option<u32>,
    slot_2: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamRosterSwapRequest {}

impl CMsgDOTAFantasyTeamRosterSwapRequest {
    pub fn new() -> CMsgDOTAFantasyTeamRosterSwapRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamRosterSwapRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamRosterSwapRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamRosterSwapRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamRosterSwapRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 team_index = 2;

    pub fn clear_team_index(&mut self) {
        self.team_index = ::std::option::Option::None;
    }

    pub fn has_team_index(&self) -> bool {
        self.team_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_index(&mut self, v: u32) {
        self.team_index = ::std::option::Option::Some(v);
    }

    pub fn get_team_index(&self) -> u32 {
        self.team_index.unwrap_or(0)
    }

    fn get_team_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_index
    }

    fn mut_team_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_index
    }

    // optional uint32 timestamp = 3;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional uint32 slot_1 = 4;

    pub fn clear_slot_1(&mut self) {
        self.slot_1 = ::std::option::Option::None;
    }

    pub fn has_slot_1(&self) -> bool {
        self.slot_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_1(&mut self, v: u32) {
        self.slot_1 = ::std::option::Option::Some(v);
    }

    pub fn get_slot_1(&self) -> u32 {
        self.slot_1.unwrap_or(0)
    }

    fn get_slot_1_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_1
    }

    fn mut_slot_1_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_1
    }

    // optional uint32 slot_2 = 5;

    pub fn clear_slot_2(&mut self) {
        self.slot_2 = ::std::option::Option::None;
    }

    pub fn has_slot_2(&self) -> bool {
        self.slot_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_2(&mut self, v: u32) {
        self.slot_2 = ::std::option::Option::Some(v);
    }

    pub fn get_slot_2(&self) -> u32 {
        self.slot_2.unwrap_or(0)
    }

    fn get_slot_2_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_2
    }

    fn mut_slot_2_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_2
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamRosterSwapRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_1 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_2 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_1 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_2 {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.team_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.slot_1 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.slot_2 {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamRosterSwapRequest {
    fn new() -> CMsgDOTAFantasyTeamRosterSwapRequest {
        CMsgDOTAFantasyTeamRosterSwapRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamRosterSwapRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyTeamRosterSwapRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyTeamRosterSwapRequest::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_index",
                    CMsgDOTAFantasyTeamRosterSwapRequest::get_team_index_for_reflect,
                    CMsgDOTAFantasyTeamRosterSwapRequest::mut_team_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgDOTAFantasyTeamRosterSwapRequest::get_timestamp_for_reflect,
                    CMsgDOTAFantasyTeamRosterSwapRequest::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_1",
                    CMsgDOTAFantasyTeamRosterSwapRequest::get_slot_1_for_reflect,
                    CMsgDOTAFantasyTeamRosterSwapRequest::mut_slot_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_2",
                    CMsgDOTAFantasyTeamRosterSwapRequest::get_slot_2_for_reflect,
                    CMsgDOTAFantasyTeamRosterSwapRequest::mut_slot_2_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamRosterSwapRequest>(
                    "CMsgDOTAFantasyTeamRosterSwapRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamRosterSwapRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_team_index();
        self.clear_timestamp();
        self.clear_slot_1();
        self.clear_slot_2();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamRosterSwapRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamRosterSwapRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamRosterSwapResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyTeamRosterSwapResponse_EResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamRosterSwapResponse {}

impl CMsgDOTAFantasyTeamRosterSwapResponse {
    pub fn new() -> CMsgDOTAFantasyTeamRosterSwapResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamRosterSwapResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamRosterSwapResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamRosterSwapResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamRosterSwapResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyTeamRosterSwapResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyTeamRosterSwapResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyTeamRosterSwapResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyTeamRosterSwapResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyTeamRosterSwapResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyTeamRosterSwapResponse_EResult> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamRosterSwapResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamRosterSwapResponse {
    fn new() -> CMsgDOTAFantasyTeamRosterSwapResponse {
        CMsgDOTAFantasyTeamRosterSwapResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamRosterSwapResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyTeamRosterSwapResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyTeamRosterSwapResponse::get_result_for_reflect,
                    CMsgDOTAFantasyTeamRosterSwapResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamRosterSwapResponse>(
                    "CMsgDOTAFantasyTeamRosterSwapResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamRosterSwapResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamRosterSwapResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamRosterSwapResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyTeamRosterSwapResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_OWNER_NOT_IN_LEAGUE = 2,
    ERROR_SLOTS_INVALID = 3,
    ERROR_SLOT_LOCKED = 4,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyTeamRosterSwapResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyTeamRosterSwapResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyTeamRosterSwapResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyTeamRosterSwapResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyTeamRosterSwapResponse_EResult::ERROR_OWNER_NOT_IN_LEAGUE),
            3 => ::std::option::Option::Some(CMsgDOTAFantasyTeamRosterSwapResponse_EResult::ERROR_SLOTS_INVALID),
            4 => ::std::option::Option::Some(CMsgDOTAFantasyTeamRosterSwapResponse_EResult::ERROR_SLOT_LOCKED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyTeamRosterSwapResponse_EResult] = &[
            CMsgDOTAFantasyTeamRosterSwapResponse_EResult::SUCCESS,
            CMsgDOTAFantasyTeamRosterSwapResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyTeamRosterSwapResponse_EResult::ERROR_OWNER_NOT_IN_LEAGUE,
            CMsgDOTAFantasyTeamRosterSwapResponse_EResult::ERROR_SLOTS_INVALID,
            CMsgDOTAFantasyTeamRosterSwapResponse_EResult::ERROR_SLOT_LOCKED,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamRosterSwapResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyTeamRosterSwapResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyTeamRosterSwapResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamRosterSwapResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamRosterAddDropRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    team_index: ::std::option::Option<u32>,
    add_account_id: ::std::option::Option<u32>,
    drop_account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamRosterAddDropRequest {}

impl CMsgDOTAFantasyTeamRosterAddDropRequest {
    pub fn new() -> CMsgDOTAFantasyTeamRosterAddDropRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamRosterAddDropRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamRosterAddDropRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamRosterAddDropRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamRosterAddDropRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 team_index = 2;

    pub fn clear_team_index(&mut self) {
        self.team_index = ::std::option::Option::None;
    }

    pub fn has_team_index(&self) -> bool {
        self.team_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_index(&mut self, v: u32) {
        self.team_index = ::std::option::Option::Some(v);
    }

    pub fn get_team_index(&self) -> u32 {
        self.team_index.unwrap_or(0)
    }

    fn get_team_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_index
    }

    fn mut_team_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_index
    }

    // optional uint32 add_account_id = 5;

    pub fn clear_add_account_id(&mut self) {
        self.add_account_id = ::std::option::Option::None;
    }

    pub fn has_add_account_id(&self) -> bool {
        self.add_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_account_id(&mut self, v: u32) {
        self.add_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_add_account_id(&self) -> u32 {
        self.add_account_id.unwrap_or(0)
    }

    fn get_add_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.add_account_id
    }

    fn mut_add_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.add_account_id
    }

    // optional uint32 drop_account_id = 6;

    pub fn clear_drop_account_id(&mut self) {
        self.drop_account_id = ::std::option::Option::None;
    }

    pub fn has_drop_account_id(&self) -> bool {
        self.drop_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drop_account_id(&mut self, v: u32) {
        self.drop_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_drop_account_id(&self) -> u32 {
        self.drop_account_id.unwrap_or(0)
    }

    fn get_drop_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.drop_account_id
    }

    fn mut_drop_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.drop_account_id
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamRosterAddDropRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_index = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.add_account_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.drop_account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.add_account_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.drop_account_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.team_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.add_account_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.drop_account_id {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamRosterAddDropRequest {
    fn new() -> CMsgDOTAFantasyTeamRosterAddDropRequest {
        CMsgDOTAFantasyTeamRosterAddDropRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamRosterAddDropRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyTeamRosterAddDropRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyTeamRosterAddDropRequest::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_index",
                    CMsgDOTAFantasyTeamRosterAddDropRequest::get_team_index_for_reflect,
                    CMsgDOTAFantasyTeamRosterAddDropRequest::mut_team_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "add_account_id",
                    CMsgDOTAFantasyTeamRosterAddDropRequest::get_add_account_id_for_reflect,
                    CMsgDOTAFantasyTeamRosterAddDropRequest::mut_add_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "drop_account_id",
                    CMsgDOTAFantasyTeamRosterAddDropRequest::get_drop_account_id_for_reflect,
                    CMsgDOTAFantasyTeamRosterAddDropRequest::mut_drop_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamRosterAddDropRequest>(
                    "CMsgDOTAFantasyTeamRosterAddDropRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamRosterAddDropRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_team_index();
        self.clear_add_account_id();
        self.clear_drop_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamRosterAddDropRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamRosterAddDropRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamRosterAddDropResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyTeamRosterAddDropResponse_EResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamRosterAddDropResponse {}

impl CMsgDOTAFantasyTeamRosterAddDropResponse {
    pub fn new() -> CMsgDOTAFantasyTeamRosterAddDropResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamRosterAddDropResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamRosterAddDropResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamRosterAddDropResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamRosterAddDropResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyTeamRosterAddDropResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyTeamRosterAddDropResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyTeamRosterAddDropResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyTeamRosterAddDropResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyTeamRosterAddDropResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyTeamRosterAddDropResponse_EResult> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamRosterAddDropResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamRosterAddDropResponse {
    fn new() -> CMsgDOTAFantasyTeamRosterAddDropResponse {
        CMsgDOTAFantasyTeamRosterAddDropResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamRosterAddDropResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyTeamRosterAddDropResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyTeamRosterAddDropResponse::get_result_for_reflect,
                    CMsgDOTAFantasyTeamRosterAddDropResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamRosterAddDropResponse>(
                    "CMsgDOTAFantasyTeamRosterAddDropResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamRosterAddDropResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamRosterAddDropResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamRosterAddDropResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyTeamRosterAddDropResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_OWNER_NOT_IN_LEAGUE = 2,
    ERROR_PLAYER_NOT_AVAILABLE = 3,
    ERROR_PLAYER_NOT_ON_TEAM = 4,
    ERROR_TRADE_ALREADY_PENDING = 5,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyTeamRosterAddDropResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyTeamRosterAddDropResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyTeamRosterAddDropResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyTeamRosterAddDropResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyTeamRosterAddDropResponse_EResult::ERROR_OWNER_NOT_IN_LEAGUE),
            3 => ::std::option::Option::Some(CMsgDOTAFantasyTeamRosterAddDropResponse_EResult::ERROR_PLAYER_NOT_AVAILABLE),
            4 => ::std::option::Option::Some(CMsgDOTAFantasyTeamRosterAddDropResponse_EResult::ERROR_PLAYER_NOT_ON_TEAM),
            5 => ::std::option::Option::Some(CMsgDOTAFantasyTeamRosterAddDropResponse_EResult::ERROR_TRADE_ALREADY_PENDING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyTeamRosterAddDropResponse_EResult] = &[
            CMsgDOTAFantasyTeamRosterAddDropResponse_EResult::SUCCESS,
            CMsgDOTAFantasyTeamRosterAddDropResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyTeamRosterAddDropResponse_EResult::ERROR_OWNER_NOT_IN_LEAGUE,
            CMsgDOTAFantasyTeamRosterAddDropResponse_EResult::ERROR_PLAYER_NOT_AVAILABLE,
            CMsgDOTAFantasyTeamRosterAddDropResponse_EResult::ERROR_PLAYER_NOT_ON_TEAM,
            CMsgDOTAFantasyTeamRosterAddDropResponse_EResult::ERROR_TRADE_ALREADY_PENDING,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamRosterAddDropResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyTeamRosterAddDropResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyTeamRosterAddDropResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamRosterAddDropResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamTradesRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamTradesRequest {}

impl CMsgDOTAFantasyTeamTradesRequest {
    pub fn new() -> CMsgDOTAFantasyTeamTradesRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamTradesRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamTradesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamTradesRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamTradesRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamTradesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamTradesRequest {
    fn new() -> CMsgDOTAFantasyTeamTradesRequest {
        CMsgDOTAFantasyTeamTradesRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamTradesRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyTeamTradesRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyTeamTradesRequest::mut_fantasy_league_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamTradesRequest>(
                    "CMsgDOTAFantasyTeamTradesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamTradesRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamTradesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamTradesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamTradesResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyTeamTradesResponse_EResult>,
    trades: ::protobuf::RepeatedField<CMsgDOTAFantasyTeamTradesResponse_Trade>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamTradesResponse {}

impl CMsgDOTAFantasyTeamTradesResponse {
    pub fn new() -> CMsgDOTAFantasyTeamTradesResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamTradesResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamTradesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamTradesResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamTradesResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyTeamTradesResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyTeamTradesResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyTeamTradesResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyTeamTradesResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyTeamTradesResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyTeamTradesResponse_EResult> {
        &mut self.result
    }

    // repeated .CMsgDOTAFantasyTeamTradesResponse.Trade trades = 2;

    pub fn clear_trades(&mut self) {
        self.trades.clear();
    }

    // Param is passed by value, moved
    pub fn set_trades(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAFantasyTeamTradesResponse_Trade>) {
        self.trades = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trades(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyTeamTradesResponse_Trade> {
        &mut self.trades
    }

    // Take field
    pub fn take_trades(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAFantasyTeamTradesResponse_Trade> {
        ::std::mem::replace(&mut self.trades, ::protobuf::RepeatedField::new())
    }

    pub fn get_trades(&self) -> &[CMsgDOTAFantasyTeamTradesResponse_Trade] {
        &self.trades
    }

    fn get_trades_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAFantasyTeamTradesResponse_Trade> {
        &self.trades
    }

    fn mut_trades_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyTeamTradesResponse_Trade> {
        &mut self.trades
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamTradesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.trades {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trades)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.trades {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        for v in &self.trades {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamTradesResponse {
    fn new() -> CMsgDOTAFantasyTeamTradesResponse {
        CMsgDOTAFantasyTeamTradesResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamTradesResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyTeamTradesResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyTeamTradesResponse::get_result_for_reflect,
                    CMsgDOTAFantasyTeamTradesResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFantasyTeamTradesResponse_Trade>>(
                    "trades",
                    CMsgDOTAFantasyTeamTradesResponse::get_trades_for_reflect,
                    CMsgDOTAFantasyTeamTradesResponse::mut_trades_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamTradesResponse>(
                    "CMsgDOTAFantasyTeamTradesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamTradesResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_trades();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamTradesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamTradesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamTradesResponse_Trade {
    // message fields
    timestamp: ::std::option::Option<u32>,
    owner_account_id_1: ::std::option::Option<u32>,
    owner_account_id_2: ::std::option::Option<u32>,
    player_account_id_1: ::std::option::Option<u32>,
    player_account_id_2: ::std::option::Option<u32>,
    status: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamTradesResponse_Trade {}

impl CMsgDOTAFantasyTeamTradesResponse_Trade {
    pub fn new() -> CMsgDOTAFantasyTeamTradesResponse_Trade {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamTradesResponse_Trade {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamTradesResponse_Trade> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamTradesResponse_Trade,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamTradesResponse_Trade::new)
        }
    }

    // optional uint32 timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional uint32 owner_account_id_1 = 2;

    pub fn clear_owner_account_id_1(&mut self) {
        self.owner_account_id_1 = ::std::option::Option::None;
    }

    pub fn has_owner_account_id_1(&self) -> bool {
        self.owner_account_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id_1(&mut self, v: u32) {
        self.owner_account_id_1 = ::std::option::Option::Some(v);
    }

    pub fn get_owner_account_id_1(&self) -> u32 {
        self.owner_account_id_1.unwrap_or(0)
    }

    fn get_owner_account_id_1_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.owner_account_id_1
    }

    fn mut_owner_account_id_1_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.owner_account_id_1
    }

    // optional uint32 owner_account_id_2 = 3;

    pub fn clear_owner_account_id_2(&mut self) {
        self.owner_account_id_2 = ::std::option::Option::None;
    }

    pub fn has_owner_account_id_2(&self) -> bool {
        self.owner_account_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id_2(&mut self, v: u32) {
        self.owner_account_id_2 = ::std::option::Option::Some(v);
    }

    pub fn get_owner_account_id_2(&self) -> u32 {
        self.owner_account_id_2.unwrap_or(0)
    }

    fn get_owner_account_id_2_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.owner_account_id_2
    }

    fn mut_owner_account_id_2_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.owner_account_id_2
    }

    // optional uint32 player_account_id_1 = 4;

    pub fn clear_player_account_id_1(&mut self) {
        self.player_account_id_1 = ::std::option::Option::None;
    }

    pub fn has_player_account_id_1(&self) -> bool {
        self.player_account_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_account_id_1(&mut self, v: u32) {
        self.player_account_id_1 = ::std::option::Option::Some(v);
    }

    pub fn get_player_account_id_1(&self) -> u32 {
        self.player_account_id_1.unwrap_or(0)
    }

    fn get_player_account_id_1_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_account_id_1
    }

    fn mut_player_account_id_1_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_account_id_1
    }

    // optional uint32 player_account_id_2 = 5;

    pub fn clear_player_account_id_2(&mut self) {
        self.player_account_id_2 = ::std::option::Option::None;
    }

    pub fn has_player_account_id_2(&self) -> bool {
        self.player_account_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_account_id_2(&mut self, v: u32) {
        self.player_account_id_2 = ::std::option::Option::Some(v);
    }

    pub fn get_player_account_id_2(&self) -> u32 {
        self.player_account_id_2.unwrap_or(0)
    }

    fn get_player_account_id_2_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_account_id_2
    }

    fn mut_player_account_id_2_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_account_id_2
    }

    // optional uint32 status = 6;

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u32) {
        self.status = ::std::option::Option::Some(v);
    }

    pub fn get_status(&self) -> u32 {
        self.status.unwrap_or(0)
    }

    fn get_status_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.status
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamTradesResponse_Trade {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id_1 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id_2 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_account_id_1 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_account_id_2 = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_account_id_1 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_account_id_2 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_account_id_1 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_account_id_2 {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owner_account_id_1 {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.owner_account_id_2 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.player_account_id_1 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.player_account_id_2 {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.status {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamTradesResponse_Trade {
    fn new() -> CMsgDOTAFantasyTeamTradesResponse_Trade {
        CMsgDOTAFantasyTeamTradesResponse_Trade::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamTradesResponse_Trade>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgDOTAFantasyTeamTradesResponse_Trade::get_timestamp_for_reflect,
                    CMsgDOTAFantasyTeamTradesResponse_Trade::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "owner_account_id_1",
                    CMsgDOTAFantasyTeamTradesResponse_Trade::get_owner_account_id_1_for_reflect,
                    CMsgDOTAFantasyTeamTradesResponse_Trade::mut_owner_account_id_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "owner_account_id_2",
                    CMsgDOTAFantasyTeamTradesResponse_Trade::get_owner_account_id_2_for_reflect,
                    CMsgDOTAFantasyTeamTradesResponse_Trade::mut_owner_account_id_2_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_account_id_1",
                    CMsgDOTAFantasyTeamTradesResponse_Trade::get_player_account_id_1_for_reflect,
                    CMsgDOTAFantasyTeamTradesResponse_Trade::mut_player_account_id_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_account_id_2",
                    CMsgDOTAFantasyTeamTradesResponse_Trade::get_player_account_id_2_for_reflect,
                    CMsgDOTAFantasyTeamTradesResponse_Trade::mut_player_account_id_2_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "status",
                    CMsgDOTAFantasyTeamTradesResponse_Trade::get_status_for_reflect,
                    CMsgDOTAFantasyTeamTradesResponse_Trade::mut_status_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamTradesResponse_Trade>(
                    "CMsgDOTAFantasyTeamTradesResponse_Trade",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamTradesResponse_Trade {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_owner_account_id_1();
        self.clear_owner_account_id_2();
        self.clear_player_account_id_1();
        self.clear_player_account_id_2();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamTradesResponse_Trade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamTradesResponse_Trade {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyTeamTradesResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_NO_PERMISSION = 2,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyTeamTradesResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyTeamTradesResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyTeamTradesResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyTeamTradesResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyTeamTradesResponse_EResult::ERROR_NO_PERMISSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyTeamTradesResponse_EResult] = &[
            CMsgDOTAFantasyTeamTradesResponse_EResult::SUCCESS,
            CMsgDOTAFantasyTeamTradesResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyTeamTradesResponse_EResult::ERROR_NO_PERMISSION,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamTradesResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyTeamTradesResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyTeamTradesResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamTradesResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamTradeCancelRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    team_index_1: ::std::option::Option<u32>,
    owner_account_id_2: ::std::option::Option<u32>,
    team_index_2: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamTradeCancelRequest {}

impl CMsgDOTAFantasyTeamTradeCancelRequest {
    pub fn new() -> CMsgDOTAFantasyTeamTradeCancelRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamTradeCancelRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamTradeCancelRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamTradeCancelRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamTradeCancelRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 team_index_1 = 3;

    pub fn clear_team_index_1(&mut self) {
        self.team_index_1 = ::std::option::Option::None;
    }

    pub fn has_team_index_1(&self) -> bool {
        self.team_index_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_index_1(&mut self, v: u32) {
        self.team_index_1 = ::std::option::Option::Some(v);
    }

    pub fn get_team_index_1(&self) -> u32 {
        self.team_index_1.unwrap_or(0)
    }

    fn get_team_index_1_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_index_1
    }

    fn mut_team_index_1_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_index_1
    }

    // optional uint32 owner_account_id_2 = 4;

    pub fn clear_owner_account_id_2(&mut self) {
        self.owner_account_id_2 = ::std::option::Option::None;
    }

    pub fn has_owner_account_id_2(&self) -> bool {
        self.owner_account_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id_2(&mut self, v: u32) {
        self.owner_account_id_2 = ::std::option::Option::Some(v);
    }

    pub fn get_owner_account_id_2(&self) -> u32 {
        self.owner_account_id_2.unwrap_or(0)
    }

    fn get_owner_account_id_2_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.owner_account_id_2
    }

    fn mut_owner_account_id_2_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.owner_account_id_2
    }

    // optional uint32 team_index_2 = 5;

    pub fn clear_team_index_2(&mut self) {
        self.team_index_2 = ::std::option::Option::None;
    }

    pub fn has_team_index_2(&self) -> bool {
        self.team_index_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_index_2(&mut self, v: u32) {
        self.team_index_2 = ::std::option::Option::Some(v);
    }

    pub fn get_team_index_2(&self) -> u32 {
        self.team_index_2.unwrap_or(0)
    }

    fn get_team_index_2_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_index_2
    }

    fn mut_team_index_2_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_index_2
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamTradeCancelRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_index_1 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id_2 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_index_2 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_index_1 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_account_id_2 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_index_2 {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.team_index_1 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.owner_account_id_2 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.team_index_2 {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamTradeCancelRequest {
    fn new() -> CMsgDOTAFantasyTeamTradeCancelRequest {
        CMsgDOTAFantasyTeamTradeCancelRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamTradeCancelRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyTeamTradeCancelRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyTeamTradeCancelRequest::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_index_1",
                    CMsgDOTAFantasyTeamTradeCancelRequest::get_team_index_1_for_reflect,
                    CMsgDOTAFantasyTeamTradeCancelRequest::mut_team_index_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "owner_account_id_2",
                    CMsgDOTAFantasyTeamTradeCancelRequest::get_owner_account_id_2_for_reflect,
                    CMsgDOTAFantasyTeamTradeCancelRequest::mut_owner_account_id_2_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_index_2",
                    CMsgDOTAFantasyTeamTradeCancelRequest::get_team_index_2_for_reflect,
                    CMsgDOTAFantasyTeamTradeCancelRequest::mut_team_index_2_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamTradeCancelRequest>(
                    "CMsgDOTAFantasyTeamTradeCancelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamTradeCancelRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_team_index_1();
        self.clear_owner_account_id_2();
        self.clear_team_index_2();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamTradeCancelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamTradeCancelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamTradeCancelResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyTeamTradeCancelResponse_EResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamTradeCancelResponse {}

impl CMsgDOTAFantasyTeamTradeCancelResponse {
    pub fn new() -> CMsgDOTAFantasyTeamTradeCancelResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamTradeCancelResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamTradeCancelResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamTradeCancelResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamTradeCancelResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyTeamTradeCancelResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyTeamTradeCancelResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyTeamTradeCancelResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyTeamTradeCancelResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyTeamTradeCancelResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyTeamTradeCancelResponse_EResult> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamTradeCancelResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamTradeCancelResponse {
    fn new() -> CMsgDOTAFantasyTeamTradeCancelResponse {
        CMsgDOTAFantasyTeamTradeCancelResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamTradeCancelResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyTeamTradeCancelResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyTeamTradeCancelResponse::get_result_for_reflect,
                    CMsgDOTAFantasyTeamTradeCancelResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamTradeCancelResponse>(
                    "CMsgDOTAFantasyTeamTradeCancelResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamTradeCancelResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamTradeCancelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamTradeCancelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyTeamTradeCancelResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_NO_PERMISSION = 2,
    ERROR_NO_TRADE = 3,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyTeamTradeCancelResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyTeamTradeCancelResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyTeamTradeCancelResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyTeamTradeCancelResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyTeamTradeCancelResponse_EResult::ERROR_NO_PERMISSION),
            3 => ::std::option::Option::Some(CMsgDOTAFantasyTeamTradeCancelResponse_EResult::ERROR_NO_TRADE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyTeamTradeCancelResponse_EResult] = &[
            CMsgDOTAFantasyTeamTradeCancelResponse_EResult::SUCCESS,
            CMsgDOTAFantasyTeamTradeCancelResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyTeamTradeCancelResponse_EResult::ERROR_NO_PERMISSION,
            CMsgDOTAFantasyTeamTradeCancelResponse_EResult::ERROR_NO_TRADE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamTradeCancelResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyTeamTradeCancelResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyTeamTradeCancelResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamTradeCancelResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamRosterRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    team_index: ::std::option::Option<u32>,
    owner_account_id: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamRosterRequest {}

impl CMsgDOTAFantasyTeamRosterRequest {
    pub fn new() -> CMsgDOTAFantasyTeamRosterRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamRosterRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamRosterRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamRosterRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamRosterRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 team_index = 2;

    pub fn clear_team_index(&mut self) {
        self.team_index = ::std::option::Option::None;
    }

    pub fn has_team_index(&self) -> bool {
        self.team_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_index(&mut self, v: u32) {
        self.team_index = ::std::option::Option::Some(v);
    }

    pub fn get_team_index(&self) -> u32 {
        self.team_index.unwrap_or(0)
    }

    fn get_team_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_index
    }

    fn mut_team_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_index
    }

    // optional uint32 owner_account_id = 3;

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    fn get_owner_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.owner_account_id
    }

    fn mut_owner_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.owner_account_id
    }

    // optional uint32 timestamp = 4;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamRosterRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.team_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamRosterRequest {
    fn new() -> CMsgDOTAFantasyTeamRosterRequest {
        CMsgDOTAFantasyTeamRosterRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamRosterRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyTeamRosterRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyTeamRosterRequest::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_index",
                    CMsgDOTAFantasyTeamRosterRequest::get_team_index_for_reflect,
                    CMsgDOTAFantasyTeamRosterRequest::mut_team_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "owner_account_id",
                    CMsgDOTAFantasyTeamRosterRequest::get_owner_account_id_for_reflect,
                    CMsgDOTAFantasyTeamRosterRequest::mut_owner_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgDOTAFantasyTeamRosterRequest::get_timestamp_for_reflect,
                    CMsgDOTAFantasyTeamRosterRequest::mut_timestamp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamRosterRequest>(
                    "CMsgDOTAFantasyTeamRosterRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamRosterRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_team_index();
        self.clear_owner_account_id();
        self.clear_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamRosterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamRosterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyTeamRosterResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyTeamRosterResponse_EResult>,
    player_account_ids: ::std::vec::Vec<u32>,
    player_locked: ::std::vec::Vec<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyTeamRosterResponse {}

impl CMsgDOTAFantasyTeamRosterResponse {
    pub fn new() -> CMsgDOTAFantasyTeamRosterResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyTeamRosterResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyTeamRosterResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyTeamRosterResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyTeamRosterResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyTeamRosterResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyTeamRosterResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyTeamRosterResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyTeamRosterResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyTeamRosterResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyTeamRosterResponse_EResult> {
        &mut self.result
    }

    // repeated uint32 player_account_ids = 2;

    pub fn clear_player_account_ids(&mut self) {
        self.player_account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.player_account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.player_account_ids
    }

    // Take field
    pub fn take_player_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.player_account_ids, ::std::vec::Vec::new())
    }

    pub fn get_player_account_ids(&self) -> &[u32] {
        &self.player_account_ids
    }

    fn get_player_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.player_account_ids
    }

    fn mut_player_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.player_account_ids
    }

    // repeated bool player_locked = 3;

    pub fn clear_player_locked(&mut self) {
        self.player_locked.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_locked(&mut self, v: ::std::vec::Vec<bool>) {
        self.player_locked = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_locked(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.player_locked
    }

    // Take field
    pub fn take_player_locked(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.player_locked, ::std::vec::Vec::new())
    }

    pub fn get_player_locked(&self) -> &[bool] {
        &self.player_locked
    }

    fn get_player_locked_for_reflect(&self) -> &::std::vec::Vec<bool> {
        &self.player_locked
    }

    fn mut_player_locked_for_reflect(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.player_locked
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyTeamRosterResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.player_account_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.player_locked)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.player_account_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += 2 * self.player_locked.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        for v in &self.player_account_ids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.player_locked {
            os.write_bool(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyTeamRosterResponse {
    fn new() -> CMsgDOTAFantasyTeamRosterResponse {
        CMsgDOTAFantasyTeamRosterResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamRosterResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyTeamRosterResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyTeamRosterResponse::get_result_for_reflect,
                    CMsgDOTAFantasyTeamRosterResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_account_ids",
                    CMsgDOTAFantasyTeamRosterResponse::get_player_account_ids_for_reflect,
                    CMsgDOTAFantasyTeamRosterResponse::mut_player_account_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "player_locked",
                    CMsgDOTAFantasyTeamRosterResponse::get_player_locked_for_reflect,
                    CMsgDOTAFantasyTeamRosterResponse::mut_player_locked_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyTeamRosterResponse>(
                    "CMsgDOTAFantasyTeamRosterResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyTeamRosterResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_player_account_ids();
        self.clear_player_locked();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyTeamRosterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamRosterResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyTeamRosterResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_NO_PERMISSION = 2,
    ERROR_OWNER_NOT_IN_LEAGUE = 3,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyTeamRosterResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyTeamRosterResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyTeamRosterResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyTeamRosterResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyTeamRosterResponse_EResult::ERROR_NO_PERMISSION),
            3 => ::std::option::Option::Some(CMsgDOTAFantasyTeamRosterResponse_EResult::ERROR_OWNER_NOT_IN_LEAGUE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyTeamRosterResponse_EResult] = &[
            CMsgDOTAFantasyTeamRosterResponse_EResult::SUCCESS,
            CMsgDOTAFantasyTeamRosterResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyTeamRosterResponse_EResult::ERROR_NO_PERMISSION,
            CMsgDOTAFantasyTeamRosterResponse_EResult::ERROR_OWNER_NOT_IN_LEAGUE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyTeamRosterResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyTeamRosterResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyTeamRosterResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyTeamRosterResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyPlayerHisoricalStatsRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyPlayerHisoricalStatsRequest {}

impl CMsgDOTAFantasyPlayerHisoricalStatsRequest {
    pub fn new() -> CMsgDOTAFantasyPlayerHisoricalStatsRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyPlayerHisoricalStatsRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyPlayerHisoricalStatsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyPlayerHisoricalStatsRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyPlayerHisoricalStatsRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerHisoricalStatsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyPlayerHisoricalStatsRequest {
    fn new() -> CMsgDOTAFantasyPlayerHisoricalStatsRequest {
        CMsgDOTAFantasyPlayerHisoricalStatsRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerHisoricalStatsRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyPlayerHisoricalStatsRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsRequest::mut_fantasy_league_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyPlayerHisoricalStatsRequest>(
                    "CMsgDOTAFantasyPlayerHisoricalStatsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyPlayerHisoricalStatsRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyPlayerHisoricalStatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerHisoricalStatsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyPlayerHisoricalStatsResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult>,
    stats: ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyPlayerHisoricalStatsResponse {}

impl CMsgDOTAFantasyPlayerHisoricalStatsResponse {
    pub fn new() -> CMsgDOTAFantasyPlayerHisoricalStatsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyPlayerHisoricalStatsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyPlayerHisoricalStatsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyPlayerHisoricalStatsResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyPlayerHisoricalStatsResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyPlayerHisoricalStatsResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult> {
        &mut self.result
    }

    // repeated .CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerStats stats = 2;

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats> {
        ::std::mem::replace(&mut self.stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_stats(&self) -> &[CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats] {
        &self.stats
    }

    fn get_stats_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats> {
        &self.stats
    }

    fn mut_stats_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats> {
        &mut self.stats
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerHisoricalStatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        for v in &self.stats {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyPlayerHisoricalStatsResponse {
    fn new() -> CMsgDOTAFantasyPlayerHisoricalStatsResponse {
        CMsgDOTAFantasyPlayerHisoricalStatsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerHisoricalStatsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse::get_result_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats>>(
                    "stats",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse::get_stats_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse::mut_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyPlayerHisoricalStatsResponse>(
                    "CMsgDOTAFantasyPlayerHisoricalStatsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyPlayerHisoricalStatsResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyPlayerHisoricalStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerHisoricalStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator {
    // message fields
    matches: ::std::option::Option<u32>,
    levels: ::std::option::Option<f32>,
    kills: ::std::option::Option<f32>,
    deaths: ::std::option::Option<f32>,
    assists: ::std::option::Option<f32>,
    last_hits: ::std::option::Option<f32>,
    denies: ::std::option::Option<f32>,
    gpm: ::std::option::Option<f32>,
    xppm: ::std::option::Option<f32>,
    stuns: ::std::option::Option<f32>,
    healing: ::std::option::Option<f32>,
    tower_kills: ::std::option::Option<f32>,
    roshan_kills: ::std::option::Option<f32>,
    score: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator {}

impl CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator {
    pub fn new() -> CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::new)
        }
    }

    // optional uint32 matches = 1;

    pub fn clear_matches(&mut self) {
        self.matches = ::std::option::Option::None;
    }

    pub fn has_matches(&self) -> bool {
        self.matches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matches(&mut self, v: u32) {
        self.matches = ::std::option::Option::Some(v);
    }

    pub fn get_matches(&self) -> u32 {
        self.matches.unwrap_or(0)
    }

    fn get_matches_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.matches
    }

    fn mut_matches_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.matches
    }

    // optional float levels = 2;

    pub fn clear_levels(&mut self) {
        self.levels = ::std::option::Option::None;
    }

    pub fn has_levels(&self) -> bool {
        self.levels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_levels(&mut self, v: f32) {
        self.levels = ::std::option::Option::Some(v);
    }

    pub fn get_levels(&self) -> f32 {
        self.levels.unwrap_or(0.)
    }

    fn get_levels_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.levels
    }

    fn mut_levels_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.levels
    }

    // optional float kills = 3;

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: f32) {
        self.kills = ::std::option::Option::Some(v);
    }

    pub fn get_kills(&self) -> f32 {
        self.kills.unwrap_or(0.)
    }

    fn get_kills_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.kills
    }

    fn mut_kills_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.kills
    }

    // optional float deaths = 4;

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: f32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    pub fn get_deaths(&self) -> f32 {
        self.deaths.unwrap_or(0.)
    }

    fn get_deaths_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.deaths
    }

    fn mut_deaths_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.deaths
    }

    // optional float assists = 5;

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: f32) {
        self.assists = ::std::option::Option::Some(v);
    }

    pub fn get_assists(&self) -> f32 {
        self.assists.unwrap_or(0.)
    }

    fn get_assists_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.assists
    }

    fn mut_assists_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.assists
    }

    // optional float last_hits = 6;

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: f32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    pub fn get_last_hits(&self) -> f32 {
        self.last_hits.unwrap_or(0.)
    }

    fn get_last_hits_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.last_hits
    }

    fn mut_last_hits_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.last_hits
    }

    // optional float denies = 7;

    pub fn clear_denies(&mut self) {
        self.denies = ::std::option::Option::None;
    }

    pub fn has_denies(&self) -> bool {
        self.denies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denies(&mut self, v: f32) {
        self.denies = ::std::option::Option::Some(v);
    }

    pub fn get_denies(&self) -> f32 {
        self.denies.unwrap_or(0.)
    }

    fn get_denies_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.denies
    }

    fn mut_denies_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.denies
    }

    // optional float gpm = 8;

    pub fn clear_gpm(&mut self) {
        self.gpm = ::std::option::Option::None;
    }

    pub fn has_gpm(&self) -> bool {
        self.gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpm(&mut self, v: f32) {
        self.gpm = ::std::option::Option::Some(v);
    }

    pub fn get_gpm(&self) -> f32 {
        self.gpm.unwrap_or(0.)
    }

    fn get_gpm_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.gpm
    }

    fn mut_gpm_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.gpm
    }

    // optional float xppm = 9;

    pub fn clear_xppm(&mut self) {
        self.xppm = ::std::option::Option::None;
    }

    pub fn has_xppm(&self) -> bool {
        self.xppm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xppm(&mut self, v: f32) {
        self.xppm = ::std::option::Option::Some(v);
    }

    pub fn get_xppm(&self) -> f32 {
        self.xppm.unwrap_or(0.)
    }

    fn get_xppm_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.xppm
    }

    fn mut_xppm_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.xppm
    }

    // optional float stuns = 10;

    pub fn clear_stuns(&mut self) {
        self.stuns = ::std::option::Option::None;
    }

    pub fn has_stuns(&self) -> bool {
        self.stuns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stuns(&mut self, v: f32) {
        self.stuns = ::std::option::Option::Some(v);
    }

    pub fn get_stuns(&self) -> f32 {
        self.stuns.unwrap_or(0.)
    }

    fn get_stuns_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.stuns
    }

    fn mut_stuns_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.stuns
    }

    // optional float healing = 11;

    pub fn clear_healing(&mut self) {
        self.healing = ::std::option::Option::None;
    }

    pub fn has_healing(&self) -> bool {
        self.healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing(&mut self, v: f32) {
        self.healing = ::std::option::Option::Some(v);
    }

    pub fn get_healing(&self) -> f32 {
        self.healing.unwrap_or(0.)
    }

    fn get_healing_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.healing
    }

    fn mut_healing_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.healing
    }

    // optional float tower_kills = 12;

    pub fn clear_tower_kills(&mut self) {
        self.tower_kills = ::std::option::Option::None;
    }

    pub fn has_tower_kills(&self) -> bool {
        self.tower_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_kills(&mut self, v: f32) {
        self.tower_kills = ::std::option::Option::Some(v);
    }

    pub fn get_tower_kills(&self) -> f32 {
        self.tower_kills.unwrap_or(0.)
    }

    fn get_tower_kills_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.tower_kills
    }

    fn mut_tower_kills_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.tower_kills
    }

    // optional float roshan_kills = 13;

    pub fn clear_roshan_kills(&mut self) {
        self.roshan_kills = ::std::option::Option::None;
    }

    pub fn has_roshan_kills(&self) -> bool {
        self.roshan_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roshan_kills(&mut self, v: f32) {
        self.roshan_kills = ::std::option::Option::Some(v);
    }

    pub fn get_roshan_kills(&self) -> f32 {
        self.roshan_kills.unwrap_or(0.)
    }

    fn get_roshan_kills_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.roshan_kills
    }

    fn mut_roshan_kills_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.roshan_kills
    }

    // optional float score = 14;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score(&self) -> f32 {
        self.score.unwrap_or(0.)
    }

    fn get_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.score
    }

    fn mut_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.score
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matches = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.levels = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.kills = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.deaths = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.assists = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.last_hits = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.denies = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.gpm = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.xppm = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.stuns = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.healing = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.tower_kills = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.roshan_kills = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.matches {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.levels {
            my_size += 5;
        }
        if let Some(v) = self.kills {
            my_size += 5;
        }
        if let Some(v) = self.deaths {
            my_size += 5;
        }
        if let Some(v) = self.assists {
            my_size += 5;
        }
        if let Some(v) = self.last_hits {
            my_size += 5;
        }
        if let Some(v) = self.denies {
            my_size += 5;
        }
        if let Some(v) = self.gpm {
            my_size += 5;
        }
        if let Some(v) = self.xppm {
            my_size += 5;
        }
        if let Some(v) = self.stuns {
            my_size += 5;
        }
        if let Some(v) = self.healing {
            my_size += 5;
        }
        if let Some(v) = self.tower_kills {
            my_size += 5;
        }
        if let Some(v) = self.roshan_kills {
            my_size += 5;
        }
        if let Some(v) = self.score {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.matches {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.levels {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.kills {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.assists {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.last_hits {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.denies {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.gpm {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.xppm {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.stuns {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.healing {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.tower_kills {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.roshan_kills {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.score {
            os.write_float(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator {
    fn new() -> CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator {
        CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "matches",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::get_matches_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::mut_matches_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "levels",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::get_levels_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::mut_levels_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "kills",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::get_kills_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::mut_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "deaths",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::get_deaths_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::mut_deaths_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "assists",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::get_assists_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::mut_assists_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "last_hits",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::get_last_hits_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::mut_last_hits_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "denies",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::get_denies_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::mut_denies_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "gpm",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::get_gpm_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::mut_gpm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "xppm",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::get_xppm_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::mut_xppm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "stuns",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::get_stuns_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::mut_stuns_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "healing",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::get_healing_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::mut_healing_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "tower_kills",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::get_tower_kills_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::mut_tower_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "roshan_kills",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::get_roshan_kills_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::mut_roshan_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "score",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::get_score_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::mut_score_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator>(
                    "CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator {
    fn clear(&mut self) {
        self.clear_matches();
        self.clear_levels();
        self.clear_kills();
        self.clear_deaths();
        self.clear_assists();
        self.clear_last_hits();
        self.clear_denies();
        self.clear_gpm();
        self.clear_xppm();
        self.clear_stuns();
        self.clear_healing();
        self.clear_tower_kills();
        self.clear_roshan_kills();
        self.clear_score();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats {
    // message fields
    account_id: ::std::option::Option<u32>,
    weeks: ::std::option::Option<u32>,
    stats_premium: ::protobuf::SingularPtrField<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator>,
    stats_professional: ::protobuf::SingularPtrField<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats {}

impl CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats {
    pub fn new() -> CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 weeks = 2;

    pub fn clear_weeks(&mut self) {
        self.weeks = ::std::option::Option::None;
    }

    pub fn has_weeks(&self) -> bool {
        self.weeks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weeks(&mut self, v: u32) {
        self.weeks = ::std::option::Option::Some(v);
    }

    pub fn get_weeks(&self) -> u32 {
        self.weeks.unwrap_or(0)
    }

    fn get_weeks_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.weeks
    }

    fn mut_weeks_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.weeks
    }

    // optional .CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator stats_premium = 4;

    pub fn clear_stats_premium(&mut self) {
        self.stats_premium.clear();
    }

    pub fn has_stats_premium(&self) -> bool {
        self.stats_premium.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_premium(&mut self, v: CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator) {
        self.stats_premium = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats_premium(&mut self) -> &mut CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator {
        if self.stats_premium.is_none() {
            self.stats_premium.set_default();
        }
        self.stats_premium.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats_premium(&mut self) -> CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator {
        self.stats_premium.take().unwrap_or_else(|| CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::new())
    }

    pub fn get_stats_premium(&self) -> &CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator {
        self.stats_premium.as_ref().unwrap_or_else(|| CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::default_instance())
    }

    fn get_stats_premium_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator> {
        &self.stats_premium
    }

    fn mut_stats_premium_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator> {
        &mut self.stats_premium
    }

    // optional .CMsgDOTAFantasyPlayerHisoricalStatsResponse.PlayerScoreAccumulator stats_professional = 5;

    pub fn clear_stats_professional(&mut self) {
        self.stats_professional.clear();
    }

    pub fn has_stats_professional(&self) -> bool {
        self.stats_professional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_professional(&mut self, v: CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator) {
        self.stats_professional = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats_professional(&mut self) -> &mut CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator {
        if self.stats_professional.is_none() {
            self.stats_professional.set_default();
        }
        self.stats_professional.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats_professional(&mut self) -> CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator {
        self.stats_professional.take().unwrap_or_else(|| CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::new())
    }

    pub fn get_stats_professional(&self) -> &CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator {
        self.stats_professional.as_ref().unwrap_or_else(|| CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator::default_instance())
    }

    fn get_stats_professional_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator> {
        &self.stats_professional
    }

    fn mut_stats_professional_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator> {
        &mut self.stats_professional
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats {
    fn is_initialized(&self) -> bool {
        for v in &self.stats_premium {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats_professional {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.weeks = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats_premium)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats_professional)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.weeks {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.stats_premium.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stats_professional.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.weeks {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.stats_premium.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stats_professional.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats {
    fn new() -> CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats {
        CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::get_account_id_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "weeks",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::get_weeks_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::mut_weeks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator>>(
                    "stats_premium",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::get_stats_premium_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::mut_stats_premium_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerScoreAccumulator>>(
                    "stats_professional",
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::get_stats_professional_for_reflect,
                    CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats::mut_stats_professional_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats>(
                    "CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_weeks();
        self.clear_stats_premium();
        self.clear_stats_professional();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerHisoricalStatsResponse_PlayerStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_NO_PERMISSION = 2,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult::ERROR_NO_PERMISSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult] = &[
            CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult::SUCCESS,
            CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult::ERROR_NO_PERMISSION,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerHisoricalStatsResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyMessageAdd {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyMessageAdd {}

impl CMsgDOTAFantasyMessageAdd {
    pub fn new() -> CMsgDOTAFantasyMessageAdd {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyMessageAdd {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyMessageAdd> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyMessageAdd,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyMessageAdd::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional string message = 2;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyMessageAdd {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyMessageAdd {
    fn new() -> CMsgDOTAFantasyMessageAdd {
        CMsgDOTAFantasyMessageAdd::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyMessageAdd>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyMessageAdd::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyMessageAdd::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    CMsgDOTAFantasyMessageAdd::get_message_for_reflect,
                    CMsgDOTAFantasyMessageAdd::mut_message_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyMessageAdd>(
                    "CMsgDOTAFantasyMessageAdd",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyMessageAdd {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyMessageAdd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyMessageAdd {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyMessagesRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    start_message: ::std::option::Option<u32>,
    end_message: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyMessagesRequest {}

impl CMsgDOTAFantasyMessagesRequest {
    pub fn new() -> CMsgDOTAFantasyMessagesRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyMessagesRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyMessagesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyMessagesRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyMessagesRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 start_message = 2;

    pub fn clear_start_message(&mut self) {
        self.start_message = ::std::option::Option::None;
    }

    pub fn has_start_message(&self) -> bool {
        self.start_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_message(&mut self, v: u32) {
        self.start_message = ::std::option::Option::Some(v);
    }

    pub fn get_start_message(&self) -> u32 {
        self.start_message.unwrap_or(0)
    }

    fn get_start_message_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.start_message
    }

    fn mut_start_message_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.start_message
    }

    // optional uint32 end_message = 3;

    pub fn clear_end_message(&mut self) {
        self.end_message = ::std::option::Option::None;
    }

    pub fn has_end_message(&self) -> bool {
        self.end_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_message(&mut self, v: u32) {
        self.end_message = ::std::option::Option::Some(v);
    }

    pub fn get_end_message(&self) -> u32 {
        self.end_message.unwrap_or(0)
    }

    fn get_end_message_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.end_message
    }

    fn mut_end_message_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.end_message
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyMessagesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_message = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.end_message = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_message {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end_message {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_message {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.end_message {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyMessagesRequest {
    fn new() -> CMsgDOTAFantasyMessagesRequest {
        CMsgDOTAFantasyMessagesRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyMessagesRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyMessagesRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyMessagesRequest::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "start_message",
                    CMsgDOTAFantasyMessagesRequest::get_start_message_for_reflect,
                    CMsgDOTAFantasyMessagesRequest::mut_start_message_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "end_message",
                    CMsgDOTAFantasyMessagesRequest::get_end_message_for_reflect,
                    CMsgDOTAFantasyMessagesRequest::mut_end_message_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyMessagesRequest>(
                    "CMsgDOTAFantasyMessagesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyMessagesRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_start_message();
        self.clear_end_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyMessagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyMessagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyMessagesResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyMessagesResponse_EResult>,
    messages: ::protobuf::RepeatedField<CMsgDOTAFantasyMessagesResponse_Message>,
    num_total_messages: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyMessagesResponse {}

impl CMsgDOTAFantasyMessagesResponse {
    pub fn new() -> CMsgDOTAFantasyMessagesResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyMessagesResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyMessagesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyMessagesResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyMessagesResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyMessagesResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyMessagesResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyMessagesResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyMessagesResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyMessagesResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyMessagesResponse_EResult> {
        &mut self.result
    }

    // repeated .CMsgDOTAFantasyMessagesResponse.Message messages = 2;

    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAFantasyMessagesResponse_Message>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyMessagesResponse_Message> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAFantasyMessagesResponse_Message> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }

    pub fn get_messages(&self) -> &[CMsgDOTAFantasyMessagesResponse_Message] {
        &self.messages
    }

    fn get_messages_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAFantasyMessagesResponse_Message> {
        &self.messages
    }

    fn mut_messages_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyMessagesResponse_Message> {
        &mut self.messages
    }

    // optional uint32 num_total_messages = 3;

    pub fn clear_num_total_messages(&mut self) {
        self.num_total_messages = ::std::option::Option::None;
    }

    pub fn has_num_total_messages(&self) -> bool {
        self.num_total_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_total_messages(&mut self, v: u32) {
        self.num_total_messages = ::std::option::Option::Some(v);
    }

    pub fn get_num_total_messages(&self) -> u32 {
        self.num_total_messages.unwrap_or(0)
    }

    fn get_num_total_messages_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.num_total_messages
    }

    fn mut_num_total_messages_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.num_total_messages
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyMessagesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_total_messages = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.num_total_messages {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        for v in &self.messages {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.num_total_messages {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyMessagesResponse {
    fn new() -> CMsgDOTAFantasyMessagesResponse {
        CMsgDOTAFantasyMessagesResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyMessagesResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyMessagesResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyMessagesResponse::get_result_for_reflect,
                    CMsgDOTAFantasyMessagesResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFantasyMessagesResponse_Message>>(
                    "messages",
                    CMsgDOTAFantasyMessagesResponse::get_messages_for_reflect,
                    CMsgDOTAFantasyMessagesResponse::mut_messages_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_total_messages",
                    CMsgDOTAFantasyMessagesResponse::get_num_total_messages_for_reflect,
                    CMsgDOTAFantasyMessagesResponse::mut_num_total_messages_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyMessagesResponse>(
                    "CMsgDOTAFantasyMessagesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyMessagesResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_messages();
        self.clear_num_total_messages();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyMessagesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyMessagesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyMessagesResponse_Message {
    // message fields
    message_id: ::std::option::Option<u32>,
    message: ::protobuf::SingularField<::std::string::String>,
    author_account_id: ::std::option::Option<u32>,
    time: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyMessagesResponse_Message {}

impl CMsgDOTAFantasyMessagesResponse_Message {
    pub fn new() -> CMsgDOTAFantasyMessagesResponse_Message {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyMessagesResponse_Message {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyMessagesResponse_Message> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyMessagesResponse_Message,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyMessagesResponse_Message::new)
        }
    }

    // optional uint32 message_id = 1;

    pub fn clear_message_id(&mut self) {
        self.message_id = ::std::option::Option::None;
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: u32) {
        self.message_id = ::std::option::Option::Some(v);
    }

    pub fn get_message_id(&self) -> u32 {
        self.message_id.unwrap_or(0)
    }

    fn get_message_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.message_id
    }

    fn mut_message_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.message_id
    }

    // optional string message = 2;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }

    // optional uint32 author_account_id = 3;

    pub fn clear_author_account_id(&mut self) {
        self.author_account_id = ::std::option::Option::None;
    }

    pub fn has_author_account_id(&self) -> bool {
        self.author_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_author_account_id(&mut self, v: u32) {
        self.author_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_author_account_id(&self) -> u32 {
        self.author_account_id.unwrap_or(0)
    }

    fn get_author_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.author_account_id
    }

    fn mut_author_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.author_account_id
    }

    // optional uint32 time = 4;

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: u32) {
        self.time = ::std::option::Option::Some(v);
    }

    pub fn get_time(&self) -> u32 {
        self.time.unwrap_or(0)
    }

    fn get_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time
    }

    fn mut_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyMessagesResponse_Message {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.message_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.author_account_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.message_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.author_account_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.message_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.author_account_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.time {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyMessagesResponse_Message {
    fn new() -> CMsgDOTAFantasyMessagesResponse_Message {
        CMsgDOTAFantasyMessagesResponse_Message::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyMessagesResponse_Message>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "message_id",
                    CMsgDOTAFantasyMessagesResponse_Message::get_message_id_for_reflect,
                    CMsgDOTAFantasyMessagesResponse_Message::mut_message_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    CMsgDOTAFantasyMessagesResponse_Message::get_message_for_reflect,
                    CMsgDOTAFantasyMessagesResponse_Message::mut_message_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "author_account_id",
                    CMsgDOTAFantasyMessagesResponse_Message::get_author_account_id_for_reflect,
                    CMsgDOTAFantasyMessagesResponse_Message::mut_author_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time",
                    CMsgDOTAFantasyMessagesResponse_Message::get_time_for_reflect,
                    CMsgDOTAFantasyMessagesResponse_Message::mut_time_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyMessagesResponse_Message>(
                    "CMsgDOTAFantasyMessagesResponse_Message",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyMessagesResponse_Message {
    fn clear(&mut self) {
        self.clear_message_id();
        self.clear_message();
        self.clear_author_account_id();
        self.clear_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyMessagesResponse_Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyMessagesResponse_Message {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyMessagesResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_NO_PERMISSION = 2,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyMessagesResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyMessagesResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyMessagesResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyMessagesResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyMessagesResponse_EResult::ERROR_NO_PERMISSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyMessagesResponse_EResult] = &[
            CMsgDOTAFantasyMessagesResponse_EResult::SUCCESS,
            CMsgDOTAFantasyMessagesResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyMessagesResponse_EResult::ERROR_NO_PERMISSION,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyMessagesResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyMessagesResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyMessagesResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyMessagesResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyRemoveOwner {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    owner_account_id: ::std::option::Option<u32>,
    team_index: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyRemoveOwner {}

impl CMsgDOTAFantasyRemoveOwner {
    pub fn new() -> CMsgDOTAFantasyRemoveOwner {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyRemoveOwner {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyRemoveOwner> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyRemoveOwner,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyRemoveOwner::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 owner_account_id = 2;

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    fn get_owner_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.owner_account_id
    }

    fn mut_owner_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.owner_account_id
    }

    // optional uint32 team_index = 3;

    pub fn clear_team_index(&mut self) {
        self.team_index = ::std::option::Option::None;
    }

    pub fn has_team_index(&self) -> bool {
        self.team_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_index(&mut self, v: u32) {
        self.team_index = ::std::option::Option::Some(v);
    }

    pub fn get_team_index(&self) -> u32 {
        self.team_index.unwrap_or(0)
    }

    fn get_team_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_index
    }

    fn mut_team_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_index
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyRemoveOwner {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_index {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.team_index {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyRemoveOwner {
    fn new() -> CMsgDOTAFantasyRemoveOwner {
        CMsgDOTAFantasyRemoveOwner::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyRemoveOwner>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyRemoveOwner::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyRemoveOwner::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "owner_account_id",
                    CMsgDOTAFantasyRemoveOwner::get_owner_account_id_for_reflect,
                    CMsgDOTAFantasyRemoveOwner::mut_owner_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_index",
                    CMsgDOTAFantasyRemoveOwner::get_team_index_for_reflect,
                    CMsgDOTAFantasyRemoveOwner::mut_team_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyRemoveOwner>(
                    "CMsgDOTAFantasyRemoveOwner",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyRemoveOwner {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_owner_account_id();
        self.clear_team_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyRemoveOwner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyRemoveOwner {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyRemoveOwnerResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyRemoveOwnerResponse_EResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyRemoveOwnerResponse {}

impl CMsgDOTAFantasyRemoveOwnerResponse {
    pub fn new() -> CMsgDOTAFantasyRemoveOwnerResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyRemoveOwnerResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyRemoveOwnerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyRemoveOwnerResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyRemoveOwnerResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyRemoveOwnerResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyRemoveOwnerResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyRemoveOwnerResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyRemoveOwnerResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyRemoveOwnerResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyRemoveOwnerResponse_EResult> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyRemoveOwnerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyRemoveOwnerResponse {
    fn new() -> CMsgDOTAFantasyRemoveOwnerResponse {
        CMsgDOTAFantasyRemoveOwnerResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyRemoveOwnerResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyRemoveOwnerResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyRemoveOwnerResponse::get_result_for_reflect,
                    CMsgDOTAFantasyRemoveOwnerResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyRemoveOwnerResponse>(
                    "CMsgDOTAFantasyRemoveOwnerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyRemoveOwnerResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyRemoveOwnerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyRemoveOwnerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyRemoveOwnerResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_NO_PERMISSION = 2,
    ERROR_LEAGUE_LOCKED = 3,
    ERROR_NOT_A_MEMBER = 4,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyRemoveOwnerResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyRemoveOwnerResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyRemoveOwnerResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyRemoveOwnerResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyRemoveOwnerResponse_EResult::ERROR_NO_PERMISSION),
            3 => ::std::option::Option::Some(CMsgDOTAFantasyRemoveOwnerResponse_EResult::ERROR_LEAGUE_LOCKED),
            4 => ::std::option::Option::Some(CMsgDOTAFantasyRemoveOwnerResponse_EResult::ERROR_NOT_A_MEMBER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyRemoveOwnerResponse_EResult] = &[
            CMsgDOTAFantasyRemoveOwnerResponse_EResult::SUCCESS,
            CMsgDOTAFantasyRemoveOwnerResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyRemoveOwnerResponse_EResult::ERROR_NO_PERMISSION,
            CMsgDOTAFantasyRemoveOwnerResponse_EResult::ERROR_LEAGUE_LOCKED,
            CMsgDOTAFantasyRemoveOwnerResponse_EResult::ERROR_NOT_A_MEMBER,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyRemoveOwnerResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyRemoveOwnerResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyRemoveOwnerResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyRemoveOwnerResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyScheduledMatchesRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyScheduledMatchesRequest {}

impl CMsgDOTAFantasyScheduledMatchesRequest {
    pub fn new() -> CMsgDOTAFantasyScheduledMatchesRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyScheduledMatchesRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyScheduledMatchesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyScheduledMatchesRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyScheduledMatchesRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyScheduledMatchesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyScheduledMatchesRequest {
    fn new() -> CMsgDOTAFantasyScheduledMatchesRequest {
        CMsgDOTAFantasyScheduledMatchesRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyScheduledMatchesRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyScheduledMatchesRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyScheduledMatchesRequest::mut_fantasy_league_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyScheduledMatchesRequest>(
                    "CMsgDOTAFantasyScheduledMatchesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyScheduledMatchesRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyScheduledMatchesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyScheduledMatchesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyScheduledMatchesResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyScheduledMatchesResponse_EResult>,
    scheduled_match_days: ::protobuf::RepeatedField<CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyScheduledMatchesResponse {}

impl CMsgDOTAFantasyScheduledMatchesResponse {
    pub fn new() -> CMsgDOTAFantasyScheduledMatchesResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyScheduledMatchesResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyScheduledMatchesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyScheduledMatchesResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyScheduledMatchesResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyScheduledMatchesResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyScheduledMatchesResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyScheduledMatchesResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyScheduledMatchesResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyScheduledMatchesResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyScheduledMatchesResponse_EResult> {
        &mut self.result
    }

    // repeated .CMsgDOTAFantasyScheduledMatchesResponse.ScheduledMatchDays scheduled_match_days = 2;

    pub fn clear_scheduled_match_days(&mut self) {
        self.scheduled_match_days.clear();
    }

    // Param is passed by value, moved
    pub fn set_scheduled_match_days(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays>) {
        self.scheduled_match_days = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scheduled_match_days(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays> {
        &mut self.scheduled_match_days
    }

    // Take field
    pub fn take_scheduled_match_days(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays> {
        ::std::mem::replace(&mut self.scheduled_match_days, ::protobuf::RepeatedField::new())
    }

    pub fn get_scheduled_match_days(&self) -> &[CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays] {
        &self.scheduled_match_days
    }

    fn get_scheduled_match_days_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays> {
        &self.scheduled_match_days
    }

    fn mut_scheduled_match_days_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays> {
        &mut self.scheduled_match_days
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyScheduledMatchesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.scheduled_match_days {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.scheduled_match_days)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.scheduled_match_days {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        for v in &self.scheduled_match_days {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyScheduledMatchesResponse {
    fn new() -> CMsgDOTAFantasyScheduledMatchesResponse {
        CMsgDOTAFantasyScheduledMatchesResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyScheduledMatchesResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyScheduledMatchesResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyScheduledMatchesResponse::get_result_for_reflect,
                    CMsgDOTAFantasyScheduledMatchesResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays>>(
                    "scheduled_match_days",
                    CMsgDOTAFantasyScheduledMatchesResponse::get_scheduled_match_days_for_reflect,
                    CMsgDOTAFantasyScheduledMatchesResponse::mut_scheduled_match_days_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyScheduledMatchesResponse>(
                    "CMsgDOTAFantasyScheduledMatchesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyScheduledMatchesResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_scheduled_match_days();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyScheduledMatchesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyScheduledMatchesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays {
    // message fields
    timestamp: ::std::option::Option<u32>,
    team_ids: ::std::vec::Vec<u32>,
    league_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays {}

impl CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays {
    pub fn new() -> CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::new)
        }
    }

    // optional uint32 timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // repeated uint32 team_ids = 2;

    pub fn clear_team_ids(&mut self) {
        self.team_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_team_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.team_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_team_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.team_ids
    }

    // Take field
    pub fn take_team_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.team_ids, ::std::vec::Vec::new())
    }

    pub fn get_team_ids(&self) -> &[u32] {
        &self.team_ids
    }

    fn get_team_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.team_ids
    }

    fn mut_team_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.team_ids
    }

    // repeated uint32 league_ids = 3;

    pub fn clear_league_ids(&mut self) {
        self.league_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_league_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.league_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_league_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.league_ids
    }

    // Take field
    pub fn take_league_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.league_ids, ::std::vec::Vec::new())
    }

    pub fn get_league_ids(&self) -> &[u32] {
        &self.league_ids
    }

    fn get_league_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.league_ids
    }

    fn mut_league_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.league_ids
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.team_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.league_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.team_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.league_ids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint32(1, v)?;
        }
        for v in &self.team_ids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.league_ids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays {
    fn new() -> CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays {
        CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::get_timestamp_for_reflect,
                    CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_ids",
                    CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::get_team_ids_for_reflect,
                    CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::mut_team_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_ids",
                    CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::get_league_ids_for_reflect,
                    CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays::mut_league_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays>(
                    "CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_team_ids();
        self.clear_league_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyScheduledMatchesResponse_ScheduledMatchDays {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyScheduledMatchesResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyScheduledMatchesResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyScheduledMatchesResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyScheduledMatchesResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyScheduledMatchesResponse_EResult::ERROR_UNSPECIFIED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyScheduledMatchesResponse_EResult] = &[
            CMsgDOTAFantasyScheduledMatchesResponse_EResult::SUCCESS,
            CMsgDOTAFantasyScheduledMatchesResponse_EResult::ERROR_UNSPECIFIED,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyScheduledMatchesResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyScheduledMatchesResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyScheduledMatchesResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyScheduledMatchesResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeaveLeagueRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    fantasy_team_index: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeaveLeagueRequest {}

impl CMsgDOTAFantasyLeaveLeagueRequest {
    pub fn new() -> CMsgDOTAFantasyLeaveLeagueRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeaveLeagueRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeaveLeagueRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeaveLeagueRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeaveLeagueRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 fantasy_team_index = 2;

    pub fn clear_fantasy_team_index(&mut self) {
        self.fantasy_team_index = ::std::option::Option::None;
    }

    pub fn has_fantasy_team_index(&self) -> bool {
        self.fantasy_team_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_team_index(&mut self, v: u32) {
        self.fantasy_team_index = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_team_index(&self) -> u32 {
        self.fantasy_team_index.unwrap_or(0)
    }

    fn get_fantasy_team_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_team_index
    }

    fn mut_fantasy_team_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_team_index
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeaveLeagueRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_team_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fantasy_team_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fantasy_team_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeaveLeagueRequest {
    fn new() -> CMsgDOTAFantasyLeaveLeagueRequest {
        CMsgDOTAFantasyLeaveLeagueRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeaveLeagueRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyLeaveLeagueRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyLeaveLeagueRequest::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_team_index",
                    CMsgDOTAFantasyLeaveLeagueRequest::get_fantasy_team_index_for_reflect,
                    CMsgDOTAFantasyLeaveLeagueRequest::mut_fantasy_team_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeaveLeagueRequest>(
                    "CMsgDOTAFantasyLeaveLeagueRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeaveLeagueRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_fantasy_team_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeaveLeagueRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeaveLeagueRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyLeaveLeagueResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyLeaveLeagueResponse_EResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyLeaveLeagueResponse {}

impl CMsgDOTAFantasyLeaveLeagueResponse {
    pub fn new() -> CMsgDOTAFantasyLeaveLeagueResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyLeaveLeagueResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyLeaveLeagueResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyLeaveLeagueResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyLeaveLeagueResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyLeaveLeagueResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyLeaveLeagueResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyLeaveLeagueResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyLeaveLeagueResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyLeaveLeagueResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyLeaveLeagueResponse_EResult> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyLeaveLeagueResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyLeaveLeagueResponse {
    fn new() -> CMsgDOTAFantasyLeaveLeagueResponse {
        CMsgDOTAFantasyLeaveLeagueResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeaveLeagueResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyLeaveLeagueResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyLeaveLeagueResponse::get_result_for_reflect,
                    CMsgDOTAFantasyLeaveLeagueResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyLeaveLeagueResponse>(
                    "CMsgDOTAFantasyLeaveLeagueResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyLeaveLeagueResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyLeaveLeagueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeaveLeagueResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyLeaveLeagueResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_NOT_MEMBER = 2,
    ERROR_LEAGUE_NOT_FOUND = 3,
    ERROR_DRAFT_ACTIVE = 4,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyLeaveLeagueResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyLeaveLeagueResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyLeaveLeagueResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyLeaveLeagueResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyLeaveLeagueResponse_EResult::ERROR_NOT_MEMBER),
            3 => ::std::option::Option::Some(CMsgDOTAFantasyLeaveLeagueResponse_EResult::ERROR_LEAGUE_NOT_FOUND),
            4 => ::std::option::Option::Some(CMsgDOTAFantasyLeaveLeagueResponse_EResult::ERROR_DRAFT_ACTIVE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyLeaveLeagueResponse_EResult] = &[
            CMsgDOTAFantasyLeaveLeagueResponse_EResult::SUCCESS,
            CMsgDOTAFantasyLeaveLeagueResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyLeaveLeagueResponse_EResult::ERROR_NOT_MEMBER,
            CMsgDOTAFantasyLeaveLeagueResponse_EResult::ERROR_LEAGUE_NOT_FOUND,
            CMsgDOTAFantasyLeaveLeagueResponse_EResult::ERROR_DRAFT_ACTIVE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyLeaveLeagueResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyLeaveLeagueResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyLeaveLeagueResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyLeaveLeagueResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyPlayerScoreDetailsRequest {
    // message fields
    fantasy_league_id: ::std::option::Option<u32>,
    player_account_id: ::std::option::Option<u32>,
    start_time: ::std::option::Option<u32>,
    end_time: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyPlayerScoreDetailsRequest {}

impl CMsgDOTAFantasyPlayerScoreDetailsRequest {
    pub fn new() -> CMsgDOTAFantasyPlayerScoreDetailsRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyPlayerScoreDetailsRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyPlayerScoreDetailsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyPlayerScoreDetailsRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyPlayerScoreDetailsRequest::new)
        }
    }

    // optional uint32 fantasy_league_id = 1;

    pub fn clear_fantasy_league_id(&mut self) {
        self.fantasy_league_id = ::std::option::Option::None;
    }

    pub fn has_fantasy_league_id(&self) -> bool {
        self.fantasy_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_league_id(&mut self, v: u32) {
        self.fantasy_league_id = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_league_id(&self) -> u32 {
        self.fantasy_league_id.unwrap_or(0)
    }

    fn get_fantasy_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_league_id
    }

    fn mut_fantasy_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_league_id
    }

    // optional uint32 player_account_id = 2;

    pub fn clear_player_account_id(&mut self) {
        self.player_account_id = ::std::option::Option::None;
    }

    pub fn has_player_account_id(&self) -> bool {
        self.player_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_account_id(&mut self, v: u32) {
        self.player_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_account_id(&self) -> u32 {
        self.player_account_id.unwrap_or(0)
    }

    fn get_player_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_account_id
    }

    fn mut_player_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_account_id
    }

    // optional uint32 start_time = 3;

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    pub fn get_start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    fn get_start_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.start_time
    }

    fn mut_start_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.start_time
    }

    // optional uint32 end_time = 4;

    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: u32) {
        self.end_time = ::std::option::Option::Some(v);
    }

    pub fn get_end_time(&self) -> u32 {
        self.end_time.unwrap_or(0)
    }

    fn get_end_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.end_time
    }

    fn mut_end_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.end_time
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerScoreDetailsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.end_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fantasy_league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end_time {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fantasy_league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyPlayerScoreDetailsRequest {
    fn new() -> CMsgDOTAFantasyPlayerScoreDetailsRequest {
        CMsgDOTAFantasyPlayerScoreDetailsRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerScoreDetailsRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_league_id",
                    CMsgDOTAFantasyPlayerScoreDetailsRequest::get_fantasy_league_id_for_reflect,
                    CMsgDOTAFantasyPlayerScoreDetailsRequest::mut_fantasy_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_account_id",
                    CMsgDOTAFantasyPlayerScoreDetailsRequest::get_player_account_id_for_reflect,
                    CMsgDOTAFantasyPlayerScoreDetailsRequest::mut_player_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "start_time",
                    CMsgDOTAFantasyPlayerScoreDetailsRequest::get_start_time_for_reflect,
                    CMsgDOTAFantasyPlayerScoreDetailsRequest::mut_start_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "end_time",
                    CMsgDOTAFantasyPlayerScoreDetailsRequest::get_end_time_for_reflect,
                    CMsgDOTAFantasyPlayerScoreDetailsRequest::mut_end_time_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyPlayerScoreDetailsRequest>(
                    "CMsgDOTAFantasyPlayerScoreDetailsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyPlayerScoreDetailsRequest {
    fn clear(&mut self) {
        self.clear_fantasy_league_id();
        self.clear_player_account_id();
        self.clear_start_time();
        self.clear_end_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyPlayerScoreDetailsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerScoreDetailsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyPlayerScoreDetailsResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult>,
    data: ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyPlayerScoreDetailsResponse {}

impl CMsgDOTAFantasyPlayerScoreDetailsResponse {
    pub fn new() -> CMsgDOTAFantasyPlayerScoreDetailsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyPlayerScoreDetailsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyPlayerScoreDetailsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyPlayerScoreDetailsResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyPlayerScoreDetailsResponse::new)
        }
    }

    // optional .CMsgDOTAFantasyPlayerScoreDetailsResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult> {
        &mut self.result
    }

    // repeated .CMsgDOTAFantasyPlayerScoreDetailsResponse.PlayerMatchData data = 2;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }

    pub fn get_data(&self) -> &[CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData] {
        &self.data
    }

    fn get_data_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData> {
        &mut self.data
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerScoreDetailsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        for v in &self.data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyPlayerScoreDetailsResponse {
    fn new() -> CMsgDOTAFantasyPlayerScoreDetailsResponse {
        CMsgDOTAFantasyPlayerScoreDetailsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerScoreDetailsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult>>(
                    "result",
                    CMsgDOTAFantasyPlayerScoreDetailsResponse::get_result_for_reflect,
                    CMsgDOTAFantasyPlayerScoreDetailsResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData>>(
                    "data",
                    CMsgDOTAFantasyPlayerScoreDetailsResponse::get_data_for_reflect,
                    CMsgDOTAFantasyPlayerScoreDetailsResponse::mut_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyPlayerScoreDetailsResponse>(
                    "CMsgDOTAFantasyPlayerScoreDetailsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyPlayerScoreDetailsResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyPlayerScoreDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerScoreDetailsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData {
    // message fields
    match_id: ::std::option::Option<u64>,
    series_id: ::std::option::Option<u32>,
    series_num: ::std::option::Option<u32>,
    series_type: ::std::option::Option<u32>,
    league_tier: ::std::option::Option<u32>,
    league_id: ::std::option::Option<u32>,
    opposing_team_id: ::std::option::Option<u32>,
    opposing_team_logo: ::std::option::Option<u64>,
    opposing_team_name: ::protobuf::SingularField<::std::string::String>,
    owned_by: ::std::option::Option<u32>,
    benched: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData {}

impl CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData {
    pub fn new() -> CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData,
        };
        unsafe {
            instance.get(CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 series_id = 2;

    pub fn clear_series_id(&mut self) {
        self.series_id = ::std::option::Option::None;
    }

    pub fn has_series_id(&self) -> bool {
        self.series_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_id(&mut self, v: u32) {
        self.series_id = ::std::option::Option::Some(v);
    }

    pub fn get_series_id(&self) -> u32 {
        self.series_id.unwrap_or(0)
    }

    fn get_series_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.series_id
    }

    fn mut_series_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.series_id
    }

    // optional uint32 series_num = 3;

    pub fn clear_series_num(&mut self) {
        self.series_num = ::std::option::Option::None;
    }

    pub fn has_series_num(&self) -> bool {
        self.series_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_num(&mut self, v: u32) {
        self.series_num = ::std::option::Option::Some(v);
    }

    pub fn get_series_num(&self) -> u32 {
        self.series_num.unwrap_or(0)
    }

    fn get_series_num_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.series_num
    }

    fn mut_series_num_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.series_num
    }

    // optional uint32 series_type = 4;

    pub fn clear_series_type(&mut self) {
        self.series_type = ::std::option::Option::None;
    }

    pub fn has_series_type(&self) -> bool {
        self.series_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_type(&mut self, v: u32) {
        self.series_type = ::std::option::Option::Some(v);
    }

    pub fn get_series_type(&self) -> u32 {
        self.series_type.unwrap_or(0)
    }

    fn get_series_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.series_type
    }

    fn mut_series_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.series_type
    }

    // optional uint32 league_tier = 5;

    pub fn clear_league_tier(&mut self) {
        self.league_tier = ::std::option::Option::None;
    }

    pub fn has_league_tier(&self) -> bool {
        self.league_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_tier(&mut self, v: u32) {
        self.league_tier = ::std::option::Option::Some(v);
    }

    pub fn get_league_tier(&self) -> u32 {
        self.league_tier.unwrap_or(0)
    }

    fn get_league_tier_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_tier
    }

    fn mut_league_tier_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_tier
    }

    // optional uint32 league_id = 6;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional uint32 opposing_team_id = 7;

    pub fn clear_opposing_team_id(&mut self) {
        self.opposing_team_id = ::std::option::Option::None;
    }

    pub fn has_opposing_team_id(&self) -> bool {
        self.opposing_team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opposing_team_id(&mut self, v: u32) {
        self.opposing_team_id = ::std::option::Option::Some(v);
    }

    pub fn get_opposing_team_id(&self) -> u32 {
        self.opposing_team_id.unwrap_or(0)
    }

    fn get_opposing_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.opposing_team_id
    }

    fn mut_opposing_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.opposing_team_id
    }

    // optional uint64 opposing_team_logo = 8;

    pub fn clear_opposing_team_logo(&mut self) {
        self.opposing_team_logo = ::std::option::Option::None;
    }

    pub fn has_opposing_team_logo(&self) -> bool {
        self.opposing_team_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opposing_team_logo(&mut self, v: u64) {
        self.opposing_team_logo = ::std::option::Option::Some(v);
    }

    pub fn get_opposing_team_logo(&self) -> u64 {
        self.opposing_team_logo.unwrap_or(0)
    }

    fn get_opposing_team_logo_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.opposing_team_logo
    }

    fn mut_opposing_team_logo_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.opposing_team_logo
    }

    // optional string opposing_team_name = 9;

    pub fn clear_opposing_team_name(&mut self) {
        self.opposing_team_name.clear();
    }

    pub fn has_opposing_team_name(&self) -> bool {
        self.opposing_team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opposing_team_name(&mut self, v: ::std::string::String) {
        self.opposing_team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_opposing_team_name(&mut self) -> &mut ::std::string::String {
        if self.opposing_team_name.is_none() {
            self.opposing_team_name.set_default();
        }
        self.opposing_team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_opposing_team_name(&mut self) -> ::std::string::String {
        self.opposing_team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_opposing_team_name(&self) -> &str {
        match self.opposing_team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_opposing_team_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.opposing_team_name
    }

    fn mut_opposing_team_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.opposing_team_name
    }

    // optional uint32 owned_by = 11;

    pub fn clear_owned_by(&mut self) {
        self.owned_by = ::std::option::Option::None;
    }

    pub fn has_owned_by(&self) -> bool {
        self.owned_by.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owned_by(&mut self, v: u32) {
        self.owned_by = ::std::option::Option::Some(v);
    }

    pub fn get_owned_by(&self) -> u32 {
        self.owned_by.unwrap_or(0)
    }

    fn get_owned_by_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.owned_by
    }

    fn mut_owned_by_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.owned_by
    }

    // optional bool benched = 12;

    pub fn clear_benched(&mut self) {
        self.benched = ::std::option::Option::None;
    }

    pub fn has_benched(&self) -> bool {
        self.benched.is_some()
    }

    // Param is passed by value, moved
    pub fn set_benched(&mut self, v: bool) {
        self.benched = ::std::option::Option::Some(v);
    }

    pub fn get_benched(&self) -> bool {
        self.benched.unwrap_or(false)
    }

    fn get_benched_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.benched
    }

    fn mut_benched_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.benched
    }
}

impl ::protobuf::Message for CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.series_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.series_num = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.series_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_tier = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.opposing_team_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.opposing_team_logo = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.opposing_team_name)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owned_by = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.benched = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.series_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.series_num {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.series_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.league_tier {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.opposing_team_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.opposing_team_logo {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.opposing_team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.owned_by {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.benched {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.series_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.series_num {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.series_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.league_tier {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.opposing_team_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.opposing_team_logo {
            os.write_uint64(8, v)?;
        }
        if let Some(ref v) = self.opposing_team_name.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.owned_by {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.benched {
            os.write_bool(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData {
    fn new() -> CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData {
        CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::get_match_id_for_reflect,
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "series_id",
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::get_series_id_for_reflect,
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::mut_series_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "series_num",
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::get_series_num_for_reflect,
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::mut_series_num_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "series_type",
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::get_series_type_for_reflect,
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::mut_series_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_tier",
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::get_league_tier_for_reflect,
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::mut_league_tier_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::get_league_id_for_reflect,
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "opposing_team_id",
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::get_opposing_team_id_for_reflect,
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::mut_opposing_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "opposing_team_logo",
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::get_opposing_team_logo_for_reflect,
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::mut_opposing_team_logo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "opposing_team_name",
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::get_opposing_team_name_for_reflect,
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::mut_opposing_team_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "owned_by",
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::get_owned_by_for_reflect,
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::mut_owned_by_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "benched",
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::get_benched_for_reflect,
                    CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData::mut_benched_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData>(
                    "CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_series_id();
        self.clear_series_num();
        self.clear_series_type();
        self.clear_league_tier();
        self.clear_league_id();
        self.clear_opposing_team_id();
        self.clear_opposing_team_logo();
        self.clear_opposing_team_name();
        self.clear_owned_by();
        self.clear_benched();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerScoreDetailsResponse_PlayerMatchData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_NOT_MEMBER = 2,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult::ERROR_NOT_MEMBER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult] = &[
            CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult::SUCCESS,
            CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult::ERROR_UNSPECIFIED,
            CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult::ERROR_NOT_MEMBER,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFantasyPlayerScoreDetailsResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAPassportVoteTeamGuess {
    // message fields
    league_id: ::std::option::Option<u32>,
    winner_id: ::std::option::Option<u32>,
    runnerup_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAPassportVoteTeamGuess {}

impl CMsgDOTAPassportVoteTeamGuess {
    pub fn new() -> CMsgDOTAPassportVoteTeamGuess {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAPassportVoteTeamGuess {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAPassportVoteTeamGuess> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAPassportVoteTeamGuess,
        };
        unsafe {
            instance.get(CMsgDOTAPassportVoteTeamGuess::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional uint32 winner_id = 2;

    pub fn clear_winner_id(&mut self) {
        self.winner_id = ::std::option::Option::None;
    }

    pub fn has_winner_id(&self) -> bool {
        self.winner_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winner_id(&mut self, v: u32) {
        self.winner_id = ::std::option::Option::Some(v);
    }

    pub fn get_winner_id(&self) -> u32 {
        self.winner_id.unwrap_or(0)
    }

    fn get_winner_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.winner_id
    }

    fn mut_winner_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.winner_id
    }

    // optional uint32 runnerup_id = 3;

    pub fn clear_runnerup_id(&mut self) {
        self.runnerup_id = ::std::option::Option::None;
    }

    pub fn has_runnerup_id(&self) -> bool {
        self.runnerup_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runnerup_id(&mut self, v: u32) {
        self.runnerup_id = ::std::option::Option::Some(v);
    }

    pub fn get_runnerup_id(&self) -> u32 {
        self.runnerup_id.unwrap_or(0)
    }

    fn get_runnerup_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.runnerup_id
    }

    fn mut_runnerup_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.runnerup_id
    }
}

impl ::protobuf::Message for CMsgDOTAPassportVoteTeamGuess {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.winner_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.runnerup_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.winner_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.runnerup_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.winner_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.runnerup_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAPassportVoteTeamGuess {
    fn new() -> CMsgDOTAPassportVoteTeamGuess {
        CMsgDOTAPassportVoteTeamGuess::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAPassportVoteTeamGuess>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgDOTAPassportVoteTeamGuess::get_league_id_for_reflect,
                    CMsgDOTAPassportVoteTeamGuess::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "winner_id",
                    CMsgDOTAPassportVoteTeamGuess::get_winner_id_for_reflect,
                    CMsgDOTAPassportVoteTeamGuess::mut_winner_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "runnerup_id",
                    CMsgDOTAPassportVoteTeamGuess::get_runnerup_id_for_reflect,
                    CMsgDOTAPassportVoteTeamGuess::mut_runnerup_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAPassportVoteTeamGuess>(
                    "CMsgDOTAPassportVoteTeamGuess",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAPassportVoteTeamGuess {
    fn clear(&mut self) {
        self.clear_league_id();
        self.clear_winner_id();
        self.clear_runnerup_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAPassportVoteTeamGuess {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAPassportVoteTeamGuess {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAPassportVoteGenericSelection {
    // message fields
    selection_index: ::std::option::Option<DOTA_2013PassportSelectionIndices>,
    selection: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAPassportVoteGenericSelection {}

impl CMsgDOTAPassportVoteGenericSelection {
    pub fn new() -> CMsgDOTAPassportVoteGenericSelection {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAPassportVoteGenericSelection {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAPassportVoteGenericSelection> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAPassportVoteGenericSelection,
        };
        unsafe {
            instance.get(CMsgDOTAPassportVoteGenericSelection::new)
        }
    }

    // optional .DOTA_2013PassportSelectionIndices selection_index = 1;

    pub fn clear_selection_index(&mut self) {
        self.selection_index = ::std::option::Option::None;
    }

    pub fn has_selection_index(&self) -> bool {
        self.selection_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_index(&mut self, v: DOTA_2013PassportSelectionIndices) {
        self.selection_index = ::std::option::Option::Some(v);
    }

    pub fn get_selection_index(&self) -> DOTA_2013PassportSelectionIndices {
        self.selection_index.unwrap_or(DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_0)
    }

    fn get_selection_index_for_reflect(&self) -> &::std::option::Option<DOTA_2013PassportSelectionIndices> {
        &self.selection_index
    }

    fn mut_selection_index_for_reflect(&mut self) -> &mut ::std::option::Option<DOTA_2013PassportSelectionIndices> {
        &mut self.selection_index
    }

    // optional uint32 selection = 2;

    pub fn clear_selection(&mut self) {
        self.selection = ::std::option::Option::None;
    }

    pub fn has_selection(&self) -> bool {
        self.selection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection(&mut self, v: u32) {
        self.selection = ::std::option::Option::Some(v);
    }

    pub fn get_selection(&self) -> u32 {
        self.selection.unwrap_or(0)
    }

    fn get_selection_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.selection
    }

    fn mut_selection_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.selection
    }
}

impl ::protobuf::Message for CMsgDOTAPassportVoteGenericSelection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.selection_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.selection = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.selection_index {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.selection {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.selection_index {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.selection {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAPassportVoteGenericSelection {
    fn new() -> CMsgDOTAPassportVoteGenericSelection {
        CMsgDOTAPassportVoteGenericSelection::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAPassportVoteGenericSelection>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DOTA_2013PassportSelectionIndices>>(
                    "selection_index",
                    CMsgDOTAPassportVoteGenericSelection::get_selection_index_for_reflect,
                    CMsgDOTAPassportVoteGenericSelection::mut_selection_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "selection",
                    CMsgDOTAPassportVoteGenericSelection::get_selection_for_reflect,
                    CMsgDOTAPassportVoteGenericSelection::mut_selection_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAPassportVoteGenericSelection>(
                    "CMsgDOTAPassportVoteGenericSelection",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAPassportVoteGenericSelection {
    fn clear(&mut self) {
        self.clear_selection_index();
        self.clear_selection();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAPassportVoteGenericSelection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAPassportVoteGenericSelection {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAPassportStampedPlayer {
    // message fields
    steam_id: ::std::option::Option<u64>,
    stamp_level: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAPassportStampedPlayer {}

impl CMsgDOTAPassportStampedPlayer {
    pub fn new() -> CMsgDOTAPassportStampedPlayer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAPassportStampedPlayer {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAPassportStampedPlayer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAPassportStampedPlayer,
        };
        unsafe {
            instance.get(CMsgDOTAPassportStampedPlayer::new)
        }
    }

    // optional uint64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    fn get_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.steam_id
    }

    fn mut_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.steam_id
    }

    // optional uint32 stamp_level = 2;

    pub fn clear_stamp_level(&mut self) {
        self.stamp_level = ::std::option::Option::None;
    }

    pub fn has_stamp_level(&self) -> bool {
        self.stamp_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stamp_level(&mut self, v: u32) {
        self.stamp_level = ::std::option::Option::Some(v);
    }

    pub fn get_stamp_level(&self) -> u32 {
        self.stamp_level.unwrap_or(0)
    }

    fn get_stamp_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.stamp_level
    }

    fn mut_stamp_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.stamp_level
    }
}

impl ::protobuf::Message for CMsgDOTAPassportStampedPlayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stamp_level = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stamp_level {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.stamp_level {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAPassportStampedPlayer {
    fn new() -> CMsgDOTAPassportStampedPlayer {
        CMsgDOTAPassportStampedPlayer::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAPassportStampedPlayer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "steam_id",
                    CMsgDOTAPassportStampedPlayer::get_steam_id_for_reflect,
                    CMsgDOTAPassportStampedPlayer::mut_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stamp_level",
                    CMsgDOTAPassportStampedPlayer::get_stamp_level_for_reflect,
                    CMsgDOTAPassportStampedPlayer::mut_stamp_level_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAPassportStampedPlayer>(
                    "CMsgDOTAPassportStampedPlayer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAPassportStampedPlayer {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_stamp_level();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAPassportStampedPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAPassportStampedPlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAPassportPlayerCardChallenge {
    // message fields
    challenge_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAPassportPlayerCardChallenge {}

impl CMsgDOTAPassportPlayerCardChallenge {
    pub fn new() -> CMsgDOTAPassportPlayerCardChallenge {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAPassportPlayerCardChallenge {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAPassportPlayerCardChallenge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAPassportPlayerCardChallenge,
        };
        unsafe {
            instance.get(CMsgDOTAPassportPlayerCardChallenge::new)
        }
    }

    // optional uint32 challenge_id = 1;

    pub fn clear_challenge_id(&mut self) {
        self.challenge_id = ::std::option::Option::None;
    }

    pub fn has_challenge_id(&self) -> bool {
        self.challenge_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_id(&mut self, v: u32) {
        self.challenge_id = ::std::option::Option::Some(v);
    }

    pub fn get_challenge_id(&self) -> u32 {
        self.challenge_id.unwrap_or(0)
    }

    fn get_challenge_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.challenge_id
    }

    fn mut_challenge_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.challenge_id
    }
}

impl ::protobuf::Message for CMsgDOTAPassportPlayerCardChallenge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.challenge_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.challenge_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.challenge_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAPassportPlayerCardChallenge {
    fn new() -> CMsgDOTAPassportPlayerCardChallenge {
        CMsgDOTAPassportPlayerCardChallenge::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAPassportPlayerCardChallenge>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "challenge_id",
                    CMsgDOTAPassportPlayerCardChallenge::get_challenge_id_for_reflect,
                    CMsgDOTAPassportPlayerCardChallenge::mut_challenge_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAPassportPlayerCardChallenge>(
                    "CMsgDOTAPassportPlayerCardChallenge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAPassportPlayerCardChallenge {
    fn clear(&mut self) {
        self.clear_challenge_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAPassportPlayerCardChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAPassportPlayerCardChallenge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAPassportVote {
    // message fields
    team_votes: ::protobuf::RepeatedField<CMsgDOTAPassportVoteTeamGuess>,
    generic_selections: ::protobuf::RepeatedField<CMsgDOTAPassportVoteGenericSelection>,
    stamped_players: ::protobuf::RepeatedField<CMsgDOTAPassportStampedPlayer>,
    player_card_challenges: ::protobuf::RepeatedField<CMsgDOTAPassportPlayerCardChallenge>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAPassportVote {}

impl CMsgDOTAPassportVote {
    pub fn new() -> CMsgDOTAPassportVote {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAPassportVote {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAPassportVote> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAPassportVote,
        };
        unsafe {
            instance.get(CMsgDOTAPassportVote::new)
        }
    }

    // repeated .CMsgDOTAPassportVoteTeamGuess team_votes = 1;

    pub fn clear_team_votes(&mut self) {
        self.team_votes.clear();
    }

    // Param is passed by value, moved
    pub fn set_team_votes(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAPassportVoteTeamGuess>) {
        self.team_votes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_team_votes(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAPassportVoteTeamGuess> {
        &mut self.team_votes
    }

    // Take field
    pub fn take_team_votes(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAPassportVoteTeamGuess> {
        ::std::mem::replace(&mut self.team_votes, ::protobuf::RepeatedField::new())
    }

    pub fn get_team_votes(&self) -> &[CMsgDOTAPassportVoteTeamGuess] {
        &self.team_votes
    }

    fn get_team_votes_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAPassportVoteTeamGuess> {
        &self.team_votes
    }

    fn mut_team_votes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAPassportVoteTeamGuess> {
        &mut self.team_votes
    }

    // repeated .CMsgDOTAPassportVoteGenericSelection generic_selections = 2;

    pub fn clear_generic_selections(&mut self) {
        self.generic_selections.clear();
    }

    // Param is passed by value, moved
    pub fn set_generic_selections(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAPassportVoteGenericSelection>) {
        self.generic_selections = v;
    }

    // Mutable pointer to the field.
    pub fn mut_generic_selections(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAPassportVoteGenericSelection> {
        &mut self.generic_selections
    }

    // Take field
    pub fn take_generic_selections(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAPassportVoteGenericSelection> {
        ::std::mem::replace(&mut self.generic_selections, ::protobuf::RepeatedField::new())
    }

    pub fn get_generic_selections(&self) -> &[CMsgDOTAPassportVoteGenericSelection] {
        &self.generic_selections
    }

    fn get_generic_selections_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAPassportVoteGenericSelection> {
        &self.generic_selections
    }

    fn mut_generic_selections_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAPassportVoteGenericSelection> {
        &mut self.generic_selections
    }

    // repeated .CMsgDOTAPassportStampedPlayer stamped_players = 3;

    pub fn clear_stamped_players(&mut self) {
        self.stamped_players.clear();
    }

    // Param is passed by value, moved
    pub fn set_stamped_players(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAPassportStampedPlayer>) {
        self.stamped_players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stamped_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAPassportStampedPlayer> {
        &mut self.stamped_players
    }

    // Take field
    pub fn take_stamped_players(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAPassportStampedPlayer> {
        ::std::mem::replace(&mut self.stamped_players, ::protobuf::RepeatedField::new())
    }

    pub fn get_stamped_players(&self) -> &[CMsgDOTAPassportStampedPlayer] {
        &self.stamped_players
    }

    fn get_stamped_players_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAPassportStampedPlayer> {
        &self.stamped_players
    }

    fn mut_stamped_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAPassportStampedPlayer> {
        &mut self.stamped_players
    }

    // repeated .CMsgDOTAPassportPlayerCardChallenge player_card_challenges = 4;

    pub fn clear_player_card_challenges(&mut self) {
        self.player_card_challenges.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_card_challenges(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAPassportPlayerCardChallenge>) {
        self.player_card_challenges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_card_challenges(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAPassportPlayerCardChallenge> {
        &mut self.player_card_challenges
    }

    // Take field
    pub fn take_player_card_challenges(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAPassportPlayerCardChallenge> {
        ::std::mem::replace(&mut self.player_card_challenges, ::protobuf::RepeatedField::new())
    }

    pub fn get_player_card_challenges(&self) -> &[CMsgDOTAPassportPlayerCardChallenge] {
        &self.player_card_challenges
    }

    fn get_player_card_challenges_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAPassportPlayerCardChallenge> {
        &self.player_card_challenges
    }

    fn mut_player_card_challenges_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAPassportPlayerCardChallenge> {
        &mut self.player_card_challenges
    }
}

impl ::protobuf::Message for CMsgDOTAPassportVote {
    fn is_initialized(&self) -> bool {
        for v in &self.team_votes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.generic_selections {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stamped_players {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.player_card_challenges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.team_votes)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.generic_selections)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stamped_players)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_card_challenges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.team_votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.generic_selections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.stamped_players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.player_card_challenges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.team_votes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.generic_selections {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.stamped_players {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.player_card_challenges {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAPassportVote {
    fn new() -> CMsgDOTAPassportVote {
        CMsgDOTAPassportVote::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAPassportVote>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAPassportVoteTeamGuess>>(
                    "team_votes",
                    CMsgDOTAPassportVote::get_team_votes_for_reflect,
                    CMsgDOTAPassportVote::mut_team_votes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAPassportVoteGenericSelection>>(
                    "generic_selections",
                    CMsgDOTAPassportVote::get_generic_selections_for_reflect,
                    CMsgDOTAPassportVote::mut_generic_selections_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAPassportStampedPlayer>>(
                    "stamped_players",
                    CMsgDOTAPassportVote::get_stamped_players_for_reflect,
                    CMsgDOTAPassportVote::mut_stamped_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAPassportPlayerCardChallenge>>(
                    "player_card_challenges",
                    CMsgDOTAPassportVote::get_player_card_challenges_for_reflect,
                    CMsgDOTAPassportVote::mut_player_card_challenges_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAPassportVote>(
                    "CMsgDOTAPassportVote",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAPassportVote {
    fn clear(&mut self) {
        self.clear_team_votes();
        self.clear_generic_selections();
        self.clear_stamped_players();
        self.clear_player_card_challenges();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAPassportVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAPassportVote {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetPlayerCardRosterRequest {
    // message fields
    league_id: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetPlayerCardRosterRequest {}

impl CMsgClientToGCGetPlayerCardRosterRequest {
    pub fn new() -> CMsgClientToGCGetPlayerCardRosterRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetPlayerCardRosterRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetPlayerCardRosterRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetPlayerCardRosterRequest,
        };
        unsafe {
            instance.get(CMsgClientToGCGetPlayerCardRosterRequest::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional uint32 timestamp = 2;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }
}

impl ::protobuf::Message for CMsgClientToGCGetPlayerCardRosterRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetPlayerCardRosterRequest {
    fn new() -> CMsgClientToGCGetPlayerCardRosterRequest {
        CMsgClientToGCGetPlayerCardRosterRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetPlayerCardRosterRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgClientToGCGetPlayerCardRosterRequest::get_league_id_for_reflect,
                    CMsgClientToGCGetPlayerCardRosterRequest::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgClientToGCGetPlayerCardRosterRequest::get_timestamp_for_reflect,
                    CMsgClientToGCGetPlayerCardRosterRequest::mut_timestamp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetPlayerCardRosterRequest>(
                    "CMsgClientToGCGetPlayerCardRosterRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetPlayerCardRosterRequest {
    fn clear(&mut self) {
        self.clear_league_id();
        self.clear_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetPlayerCardRosterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetPlayerCardRosterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetPlayerCardRosterResponse {
    // message fields
    result: ::std::option::Option<CMsgClientToGCGetPlayerCardRosterResponse_Result>,
    player_card_item_id: ::std::vec::Vec<u64>,
    score: ::std::option::Option<f32>,
    finalized: ::std::option::Option<bool>,
    percentile: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetPlayerCardRosterResponse {}

impl CMsgClientToGCGetPlayerCardRosterResponse {
    pub fn new() -> CMsgClientToGCGetPlayerCardRosterResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetPlayerCardRosterResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetPlayerCardRosterResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetPlayerCardRosterResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCGetPlayerCardRosterResponse::new)
        }
    }

    // optional .CMsgClientToGCGetPlayerCardRosterResponse.Result result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgClientToGCGetPlayerCardRosterResponse_Result) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgClientToGCGetPlayerCardRosterResponse_Result {
        self.result.unwrap_or(CMsgClientToGCGetPlayerCardRosterResponse_Result::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgClientToGCGetPlayerCardRosterResponse_Result> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgClientToGCGetPlayerCardRosterResponse_Result> {
        &mut self.result
    }

    // repeated uint64 player_card_item_id = 2;

    pub fn clear_player_card_item_id(&mut self) {
        self.player_card_item_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_card_item_id(&mut self, v: ::std::vec::Vec<u64>) {
        self.player_card_item_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_card_item_id(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.player_card_item_id
    }

    // Take field
    pub fn take_player_card_item_id(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.player_card_item_id, ::std::vec::Vec::new())
    }

    pub fn get_player_card_item_id(&self) -> &[u64] {
        &self.player_card_item_id
    }

    fn get_player_card_item_id_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.player_card_item_id
    }

    fn mut_player_card_item_id_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.player_card_item_id
    }

    // optional float score = 3;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score(&self) -> f32 {
        self.score.unwrap_or(0.)
    }

    fn get_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.score
    }

    fn mut_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.score
    }

    // optional bool finalized = 4;

    pub fn clear_finalized(&mut self) {
        self.finalized = ::std::option::Option::None;
    }

    pub fn has_finalized(&self) -> bool {
        self.finalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finalized(&mut self, v: bool) {
        self.finalized = ::std::option::Option::Some(v);
    }

    pub fn get_finalized(&self) -> bool {
        self.finalized.unwrap_or(false)
    }

    fn get_finalized_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.finalized
    }

    fn mut_finalized_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.finalized
    }

    // optional float percentile = 5;

    pub fn clear_percentile(&mut self) {
        self.percentile = ::std::option::Option::None;
    }

    pub fn has_percentile(&self) -> bool {
        self.percentile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_percentile(&mut self, v: f32) {
        self.percentile = ::std::option::Option::Some(v);
    }

    pub fn get_percentile(&self) -> f32 {
        self.percentile.unwrap_or(0.)
    }

    fn get_percentile_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.percentile
    }

    fn mut_percentile_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.percentile
    }
}

impl ::protobuf::Message for CMsgClientToGCGetPlayerCardRosterResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.player_card_item_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.finalized = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.percentile = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.player_card_item_id {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.score {
            my_size += 5;
        }
        if let Some(v) = self.finalized {
            my_size += 2;
        }
        if let Some(v) = self.percentile {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        for v in &self.player_card_item_id {
            os.write_uint64(2, *v)?;
        };
        if let Some(v) = self.score {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.finalized {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.percentile {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetPlayerCardRosterResponse {
    fn new() -> CMsgClientToGCGetPlayerCardRosterResponse {
        CMsgClientToGCGetPlayerCardRosterResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetPlayerCardRosterResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgClientToGCGetPlayerCardRosterResponse_Result>>(
                    "result",
                    CMsgClientToGCGetPlayerCardRosterResponse::get_result_for_reflect,
                    CMsgClientToGCGetPlayerCardRosterResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "player_card_item_id",
                    CMsgClientToGCGetPlayerCardRosterResponse::get_player_card_item_id_for_reflect,
                    CMsgClientToGCGetPlayerCardRosterResponse::mut_player_card_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "score",
                    CMsgClientToGCGetPlayerCardRosterResponse::get_score_for_reflect,
                    CMsgClientToGCGetPlayerCardRosterResponse::mut_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "finalized",
                    CMsgClientToGCGetPlayerCardRosterResponse::get_finalized_for_reflect,
                    CMsgClientToGCGetPlayerCardRosterResponse::mut_finalized_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "percentile",
                    CMsgClientToGCGetPlayerCardRosterResponse::get_percentile_for_reflect,
                    CMsgClientToGCGetPlayerCardRosterResponse::mut_percentile_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetPlayerCardRosterResponse>(
                    "CMsgClientToGCGetPlayerCardRosterResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetPlayerCardRosterResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_player_card_item_id();
        self.clear_score();
        self.clear_finalized();
        self.clear_percentile();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetPlayerCardRosterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetPlayerCardRosterResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgClientToGCGetPlayerCardRosterResponse_Result {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_INVALID_LEAGUE_ID = 2,
    ERROR_INVALID_TIMESTAMP = 3,
}

impl ::protobuf::ProtobufEnum for CMsgClientToGCGetPlayerCardRosterResponse_Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgClientToGCGetPlayerCardRosterResponse_Result> {
        match value {
            0 => ::std::option::Option::Some(CMsgClientToGCGetPlayerCardRosterResponse_Result::SUCCESS),
            1 => ::std::option::Option::Some(CMsgClientToGCGetPlayerCardRosterResponse_Result::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgClientToGCGetPlayerCardRosterResponse_Result::ERROR_INVALID_LEAGUE_ID),
            3 => ::std::option::Option::Some(CMsgClientToGCGetPlayerCardRosterResponse_Result::ERROR_INVALID_TIMESTAMP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgClientToGCGetPlayerCardRosterResponse_Result] = &[
            CMsgClientToGCGetPlayerCardRosterResponse_Result::SUCCESS,
            CMsgClientToGCGetPlayerCardRosterResponse_Result::ERROR_UNSPECIFIED,
            CMsgClientToGCGetPlayerCardRosterResponse_Result::ERROR_INVALID_LEAGUE_ID,
            CMsgClientToGCGetPlayerCardRosterResponse_Result::ERROR_INVALID_TIMESTAMP,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgClientToGCGetPlayerCardRosterResponse_Result>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgClientToGCGetPlayerCardRosterResponse_Result", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgClientToGCGetPlayerCardRosterResponse_Result {
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetPlayerCardRosterResponse_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCSetPlayerCardRosterRequest {
    // message fields
    league_id: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    slot: ::std::option::Option<u32>,
    player_card_item_id: ::std::option::Option<u64>,
    event_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCSetPlayerCardRosterRequest {}

impl CMsgClientToGCSetPlayerCardRosterRequest {
    pub fn new() -> CMsgClientToGCSetPlayerCardRosterRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCSetPlayerCardRosterRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCSetPlayerCardRosterRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCSetPlayerCardRosterRequest,
        };
        unsafe {
            instance.get(CMsgClientToGCSetPlayerCardRosterRequest::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional uint32 timestamp = 2;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional uint32 slot = 3;

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: u32) {
        self.slot = ::std::option::Option::Some(v);
    }

    pub fn get_slot(&self) -> u32 {
        self.slot.unwrap_or(0)
    }

    fn get_slot_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot
    }

    fn mut_slot_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot
    }

    // optional uint64 player_card_item_id = 4;

    pub fn clear_player_card_item_id(&mut self) {
        self.player_card_item_id = ::std::option::Option::None;
    }

    pub fn has_player_card_item_id(&self) -> bool {
        self.player_card_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_card_item_id(&mut self, v: u64) {
        self.player_card_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_card_item_id(&self) -> u64 {
        self.player_card_item_id.unwrap_or(0)
    }

    fn get_player_card_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.player_card_item_id
    }

    fn mut_player_card_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.player_card_item_id
    }

    // optional uint32 event_id = 5;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }
}

impl ::protobuf::Message for CMsgClientToGCSetPlayerCardRosterRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.player_card_item_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_card_item_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.slot {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.player_card_item_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCSetPlayerCardRosterRequest {
    fn new() -> CMsgClientToGCSetPlayerCardRosterRequest {
        CMsgClientToGCSetPlayerCardRosterRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCSetPlayerCardRosterRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgClientToGCSetPlayerCardRosterRequest::get_league_id_for_reflect,
                    CMsgClientToGCSetPlayerCardRosterRequest::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgClientToGCSetPlayerCardRosterRequest::get_timestamp_for_reflect,
                    CMsgClientToGCSetPlayerCardRosterRequest::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot",
                    CMsgClientToGCSetPlayerCardRosterRequest::get_slot_for_reflect,
                    CMsgClientToGCSetPlayerCardRosterRequest::mut_slot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "player_card_item_id",
                    CMsgClientToGCSetPlayerCardRosterRequest::get_player_card_item_id_for_reflect,
                    CMsgClientToGCSetPlayerCardRosterRequest::mut_player_card_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgClientToGCSetPlayerCardRosterRequest::get_event_id_for_reflect,
                    CMsgClientToGCSetPlayerCardRosterRequest::mut_event_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCSetPlayerCardRosterRequest>(
                    "CMsgClientToGCSetPlayerCardRosterRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCSetPlayerCardRosterRequest {
    fn clear(&mut self) {
        self.clear_league_id();
        self.clear_timestamp();
        self.clear_slot();
        self.clear_player_card_item_id();
        self.clear_event_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCSetPlayerCardRosterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetPlayerCardRosterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCSetPlayerCardRosterResponse {
    // message fields
    result: ::std::option::Option<CMsgClientToGCSetPlayerCardRosterResponse_Result>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCSetPlayerCardRosterResponse {}

impl CMsgClientToGCSetPlayerCardRosterResponse {
    pub fn new() -> CMsgClientToGCSetPlayerCardRosterResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCSetPlayerCardRosterResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCSetPlayerCardRosterResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCSetPlayerCardRosterResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCSetPlayerCardRosterResponse::new)
        }
    }

    // optional .CMsgClientToGCSetPlayerCardRosterResponse.Result result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgClientToGCSetPlayerCardRosterResponse_Result) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgClientToGCSetPlayerCardRosterResponse_Result {
        self.result.unwrap_or(CMsgClientToGCSetPlayerCardRosterResponse_Result::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgClientToGCSetPlayerCardRosterResponse_Result> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgClientToGCSetPlayerCardRosterResponse_Result> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgClientToGCSetPlayerCardRosterResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCSetPlayerCardRosterResponse {
    fn new() -> CMsgClientToGCSetPlayerCardRosterResponse {
        CMsgClientToGCSetPlayerCardRosterResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCSetPlayerCardRosterResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgClientToGCSetPlayerCardRosterResponse_Result>>(
                    "result",
                    CMsgClientToGCSetPlayerCardRosterResponse::get_result_for_reflect,
                    CMsgClientToGCSetPlayerCardRosterResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCSetPlayerCardRosterResponse>(
                    "CMsgClientToGCSetPlayerCardRosterResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCSetPlayerCardRosterResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCSetPlayerCardRosterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetPlayerCardRosterResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgClientToGCSetPlayerCardRosterResponse_Result {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_INVALID_LEAGUE_ID = 2,
    ERROR_INVALID_TIMESTAMP = 3,
    ERROR_PLAYER_CARD_NOT_OWNED = 4,
    ERROR_INVALID_SLOT = 5,
    ERROR_FAILED_CARD_INFO = 6,
    ERROR_ACCOUNT_DUPLICATE = 7,
    ERROR_LOCKED_TIMESTAMP = 8,
}

impl ::protobuf::ProtobufEnum for CMsgClientToGCSetPlayerCardRosterResponse_Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgClientToGCSetPlayerCardRosterResponse_Result> {
        match value {
            0 => ::std::option::Option::Some(CMsgClientToGCSetPlayerCardRosterResponse_Result::SUCCESS),
            1 => ::std::option::Option::Some(CMsgClientToGCSetPlayerCardRosterResponse_Result::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgClientToGCSetPlayerCardRosterResponse_Result::ERROR_INVALID_LEAGUE_ID),
            3 => ::std::option::Option::Some(CMsgClientToGCSetPlayerCardRosterResponse_Result::ERROR_INVALID_TIMESTAMP),
            4 => ::std::option::Option::Some(CMsgClientToGCSetPlayerCardRosterResponse_Result::ERROR_PLAYER_CARD_NOT_OWNED),
            5 => ::std::option::Option::Some(CMsgClientToGCSetPlayerCardRosterResponse_Result::ERROR_INVALID_SLOT),
            6 => ::std::option::Option::Some(CMsgClientToGCSetPlayerCardRosterResponse_Result::ERROR_FAILED_CARD_INFO),
            7 => ::std::option::Option::Some(CMsgClientToGCSetPlayerCardRosterResponse_Result::ERROR_ACCOUNT_DUPLICATE),
            8 => ::std::option::Option::Some(CMsgClientToGCSetPlayerCardRosterResponse_Result::ERROR_LOCKED_TIMESTAMP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgClientToGCSetPlayerCardRosterResponse_Result] = &[
            CMsgClientToGCSetPlayerCardRosterResponse_Result::SUCCESS,
            CMsgClientToGCSetPlayerCardRosterResponse_Result::ERROR_UNSPECIFIED,
            CMsgClientToGCSetPlayerCardRosterResponse_Result::ERROR_INVALID_LEAGUE_ID,
            CMsgClientToGCSetPlayerCardRosterResponse_Result::ERROR_INVALID_TIMESTAMP,
            CMsgClientToGCSetPlayerCardRosterResponse_Result::ERROR_PLAYER_CARD_NOT_OWNED,
            CMsgClientToGCSetPlayerCardRosterResponse_Result::ERROR_INVALID_SLOT,
            CMsgClientToGCSetPlayerCardRosterResponse_Result::ERROR_FAILED_CARD_INFO,
            CMsgClientToGCSetPlayerCardRosterResponse_Result::ERROR_ACCOUNT_DUPLICATE,
            CMsgClientToGCSetPlayerCardRosterResponse_Result::ERROR_LOCKED_TIMESTAMP,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgClientToGCSetPlayerCardRosterResponse_Result>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgClientToGCSetPlayerCardRosterResponse_Result", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgClientToGCSetPlayerCardRosterResponse_Result {
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetPlayerCardRosterResponse_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DOTA_2013PassportSelectionIndices {
    PP13_SEL_ALLSTAR_PLAYER_0 = 0,
    PP13_SEL_ALLSTAR_PLAYER_1 = 1,
    PP13_SEL_ALLSTAR_PLAYER_2 = 2,
    PP13_SEL_ALLSTAR_PLAYER_3 = 3,
    PP13_SEL_ALLSTAR_PLAYER_4 = 4,
    PP13_SEL_ALLSTAR_PLAYER_5 = 5,
    PP13_SEL_ALLSTAR_PLAYER_6 = 6,
    PP13_SEL_ALLSTAR_PLAYER_7 = 7,
    PP13_SEL_ALLSTAR_PLAYER_8 = 8,
    PP13_SEL_ALLSTAR_PLAYER_9 = 9,
    PP13_SEL_QUALPRED_WEST_0 = 10,
    PP13_SEL_QUALPRED_WEST_1 = 11,
    PP13_SEL_QUALPRED_WEST_2 = 12,
    PP13_SEL_QUALPRED_WEST_3 = 13,
    PP13_SEL_QUALPRED_WEST_4 = 14,
    PP13_SEL_QUALPRED_WEST_5 = 15,
    PP13_SEL_QUALPRED_WEST_6 = 16,
    PP13_SEL_QUALPRED_WEST_7 = 17,
    PP13_SEL_QUALPRED_WEST_8 = 18,
    PP13_SEL_QUALPRED_WEST_9 = 19,
    PP13_SEL_QUALPRED_WEST_10 = 20,
    PP13_SEL_QUALPRED_WEST_11 = 21,
    PP13_SEL_QUALPRED_WEST_12 = 22,
    PP13_SEL_QUALPRED_WEST_13 = 23,
    PP13_SEL_QUALPRED_WEST_14 = 24,
    PP13_SEL_QUALPRED_EAST_0 = 25,
    PP13_SEL_QUALPRED_EAST_1 = 26,
    PP13_SEL_QUALPRED_EAST_2 = 27,
    PP13_SEL_QUALPRED_EAST_3 = 28,
    PP13_SEL_QUALPRED_EAST_4 = 29,
    PP13_SEL_QUALPRED_EAST_5 = 30,
    PP13_SEL_QUALPRED_EAST_6 = 31,
    PP13_SEL_QUALPRED_EAST_7 = 32,
    PP13_SEL_QUALPRED_EAST_8 = 33,
    PP13_SEL_QUALPRED_EAST_9 = 34,
    PP13_SEL_QUALPRED_EAST_10 = 35,
    PP13_SEL_QUALPRED_EAST_11 = 36,
    PP13_SEL_QUALPRED_EAST_12 = 37,
    PP13_SEL_QUALPRED_EAST_13 = 38,
    PP13_SEL_QUALPRED_EAST_14 = 39,
    PP13_SEL_TEAMCUP_TEAM = 40,
    PP13_SEL_TEAMCUP_PLAYER = 41,
    PP13_SEL_TEAMCUP_TEAM_LOCK = 42,
    PP13_SEL_TEAMCUP_PLAYER_LOCK = 43,
    PP13_SEL_EVENTPRED_0 = 44,
    PP13_SEL_EVENTPRED_1 = 45,
    PP13_SEL_EVENTPRED_2 = 46,
    PP13_SEL_EVENTPRED_3 = 47,
    PP13_SEL_EVENTPRED_4 = 48,
    PP13_SEL_EVENTPRED_5 = 49,
    PP13_SEL_EVENTPRED_6 = 50,
    PP13_SEL_EVENTPRED_7 = 51,
    PP13_SEL_EVENTPRED_8 = 52,
    PP13_SEL_EVENTPRED_9 = 53,
    PP13_SEL_EVENTPRED_10 = 54,
    PP13_SEL_EVENTPRED_11 = 55,
    PP13_SEL_EVENTPRED_12 = 56,
    PP13_SEL_EVENTPRED_13 = 57,
    PP13_SEL_EVENTPRED_14 = 58,
    PP13_SEL_EVENTPRED_15 = 59,
    PP13_SEL_EVENTPRED_16 = 60,
    PP13_SEL_EVENTPRED_17 = 61,
    PP13_SEL_EVENTPRED_18 = 62,
    PP13_SEL_EVENTPRED_19 = 63,
    PP13_SEL_EVENTPRED_20 = 64,
    PP13_SEL_EVENTPRED_21 = 65,
    PP13_SEL_EVENTPRED_22 = 66,
    PP13_SEL_EVENTPRED_23 = 67,
    PP13_SEL_EVENTPRED_24 = 68,
    PP13_SEL_EVENTPRED_25 = 69,
    PP13_SEL_EVENTPRED_26 = 70,
    PP13_SEL_EVENTPRED_27 = 71,
    PP13_SEL_EVENTPRED_28 = 72,
    PP13_SEL_EVENTPRED_29 = 73,
    PP13_SEL_EVENTPRED_30 = 74,
    PP13_SEL_EVENTPRED_31 = 75,
    PP13_SEL_EVENTPRED_32 = 76,
    PP13_SEL_EVENTPRED_33 = 77,
    PP13_SEL_EVENTPRED_34 = 78,
    PP13_SEL_EVENTPRED_35 = 79,
    PP13_SEL_EVENTPRED_36 = 80,
    PP13_SEL_EVENTPRED_37 = 81,
    PP13_SEL_EVENTPRED_38 = 82,
    PP13_SEL_EVENTPRED_39 = 83,
    PP13_SEL_EVENTPRED_40 = 84,
    PP13_SEL_EVENTPRED_41 = 85,
    PP13_SEL_EVENTPRED_42 = 86,
    PP13_SEL_EVENTPRED_43 = 87,
    PP13_SEL_SOLO_0 = 88,
    PP13_SEL_SOLO_1 = 89,
    PP13_SEL_SOLO_2 = 90,
    PP13_SEL_SOLO_3 = 91,
    PP13_SEL_SOLO_4 = 92,
    PP13_SEL_SOLO_5 = 93,
    PP13_SEL_SOLO_6 = 94,
    PP13_SEL_SOLO_7 = 95,
}

impl ::protobuf::ProtobufEnum for DOTA_2013PassportSelectionIndices {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_2013PassportSelectionIndices> {
        match value {
            0 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_0),
            1 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_1),
            2 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_2),
            3 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_3),
            4 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_4),
            5 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_5),
            6 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_6),
            7 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_7),
            8 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_8),
            9 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_9),
            10 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_0),
            11 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_1),
            12 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_2),
            13 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_3),
            14 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_4),
            15 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_5),
            16 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_6),
            17 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_7),
            18 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_8),
            19 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_9),
            20 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_10),
            21 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_11),
            22 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_12),
            23 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_13),
            24 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_14),
            25 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_0),
            26 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_1),
            27 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_2),
            28 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_3),
            29 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_4),
            30 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_5),
            31 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_6),
            32 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_7),
            33 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_8),
            34 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_9),
            35 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_10),
            36 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_11),
            37 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_12),
            38 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_13),
            39 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_14),
            40 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_TEAMCUP_TEAM),
            41 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_TEAMCUP_PLAYER),
            42 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_TEAMCUP_TEAM_LOCK),
            43 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_TEAMCUP_PLAYER_LOCK),
            44 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_0),
            45 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_1),
            46 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_2),
            47 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_3),
            48 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_4),
            49 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_5),
            50 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_6),
            51 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_7),
            52 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_8),
            53 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_9),
            54 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_10),
            55 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_11),
            56 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_12),
            57 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_13),
            58 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_14),
            59 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_15),
            60 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_16),
            61 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_17),
            62 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_18),
            63 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_19),
            64 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_20),
            65 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_21),
            66 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_22),
            67 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_23),
            68 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_24),
            69 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_25),
            70 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_26),
            71 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_27),
            72 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_28),
            73 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_29),
            74 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_30),
            75 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_31),
            76 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_32),
            77 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_33),
            78 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_34),
            79 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_35),
            80 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_36),
            81 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_37),
            82 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_38),
            83 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_39),
            84 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_40),
            85 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_41),
            86 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_42),
            87 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_43),
            88 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_SOLO_0),
            89 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_SOLO_1),
            90 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_SOLO_2),
            91 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_SOLO_3),
            92 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_SOLO_4),
            93 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_SOLO_5),
            94 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_SOLO_6),
            95 => ::std::option::Option::Some(DOTA_2013PassportSelectionIndices::PP13_SEL_SOLO_7),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DOTA_2013PassportSelectionIndices] = &[
            DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_0,
            DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_1,
            DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_2,
            DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_3,
            DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_4,
            DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_5,
            DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_6,
            DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_7,
            DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_8,
            DOTA_2013PassportSelectionIndices::PP13_SEL_ALLSTAR_PLAYER_9,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_0,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_1,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_2,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_3,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_4,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_5,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_6,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_7,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_8,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_9,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_10,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_11,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_12,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_13,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_WEST_14,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_0,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_1,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_2,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_3,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_4,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_5,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_6,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_7,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_8,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_9,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_10,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_11,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_12,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_13,
            DOTA_2013PassportSelectionIndices::PP13_SEL_QUALPRED_EAST_14,
            DOTA_2013PassportSelectionIndices::PP13_SEL_TEAMCUP_TEAM,
            DOTA_2013PassportSelectionIndices::PP13_SEL_TEAMCUP_PLAYER,
            DOTA_2013PassportSelectionIndices::PP13_SEL_TEAMCUP_TEAM_LOCK,
            DOTA_2013PassportSelectionIndices::PP13_SEL_TEAMCUP_PLAYER_LOCK,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_0,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_1,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_2,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_3,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_4,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_5,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_6,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_7,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_8,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_9,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_10,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_11,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_12,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_13,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_14,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_15,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_16,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_17,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_18,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_19,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_20,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_21,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_22,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_23,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_24,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_25,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_26,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_27,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_28,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_29,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_30,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_31,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_32,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_33,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_34,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_35,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_36,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_37,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_38,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_39,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_40,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_41,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_42,
            DOTA_2013PassportSelectionIndices::PP13_SEL_EVENTPRED_43,
            DOTA_2013PassportSelectionIndices::PP13_SEL_SOLO_0,
            DOTA_2013PassportSelectionIndices::PP13_SEL_SOLO_1,
            DOTA_2013PassportSelectionIndices::PP13_SEL_SOLO_2,
            DOTA_2013PassportSelectionIndices::PP13_SEL_SOLO_3,
            DOTA_2013PassportSelectionIndices::PP13_SEL_SOLO_4,
            DOTA_2013PassportSelectionIndices::PP13_SEL_SOLO_5,
            DOTA_2013PassportSelectionIndices::PP13_SEL_SOLO_6,
            DOTA_2013PassportSelectionIndices::PP13_SEL_SOLO_7,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<DOTA_2013PassportSelectionIndices>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DOTA_2013PassportSelectionIndices", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DOTA_2013PassportSelectionIndices {
}

impl ::protobuf::reflect::ProtobufValue for DOTA_2013PassportSelectionIndices {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$dota_gcmessages_client_fantasy.proto\x1a\x17dota_shared_enums.proto\"\
    \xd6\x04\n\x10CMsgGCPlayerInfo\x12?\n\x0cplayer_infos\x18\x01\x20\x03(\
    \x0b2\x1c.CMsgGCPlayerInfo.PlayerInfoR\x0bplayerInfos\x12G\n\x0cleaderbo\
    ards\x18\x02\x20\x03(\x0b2#.CMsgGCPlayerInfo.RegionLeaderboardR\x0cleade\
    rboards\x1a\xe5\x02\n\nPlayerInfo\x12\x1d\n\naccount_id\x18\x01\x20\x01(\
    \rR\taccountId\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12!\n\x0cc\
    ountry_code\x18\x03\x20\x01(\tR\x0bcountryCode\x12!\n\x0cfantasy_role\
    \x18\x04\x20\x01(\rR\x0bfantasyRole\x12\x17\n\x07team_id\x18\x05\x20\x01\
    (\rR\x06teamId\x12\x1b\n\tteam_name\x18\x06\x20\x01(\tR\x08teamName\x12\
    \x19\n\x08team_tag\x18\x07\x20\x01(\tR\x07teamTag\x12\x18\n\x07sponsor\
    \x18\x08\x20\x01(\tR\x07sponsor\x12\x1b\n\tis_locked\x18\t\x20\x01(\x08R\
    \x08isLocked\x12\x15\n\x06is_pro\x18\n\x20\x01(\x08R\x05isPro\x12!\n\x0c\
    locked_until\x18\x0b\x20\x01(\rR\x0blockedUntil\x12\x1c\n\ttimestamp\x18\
    \x0c\x20\x01(\rR\ttimestamp\x1aP\n\x11RegionLeaderboard\x12\x1a\n\x08div\
    ision\x18\x01\x20\x01(\rR\x08division\x12\x1f\n\x0baccount_ids\x18\x02\
    \x20\x03(\rR\naccountIds\"\xe0\x01\n\"CMsgDOTACreateFantasyLeagueRequest\
    \x12\x1f\n\x0bleague_name\x18\x01\x20\x01(\tR\nleagueName\x12\x1f\n\x0bl\
    eague_logo\x18\x02\x20\x01(\x04R\nleagueLogo\x12Y\n\x0eselection_mode\
    \x18\x03\x20\x01(\x0e2\x17.Fantasy_Selection_Mode:\x19FANTASY_SELECTION_\
    INVALIDR\rselectionMode\x12\x1d\n\nteam_count\x18\x04\x20\x01(\rR\tteamC\
    ount\"\xfb\x01\n#CMsgDOTACreateFantasyLeagueResponse\x12M\n\x06result\
    \x18\x01\x20\x01(\x0e2,.CMsgDOTACreateFantasyLeagueResponse.EResult:\x07\
    SUCCESSR\x06result\"\x84\x01\n\x07EResult\x12\x0b\n\x07SUCCESS\x10\0\x12\
    \x15\n\x11ERROR_UNSPECIFIED\x10\x01\x12\x1a\n\x16ERROR_TOO_MANY_LEAGUES\
    \x10\x02\x12\x1c\n\x18ERROR_INVALID_TEAM_COUNT\x10\x03\x12\x1b\n\x17ERRO\
    R_CREATION_DISABLED\x10\x04\"\xaf\x03\n\x18CMsgFantasyLeagueScoring\x12\
    \x14\n\x05level\x18\x01\x20\x01(\x02R\x05level\x12\x14\n\x05kills\x18\
    \x02\x20\x01(\x02R\x05kills\x12\x16\n\x06deaths\x18\x03\x20\x01(\x02R\
    \x06deaths\x12\x18\n\x07assists\x18\x04\x20\x01(\x02R\x07assists\x12\x1b\
    \n\tlast_hits\x18\x05\x20\x01(\x02R\x08lastHits\x12\x16\n\x06denies\x18\
    \x06\x20\x01(\x02R\x06denies\x12\x10\n\x03gpm\x18\x07\x20\x01(\x02R\x03g\
    pm\x12\x12\n\x04xppm\x18\x08\x20\x01(\x02R\x04xppm\x12\x14\n\x05stuns\
    \x18\t\x20\x01(\x02R\x05stuns\x12\x18\n\x07healing\x18\n\x20\x01(\x02R\
    \x07healing\x12\x1f\n\x0btower_kills\x18\x0b\x20\x01(\x02R\ntowerKills\
    \x12!\n\x0croshan_kills\x18\x0c\x20\x01(\x02R\x0broshanKills\x12-\n\x12m\
    ultiplier_premium\x18\r\x20\x01(\x02R\x11multiplierPremium\x127\n\x17mul\
    tiplier_professional\x18\x0e\x20\x01(\x02R\x16multiplierProfessional\"\
    \x8d\x08\n\x19CMsgDOTAFantasyLeagueInfo\x12*\n\x11fantasy_league_id\x18\
    \x01\x20\x01(\rR\x0ffantasyLeagueId\x126\n\x17commissioner_account_id\
    \x18\x02\x20\x01(\rR\x15commissionerAccountId\x12.\n\x13fantasy_league_n\
    ame\x18\x03\x20\x01(\tR\x11fantasyLeagueName\x12Y\n\x0eselection_mode\
    \x18\x04\x20\x01(\x0e2\x17.Fantasy_Selection_Mode:\x19FANTASY_SELECTION_\
    INVALIDR\rselectionMode\x12\x1d\n\nteam_count\x18\x05\x20\x01(\rR\tteamC\
    ount\x12\x12\n\x04logo\x18\x06\x20\x01(\x04R\x04logo\x123\n\x07scoring\
    \x18\x07\x20\x01(\x0b2\x19.CMsgFantasyLeagueScoringR\x07scoring\x12\x1d\
    \n\ndraft_time\x18\x0c\x20\x01(\rR\tdraftTime\x12&\n\x0fdraft_pick_time\
    \x18\r\x20\x01(\rR\rdraftPickTime\x12!\n\x0cseason_start\x18\x0f\x20\x01\
    (\rR\x0bseasonStart\x12#\n\rseason_length\x18\x10\x20\x01(\rR\x0cseasonL\
    ength\x12\x1d\n\nveto_votes\x18\x11\x20\x01(\rR\tvetoVotes\x12\"\n\x0cac\
    quisitions\x18\x12\x20\x01(\rR\x0cacquisitions\x12\x15\n\x06slot_1\x18\
    \x13\x20\x01(\rR\x05slot1\x12\x15\n\x06slot_2\x18\x14\x20\x01(\rR\x05slo\
    t2\x12\x15\n\x06slot_3\x18\x15\x20\x01(\rR\x05slot3\x12\x15\n\x06slot_4\
    \x18\x16\x20\x01(\rR\x05slot4\x12\x15\n\x06slot_5\x18\x17\x20\x01(\rR\
    \x05slot5\x12\x1f\n\x0bbench_slots\x18\x18\x20\x01(\rR\nbenchSlots\x12C\
    \n\nowner_info\x18\x19\x20\x03(\x0b2$.CMsgDOTAFantasyLeagueInfo.OwnerInf\
    oR\townerInfo\x12\x18\n\x07players\x18\x1a\x20\x03(\rR\x07players\x12\
    \x1b\n\ttime_zone\x18\x1b\x20\x01(\rR\x08timeZone\x12\x16\n\x06season\
    \x18\x1c\x20\x01(\rR\x06season\x12\x1a\n\x08password\x18\x1d\x20\x01(\tR\
    \x08password\x1a\x82\x01\n\tOwnerInfo\x12(\n\x10owner_account_id\x18\x01\
    \x20\x01(\rR\x0eownerAccountId\x12\x1f\n\x0bleft_league\x18\x02\x20\x01(\
    \x08R\nleftLeague\x12*\n\x11player_account_id\x18\x03\x20\x03(\rR\x0fpla\
    yerAccountId\"\x8b\x01\n$CMsgDOTAFantasyLeagueEditInfoRequest\x12*\n\x11\
    fantasy_league_id\x18\x01\x20\x01(\rR\x0ffantasyLeagueId\x127\n\tedit_in\
    fo\x18\x02\x20\x01(\x0b2\x1a.CMsgDOTAFantasyLeagueInfoR\x08editInfo\"\
    \xc0\x01\n%CMsgDOTAFantasyLeagueEditInfoResponse\x12O\n\x06result\x18\
    \x01\x20\x01(\x0e2..CMsgDOTAFantasyLeagueEditInfoResponse.EResult:\x07SU\
    CCESSR\x06result\"F\n\x07EResult\x12\x0b\n\x07SUCCESS\x10\0\x12\x15\n\
    \x11ERROR_UNSPECIFIED\x10\x01\x12\x17\n\x13ERROR_NO_PERMISSION\x10\x02\"\
    j\n\x20CMsgDOTAFantasyLeagueFindRequest\x12*\n\x11fantasy_league_id\x18\
    \x01\x20\x01(\rR\x0ffantasyLeagueId\x12\x1a\n\x08password\x18\x02\x20\
    \x01(\tR\x08password\"\xf4\x02\n!CMsgDOTAFantasyLeagueFindResponse\x12K\
    \n\x06result\x18\x01\x20\x01(\x0e2*.CMsgDOTAFantasyLeagueFindResponse.ER\
    esult:\x07SUCCESSR\x06result\x12.\n\x13fantasy_league_name\x18\x02\x20\
    \x01(\tR\x11fantasyLeagueName\x12+\n\x11commissioner_name\x18\x03\x20\
    \x01(\tR\x10commissionerName\"\xa4\x01\n\x07EResult\x12\x0b\n\x07SUCCESS\
    \x10\0\x12\x1a\n\x16ERROR_LEAGUE_NOT_FOUND\x10\x01\x12\x16\n\x12ERROR_BA\
    D_PASSWORD\x10\x02\x12\x15\n\x11ERROR_UNSPECIFIED\x10\x03\x12\x0e\n\nERR\
    OR_FULL\x10\x04\x12\x18\n\x14ERROR_ALREADY_MEMBER\x10\x05\x12\x17\n\x13E\
    RROR_LEAGUE_LOCKED\x10\x06\"N\n\x20CMsgDOTAFantasyLeagueInfoRequest\x12*\
    \n\x11fantasy_league_id\x18\x01\x20\x01(\rR\x0ffantasyLeagueId\"\xb8\x01\
    \n!CMsgDOTAFantasyLeagueInfoResponse\x12K\n\x06result\x18\x01\x20\x01(\
    \x0e2*.CMsgDOTAFantasyLeagueInfoResponse.EResult:\x07SUCCESSR\x06result\
    \"F\n\x07EResult\x12\x0b\n\x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNSPECIFI\
    ED\x10\x01\x12\x17\n\x13ERROR_BAD_LEAGUE_ID\x10\x02\"R\n$CMsgDOTAFantasy\
    LeagueMatchupsRequest\x12*\n\x11fantasy_league_id\x18\x01\x20\x01(\rR\
    \x0ffantasyLeagueId\"\x94\x05\n%CMsgDOTAFantasyLeagueMatchupsResponse\
    \x12O\n\x06result\x18\x01\x20\x01(\x0e2..CMsgDOTAFantasyLeagueMatchupsRe\
    sponse.EResult:\x07SUCCESSR\x06result\x12*\n\x11fantasy_league_id\x18\
    \x02\x20\x01(\rR\x0ffantasyLeagueId\x12^\n\x0fweekly_matchups\x18\x03\
    \x20\x03(\x0b25.CMsgDOTAFantasyLeagueMatchupsResponse.WeeklyMatchupsR\
    \x0eweeklyMatchups\x1a\x95\x01\n\x07Matchup\x12+\n\x12owner_account_id_1\
    \x18\x01\x20\x01(\rR\x0fownerAccountId1\x12+\n\x12owner_account_id_2\x18\
    \x02\x20\x01(\rR\x0fownerAccountId2\x12\x17\n\x07score_1\x18\x03\x20\x01\
    (\x02R\x06score1\x12\x17\n\x07score_2\x18\x04\x20\x01(\x02R\x06score2\
    \x1a\x94\x01\n\x0eWeeklyMatchups\x12H\n\x07matchup\x18\x01\x20\x03(\x0b2\
    ..CMsgDOTAFantasyLeagueMatchupsResponse.MatchupR\x07matchup\x12\x1d\n\ns\
    tart_time\x18\x02\x20\x01(\rR\tstartTime\x12\x19\n\x08end_time\x18\x03\
    \x20\x01(\rR\x07endTime\"_\n\x07EResult\x12\x0b\n\x07SUCCESS\x10\0\x12\
    \x15\n\x11ERROR_UNSPECIFIED\x10\x01\x12\x17\n\x13ERROR_BAD_LEAGUE_ID\x10\
    \x02\x12\x17\n\x13ERROR_NO_PERMISSION\x10\x03\"\xa5\x01\n\x1eCMsgDOTAEdi\
    tFantasyTeamRequest\x12*\n\x11fantasy_league_id\x18\x01\x20\x01(\rR\x0ff\
    antasyLeagueId\x12\x1d\n\nteam_index\x18\x02\x20\x01(\rR\tteamIndex\x12\
    \x1b\n\tteam_name\x18\x03\x20\x01(\tR\x08teamName\x12\x1b\n\tteam_logo\
    \x18\x04\x20\x01(\x04R\x08teamLogo\"\xf0\x01\n\x1fCMsgDOTAEditFantasyTea\
    mResponse\x12I\n\x06result\x18\x01\x20\x01(\x0e2(.CMsgDOTAEditFantasyTea\
    mResponse.EResult:\x07SUCCESSR\x06result\"\x81\x01\n\x07EResult\x12\x0b\
    \n\x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNSPECIFIED\x10\x01\x12\x1b\n\x17\
    ERROR_INVALID_TEAM_INFO\x10\x02\x12\x1c\n\x18ERROR_NAME_ALREADY_TAKEN\
    \x10\x03\x12\x17\n\x13ERROR_NO_PERMISSION\x10\x04\"]\n/CMsgDOTAFantasyTe\
    amInfoRequestByFantasyLeagueID\x12*\n\x11fantasy_league_id\x18\x01\x20\
    \x01(\rR\x0ffantasyLeagueId\"Z\n.CMsgDOTAFantasyTeamInfoRequestByOwnerAc\
    countID\x12(\n\x10owner_account_id\x18\x01\x20\x01(\rR\x0eownerAccountId\
    \"U\n\x1fCMsgDOTAFantasyTeamInfoResponse\x122\n\x07results\x18\x01\x20\
    \x03(\x0b2\x18.CMsgDOTAFantasyTeamInfoR\x07results\"\xaa\x02\n\x17CMsgDO\
    TAFantasyTeamInfo\x12*\n\x11fantasy_league_id\x18\x01\x20\x01(\rR\x0ffan\
    tasyLeagueId\x12(\n\x10owner_account_id\x18\x02\x20\x01(\rR\x0eownerAcco\
    untId\x12,\n\x12fantasy_team_index\x18\x03\x20\x01(\rR\x10fantasyTeamInd\
    ex\x12\x1b\n\tteam_name\x18\x04\x20\x01(\tR\x08teamName\x12\x1b\n\tteam_\
    logo\x18\x05\x20\x01(\x04R\x08teamLogo\x12\x12\n\x04wins\x18\x06\x20\x01\
    (\rR\x04wins\x12\x16\n\x06losses\x18\x07\x20\x01(\rR\x06losses\x12%\n\
    \x0ecurrent_roster\x18\x08\x20\x03(\rR\rcurrentRoster\"\xc6\x02\n\x1fCMs\
    gDOTAFantasyTeamScoreRequest\x12*\n\x11fantasy_league_id\x18\x01\x20\x01\
    (\rR\x0ffantasyLeagueId\x12(\n\x10owner_account_id\x18\x02\x20\x01(\rR\
    \x0eownerAccountId\x12,\n\x12fantasy_team_index\x18\x03\x20\x01(\rR\x10f\
    antasyTeamIndex\x12&\n\x0ffilter_match_id\x18\x04\x20\x01(\x04R\rfilterM\
    atchId\x12*\n\x11filter_start_time\x18\x05\x20\x01(\rR\x0ffilterStartTim\
    e\x12&\n\x0ffilter_end_time\x18\x06\x20\x01(\rR\rfilterEndTime\x12#\n\ri\
    nclude_bench\x18\x07\x20\x01(\x08R\x0cincludeBench\"\xb0\x03\n\x20CMsgDO\
    TAFantasyTeamScoreResponse\x12J\n\x06result\x18\x01\x20\x01(\x0e2).CMsgD\
    OTAFantasyTeamScoreResponse.EResult:\x07SUCCESSR\x06result\x12,\n\x12fan\
    tasy_team_score\x18\x02\x20\x01(\x02R\x10fantasyTeamScore\x12c\n\x14fant\
    asy_player_score\x18\x03\x20\x03(\x0b21.CMsgDOTAFantasyTeamScoreResponse\
    .CMsgPlayerScoreR\x12fantasyPlayerScore\x1aF\n\x0fCMsgPlayerScore\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x14\n\x05score\x18\
    \x02\x20\x01(\x02R\x05score\"e\n\x07EResult\x12\x0b\n\x07SUCCESS\x10\0\
    \x12\x15\n\x11ERROR_UNSPECIFIED\x10\x01\x12\x17\n\x13ERROR_NO_PERMISSION\
    \x10\x02\x12\x1d\n\x19ERROR_OWNER_NOT_IN_LEAGUE\x10\x03\"\xb5\x02\n#CMsg\
    DOTAFantasyTeamStandingsRequest\x12*\n\x11fantasy_league_id\x18\x01\x20\
    \x01(\rR\x0ffantasyLeagueId\x12\x14\n\x05count\x18\x02\x20\x01(\rR\x05co\
    unt\x12*\n\x11filter_start_time\x18\x03\x20\x01(\rR\x0ffilterStartTime\
    \x12&\n\x0ffilter_end_time\x18\x04\x20\x01(\rR\rfilterEndTime\x12&\n\x0f\
    filter_match_id\x18\x05\x20\x01(\x04R\rfilterMatchId\x12*\n\x11filter_la\
    st_match\x18\x06\x20\x01(\x08R\x0ffilterLastMatch\x12$\n\x0efilter_in_ha\
    ll\x18\x07\x20\x01(\x08R\x0cfilterInHall\"\xa0\x05\n$CMsgDOTAFantasyTeam\
    StandingsResponse\x12N\n\x06result\x18\x01\x20\x01(\x0e2-.CMsgDOTAFantas\
    yTeamStandingsResponse.EResult:\x07SUCCESSR\x06result\x12T\n\x0bteam_sco\
    res\x18\x03\x20\x03(\x0b23.CMsgDOTAFantasyTeamStandingsResponse.CMsgTeam\
    ScoreR\nteamScores\x1a\x89\x03\n\rCMsgTeamScore\x12*\n\x11fantasy_league\
    _id\x18\x01\x20\x01(\rR\x0ffantasyLeagueId\x12(\n\x10owner_account_id\
    \x18\x02\x20\x01(\rR\x0eownerAccountId\x12,\n\x12fantasy_team_index\x18\
    \x03\x20\x01(\rR\x10fantasyTeamIndex\x12*\n\x11fantasy_team_logo\x18\x04\
    \x20\x01(\x04R\x0ffantasyTeamLogo\x12\x1d\n\nowner_name\x18\x05\x20\x01(\
    \tR\townerName\x12*\n\x11fantasy_team_name\x18\x06\x20\x01(\tR\x0ffantas\
    yTeamName\x12\x14\n\x05score\x18\x07\x20\x01(\x02R\x05score\x12#\n\rscor\
    e_against\x18\x08\x20\x01(\x02R\x0cscoreAgainst\x12\x12\n\x04wins\x18\t\
    \x20\x01(\rR\x04wins\x12\x16\n\x06losses\x18\n\x20\x01(\rR\x06losses\x12\
    \x16\n\x06streak\x18\x0b\x20\x01(\x05R\x06streak\"F\n\x07EResult\x12\x0b\
    \n\x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNSPECIFIED\x10\x01\x12\x17\n\x13\
    ERROR_NO_PERMISSION\x10\x02\"\xa3\x02\n!CMsgDOTAFantasyPlayerScoreReques\
    t\x12*\n\x11fantasy_league_id\x18\x01\x20\x01(\rR\x0ffantasyLeagueId\x12\
    *\n\x11player_account_id\x18\x02\x20\x01(\rR\x0fplayerAccountId\x12*\n\
    \x11filter_start_time\x18\x03\x20\x01(\rR\x0ffilterStartTime\x12&\n\x0ff\
    ilter_end_time\x18\x04\x20\x01(\rR\rfilterEndTime\x12&\n\x0ffilter_match\
    _id\x18\x05\x20\x01(\x04R\rfilterMatchId\x12*\n\x11filter_last_match\x18\
    \x06\x20\x01(\x08R\x0ffilterLastMatch\"\xc9\x02\n\"CMsgDOTAFantasyPlayer\
    ScoreResponse\x12L\n\x06result\x18\x01\x20\x01(\x0e2+.CMsgDOTAFantasyPla\
    yerScoreResponse.EResult:\x07SUCCESSR\x06result\x12*\n\x11fantasy_league\
    _id\x18\x02\x20\x01(\rR\x0ffantasyLeagueId\x12*\n\x11player_account_id\
    \x18\x03\x20\x01(\rR\x0fplayerAccountId\x12\x1f\n\x0bplayer_name\x18\x04\
    \x20\x01(\tR\nplayerName\x12\x14\n\x05score\x18\x05\x20\x01(\x02R\x05sco\
    re\"F\n\x07EResult\x12\x0b\n\x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNSPECI\
    FIED\x10\x01\x12\x17\n\x13ERROR_NO_PERMISSION\x10\x02\"\xa5\x02\n%CMsgDO\
    TAFantasyPlayerStandingsRequest\x12*\n\x11fantasy_league_id\x18\x01\x20\
    \x01(\rR\x0ffantasyLeagueId\x12\x14\n\x05count\x18\x02\x20\x01(\rR\x05co\
    unt\x12\x12\n\x04role\x18\x03\x20\x01(\rR\x04role\x12*\n\x11filter_start\
    _time\x18\x04\x20\x01(\rR\x0ffilterStartTime\x12&\n\x0ffilter_end_time\
    \x18\x05\x20\x01(\rR\rfilterEndTime\x12&\n\x0ffilter_match_id\x18\x06\
    \x20\x01(\x04R\rfilterMatchId\x12*\n\x11filter_last_match\x18\x07\x20\
    \x01(\x08R\x0ffilterLastMatch\"\xd6\x03\n&CMsgDOTAFantasyPlayerStandings\
    Response\x12P\n\x06result\x18\x01\x20\x01(\x0e2/.CMsgDOTAFantasyPlayerSt\
    andingsResponse.EResult:\x07SUCCESSR\x06result\x12*\n\x11fantasy_league_\
    id\x18\x02\x20\x01(\rR\x0ffantasyLeagueId\x12\x12\n\x04role\x18\x03\x20\
    \x01(\rR\x04role\x12\\\n\rplayer_scores\x18\x04\x20\x03(\x0b27.CMsgDOTAF\
    antasyPlayerStandingsResponse.CMsgPlayerScoreR\x0cplayerScores\x1at\n\
    \x0fCMsgPlayerScore\x12*\n\x11player_account_id\x18\x01\x20\x01(\rR\x0fp\
    layerAccountId\x12\x1f\n\x0bplayer_name\x18\x02\x20\x01(\tR\nplayerName\
    \x12\x14\n\x05score\x18\x03\x20\x01(\x02R\x05score\"F\n\x07EResult\x12\
    \x0b\n\x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNSPECIFIED\x10\x01\x12\x17\n\
    \x13ERROR_NO_PERMISSION\x10\x02\"\"\n\x20CMsgDOTAFantasyPlayerInfoReques\
    t\"H\n!CMsgDOTAFantasyPlayerInfoResponse\x12#\n\x03msg\x18\x01\x20\x01(\
    \x0b2\x11.CMsgGCPlayerInfoR\x03msg\"\xe4\x01\n\"CMsgDOTAFantasyLeagueCre\
    ateRequest\x12\x1b\n\tseason_id\x18\x01\x20\x01(\rR\x08seasonId\x12.\n\
    \x13fantasy_league_name\x18\x02\x20\x01(\tR\x11fantasyLeagueName\x12\x1a\
    \n\x08password\x18\x03\x20\x01(\tR\x08password\x12\x1b\n\tteam_name\x18\
    \x04\x20\x01(\tR\x08teamName\x12\x12\n\x04logo\x18\x05\x20\x01(\x04R\x04\
    logo\x12$\n\x0eticket_item_id\x18\x06\x20\x01(\x04R\x0cticketItemId\"\
    \xe9\x02\n#CMsgDOTAFantasyLeagueCreateResponse\x12M\n\x06result\x18\x01\
    \x20\x01(\x0e2,.CMsgDOTAFantasyLeagueCreateResponse.EResult:\x07SUCCESSR\
    \x06result\x12*\n\x11fantasy_league_id\x18\x02\x20\x01(\rR\x0ffantasyLea\
    gueId\"\xc6\x01\n\x07EResult\x12\x0b\n\x07SUCCESS\x10\0\x12\x17\n\x13ERR\
    OR_NO_PERMISSION\x10\x01\x12\x17\n\x13ERROR_BAD_SEASON_ID\x10\x02\x12\
    \x19\n\x15ERROR_BAD_LEAGUE_NAME\x10\x03\x12\x17\n\x13ERROR_BAD_TEAM_NAME\
    \x10\x04\x12\x15\n\x11ERROR_UNSPECIFIED\x10\x05\x12\x1c\n\x18ERROR_FAILE\
    D_LOGO_UPLOAD\x10\x06\x12\x13\n\x0fERROR_NO_TICKET\x10\x07\"\xc1\x01\n\
    \x20CMsgDOTAFantasyTeamCreateRequest\x12*\n\x11fantasy_league_id\x18\x01\
    \x20\x01(\rR\x0ffantasyLeagueId\x12\x1a\n\x08password\x18\x02\x20\x01(\t\
    R\x08password\x12\x1b\n\tteam_name\x18\x03\x20\x01(\tR\x08teamName\x12\
    \x12\n\x04logo\x18\x04\x20\x01(\x04R\x04logo\x12$\n\x0eticket_item_id\
    \x18\x05\x20\x01(\x04R\x0cticketItemId\"\xaa\x03\n!CMsgDOTAFantasyTeamCr\
    eateResponse\x12K\n\x06result\x18\x01\x20\x01(\x0e2*.CMsgDOTAFantasyTeam\
    CreateResponse.EResult:\x07SUCCESSR\x06result\x12,\n\x12fantasy_team_ind\
    ex\x18\x02\x20\x01(\rR\x10fantasyTeamIndex\"\x89\x02\n\x07EResult\x12\
    \x0b\n\x07SUCCESS\x10\0\x12\x17\n\x13ERROR_NO_PERMISSION\x10\x01\x12\x1c\
    \n\x18ERROR_FAILED_LOGO_UPLOAD\x10\x02\x12\x1f\n\x1bERROR_BAD_FANTASY_LE\
    AGUE_ID\x10\x03\x12\x12\n\x0eERROR_BAD_NAME\x10\x04\x12\x0e\n\nERROR_FUL\
    L\x10\x05\x12\x18\n\x14ERROR_ALREADY_MEMBER\x10\x06\x12\x16\n\x12ERROR_B\
    AD_PASSWORD\x10\x07\x12\x15\n\x11ERROR_UNSPECIFIED\x10\x08\x12\x13\n\x0f\
    ERROR_NO_TICKET\x10\t\x12\x17\n\x13ERROR_LEAGUE_LOCKED\x10\n\"\x96\x02\n\
    'CMsgDOTAFantasyLeagueEditInvitesRequest\x12*\n\x11fantasy_league_id\x18\
    \x01\x20\x01(\rR\x0ffantasyLeagueId\x12\x1a\n\x08password\x18\x02\x20\
    \x01(\tR\x08password\x12Z\n\rinvite_change\x18\x03\x20\x03(\x0b25.CMsgDO\
    TAFantasyLeagueEditInvitesRequest.InviteChangeR\x0cinviteChange\x1aG\n\
    \x0cInviteChange\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\
    \x12\x18\n\x07invited\x18\x02\x20\x01(\x08R\x07invited\"\xad\x01\n(CMsgD\
    OTAFantasyLeagueEditInvitesResponse\x12R\n\x06result\x18\x01\x20\x01(\
    \x0e21.CMsgDOTAFantasyLeagueEditInvitesResponse.EResult:\x07SUCCESSR\x06\
    result\"-\n\x07EResult\x12\x0b\n\x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNS\
    PECIFIED\x10\x01\"U\n'CMsgDOTAFantasyLeagueDraftStatusRequest\x12*\n\x11\
    fantasy_league_id\x18\x01\x20\x01(\rR\x0ffantasyLeagueId\"\xab\x02\n\x20\
    CMsgDOTAFantasyLeagueDraftStatus\x12*\n\x11fantasy_league_id\x18\x01\x20\
    \x01(\rR\x0ffantasyLeagueId\x12\x1f\n\x0bdraft_order\x18\x02\x20\x03(\rR\
    \ndraftOrder\x12!\n\x0ccurrent_pick\x18\x03\x20\x01(\rR\x0bcurrentPick\
    \x12%\n\x0etime_remaining\x18\x04\x20\x01(\rR\rtimeRemaining\x12%\n\x0ep\
    ending_resume\x18\x05\x20\x01(\x08R\rpendingResume\x12\x1c\n\tcompleted\
    \x18\x06\x20\x01(\x08R\tcompleted\x12+\n\x11available_players\x18\x07\
    \x20\x03(\rR\x10availablePlayers\"\xa0\x01\n'CMsgDOTAFantasyLeagueDraftP\
    layerRequest\x12*\n\x11fantasy_league_id\x18\x01\x20\x01(\rR\x0ffantasyL\
    eagueId\x12\x1d\n\nteam_index\x18\x02\x20\x01(\rR\tteamIndex\x12*\n\x11p\
    layer_account_id\x18\x03\x20\x01(\rR\x0fplayerAccountId\"\x8a\x03\n(CMsg\
    DOTAFantasyLeagueDraftPlayerResponse\x12R\n\x06result\x18\x01\x20\x01(\
    \x0e21.CMsgDOTAFantasyLeagueDraftPlayerResponse.EResult:\x07SUCCESSR\x06\
    result\"\x89\x02\n\x07EResult\x12\x0b\n\x07SUCCESS\x10\0\x12\x15\n\x11ER\
    ROR_UNSPECIFIED\x10\x01\x12\x20\n\x1cERROR_INVALID_FANTASY_LEAGUE\x10\
    \x02\x12%\n!ERROR_FANTASY_LEAGUE_NOT_DRAFTING\x10\x03\x12\x1d\n\x19ERROR\
    _OWNER_NOT_IN_LEAGUE\x10\x04\x12\x19\n\x15ERROR_NOT_OWNERS_TURN\x10\x05\
    \x12\x18\n\x14ERROR_PLAYER_INVALID\x10\x06\x12\x1c\n\x18ERROR_PLAYER_UNA\
    VAILABLE\x10\x07\x12\x1f\n\x1bERROR_PLAYER_NO_VALID_SLOTS\x10\x08\"\xbd\
    \x01\n$CMsgDOTAFantasyTeamRosterSwapRequest\x12*\n\x11fantasy_league_id\
    \x18\x01\x20\x01(\rR\x0ffantasyLeagueId\x12\x1d\n\nteam_index\x18\x02\
    \x20\x01(\rR\tteamIndex\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\rR\ttimest\
    amp\x12\x15\n\x06slot_1\x18\x04\x20\x01(\rR\x05slot1\x12\x15\n\x06slot_2\
    \x18\x05\x20\x01(\rR\x05slot2\"\xf6\x01\n%CMsgDOTAFantasyTeamRosterSwapR\
    esponse\x12O\n\x06result\x18\x01\x20\x01(\x0e2..CMsgDOTAFantasyTeamRoste\
    rSwapResponse.EResult:\x07SUCCESSR\x06result\"|\n\x07EResult\x12\x0b\n\
    \x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNSPECIFIED\x10\x01\x12\x1d\n\x19ER\
    ROR_OWNER_NOT_IN_LEAGUE\x10\x02\x12\x17\n\x13ERROR_SLOTS_INVALID\x10\x03\
    \x12\x15\n\x11ERROR_SLOT_LOCKED\x10\x04\"\xc2\x01\n'CMsgDOTAFantasyTeamR\
    osterAddDropRequest\x12*\n\x11fantasy_league_id\x18\x01\x20\x01(\rR\x0ff\
    antasyLeagueId\x12\x1d\n\nteam_index\x18\x02\x20\x01(\rR\tteamIndex\x12$\
    \n\x0eadd_account_id\x18\x05\x20\x01(\rR\x0caddAccountId\x12&\n\x0fdrop_\
    account_id\x18\x06\x20\x01(\rR\rdropAccountId\"\xac\x02\n(CMsgDOTAFantas\
    yTeamRosterAddDropResponse\x12R\n\x06result\x18\x01\x20\x01(\x0e21.CMsgD\
    OTAFantasyTeamRosterAddDropResponse.EResult:\x07SUCCESSR\x06result\"\xab\
    \x01\n\x07EResult\x12\x0b\n\x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNSPECIF\
    IED\x10\x01\x12\x1d\n\x19ERROR_OWNER_NOT_IN_LEAGUE\x10\x02\x12\x1e\n\x1a\
    ERROR_PLAYER_NOT_AVAILABLE\x10\x03\x12\x1c\n\x18ERROR_PLAYER_NOT_ON_TEAM\
    \x10\x04\x12\x1f\n\x1bERROR_TRADE_ALREADY_PENDING\x10\x05\"N\n\x20CMsgDO\
    TAFantasyTeamTradesRequest\x12*\n\x11fantasy_league_id\x18\x01\x20\x01(\
    \rR\x0ffantasyLeagueId\"\xf2\x03\n!CMsgDOTAFantasyTeamTradesResponse\x12\
    K\n\x06result\x18\x01\x20\x01(\x0e2*.CMsgDOTAFantasyTeamTradesResponse.E\
    Result:\x07SUCCESSR\x06result\x12@\n\x06trades\x18\x02\x20\x03(\x0b2(.CM\
    sgDOTAFantasyTeamTradesResponse.TradeR\x06trades\x1a\xf5\x01\n\x05Trade\
    \x12\x1c\n\ttimestamp\x18\x01\x20\x01(\rR\ttimestamp\x12+\n\x12owner_acc\
    ount_id_1\x18\x02\x20\x01(\rR\x0fownerAccountId1\x12+\n\x12owner_account\
    _id_2\x18\x03\x20\x01(\rR\x0fownerAccountId2\x12-\n\x13player_account_id\
    _1\x18\x04\x20\x01(\rR\x10playerAccountId1\x12-\n\x13player_account_id_2\
    \x18\x05\x20\x01(\rR\x10playerAccountId2\x12\x16\n\x06status\x18\x06\x20\
    \x01(\rR\x06status\"F\n\x07EResult\x12\x0b\n\x07SUCCESS\x10\0\x12\x15\n\
    \x11ERROR_UNSPECIFIED\x10\x01\x12\x17\n\x13ERROR_NO_PERMISSION\x10\x02\"\
    \xc4\x01\n%CMsgDOTAFantasyTeamTradeCancelRequest\x12*\n\x11fantasy_leagu\
    e_id\x18\x01\x20\x01(\rR\x0ffantasyLeagueId\x12\x20\n\x0cteam_index_1\
    \x18\x03\x20\x01(\rR\nteamIndex1\x12+\n\x12owner_account_id_2\x18\x04\
    \x20\x01(\rR\x0fownerAccountId2\x12\x20\n\x0cteam_index_2\x18\x05\x20\
    \x01(\rR\nteamIndex2\"\xd6\x01\n&CMsgDOTAFantasyTeamTradeCancelResponse\
    \x12P\n\x06result\x18\x01\x20\x01(\x0e2/.CMsgDOTAFantasyTeamTradeCancelR\
    esponse.EResult:\x07SUCCESSR\x06result\"Z\n\x07EResult\x12\x0b\n\x07SUCC\
    ESS\x10\0\x12\x15\n\x11ERROR_UNSPECIFIED\x10\x01\x12\x17\n\x13ERROR_NO_P\
    ERMISSION\x10\x02\x12\x12\n\x0eERROR_NO_TRADE\x10\x03\"\xb5\x01\n\x20CMs\
    gDOTAFantasyTeamRosterRequest\x12*\n\x11fantasy_league_id\x18\x01\x20\
    \x01(\rR\x0ffantasyLeagueId\x12\x1d\n\nteam_index\x18\x02\x20\x01(\rR\tt\
    eamIndex\x12(\n\x10owner_account_id\x18\x03\x20\x01(\rR\x0eownerAccountI\
    d\x12\x1c\n\ttimestamp\x18\x04\x20\x01(\rR\ttimestamp\"\xaa\x02\n!CMsgDO\
    TAFantasyTeamRosterResponse\x12K\n\x06result\x18\x01\x20\x01(\x0e2*.CMsg\
    DOTAFantasyTeamRosterResponse.EResult:\x07SUCCESSR\x06result\x12,\n\x12p\
    layer_account_ids\x18\x02\x20\x03(\rR\x10playerAccountIds\x12#\n\rplayer\
    _locked\x18\x03\x20\x03(\x08R\x0cplayerLocked\"e\n\x07EResult\x12\x0b\n\
    \x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNSPECIFIED\x10\x01\x12\x17\n\x13ER\
    ROR_NO_PERMISSION\x10\x02\x12\x1d\n\x19ERROR_OWNER_NOT_IN_LEAGUE\x10\x03\
    \"X\n*CMsgDOTAFantasyPlayerHisoricalStatsRequest\x12*\n\x11fantasy_leagu\
    e_id\x18\x01\x20\x01(\rR\x0ffantasyLeagueId\"\xb9\x07\n+CMsgDOTAFantasyP\
    layerHisoricalStatsResponse\x12U\n\x06result\x18\x01\x20\x01(\x0e24.CMsg\
    DOTAFantasyPlayerHisoricalStatsResponse.EResult:\x07SUCCESSR\x06result\
    \x12N\n\x05stats\x18\x02\x20\x03(\x0b28.CMsgDOTAFantasyPlayerHisoricalSt\
    atsResponse.PlayerStatsR\x05stats\x1a\xf7\x02\n\x16PlayerScoreAccumulato\
    r\x12\x18\n\x07matches\x18\x01\x20\x01(\rR\x07matches\x12\x16\n\x06level\
    s\x18\x02\x20\x01(\x02R\x06levels\x12\x14\n\x05kills\x18\x03\x20\x01(\
    \x02R\x05kills\x12\x16\n\x06deaths\x18\x04\x20\x01(\x02R\x06deaths\x12\
    \x18\n\x07assists\x18\x05\x20\x01(\x02R\x07assists\x12\x1b\n\tlast_hits\
    \x18\x06\x20\x01(\x02R\x08lastHits\x12\x16\n\x06denies\x18\x07\x20\x01(\
    \x02R\x06denies\x12\x10\n\x03gpm\x18\x08\x20\x01(\x02R\x03gpm\x12\x12\n\
    \x04xppm\x18\t\x20\x01(\x02R\x04xppm\x12\x14\n\x05stuns\x18\n\x20\x01(\
    \x02R\x05stuns\x12\x18\n\x07healing\x18\x0b\x20\x01(\x02R\x07healing\x12\
    \x1f\n\x0btower_kills\x18\x0c\x20\x01(\x02R\ntowerKills\x12!\n\x0croshan\
    _kills\x18\r\x20\x01(\x02R\x0broshanKills\x12\x14\n\x05score\x18\x0e\x20\
    \x01(\x02R\x05score\x1a\xa0\x02\n\x0bPlayerStats\x12\x1d\n\naccount_id\
    \x18\x01\x20\x01(\rR\taccountId\x12\x14\n\x05weeks\x18\x02\x20\x01(\rR\
    \x05weeks\x12h\n\rstats_premium\x18\x04\x20\x01(\x0b2C.CMsgDOTAFantasyPl\
    ayerHisoricalStatsResponse.PlayerScoreAccumulatorR\x0cstatsPremium\x12r\
    \n\x12stats_professional\x18\x05\x20\x01(\x0b2C.CMsgDOTAFantasyPlayerHis\
    oricalStatsResponse.PlayerScoreAccumulatorR\x11statsProfessional\"F\n\
    \x07EResult\x12\x0b\n\x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNSPECIFIED\
    \x10\x01\x12\x17\n\x13ERROR_NO_PERMISSION\x10\x02\"a\n\x19CMsgDOTAFantas\
    yMessageAdd\x12*\n\x11fantasy_league_id\x18\x01\x20\x01(\rR\x0ffantasyLe\
    agueId\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"\x92\x01\n\
    \x1eCMsgDOTAFantasyMessagesRequest\x12*\n\x11fantasy_league_id\x18\x01\
    \x20\x01(\rR\x0ffantasyLeagueId\x12#\n\rstart_message\x18\x02\x20\x01(\r\
    R\x0cstartMessage\x12\x1f\n\x0bend_message\x18\x03\x20\x01(\rR\nendMessa\
    ge\"\xad\x03\n\x1fCMsgDOTAFantasyMessagesResponse\x12I\n\x06result\x18\
    \x01\x20\x01(\x0e2(.CMsgDOTAFantasyMessagesResponse.EResult:\x07SUCCESSR\
    \x06result\x12D\n\x08messages\x18\x02\x20\x03(\x0b2(.CMsgDOTAFantasyMess\
    agesResponse.MessageR\x08messages\x12,\n\x12num_total_messages\x18\x03\
    \x20\x01(\rR\x10numTotalMessages\x1a\x82\x01\n\x07Message\x12\x1d\n\nmes\
    sage_id\x18\x01\x20\x01(\rR\tmessageId\x12\x18\n\x07message\x18\x02\x20\
    \x01(\tR\x07message\x12*\n\x11author_account_id\x18\x03\x20\x01(\rR\x0fa\
    uthorAccountId\x12\x12\n\x04time\x18\x04\x20\x01(\rR\x04time\"F\n\x07ERe\
    sult\x12\x0b\n\x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNSPECIFIED\x10\x01\
    \x12\x17\n\x13ERROR_NO_PERMISSION\x10\x02\"\x91\x01\n\x1aCMsgDOTAFantasy\
    RemoveOwner\x12*\n\x11fantasy_league_id\x18\x01\x20\x01(\rR\x0ffantasyLe\
    agueId\x12(\n\x10owner_account_id\x18\x02\x20\x01(\rR\x0eownerAccountId\
    \x12\x1d\n\nteam_index\x18\x03\x20\x01(\rR\tteamIndex\"\xeb\x01\n\"CMsgD\
    OTAFantasyRemoveOwnerResponse\x12L\n\x06result\x18\x01\x20\x01(\x0e2+.CM\
    sgDOTAFantasyRemoveOwnerResponse.EResult:\x07SUCCESSR\x06result\"w\n\x07\
    EResult\x12\x0b\n\x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNSPECIFIED\x10\
    \x01\x12\x17\n\x13ERROR_NO_PERMISSION\x10\x02\x12\x17\n\x13ERROR_LEAGUE_\
    LOCKED\x10\x03\x12\x16\n\x12ERROR_NOT_A_MEMBER\x10\x04\"T\n&CMsgDOTAFant\
    asyScheduledMatchesRequest\x12*\n\x11fantasy_league_id\x18\x01\x20\x01(\
    \rR\x0ffantasyLeagueId\"\x88\x03\n'CMsgDOTAFantasyScheduledMatchesRespon\
    se\x12Q\n\x06result\x18\x01\x20\x01(\x0e20.CMsgDOTAFantasyScheduledMatch\
    esResponse.EResult:\x07SUCCESSR\x06result\x12m\n\x14scheduled_match_days\
    \x18\x02\x20\x03(\x0b2;.CMsgDOTAFantasyScheduledMatchesResponse.Schedule\
    dMatchDaysR\x12scheduledMatchDays\x1al\n\x12ScheduledMatchDays\x12\x1c\n\
    \ttimestamp\x18\x01\x20\x01(\rR\ttimestamp\x12\x19\n\x08team_ids\x18\x02\
    \x20\x03(\rR\x07teamIds\x12\x1d\n\nleague_ids\x18\x03\x20\x03(\rR\tleagu\
    eIds\"-\n\x07EResult\x12\x0b\n\x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNSPE\
    CIFIED\x10\x01\"}\n!CMsgDOTAFantasyLeaveLeagueRequest\x12*\n\x11fantasy_\
    league_id\x18\x01\x20\x01(\rR\x0ffantasyLeagueId\x12,\n\x12fantasy_team_\
    index\x18\x02\x20\x01(\rR\x10fantasyTeamIndex\"\xeb\x01\n\"CMsgDOTAFanta\
    syLeaveLeagueResponse\x12L\n\x06result\x18\x01\x20\x01(\x0e2+.CMsgDOTAFa\
    ntasyLeaveLeagueResponse.EResult:\x07SUCCESSR\x06result\"w\n\x07EResult\
    \x12\x0b\n\x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNSPECIFIED\x10\x01\x12\
    \x14\n\x10ERROR_NOT_MEMBER\x10\x02\x12\x1a\n\x16ERROR_LEAGUE_NOT_FOUND\
    \x10\x03\x12\x16\n\x12ERROR_DRAFT_ACTIVE\x10\x04\"\xbc\x01\n(CMsgDOTAFan\
    tasyPlayerScoreDetailsRequest\x12*\n\x11fantasy_league_id\x18\x01\x20\
    \x01(\rR\x0ffantasyLeagueId\x12*\n\x11player_account_id\x18\x02\x20\x01(\
    \rR\x0fplayerAccountId\x12\x1d\n\nstart_time\x18\x03\x20\x01(\rR\tstartT\
    ime\x12\x19\n\x08end_time\x18\x04\x20\x01(\rR\x07endTime\"\x9a\x05\n)CMs\
    gDOTAFantasyPlayerScoreDetailsResponse\x12S\n\x06result\x18\x01\x20\x01(\
    \x0e22.CMsgDOTAFantasyPlayerScoreDetailsResponse.EResult:\x07SUCCESSR\
    \x06result\x12N\n\x04data\x18\x02\x20\x03(\x0b2:.CMsgDOTAFantasyPlayerSc\
    oreDetailsResponse.PlayerMatchDataR\x04data\x1a\x82\x03\n\x0fPlayerMatch\
    Data\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\x1b\n\ts\
    eries_id\x18\x02\x20\x01(\rR\x08seriesId\x12\x1d\n\nseries_num\x18\x03\
    \x20\x01(\rR\tseriesNum\x12\x1f\n\x0bseries_type\x18\x04\x20\x01(\rR\nse\
    riesType\x12\x1f\n\x0bleague_tier\x18\x05\x20\x01(\rR\nleagueTier\x12\
    \x1b\n\tleague_id\x18\x06\x20\x01(\rR\x08leagueId\x12(\n\x10opposing_tea\
    m_id\x18\x07\x20\x01(\rR\x0eopposingTeamId\x12,\n\x12opposing_team_logo\
    \x18\x08\x20\x01(\x04R\x10opposingTeamLogo\x12,\n\x12opposing_team_name\
    \x18\t\x20\x01(\tR\x10opposingTeamName\x12\x19\n\x08owned_by\x18\x0b\x20\
    \x01(\rR\x07ownedBy\x12\x18\n\x07benched\x18\x0c\x20\x01(\x08R\x07benche\
    d\"C\n\x07EResult\x12\x0b\n\x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNSPECIF\
    IED\x10\x01\x12\x14\n\x10ERROR_NOT_MEMBER\x10\x02\"z\n\x1dCMsgDOTAPasspo\
    rtVoteTeamGuess\x12\x1b\n\tleague_id\x18\x01\x20\x01(\rR\x08leagueId\x12\
    \x1b\n\twinner_id\x18\x02\x20\x01(\rR\x08winnerId\x12\x1f\n\x0brunnerup_\
    id\x18\x03\x20\x01(\rR\nrunnerupId\"\xac\x01\n$CMsgDOTAPassportVoteGener\
    icSelection\x12f\n\x0fselection_index\x18\x01\x20\x01(\x0e2\".DOTA_2013P\
    assportSelectionIndices:\x19PP13_SEL_ALLSTAR_PLAYER_0R\x0eselectionIndex\
    \x12\x1c\n\tselection\x18\x02\x20\x01(\rR\tselection\"[\n\x1dCMsgDOTAPas\
    sportStampedPlayer\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x04R\x07steamI\
    d\x12\x1f\n\x0bstamp_level\x18\x02\x20\x01(\rR\nstampLevel\"H\n#CMsgDOTA\
    PassportPlayerCardChallenge\x12!\n\x0cchallenge_id\x18\x01\x20\x01(\rR\
    \x0bchallengeId\"\xd0\x02\n\x14CMsgDOTAPassportVote\x12=\n\nteam_votes\
    \x18\x01\x20\x03(\x0b2\x1e.CMsgDOTAPassportVoteTeamGuessR\tteamVotes\x12\
    T\n\x12generic_selections\x18\x02\x20\x03(\x0b2%.CMsgDOTAPassportVoteGen\
    ericSelectionR\x11genericSelections\x12G\n\x0fstamped_players\x18\x03\
    \x20\x03(\x0b2\x1e.CMsgDOTAPassportStampedPlayerR\x0estampedPlayers\x12Z\
    \n\x16player_card_challenges\x18\x04\x20\x03(\x0b2$.CMsgDOTAPassportPlay\
    erCardChallengeR\x14playerCardChallenges\"e\n(CMsgClientToGCGetPlayerCar\
    dRosterRequest\x12\x1b\n\tleague_id\x18\x01\x20\x01(\rR\x08leagueId\x12\
    \x1c\n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\"\xea\x02\n)CMsgClientT\
    oGCGetPlayerCardRosterResponse\x12R\n\x06result\x18\x01\x20\x01(\x0e21.C\
    MsgClientToGCGetPlayerCardRosterResponse.Result:\x07SUCCESSR\x06result\
    \x12-\n\x13player_card_item_id\x18\x02\x20\x03(\x04R\x10playerCardItemId\
    \x12\x14\n\x05score\x18\x03\x20\x01(\x02R\x05score\x12\x1c\n\tfinalized\
    \x18\x04\x20\x01(\x08R\tfinalized\x12\x1e\n\npercentile\x18\x05\x20\x01(\
    \x02R\npercentile\"f\n\x06Result\x12\x0b\n\x07SUCCESS\x10\0\x12\x15\n\
    \x11ERROR_UNSPECIFIED\x10\x01\x12\x1b\n\x17ERROR_INVALID_LEAGUE_ID\x10\
    \x02\x12\x1b\n\x17ERROR_INVALID_TIMESTAMP\x10\x03\"\xc3\x01\n(CMsgClient\
    ToGCSetPlayerCardRosterRequest\x12\x1b\n\tleague_id\x18\x01\x20\x01(\rR\
    \x08leagueId\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\x12\x12\
    \n\x04slot\x18\x03\x20\x01(\rR\x04slot\x12-\n\x13player_card_item_id\x18\
    \x04\x20\x01(\x04R\x10playerCardItemId\x12\x19\n\x08event_id\x18\x05\x20\
    \x01(\rR\x07eventId\"\xf6\x02\n)CMsgClientToGCSetPlayerCardRosterRespons\
    e\x12R\n\x06result\x18\x01\x20\x01(\x0e21.CMsgClientToGCSetPlayerCardRos\
    terResponse.Result:\x07SUCCESSR\x06result\"\xf4\x01\n\x06Result\x12\x0b\
    \n\x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNSPECIFIED\x10\x01\x12\x1b\n\x17\
    ERROR_INVALID_LEAGUE_ID\x10\x02\x12\x1b\n\x17ERROR_INVALID_TIMESTAMP\x10\
    \x03\x12\x1f\n\x1bERROR_PLAYER_CARD_NOT_OWNED\x10\x04\x12\x16\n\x12ERROR\
    _INVALID_SLOT\x10\x05\x12\x1a\n\x16ERROR_FAILED_CARD_INFO\x10\x06\x12\
    \x1b\n\x17ERROR_ACCOUNT_DUPLICATE\x10\x07\x12\x1a\n\x16ERROR_LOCKED_TIME\
    STAMP\x10\x08*\xa3\x15\n!DOTA_2013PassportSelectionIndices\x12\x1d\n\x19\
    PP13_SEL_ALLSTAR_PLAYER_0\x10\0\x12\x1d\n\x19PP13_SEL_ALLSTAR_PLAYER_1\
    \x10\x01\x12\x1d\n\x19PP13_SEL_ALLSTAR_PLAYER_2\x10\x02\x12\x1d\n\x19PP1\
    3_SEL_ALLSTAR_PLAYER_3\x10\x03\x12\x1d\n\x19PP13_SEL_ALLSTAR_PLAYER_4\
    \x10\x04\x12\x1d\n\x19PP13_SEL_ALLSTAR_PLAYER_5\x10\x05\x12\x1d\n\x19PP1\
    3_SEL_ALLSTAR_PLAYER_6\x10\x06\x12\x1d\n\x19PP13_SEL_ALLSTAR_PLAYER_7\
    \x10\x07\x12\x1d\n\x19PP13_SEL_ALLSTAR_PLAYER_8\x10\x08\x12\x1d\n\x19PP1\
    3_SEL_ALLSTAR_PLAYER_9\x10\t\x12\x1c\n\x18PP13_SEL_QUALPRED_WEST_0\x10\n\
    \x12\x1c\n\x18PP13_SEL_QUALPRED_WEST_1\x10\x0b\x12\x1c\n\x18PP13_SEL_QUA\
    LPRED_WEST_2\x10\x0c\x12\x1c\n\x18PP13_SEL_QUALPRED_WEST_3\x10\r\x12\x1c\
    \n\x18PP13_SEL_QUALPRED_WEST_4\x10\x0e\x12\x1c\n\x18PP13_SEL_QUALPRED_WE\
    ST_5\x10\x0f\x12\x1c\n\x18PP13_SEL_QUALPRED_WEST_6\x10\x10\x12\x1c\n\x18\
    PP13_SEL_QUALPRED_WEST_7\x10\x11\x12\x1c\n\x18PP13_SEL_QUALPRED_WEST_8\
    \x10\x12\x12\x1c\n\x18PP13_SEL_QUALPRED_WEST_9\x10\x13\x12\x1d\n\x19PP13\
    _SEL_QUALPRED_WEST_10\x10\x14\x12\x1d\n\x19PP13_SEL_QUALPRED_WEST_11\x10\
    \x15\x12\x1d\n\x19PP13_SEL_QUALPRED_WEST_12\x10\x16\x12\x1d\n\x19PP13_SE\
    L_QUALPRED_WEST_13\x10\x17\x12\x1d\n\x19PP13_SEL_QUALPRED_WEST_14\x10\
    \x18\x12\x1c\n\x18PP13_SEL_QUALPRED_EAST_0\x10\x19\x12\x1c\n\x18PP13_SEL\
    _QUALPRED_EAST_1\x10\x1a\x12\x1c\n\x18PP13_SEL_QUALPRED_EAST_2\x10\x1b\
    \x12\x1c\n\x18PP13_SEL_QUALPRED_EAST_3\x10\x1c\x12\x1c\n\x18PP13_SEL_QUA\
    LPRED_EAST_4\x10\x1d\x12\x1c\n\x18PP13_SEL_QUALPRED_EAST_5\x10\x1e\x12\
    \x1c\n\x18PP13_SEL_QUALPRED_EAST_6\x10\x1f\x12\x1c\n\x18PP13_SEL_QUALPRE\
    D_EAST_7\x10\x20\x12\x1c\n\x18PP13_SEL_QUALPRED_EAST_8\x10!\x12\x1c\n\
    \x18PP13_SEL_QUALPRED_EAST_9\x10\"\x12\x1d\n\x19PP13_SEL_QUALPRED_EAST_1\
    0\x10#\x12\x1d\n\x19PP13_SEL_QUALPRED_EAST_11\x10$\x12\x1d\n\x19PP13_SEL\
    _QUALPRED_EAST_12\x10%\x12\x1d\n\x19PP13_SEL_QUALPRED_EAST_13\x10&\x12\
    \x1d\n\x19PP13_SEL_QUALPRED_EAST_14\x10'\x12\x19\n\x15PP13_SEL_TEAMCUP_T\
    EAM\x10(\x12\x1b\n\x17PP13_SEL_TEAMCUP_PLAYER\x10)\x12\x1e\n\x1aPP13_SEL\
    _TEAMCUP_TEAM_LOCK\x10*\x12\x20\n\x1cPP13_SEL_TEAMCUP_PLAYER_LOCK\x10+\
    \x12\x18\n\x14PP13_SEL_EVENTPRED_0\x10,\x12\x18\n\x14PP13_SEL_EVENTPRED_\
    1\x10-\x12\x18\n\x14PP13_SEL_EVENTPRED_2\x10.\x12\x18\n\x14PP13_SEL_EVEN\
    TPRED_3\x10/\x12\x18\n\x14PP13_SEL_EVENTPRED_4\x100\x12\x18\n\x14PP13_SE\
    L_EVENTPRED_5\x101\x12\x18\n\x14PP13_SEL_EVENTPRED_6\x102\x12\x18\n\x14P\
    P13_SEL_EVENTPRED_7\x103\x12\x18\n\x14PP13_SEL_EVENTPRED_8\x104\x12\x18\
    \n\x14PP13_SEL_EVENTPRED_9\x105\x12\x19\n\x15PP13_SEL_EVENTPRED_10\x106\
    \x12\x19\n\x15PP13_SEL_EVENTPRED_11\x107\x12\x19\n\x15PP13_SEL_EVENTPRED\
    _12\x108\x12\x19\n\x15PP13_SEL_EVENTPRED_13\x109\x12\x19\n\x15PP13_SEL_E\
    VENTPRED_14\x10:\x12\x19\n\x15PP13_SEL_EVENTPRED_15\x10;\x12\x19\n\x15PP\
    13_SEL_EVENTPRED_16\x10<\x12\x19\n\x15PP13_SEL_EVENTPRED_17\x10=\x12\x19\
    \n\x15PP13_SEL_EVENTPRED_18\x10>\x12\x19\n\x15PP13_SEL_EVENTPRED_19\x10?\
    \x12\x19\n\x15PP13_SEL_EVENTPRED_20\x10@\x12\x19\n\x15PP13_SEL_EVENTPRED\
    _21\x10A\x12\x19\n\x15PP13_SEL_EVENTPRED_22\x10B\x12\x19\n\x15PP13_SEL_E\
    VENTPRED_23\x10C\x12\x19\n\x15PP13_SEL_EVENTPRED_24\x10D\x12\x19\n\x15PP\
    13_SEL_EVENTPRED_25\x10E\x12\x19\n\x15PP13_SEL_EVENTPRED_26\x10F\x12\x19\
    \n\x15PP13_SEL_EVENTPRED_27\x10G\x12\x19\n\x15PP13_SEL_EVENTPRED_28\x10H\
    \x12\x19\n\x15PP13_SEL_EVENTPRED_29\x10I\x12\x19\n\x15PP13_SEL_EVENTPRED\
    _30\x10J\x12\x19\n\x15PP13_SEL_EVENTPRED_31\x10K\x12\x19\n\x15PP13_SEL_E\
    VENTPRED_32\x10L\x12\x19\n\x15PP13_SEL_EVENTPRED_33\x10M\x12\x19\n\x15PP\
    13_SEL_EVENTPRED_34\x10N\x12\x19\n\x15PP13_SEL_EVENTPRED_35\x10O\x12\x19\
    \n\x15PP13_SEL_EVENTPRED_36\x10P\x12\x19\n\x15PP13_SEL_EVENTPRED_37\x10Q\
    \x12\x19\n\x15PP13_SEL_EVENTPRED_38\x10R\x12\x19\n\x15PP13_SEL_EVENTPRED\
    _39\x10S\x12\x19\n\x15PP13_SEL_EVENTPRED_40\x10T\x12\x19\n\x15PP13_SEL_E\
    VENTPRED_41\x10U\x12\x19\n\x15PP13_SEL_EVENTPRED_42\x10V\x12\x19\n\x15PP\
    13_SEL_EVENTPRED_43\x10W\x12\x13\n\x0fPP13_SEL_SOLO_0\x10X\x12\x13\n\x0f\
    PP13_SEL_SOLO_1\x10Y\x12\x13\n\x0fPP13_SEL_SOLO_2\x10Z\x12\x13\n\x0fPP13\
    _SEL_SOLO_3\x10[\x12\x13\n\x0fPP13_SEL_SOLO_4\x10\\\x12\x13\n\x0fPP13_SE\
    L_SOLO_5\x10]\x12\x13\n\x0fPP13_SEL_SOLO_6\x10^\x12\x13\n\x0fPP13_SEL_SO\
    LO_7\x10_B\x05H\x01\x80\x01\0\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
