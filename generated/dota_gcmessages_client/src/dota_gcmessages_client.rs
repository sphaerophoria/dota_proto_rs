// This file is generated. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientSuspended {
    // message fields
    time_end: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientSuspended {}

impl CMsgClientSuspended {
    pub fn new() -> CMsgClientSuspended {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientSuspended {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientSuspended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientSuspended,
        };
        unsafe {
            instance.get(CMsgClientSuspended::new)
        }
    }

    // optional uint32 time_end = 1;

    pub fn clear_time_end(&mut self) {
        self.time_end = ::std::option::Option::None;
    }

    pub fn has_time_end(&self) -> bool {
        self.time_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_end(&mut self, v: u32) {
        self.time_end = ::std::option::Option::Some(v);
    }

    pub fn get_time_end(&self) -> u32 {
        self.time_end.unwrap_or(0)
    }

    fn get_time_end_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time_end
    }

    fn mut_time_end_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time_end
    }
}

impl ::protobuf::Message for CMsgClientSuspended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_end = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.time_end {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.time_end {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientSuspended {
    fn new() -> CMsgClientSuspended {
        CMsgClientSuspended::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientSuspended>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_end",
                    CMsgClientSuspended::get_time_end_for_reflect,
                    CMsgClientSuspended::mut_time_end_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientSuspended>(
                    "CMsgClientSuspended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientSuspended {
    fn clear(&mut self) {
        self.clear_time_end();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSuspended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSuspended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestInternationalTicket {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgRequestInternationalTicket {}

impl CMsgRequestInternationalTicket {
    pub fn new() -> CMsgRequestInternationalTicket {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgRequestInternationalTicket {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRequestInternationalTicket> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRequestInternationalTicket,
        };
        unsafe {
            instance.get(CMsgRequestInternationalTicket::new)
        }
    }
}

impl ::protobuf::Message for CMsgRequestInternationalTicket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgRequestInternationalTicket {
    fn new() -> CMsgRequestInternationalTicket {
        CMsgRequestInternationalTicket::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgRequestInternationalTicket>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRequestInternationalTicket>(
                    "CMsgRequestInternationalTicket",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgRequestInternationalTicket {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestInternationalTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestInternationalTicket {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgBalancedShuffleLobby {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgBalancedShuffleLobby {}

impl CMsgBalancedShuffleLobby {
    pub fn new() -> CMsgBalancedShuffleLobby {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgBalancedShuffleLobby {
        static mut instance: ::protobuf::lazy::Lazy<CMsgBalancedShuffleLobby> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgBalancedShuffleLobby,
        };
        unsafe {
            instance.get(CMsgBalancedShuffleLobby::new)
        }
    }
}

impl ::protobuf::Message for CMsgBalancedShuffleLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgBalancedShuffleLobby {
    fn new() -> CMsgBalancedShuffleLobby {
        CMsgBalancedShuffleLobby::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgBalancedShuffleLobby>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgBalancedShuffleLobby>(
                    "CMsgBalancedShuffleLobby",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgBalancedShuffleLobby {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgBalancedShuffleLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBalancedShuffleLobby {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgInitialQuestionnaireResponse {
    // message fields
    initial_skill: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgInitialQuestionnaireResponse {}

impl CMsgInitialQuestionnaireResponse {
    pub fn new() -> CMsgInitialQuestionnaireResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgInitialQuestionnaireResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgInitialQuestionnaireResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgInitialQuestionnaireResponse,
        };
        unsafe {
            instance.get(CMsgInitialQuestionnaireResponse::new)
        }
    }

    // optional uint32 initial_skill = 1;

    pub fn clear_initial_skill(&mut self) {
        self.initial_skill = ::std::option::Option::None;
    }

    pub fn has_initial_skill(&self) -> bool {
        self.initial_skill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_skill(&mut self, v: u32) {
        self.initial_skill = ::std::option::Option::Some(v);
    }

    pub fn get_initial_skill(&self) -> u32 {
        self.initial_skill.unwrap_or(0)
    }

    fn get_initial_skill_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.initial_skill
    }

    fn mut_initial_skill_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.initial_skill
    }
}

impl ::protobuf::Message for CMsgInitialQuestionnaireResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initial_skill = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.initial_skill {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.initial_skill {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgInitialQuestionnaireResponse {
    fn new() -> CMsgInitialQuestionnaireResponse {
        CMsgInitialQuestionnaireResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgInitialQuestionnaireResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "initial_skill",
                    CMsgInitialQuestionnaireResponse::get_initial_skill_for_reflect,
                    CMsgInitialQuestionnaireResponse::mut_initial_skill_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgInitialQuestionnaireResponse>(
                    "CMsgInitialQuestionnaireResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgInitialQuestionnaireResponse {
    fn clear(&mut self) {
        self.clear_initial_skill();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgInitialQuestionnaireResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgInitialQuestionnaireResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAPlayerMatchHistory {
    // message fields
    match_ids: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAPlayerMatchHistory {}

impl CMsgDOTAPlayerMatchHistory {
    pub fn new() -> CMsgDOTAPlayerMatchHistory {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAPlayerMatchHistory {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAPlayerMatchHistory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAPlayerMatchHistory,
        };
        unsafe {
            instance.get(CMsgDOTAPlayerMatchHistory::new)
        }
    }

    // repeated uint64 match_ids = 1;

    pub fn clear_match_ids(&mut self) {
        self.match_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_match_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.match_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_match_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.match_ids
    }

    // Take field
    pub fn take_match_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.match_ids, ::std::vec::Vec::new())
    }

    pub fn get_match_ids(&self) -> &[u64] {
        &self.match_ids
    }

    fn get_match_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.match_ids
    }

    fn mut_match_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.match_ids
    }
}

impl ::protobuf::Message for CMsgDOTAPlayerMatchHistory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.match_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.match_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.match_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAPlayerMatchHistory {
    fn new() -> CMsgDOTAPlayerMatchHistory {
        CMsgDOTAPlayerMatchHistory::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAPlayerMatchHistory>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_ids",
                    CMsgDOTAPlayerMatchHistory::get_match_ids_for_reflect,
                    CMsgDOTAPlayerMatchHistory::mut_match_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAPlayerMatchHistory>(
                    "CMsgDOTAPlayerMatchHistory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAPlayerMatchHistory {
    fn clear(&mut self) {
        self.clear_match_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAPlayerMatchHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAPlayerMatchHistory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAMatchHistoryFilter {
    // message fields
    match_ids: ::std::vec::Vec<u64>,
    newest_match_id_at_last_query: ::std::option::Option<u64>,
    time_last_query: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAMatchHistoryFilter {}

impl CMsgDOTAMatchHistoryFilter {
    pub fn new() -> CMsgDOTAMatchHistoryFilter {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAMatchHistoryFilter {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAMatchHistoryFilter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAMatchHistoryFilter,
        };
        unsafe {
            instance.get(CMsgDOTAMatchHistoryFilter::new)
        }
    }

    // repeated uint64 match_ids = 1;

    pub fn clear_match_ids(&mut self) {
        self.match_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_match_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.match_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_match_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.match_ids
    }

    // Take field
    pub fn take_match_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.match_ids, ::std::vec::Vec::new())
    }

    pub fn get_match_ids(&self) -> &[u64] {
        &self.match_ids
    }

    fn get_match_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.match_ids
    }

    fn mut_match_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.match_ids
    }

    // optional uint64 newest_match_id_at_last_query = 2;

    pub fn clear_newest_match_id_at_last_query(&mut self) {
        self.newest_match_id_at_last_query = ::std::option::Option::None;
    }

    pub fn has_newest_match_id_at_last_query(&self) -> bool {
        self.newest_match_id_at_last_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newest_match_id_at_last_query(&mut self, v: u64) {
        self.newest_match_id_at_last_query = ::std::option::Option::Some(v);
    }

    pub fn get_newest_match_id_at_last_query(&self) -> u64 {
        self.newest_match_id_at_last_query.unwrap_or(0)
    }

    fn get_newest_match_id_at_last_query_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.newest_match_id_at_last_query
    }

    fn mut_newest_match_id_at_last_query_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.newest_match_id_at_last_query
    }

    // optional uint32 time_last_query = 3;

    pub fn clear_time_last_query(&mut self) {
        self.time_last_query = ::std::option::Option::None;
    }

    pub fn has_time_last_query(&self) -> bool {
        self.time_last_query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_query(&mut self, v: u32) {
        self.time_last_query = ::std::option::Option::Some(v);
    }

    pub fn get_time_last_query(&self) -> u32 {
        self.time_last_query.unwrap_or(0)
    }

    fn get_time_last_query_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time_last_query
    }

    fn mut_time_last_query_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time_last_query
    }
}

impl ::protobuf::Message for CMsgDOTAMatchHistoryFilter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.match_ids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.newest_match_id_at_last_query = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_last_query = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.match_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.newest_match_id_at_last_query {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_last_query {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.match_ids {
            os.write_uint64(1, *v)?;
        };
        if let Some(v) = self.newest_match_id_at_last_query {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.time_last_query {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAMatchHistoryFilter {
    fn new() -> CMsgDOTAMatchHistoryFilter {
        CMsgDOTAMatchHistoryFilter::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAMatchHistoryFilter>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_ids",
                    CMsgDOTAMatchHistoryFilter::get_match_ids_for_reflect,
                    CMsgDOTAMatchHistoryFilter::mut_match_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "newest_match_id_at_last_query",
                    CMsgDOTAMatchHistoryFilter::get_newest_match_id_at_last_query_for_reflect,
                    CMsgDOTAMatchHistoryFilter::mut_newest_match_id_at_last_query_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_last_query",
                    CMsgDOTAMatchHistoryFilter::get_time_last_query_for_reflect,
                    CMsgDOTAMatchHistoryFilter::mut_time_last_query_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAMatchHistoryFilter>(
                    "CMsgDOTAMatchHistoryFilter",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAMatchHistoryFilter {
    fn clear(&mut self) {
        self.clear_match_ids();
        self.clear_newest_match_id_at_last_query();
        self.clear_time_last_query();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAMatchHistoryFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAMatchHistoryFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARequestMatches {
    // message fields
    hero_id: ::std::option::Option<u32>,
    game_mode: ::std::option::Option<u32>,
    date_min: ::std::option::Option<u32>,
    date_max: ::std::option::Option<u32>,
    matches_requested: ::std::option::Option<u32>,
    start_at_match_id: ::std::option::Option<u64>,
    min_players: ::std::option::Option<u32>,
    request_id: ::std::option::Option<u32>,
    tournament_games_only: ::std::option::Option<bool>,
    account_id: ::std::option::Option<u32>,
    league_id: ::std::option::Option<u32>,
    skill: ::std::option::Option<CMsgDOTARequestMatches_SkillLevel>,
    team_id: ::std::option::Option<u32>,
    custom_game_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARequestMatches {}

impl CMsgDOTARequestMatches {
    pub fn new() -> CMsgDOTARequestMatches {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARequestMatches {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARequestMatches> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARequestMatches,
        };
        unsafe {
            instance.get(CMsgDOTARequestMatches::new)
        }
    }

    // optional uint32 hero_id = 2;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 game_mode = 3;

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    pub fn get_game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    fn get_game_mode_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.game_mode
    }

    fn mut_game_mode_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.game_mode
    }

    // optional fixed32 date_min = 6;

    pub fn clear_date_min(&mut self) {
        self.date_min = ::std::option::Option::None;
    }

    pub fn has_date_min(&self) -> bool {
        self.date_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_min(&mut self, v: u32) {
        self.date_min = ::std::option::Option::Some(v);
    }

    pub fn get_date_min(&self) -> u32 {
        self.date_min.unwrap_or(0)
    }

    fn get_date_min_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.date_min
    }

    fn mut_date_min_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.date_min
    }

    // optional fixed32 date_max = 7;

    pub fn clear_date_max(&mut self) {
        self.date_max = ::std::option::Option::None;
    }

    pub fn has_date_max(&self) -> bool {
        self.date_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_max(&mut self, v: u32) {
        self.date_max = ::std::option::Option::Some(v);
    }

    pub fn get_date_max(&self) -> u32 {
        self.date_max.unwrap_or(0)
    }

    fn get_date_max_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.date_max
    }

    fn mut_date_max_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.date_max
    }

    // optional uint32 matches_requested = 10;

    pub fn clear_matches_requested(&mut self) {
        self.matches_requested = ::std::option::Option::None;
    }

    pub fn has_matches_requested(&self) -> bool {
        self.matches_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matches_requested(&mut self, v: u32) {
        self.matches_requested = ::std::option::Option::Some(v);
    }

    pub fn get_matches_requested(&self) -> u32 {
        self.matches_requested.unwrap_or(0)
    }

    fn get_matches_requested_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.matches_requested
    }

    fn mut_matches_requested_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.matches_requested
    }

    // optional uint64 start_at_match_id = 11;

    pub fn clear_start_at_match_id(&mut self) {
        self.start_at_match_id = ::std::option::Option::None;
    }

    pub fn has_start_at_match_id(&self) -> bool {
        self.start_at_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_at_match_id(&mut self, v: u64) {
        self.start_at_match_id = ::std::option::Option::Some(v);
    }

    pub fn get_start_at_match_id(&self) -> u64 {
        self.start_at_match_id.unwrap_or(0)
    }

    fn get_start_at_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.start_at_match_id
    }

    fn mut_start_at_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.start_at_match_id
    }

    // optional fixed32 min_players = 12;

    pub fn clear_min_players(&mut self) {
        self.min_players = ::std::option::Option::None;
    }

    pub fn has_min_players(&self) -> bool {
        self.min_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_players(&mut self, v: u32) {
        self.min_players = ::std::option::Option::Some(v);
    }

    pub fn get_min_players(&self) -> u32 {
        self.min_players.unwrap_or(0)
    }

    fn get_min_players_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.min_players
    }

    fn mut_min_players_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.min_players
    }

    // optional uint32 request_id = 13;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    fn get_request_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.request_id
    }

    fn mut_request_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.request_id
    }

    // optional bool tournament_games_only = 14;

    pub fn clear_tournament_games_only(&mut self) {
        self.tournament_games_only = ::std::option::Option::None;
    }

    pub fn has_tournament_games_only(&self) -> bool {
        self.tournament_games_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_games_only(&mut self, v: bool) {
        self.tournament_games_only = ::std::option::Option::Some(v);
    }

    pub fn get_tournament_games_only(&self) -> bool {
        self.tournament_games_only.unwrap_or(false)
    }

    fn get_tournament_games_only_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.tournament_games_only
    }

    fn mut_tournament_games_only_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.tournament_games_only
    }

    // optional uint32 account_id = 15;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 league_id = 16;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional .CMsgDOTARequestMatches.SkillLevel skill = 17;

    pub fn clear_skill(&mut self) {
        self.skill = ::std::option::Option::None;
    }

    pub fn has_skill(&self) -> bool {
        self.skill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skill(&mut self, v: CMsgDOTARequestMatches_SkillLevel) {
        self.skill = ::std::option::Option::Some(v);
    }

    pub fn get_skill(&self) -> CMsgDOTARequestMatches_SkillLevel {
        self.skill.unwrap_or(CMsgDOTARequestMatches_SkillLevel::Any)
    }

    fn get_skill_for_reflect(&self) -> &::std::option::Option<CMsgDOTARequestMatches_SkillLevel> {
        &self.skill
    }

    fn mut_skill_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTARequestMatches_SkillLevel> {
        &mut self.skill
    }

    // optional uint32 team_id = 18;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_id
    }

    // optional uint64 custom_game_id = 20;

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    pub fn get_custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    fn get_custom_game_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.custom_game_id
    }

    fn mut_custom_game_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.custom_game_id
    }
}

impl ::protobuf::Message for CMsgDOTARequestMatches {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_mode = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.date_min = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.date_max = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matches_requested = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_at_match_id = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.min_players = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tournament_games_only = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.skill = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.custom_game_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.date_min {
            my_size += 5;
        }
        if let Some(v) = self.date_max {
            my_size += 5;
        }
        if let Some(v) = self.matches_requested {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_at_match_id {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.min_players {
            my_size += 5;
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tournament_games_only {
            my_size += 2;
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.skill {
            my_size += ::protobuf::rt::enum_size(17, v);
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.custom_game_id {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.date_min {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.date_max {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.matches_requested {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.start_at_match_id {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.min_players {
            os.write_fixed32(12, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.tournament_games_only {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.skill {
            os.write_enum(17, v.value())?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_uint64(20, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARequestMatches {
    fn new() -> CMsgDOTARequestMatches {
        CMsgDOTARequestMatches::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARequestMatches>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgDOTARequestMatches::get_hero_id_for_reflect,
                    CMsgDOTARequestMatches::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_mode",
                    CMsgDOTARequestMatches::get_game_mode_for_reflect,
                    CMsgDOTARequestMatches::mut_game_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "date_min",
                    CMsgDOTARequestMatches::get_date_min_for_reflect,
                    CMsgDOTARequestMatches::mut_date_min_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "date_max",
                    CMsgDOTARequestMatches::get_date_max_for_reflect,
                    CMsgDOTARequestMatches::mut_date_max_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "matches_requested",
                    CMsgDOTARequestMatches::get_matches_requested_for_reflect,
                    CMsgDOTARequestMatches::mut_matches_requested_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "start_at_match_id",
                    CMsgDOTARequestMatches::get_start_at_match_id_for_reflect,
                    CMsgDOTARequestMatches::mut_start_at_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "min_players",
                    CMsgDOTARequestMatches::get_min_players_for_reflect,
                    CMsgDOTARequestMatches::mut_min_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "request_id",
                    CMsgDOTARequestMatches::get_request_id_for_reflect,
                    CMsgDOTARequestMatches::mut_request_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "tournament_games_only",
                    CMsgDOTARequestMatches::get_tournament_games_only_for_reflect,
                    CMsgDOTARequestMatches::mut_tournament_games_only_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTARequestMatches::get_account_id_for_reflect,
                    CMsgDOTARequestMatches::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgDOTARequestMatches::get_league_id_for_reflect,
                    CMsgDOTARequestMatches::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTARequestMatches_SkillLevel>>(
                    "skill",
                    CMsgDOTARequestMatches::get_skill_for_reflect,
                    CMsgDOTARequestMatches::mut_skill_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_id",
                    CMsgDOTARequestMatches::get_team_id_for_reflect,
                    CMsgDOTARequestMatches::mut_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "custom_game_id",
                    CMsgDOTARequestMatches::get_custom_game_id_for_reflect,
                    CMsgDOTARequestMatches::mut_custom_game_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARequestMatches>(
                    "CMsgDOTARequestMatches",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARequestMatches {
    fn clear(&mut self) {
        self.clear_hero_id();
        self.clear_game_mode();
        self.clear_date_min();
        self.clear_date_max();
        self.clear_matches_requested();
        self.clear_start_at_match_id();
        self.clear_min_players();
        self.clear_request_id();
        self.clear_tournament_games_only();
        self.clear_account_id();
        self.clear_league_id();
        self.clear_skill();
        self.clear_team_id();
        self.clear_custom_game_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARequestMatches {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARequestMatches {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTARequestMatches_SkillLevel {
    Any = 0,
    Normal = 1,
    High = 2,
    VeryHigh = 3,
}

impl ::protobuf::ProtobufEnum for CMsgDOTARequestMatches_SkillLevel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTARequestMatches_SkillLevel> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTARequestMatches_SkillLevel::Any),
            1 => ::std::option::Option::Some(CMsgDOTARequestMatches_SkillLevel::Normal),
            2 => ::std::option::Option::Some(CMsgDOTARequestMatches_SkillLevel::High),
            3 => ::std::option::Option::Some(CMsgDOTARequestMatches_SkillLevel::VeryHigh),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTARequestMatches_SkillLevel] = &[
            CMsgDOTARequestMatches_SkillLevel::Any,
            CMsgDOTARequestMatches_SkillLevel::Normal,
            CMsgDOTARequestMatches_SkillLevel::High,
            CMsgDOTARequestMatches_SkillLevel::VeryHigh,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTARequestMatches_SkillLevel>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTARequestMatches_SkillLevel", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTARequestMatches_SkillLevel {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARequestMatches_SkillLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARequestMatchesResponse {
    // message fields
    matches: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch>,
    series: ::protobuf::RepeatedField<CMsgDOTARequestMatchesResponse_Series>,
    request_id: ::std::option::Option<u32>,
    total_results: ::std::option::Option<u32>,
    results_remaining: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARequestMatchesResponse {}

impl CMsgDOTARequestMatchesResponse {
    pub fn new() -> CMsgDOTARequestMatchesResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARequestMatchesResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARequestMatchesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARequestMatchesResponse,
        };
        unsafe {
            instance.get(CMsgDOTARequestMatchesResponse::new)
        }
    }

    // repeated .CMsgDOTAMatch matches = 1;

    pub fn clear_matches(&mut self) {
        self.matches.clear();
    }

    // Param is passed by value, moved
    pub fn set_matches(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch>) {
        self.matches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matches(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &mut self.matches
    }

    // Take field
    pub fn take_matches(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        ::std::mem::replace(&mut self.matches, ::protobuf::RepeatedField::new())
    }

    pub fn get_matches(&self) -> &[super::dota_gcmessages_common::CMsgDOTAMatch] {
        &self.matches
    }

    fn get_matches_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &self.matches
    }

    fn mut_matches_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &mut self.matches
    }

    // repeated .CMsgDOTARequestMatchesResponse.Series series = 2;

    pub fn clear_series(&mut self) {
        self.series.clear();
    }

    // Param is passed by value, moved
    pub fn set_series(&mut self, v: ::protobuf::RepeatedField<CMsgDOTARequestMatchesResponse_Series>) {
        self.series = v;
    }

    // Mutable pointer to the field.
    pub fn mut_series(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARequestMatchesResponse_Series> {
        &mut self.series
    }

    // Take field
    pub fn take_series(&mut self) -> ::protobuf::RepeatedField<CMsgDOTARequestMatchesResponse_Series> {
        ::std::mem::replace(&mut self.series, ::protobuf::RepeatedField::new())
    }

    pub fn get_series(&self) -> &[CMsgDOTARequestMatchesResponse_Series] {
        &self.series
    }

    fn get_series_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTARequestMatchesResponse_Series> {
        &self.series
    }

    fn mut_series_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTARequestMatchesResponse_Series> {
        &mut self.series
    }

    // optional uint32 request_id = 3;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    fn get_request_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.request_id
    }

    fn mut_request_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.request_id
    }

    // optional uint32 total_results = 4;

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }

    pub fn get_total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }

    fn get_total_results_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_results
    }

    fn mut_total_results_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_results
    }

    // optional uint32 results_remaining = 5;

    pub fn clear_results_remaining(&mut self) {
        self.results_remaining = ::std::option::Option::None;
    }

    pub fn has_results_remaining(&self) -> bool {
        self.results_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_results_remaining(&mut self, v: u32) {
        self.results_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_results_remaining(&self) -> u32 {
        self.results_remaining.unwrap_or(0)
    }

    fn get_results_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.results_remaining
    }

    fn mut_results_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.results_remaining
    }
}

impl ::protobuf::Message for CMsgDOTARequestMatchesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.matches {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.series {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matches)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.series)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_results = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.results_remaining = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.series {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.results_remaining {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.matches {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.series {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.request_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.total_results {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.results_remaining {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARequestMatchesResponse {
    fn new() -> CMsgDOTARequestMatchesResponse {
        CMsgDOTARequestMatchesResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARequestMatchesResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMsgDOTAMatch>>(
                    "matches",
                    CMsgDOTARequestMatchesResponse::get_matches_for_reflect,
                    CMsgDOTARequestMatchesResponse::mut_matches_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTARequestMatchesResponse_Series>>(
                    "series",
                    CMsgDOTARequestMatchesResponse::get_series_for_reflect,
                    CMsgDOTARequestMatchesResponse::mut_series_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "request_id",
                    CMsgDOTARequestMatchesResponse::get_request_id_for_reflect,
                    CMsgDOTARequestMatchesResponse::mut_request_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_results",
                    CMsgDOTARequestMatchesResponse::get_total_results_for_reflect,
                    CMsgDOTARequestMatchesResponse::mut_total_results_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "results_remaining",
                    CMsgDOTARequestMatchesResponse::get_results_remaining_for_reflect,
                    CMsgDOTARequestMatchesResponse::mut_results_remaining_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARequestMatchesResponse>(
                    "CMsgDOTARequestMatchesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARequestMatchesResponse {
    fn clear(&mut self) {
        self.clear_matches();
        self.clear_series();
        self.clear_request_id();
        self.clear_total_results();
        self.clear_results_remaining();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARequestMatchesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARequestMatchesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARequestMatchesResponse_Series {
    // message fields
    matches: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch>,
    series_id: ::std::option::Option<u32>,
    series_type: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARequestMatchesResponse_Series {}

impl CMsgDOTARequestMatchesResponse_Series {
    pub fn new() -> CMsgDOTARequestMatchesResponse_Series {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARequestMatchesResponse_Series {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARequestMatchesResponse_Series> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARequestMatchesResponse_Series,
        };
        unsafe {
            instance.get(CMsgDOTARequestMatchesResponse_Series::new)
        }
    }

    // repeated .CMsgDOTAMatch matches = 1;

    pub fn clear_matches(&mut self) {
        self.matches.clear();
    }

    // Param is passed by value, moved
    pub fn set_matches(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch>) {
        self.matches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matches(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &mut self.matches
    }

    // Take field
    pub fn take_matches(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        ::std::mem::replace(&mut self.matches, ::protobuf::RepeatedField::new())
    }

    pub fn get_matches(&self) -> &[super::dota_gcmessages_common::CMsgDOTAMatch] {
        &self.matches
    }

    fn get_matches_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &self.matches
    }

    fn mut_matches_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &mut self.matches
    }

    // optional uint32 series_id = 2;

    pub fn clear_series_id(&mut self) {
        self.series_id = ::std::option::Option::None;
    }

    pub fn has_series_id(&self) -> bool {
        self.series_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_id(&mut self, v: u32) {
        self.series_id = ::std::option::Option::Some(v);
    }

    pub fn get_series_id(&self) -> u32 {
        self.series_id.unwrap_or(0)
    }

    fn get_series_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.series_id
    }

    fn mut_series_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.series_id
    }

    // optional uint32 series_type = 3;

    pub fn clear_series_type(&mut self) {
        self.series_type = ::std::option::Option::None;
    }

    pub fn has_series_type(&self) -> bool {
        self.series_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_type(&mut self, v: u32) {
        self.series_type = ::std::option::Option::Some(v);
    }

    pub fn get_series_type(&self) -> u32 {
        self.series_type.unwrap_or(0)
    }

    fn get_series_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.series_type
    }

    fn mut_series_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.series_type
    }
}

impl ::protobuf::Message for CMsgDOTARequestMatchesResponse_Series {
    fn is_initialized(&self) -> bool {
        for v in &self.matches {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matches)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.series_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.series_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.series_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.series_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.matches {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.series_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.series_type {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARequestMatchesResponse_Series {
    fn new() -> CMsgDOTARequestMatchesResponse_Series {
        CMsgDOTARequestMatchesResponse_Series::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARequestMatchesResponse_Series>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMsgDOTAMatch>>(
                    "matches",
                    CMsgDOTARequestMatchesResponse_Series::get_matches_for_reflect,
                    CMsgDOTARequestMatchesResponse_Series::mut_matches_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "series_id",
                    CMsgDOTARequestMatchesResponse_Series::get_series_id_for_reflect,
                    CMsgDOTARequestMatchesResponse_Series::mut_series_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "series_type",
                    CMsgDOTARequestMatchesResponse_Series::get_series_type_for_reflect,
                    CMsgDOTARequestMatchesResponse_Series::mut_series_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARequestMatchesResponse_Series>(
                    "CMsgDOTARequestMatchesResponse_Series",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARequestMatchesResponse_Series {
    fn clear(&mut self) {
        self.clear_matches();
        self.clear_series_id();
        self.clear_series_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARequestMatchesResponse_Series {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARequestMatchesResponse_Series {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAPopup {
    // message fields
    id: ::std::option::Option<CMsgDOTAPopup_PopupID>,
    custom_text: ::protobuf::SingularField<::std::string::String>,
    int_data: ::std::option::Option<i32>,
    popup_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    loc_token_header: ::protobuf::SingularField<::std::string::String>,
    loc_token_msg: ::protobuf::SingularField<::std::string::String>,
    var_names: ::protobuf::RepeatedField<::std::string::String>,
    var_values: ::protobuf::RepeatedField<::std::string::String>,
    debug_text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAPopup {}

impl CMsgDOTAPopup {
    pub fn new() -> CMsgDOTAPopup {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAPopup {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAPopup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAPopup,
        };
        unsafe {
            instance.get(CMsgDOTAPopup::new)
        }
    }

    // optional .CMsgDOTAPopup.PopupID id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: CMsgDOTAPopup_PopupID) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> CMsgDOTAPopup_PopupID {
        self.id.unwrap_or(CMsgDOTAPopup_PopupID::NONE)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<CMsgDOTAPopup_PopupID> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAPopup_PopupID> {
        &mut self.id
    }

    // optional string custom_text = 2;

    pub fn clear_custom_text(&mut self) {
        self.custom_text.clear();
    }

    pub fn has_custom_text(&self) -> bool {
        self.custom_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_text(&mut self, v: ::std::string::String) {
        self.custom_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_text(&mut self) -> &mut ::std::string::String {
        if self.custom_text.is_none() {
            self.custom_text.set_default();
        }
        self.custom_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_text(&mut self) -> ::std::string::String {
        self.custom_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_custom_text(&self) -> &str {
        match self.custom_text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_custom_text_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.custom_text
    }

    fn mut_custom_text_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.custom_text
    }

    // optional sint32 int_data = 3;

    pub fn clear_int_data(&mut self) {
        self.int_data = ::std::option::Option::None;
    }

    pub fn has_int_data(&self) -> bool {
        self.int_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_data(&mut self, v: i32) {
        self.int_data = ::std::option::Option::Some(v);
    }

    pub fn get_int_data(&self) -> i32 {
        self.int_data.unwrap_or(0)
    }

    fn get_int_data_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.int_data
    }

    fn mut_int_data_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.int_data
    }

    // optional bytes popup_data = 4;

    pub fn clear_popup_data(&mut self) {
        self.popup_data.clear();
    }

    pub fn has_popup_data(&self) -> bool {
        self.popup_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_popup_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.popup_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_popup_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.popup_data.is_none() {
            self.popup_data.set_default();
        }
        self.popup_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_popup_data(&mut self) -> ::std::vec::Vec<u8> {
        self.popup_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_popup_data(&self) -> &[u8] {
        match self.popup_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_popup_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.popup_data
    }

    fn mut_popup_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.popup_data
    }

    // optional string loc_token_header = 5;

    pub fn clear_loc_token_header(&mut self) {
        self.loc_token_header.clear();
    }

    pub fn has_loc_token_header(&self) -> bool {
        self.loc_token_header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc_token_header(&mut self, v: ::std::string::String) {
        self.loc_token_header = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc_token_header(&mut self) -> &mut ::std::string::String {
        if self.loc_token_header.is_none() {
            self.loc_token_header.set_default();
        }
        self.loc_token_header.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc_token_header(&mut self) -> ::std::string::String {
        self.loc_token_header.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_loc_token_header(&self) -> &str {
        match self.loc_token_header.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_loc_token_header_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.loc_token_header
    }

    fn mut_loc_token_header_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.loc_token_header
    }

    // optional string loc_token_msg = 6;

    pub fn clear_loc_token_msg(&mut self) {
        self.loc_token_msg.clear();
    }

    pub fn has_loc_token_msg(&self) -> bool {
        self.loc_token_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc_token_msg(&mut self, v: ::std::string::String) {
        self.loc_token_msg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc_token_msg(&mut self) -> &mut ::std::string::String {
        if self.loc_token_msg.is_none() {
            self.loc_token_msg.set_default();
        }
        self.loc_token_msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc_token_msg(&mut self) -> ::std::string::String {
        self.loc_token_msg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_loc_token_msg(&self) -> &str {
        match self.loc_token_msg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_loc_token_msg_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.loc_token_msg
    }

    fn mut_loc_token_msg_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.loc_token_msg
    }

    // repeated string var_names = 7;

    pub fn clear_var_names(&mut self) {
        self.var_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_var_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.var_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_var_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.var_names
    }

    // Take field
    pub fn take_var_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.var_names, ::protobuf::RepeatedField::new())
    }

    pub fn get_var_names(&self) -> &[::std::string::String] {
        &self.var_names
    }

    fn get_var_names_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.var_names
    }

    fn mut_var_names_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.var_names
    }

    // repeated string var_values = 8;

    pub fn clear_var_values(&mut self) {
        self.var_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_var_values(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.var_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_var_values(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.var_values
    }

    // Take field
    pub fn take_var_values(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.var_values, ::protobuf::RepeatedField::new())
    }

    pub fn get_var_values(&self) -> &[::std::string::String] {
        &self.var_values
    }

    fn get_var_values_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.var_values
    }

    fn mut_var_values_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.var_values
    }

    // optional string debug_text = 9;

    pub fn clear_debug_text(&mut self) {
        self.debug_text.clear();
    }

    pub fn has_debug_text(&self) -> bool {
        self.debug_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_text(&mut self, v: ::std::string::String) {
        self.debug_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_text(&mut self) -> &mut ::std::string::String {
        if self.debug_text.is_none() {
            self.debug_text.set_default();
        }
        self.debug_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_text(&mut self) -> ::std::string::String {
        self.debug_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_debug_text(&self) -> &str {
        match self.debug_text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_debug_text_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.debug_text
    }

    fn mut_debug_text_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.debug_text
    }
}

impl ::protobuf::Message for CMsgDOTAPopup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.custom_text)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.int_data = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.popup_data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loc_token_header)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loc_token_msg)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.var_names)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.var_values)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.debug_text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.custom_text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.int_data {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        if let Some(ref v) = self.popup_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.loc_token_header.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.loc_token_msg.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.var_names {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.var_values {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if let Some(ref v) = self.debug_text.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.custom_text.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.int_data {
            os.write_sint32(3, v)?;
        }
        if let Some(ref v) = self.popup_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.loc_token_header.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.loc_token_msg.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.var_names {
            os.write_string(7, &v)?;
        };
        for v in &self.var_values {
            os.write_string(8, &v)?;
        };
        if let Some(ref v) = self.debug_text.as_ref() {
            os.write_string(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAPopup {
    fn new() -> CMsgDOTAPopup {
        CMsgDOTAPopup::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAPopup>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAPopup_PopupID>>(
                    "id",
                    CMsgDOTAPopup::get_id_for_reflect,
                    CMsgDOTAPopup::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "custom_text",
                    CMsgDOTAPopup::get_custom_text_for_reflect,
                    CMsgDOTAPopup::mut_custom_text_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "int_data",
                    CMsgDOTAPopup::get_int_data_for_reflect,
                    CMsgDOTAPopup::mut_int_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "popup_data",
                    CMsgDOTAPopup::get_popup_data_for_reflect,
                    CMsgDOTAPopup::mut_popup_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "loc_token_header",
                    CMsgDOTAPopup::get_loc_token_header_for_reflect,
                    CMsgDOTAPopup::mut_loc_token_header_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "loc_token_msg",
                    CMsgDOTAPopup::get_loc_token_msg_for_reflect,
                    CMsgDOTAPopup::mut_loc_token_msg_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "var_names",
                    CMsgDOTAPopup::get_var_names_for_reflect,
                    CMsgDOTAPopup::mut_var_names_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "var_values",
                    CMsgDOTAPopup::get_var_values_for_reflect,
                    CMsgDOTAPopup::mut_var_values_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "debug_text",
                    CMsgDOTAPopup::get_debug_text_for_reflect,
                    CMsgDOTAPopup::mut_debug_text_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAPopup>(
                    "CMsgDOTAPopup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAPopup {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_custom_text();
        self.clear_int_data();
        self.clear_popup_data();
        self.clear_loc_token_header();
        self.clear_loc_token_msg();
        self.clear_var_names();
        self.clear_var_values();
        self.clear_debug_text();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAPopup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAPopup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAPopup_PopupID {
    NONE = -1,
    KICKED_FROM_LOBBY = 0,
    KICKED_FROM_PARTY = 1,
    KICKED_FROM_TEAM = 2,
    TEAM_WAS_DISBANDED = 3,
    TEAM_MATCHMAKE_ALREADY_MATCH = 4,
    TEAM_MATCHMAKE_ALREADY_FINDING = 5,
    TEAM_MATCHMAKE_FULL = 6,
    TEAM_MATCHMAKE_FAIL_ADD = 7,
    TEAM_MATCHMAKE_FAIL_ADD_CURRENT = 8,
    TEAM_MATCHMAKE_FAILED_TEAM_MEMBER = 9,
    TEAM_MATCHMAKE_ALREADY_GAME = 10,
    TEAM_MATCHMAKE_FAIL_GET_PARTY = 11,
    MATCHMAKING_DISABLED = 12,
    INVITE_DENIED = 13,
    PARTY_FULL = 14,
    MADE_ADMIN = 15,
    NEED_TO_PURCHASE = 16,
    SIGNON_MESSAGE = 17,
    GUILD_KICKED = 18,
    MATCHMAKING_REGION_OFFLINE = 19,
    TOURNAMENT_GAME_NOT_FOUND = 21,
    TOURNAMENT_GAME_HAS_LOBBY_ID = 22,
    TOURNAMENT_GAME_HAS_MATCH_ID = 23,
    TOURNAMENT_GAME_HAS_NO_RADIANT_TEAM = 24,
    TOURNAMENT_GAME_HAS_NO_DIRE_TEAM = 25,
    TOURNAMENT_GAME_SQL_UPDATE_FAILED = 26,
    NOT_LEAGUE_ADMIN = 27,
    IN_ANOTHER_GAME = 29,
    PARTY_MEMBER_IN_ANOTHER_GAME = 30,
    PARTY_MEMBER_IN_LOW_PRIORITY = 31,
    CLIENT_OUT_OF_DATE = 32,
    SAVE_GAME_CORRUPT = 38,
    INSUFFICIENT_INGOTS = 39,
    COMPETITIVE_MM_NOT_ENOUGH_SKILL_DATA_PLAY_MORE_CASUAL = 42,
    PARTY_LEADER_JOINED_LOBBY = 44,
    WEEKEND_TOURNEY_UNMATCHED = 48,
    POST_MATCH_SURVEY = 49,
    TROPHY_AWARDED = 50,
    TROPHY_LEVEL_UP = 51,
    ALL_HERO_CHALLENGE_PROGRESS = 52,
    NEED_INITIAL_SKILL = 53,
    NEED_INITIAL_SKILL_IN_PARTY = 54,
    TARGET_ENGINE_MISMATCH = 55,
    VAC_NOT_VERIFIED = 56,
    KICKED_FROM_QUEUE_EVENT_STARTING = 57,
    KICKED_FROM_QUEUE_EVENT_ENDING = 58,
    LOBBY_FULL = 62,
    EVENT_POINTS_EARNED = 63,
    CUSTOM_GAME_INCORRECT_VERSION = 64,
    LIMITED_USER_CHAT = 66,
    EVENT_PREMIUM_POINTS_EARNED = 67,
    LOBBY_MVP_AWARDED = 68,
    LOW_BADGE_LEVEL_CHAT = 71,
    LOW_WINS_CHAT = 72,
    UNVERIFIED_USER_CHAT = 73,
    PARTY_STARTED_FINDING_EVENT_MATCH = 74,
    GENERIC_INFO = 69,
    GENERIC_ERROR = 70,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAPopup_PopupID {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAPopup_PopupID> {
        match value {
            -1 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::NONE),
            0 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::KICKED_FROM_LOBBY),
            1 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::KICKED_FROM_PARTY),
            2 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::KICKED_FROM_TEAM),
            3 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TEAM_WAS_DISBANDED),
            4 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TEAM_MATCHMAKE_ALREADY_MATCH),
            5 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TEAM_MATCHMAKE_ALREADY_FINDING),
            6 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TEAM_MATCHMAKE_FULL),
            7 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TEAM_MATCHMAKE_FAIL_ADD),
            8 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TEAM_MATCHMAKE_FAIL_ADD_CURRENT),
            9 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TEAM_MATCHMAKE_FAILED_TEAM_MEMBER),
            10 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TEAM_MATCHMAKE_ALREADY_GAME),
            11 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TEAM_MATCHMAKE_FAIL_GET_PARTY),
            12 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::MATCHMAKING_DISABLED),
            13 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::INVITE_DENIED),
            14 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::PARTY_FULL),
            15 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::MADE_ADMIN),
            16 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::NEED_TO_PURCHASE),
            17 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::SIGNON_MESSAGE),
            18 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::GUILD_KICKED),
            19 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::MATCHMAKING_REGION_OFFLINE),
            21 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TOURNAMENT_GAME_NOT_FOUND),
            22 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TOURNAMENT_GAME_HAS_LOBBY_ID),
            23 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TOURNAMENT_GAME_HAS_MATCH_ID),
            24 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TOURNAMENT_GAME_HAS_NO_RADIANT_TEAM),
            25 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TOURNAMENT_GAME_HAS_NO_DIRE_TEAM),
            26 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TOURNAMENT_GAME_SQL_UPDATE_FAILED),
            27 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::NOT_LEAGUE_ADMIN),
            29 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::IN_ANOTHER_GAME),
            30 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::PARTY_MEMBER_IN_ANOTHER_GAME),
            31 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::PARTY_MEMBER_IN_LOW_PRIORITY),
            32 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::CLIENT_OUT_OF_DATE),
            38 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::SAVE_GAME_CORRUPT),
            39 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::INSUFFICIENT_INGOTS),
            42 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::COMPETITIVE_MM_NOT_ENOUGH_SKILL_DATA_PLAY_MORE_CASUAL),
            44 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::PARTY_LEADER_JOINED_LOBBY),
            48 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::WEEKEND_TOURNEY_UNMATCHED),
            49 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::POST_MATCH_SURVEY),
            50 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TROPHY_AWARDED),
            51 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TROPHY_LEVEL_UP),
            52 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::ALL_HERO_CHALLENGE_PROGRESS),
            53 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::NEED_INITIAL_SKILL),
            54 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::NEED_INITIAL_SKILL_IN_PARTY),
            55 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::TARGET_ENGINE_MISMATCH),
            56 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::VAC_NOT_VERIFIED),
            57 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::KICKED_FROM_QUEUE_EVENT_STARTING),
            58 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::KICKED_FROM_QUEUE_EVENT_ENDING),
            62 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::LOBBY_FULL),
            63 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::EVENT_POINTS_EARNED),
            64 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::CUSTOM_GAME_INCORRECT_VERSION),
            66 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::LIMITED_USER_CHAT),
            67 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::EVENT_PREMIUM_POINTS_EARNED),
            68 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::LOBBY_MVP_AWARDED),
            71 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::LOW_BADGE_LEVEL_CHAT),
            72 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::LOW_WINS_CHAT),
            73 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::UNVERIFIED_USER_CHAT),
            74 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::PARTY_STARTED_FINDING_EVENT_MATCH),
            69 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::GENERIC_INFO),
            70 => ::std::option::Option::Some(CMsgDOTAPopup_PopupID::GENERIC_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAPopup_PopupID] = &[
            CMsgDOTAPopup_PopupID::NONE,
            CMsgDOTAPopup_PopupID::KICKED_FROM_LOBBY,
            CMsgDOTAPopup_PopupID::KICKED_FROM_PARTY,
            CMsgDOTAPopup_PopupID::KICKED_FROM_TEAM,
            CMsgDOTAPopup_PopupID::TEAM_WAS_DISBANDED,
            CMsgDOTAPopup_PopupID::TEAM_MATCHMAKE_ALREADY_MATCH,
            CMsgDOTAPopup_PopupID::TEAM_MATCHMAKE_ALREADY_FINDING,
            CMsgDOTAPopup_PopupID::TEAM_MATCHMAKE_FULL,
            CMsgDOTAPopup_PopupID::TEAM_MATCHMAKE_FAIL_ADD,
            CMsgDOTAPopup_PopupID::TEAM_MATCHMAKE_FAIL_ADD_CURRENT,
            CMsgDOTAPopup_PopupID::TEAM_MATCHMAKE_FAILED_TEAM_MEMBER,
            CMsgDOTAPopup_PopupID::TEAM_MATCHMAKE_ALREADY_GAME,
            CMsgDOTAPopup_PopupID::TEAM_MATCHMAKE_FAIL_GET_PARTY,
            CMsgDOTAPopup_PopupID::MATCHMAKING_DISABLED,
            CMsgDOTAPopup_PopupID::INVITE_DENIED,
            CMsgDOTAPopup_PopupID::PARTY_FULL,
            CMsgDOTAPopup_PopupID::MADE_ADMIN,
            CMsgDOTAPopup_PopupID::NEED_TO_PURCHASE,
            CMsgDOTAPopup_PopupID::SIGNON_MESSAGE,
            CMsgDOTAPopup_PopupID::GUILD_KICKED,
            CMsgDOTAPopup_PopupID::MATCHMAKING_REGION_OFFLINE,
            CMsgDOTAPopup_PopupID::TOURNAMENT_GAME_NOT_FOUND,
            CMsgDOTAPopup_PopupID::TOURNAMENT_GAME_HAS_LOBBY_ID,
            CMsgDOTAPopup_PopupID::TOURNAMENT_GAME_HAS_MATCH_ID,
            CMsgDOTAPopup_PopupID::TOURNAMENT_GAME_HAS_NO_RADIANT_TEAM,
            CMsgDOTAPopup_PopupID::TOURNAMENT_GAME_HAS_NO_DIRE_TEAM,
            CMsgDOTAPopup_PopupID::TOURNAMENT_GAME_SQL_UPDATE_FAILED,
            CMsgDOTAPopup_PopupID::NOT_LEAGUE_ADMIN,
            CMsgDOTAPopup_PopupID::IN_ANOTHER_GAME,
            CMsgDOTAPopup_PopupID::PARTY_MEMBER_IN_ANOTHER_GAME,
            CMsgDOTAPopup_PopupID::PARTY_MEMBER_IN_LOW_PRIORITY,
            CMsgDOTAPopup_PopupID::CLIENT_OUT_OF_DATE,
            CMsgDOTAPopup_PopupID::SAVE_GAME_CORRUPT,
            CMsgDOTAPopup_PopupID::INSUFFICIENT_INGOTS,
            CMsgDOTAPopup_PopupID::COMPETITIVE_MM_NOT_ENOUGH_SKILL_DATA_PLAY_MORE_CASUAL,
            CMsgDOTAPopup_PopupID::PARTY_LEADER_JOINED_LOBBY,
            CMsgDOTAPopup_PopupID::WEEKEND_TOURNEY_UNMATCHED,
            CMsgDOTAPopup_PopupID::POST_MATCH_SURVEY,
            CMsgDOTAPopup_PopupID::TROPHY_AWARDED,
            CMsgDOTAPopup_PopupID::TROPHY_LEVEL_UP,
            CMsgDOTAPopup_PopupID::ALL_HERO_CHALLENGE_PROGRESS,
            CMsgDOTAPopup_PopupID::NEED_INITIAL_SKILL,
            CMsgDOTAPopup_PopupID::NEED_INITIAL_SKILL_IN_PARTY,
            CMsgDOTAPopup_PopupID::TARGET_ENGINE_MISMATCH,
            CMsgDOTAPopup_PopupID::VAC_NOT_VERIFIED,
            CMsgDOTAPopup_PopupID::KICKED_FROM_QUEUE_EVENT_STARTING,
            CMsgDOTAPopup_PopupID::KICKED_FROM_QUEUE_EVENT_ENDING,
            CMsgDOTAPopup_PopupID::LOBBY_FULL,
            CMsgDOTAPopup_PopupID::EVENT_POINTS_EARNED,
            CMsgDOTAPopup_PopupID::CUSTOM_GAME_INCORRECT_VERSION,
            CMsgDOTAPopup_PopupID::LIMITED_USER_CHAT,
            CMsgDOTAPopup_PopupID::EVENT_PREMIUM_POINTS_EARNED,
            CMsgDOTAPopup_PopupID::LOBBY_MVP_AWARDED,
            CMsgDOTAPopup_PopupID::LOW_BADGE_LEVEL_CHAT,
            CMsgDOTAPopup_PopupID::LOW_WINS_CHAT,
            CMsgDOTAPopup_PopupID::UNVERIFIED_USER_CHAT,
            CMsgDOTAPopup_PopupID::PARTY_STARTED_FINDING_EVENT_MATCH,
            CMsgDOTAPopup_PopupID::GENERIC_INFO,
            CMsgDOTAPopup_PopupID::GENERIC_ERROR,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAPopup_PopupID>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAPopup_PopupID", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAPopup_PopupID {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAPopup_PopupID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAReportsRemainingRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAReportsRemainingRequest {}

impl CMsgDOTAReportsRemainingRequest {
    pub fn new() -> CMsgDOTAReportsRemainingRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAReportsRemainingRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAReportsRemainingRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAReportsRemainingRequest,
        };
        unsafe {
            instance.get(CMsgDOTAReportsRemainingRequest::new)
        }
    }
}

impl ::protobuf::Message for CMsgDOTAReportsRemainingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAReportsRemainingRequest {
    fn new() -> CMsgDOTAReportsRemainingRequest {
        CMsgDOTAReportsRemainingRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAReportsRemainingRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAReportsRemainingRequest>(
                    "CMsgDOTAReportsRemainingRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAReportsRemainingRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAReportsRemainingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAReportsRemainingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAReportsRemainingResponse {
    // message fields
    num_positive_reports_remaining: ::std::option::Option<u32>,
    num_negative_reports_remaining: ::std::option::Option<u32>,
    num_positive_reports_total: ::std::option::Option<u32>,
    num_negative_reports_total: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAReportsRemainingResponse {}

impl CMsgDOTAReportsRemainingResponse {
    pub fn new() -> CMsgDOTAReportsRemainingResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAReportsRemainingResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAReportsRemainingResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAReportsRemainingResponse,
        };
        unsafe {
            instance.get(CMsgDOTAReportsRemainingResponse::new)
        }
    }

    // optional uint32 num_positive_reports_remaining = 1;

    pub fn clear_num_positive_reports_remaining(&mut self) {
        self.num_positive_reports_remaining = ::std::option::Option::None;
    }

    pub fn has_num_positive_reports_remaining(&self) -> bool {
        self.num_positive_reports_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_positive_reports_remaining(&mut self, v: u32) {
        self.num_positive_reports_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_num_positive_reports_remaining(&self) -> u32 {
        self.num_positive_reports_remaining.unwrap_or(0)
    }

    fn get_num_positive_reports_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.num_positive_reports_remaining
    }

    fn mut_num_positive_reports_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.num_positive_reports_remaining
    }

    // optional uint32 num_negative_reports_remaining = 2;

    pub fn clear_num_negative_reports_remaining(&mut self) {
        self.num_negative_reports_remaining = ::std::option::Option::None;
    }

    pub fn has_num_negative_reports_remaining(&self) -> bool {
        self.num_negative_reports_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_negative_reports_remaining(&mut self, v: u32) {
        self.num_negative_reports_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_num_negative_reports_remaining(&self) -> u32 {
        self.num_negative_reports_remaining.unwrap_or(0)
    }

    fn get_num_negative_reports_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.num_negative_reports_remaining
    }

    fn mut_num_negative_reports_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.num_negative_reports_remaining
    }

    // optional uint32 num_positive_reports_total = 3;

    pub fn clear_num_positive_reports_total(&mut self) {
        self.num_positive_reports_total = ::std::option::Option::None;
    }

    pub fn has_num_positive_reports_total(&self) -> bool {
        self.num_positive_reports_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_positive_reports_total(&mut self, v: u32) {
        self.num_positive_reports_total = ::std::option::Option::Some(v);
    }

    pub fn get_num_positive_reports_total(&self) -> u32 {
        self.num_positive_reports_total.unwrap_or(0)
    }

    fn get_num_positive_reports_total_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.num_positive_reports_total
    }

    fn mut_num_positive_reports_total_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.num_positive_reports_total
    }

    // optional uint32 num_negative_reports_total = 4;

    pub fn clear_num_negative_reports_total(&mut self) {
        self.num_negative_reports_total = ::std::option::Option::None;
    }

    pub fn has_num_negative_reports_total(&self) -> bool {
        self.num_negative_reports_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_negative_reports_total(&mut self, v: u32) {
        self.num_negative_reports_total = ::std::option::Option::Some(v);
    }

    pub fn get_num_negative_reports_total(&self) -> u32 {
        self.num_negative_reports_total.unwrap_or(0)
    }

    fn get_num_negative_reports_total_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.num_negative_reports_total
    }

    fn mut_num_negative_reports_total_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.num_negative_reports_total
    }
}

impl ::protobuf::Message for CMsgDOTAReportsRemainingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_positive_reports_remaining = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_negative_reports_remaining = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_positive_reports_total = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_negative_reports_total = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.num_positive_reports_remaining {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_negative_reports_remaining {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_positive_reports_total {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_negative_reports_total {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.num_positive_reports_remaining {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_negative_reports_remaining {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_positive_reports_total {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.num_negative_reports_total {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAReportsRemainingResponse {
    fn new() -> CMsgDOTAReportsRemainingResponse {
        CMsgDOTAReportsRemainingResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAReportsRemainingResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_positive_reports_remaining",
                    CMsgDOTAReportsRemainingResponse::get_num_positive_reports_remaining_for_reflect,
                    CMsgDOTAReportsRemainingResponse::mut_num_positive_reports_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_negative_reports_remaining",
                    CMsgDOTAReportsRemainingResponse::get_num_negative_reports_remaining_for_reflect,
                    CMsgDOTAReportsRemainingResponse::mut_num_negative_reports_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_positive_reports_total",
                    CMsgDOTAReportsRemainingResponse::get_num_positive_reports_total_for_reflect,
                    CMsgDOTAReportsRemainingResponse::mut_num_positive_reports_total_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_negative_reports_total",
                    CMsgDOTAReportsRemainingResponse::get_num_negative_reports_total_for_reflect,
                    CMsgDOTAReportsRemainingResponse::mut_num_negative_reports_total_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAReportsRemainingResponse>(
                    "CMsgDOTAReportsRemainingResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAReportsRemainingResponse {
    fn clear(&mut self) {
        self.clear_num_positive_reports_remaining();
        self.clear_num_negative_reports_remaining();
        self.clear_num_positive_reports_total();
        self.clear_num_negative_reports_total();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAReportsRemainingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAReportsRemainingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASubmitPlayerReport {
    // message fields
    target_account_id: ::std::option::Option<u32>,
    report_flags: ::std::option::Option<u32>,
    lobby_id: ::std::option::Option<u64>,
    comment: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASubmitPlayerReport {}

impl CMsgDOTASubmitPlayerReport {
    pub fn new() -> CMsgDOTASubmitPlayerReport {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASubmitPlayerReport {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASubmitPlayerReport> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASubmitPlayerReport,
        };
        unsafe {
            instance.get(CMsgDOTASubmitPlayerReport::new)
        }
    }

    // optional uint32 target_account_id = 1;

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    fn get_target_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_account_id
    }

    fn mut_target_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_account_id
    }

    // optional uint32 report_flags = 2;

    pub fn clear_report_flags(&mut self) {
        self.report_flags = ::std::option::Option::None;
    }

    pub fn has_report_flags(&self) -> bool {
        self.report_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_flags(&mut self, v: u32) {
        self.report_flags = ::std::option::Option::Some(v);
    }

    pub fn get_report_flags(&self) -> u32 {
        self.report_flags.unwrap_or(0)
    }

    fn get_report_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.report_flags
    }

    fn mut_report_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.report_flags
    }

    // optional uint64 lobby_id = 4;

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    fn get_lobby_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.lobby_id
    }

    fn mut_lobby_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.lobby_id
    }

    // optional string comment = 5;

    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment.set_default();
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_comment_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.comment
    }

    fn mut_comment_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.comment
    }
}

impl ::protobuf::Message for CMsgDOTASubmitPlayerReport {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.report_flags = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lobby_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.comment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.report_flags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.report_flags {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(4, v)?;
        }
        if let Some(ref v) = self.comment.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASubmitPlayerReport {
    fn new() -> CMsgDOTASubmitPlayerReport {
        CMsgDOTASubmitPlayerReport::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASubmitPlayerReport>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_account_id",
                    CMsgDOTASubmitPlayerReport::get_target_account_id_for_reflect,
                    CMsgDOTASubmitPlayerReport::mut_target_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "report_flags",
                    CMsgDOTASubmitPlayerReport::get_report_flags_for_reflect,
                    CMsgDOTASubmitPlayerReport::mut_report_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "lobby_id",
                    CMsgDOTASubmitPlayerReport::get_lobby_id_for_reflect,
                    CMsgDOTASubmitPlayerReport::mut_lobby_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "comment",
                    CMsgDOTASubmitPlayerReport::get_comment_for_reflect,
                    CMsgDOTASubmitPlayerReport::mut_comment_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASubmitPlayerReport>(
                    "CMsgDOTASubmitPlayerReport",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASubmitPlayerReport {
    fn clear(&mut self) {
        self.clear_target_account_id();
        self.clear_report_flags();
        self.clear_lobby_id();
        self.clear_comment();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASubmitPlayerReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASubmitPlayerReport {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASubmitPlayerReportResponse {
    // message fields
    target_account_id: ::std::option::Option<u32>,
    report_flags: ::std::option::Option<u32>,
    result: ::std::option::Option<u32>,
    debug_message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASubmitPlayerReportResponse {}

impl CMsgDOTASubmitPlayerReportResponse {
    pub fn new() -> CMsgDOTASubmitPlayerReportResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASubmitPlayerReportResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASubmitPlayerReportResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASubmitPlayerReportResponse,
        };
        unsafe {
            instance.get(CMsgDOTASubmitPlayerReportResponse::new)
        }
    }

    // optional uint32 target_account_id = 1;

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    fn get_target_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_account_id
    }

    fn mut_target_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_account_id
    }

    // optional uint32 report_flags = 2;

    pub fn clear_report_flags(&mut self) {
        self.report_flags = ::std::option::Option::None;
    }

    pub fn has_report_flags(&self) -> bool {
        self.report_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_flags(&mut self, v: u32) {
        self.report_flags = ::std::option::Option::Some(v);
    }

    pub fn get_report_flags(&self) -> u32 {
        self.report_flags.unwrap_or(0)
    }

    fn get_report_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.report_flags
    }

    fn mut_report_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.report_flags
    }

    // optional uint32 result = 3;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.result
    }

    // optional string debug_message = 4;

    pub fn clear_debug_message(&mut self) {
        self.debug_message.clear();
    }

    pub fn has_debug_message(&self) -> bool {
        self.debug_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_message(&mut self, v: ::std::string::String) {
        self.debug_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_message(&mut self) -> &mut ::std::string::String {
        if self.debug_message.is_none() {
            self.debug_message.set_default();
        }
        self.debug_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_message(&mut self) -> ::std::string::String {
        self.debug_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_debug_message(&self) -> &str {
        match self.debug_message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_debug_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.debug_message
    }

    fn mut_debug_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.debug_message
    }
}

impl ::protobuf::Message for CMsgDOTASubmitPlayerReportResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.report_flags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.debug_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.report_flags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.debug_message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.report_flags {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.result {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.debug_message.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASubmitPlayerReportResponse {
    fn new() -> CMsgDOTASubmitPlayerReportResponse {
        CMsgDOTASubmitPlayerReportResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASubmitPlayerReportResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_account_id",
                    CMsgDOTASubmitPlayerReportResponse::get_target_account_id_for_reflect,
                    CMsgDOTASubmitPlayerReportResponse::mut_target_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "report_flags",
                    CMsgDOTASubmitPlayerReportResponse::get_report_flags_for_reflect,
                    CMsgDOTASubmitPlayerReportResponse::mut_report_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "result",
                    CMsgDOTASubmitPlayerReportResponse::get_result_for_reflect,
                    CMsgDOTASubmitPlayerReportResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "debug_message",
                    CMsgDOTASubmitPlayerReportResponse::get_debug_message_for_reflect,
                    CMsgDOTASubmitPlayerReportResponse::mut_debug_message_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASubmitPlayerReportResponse>(
                    "CMsgDOTASubmitPlayerReportResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASubmitPlayerReportResponse {
    fn clear(&mut self) {
        self.clear_target_account_id();
        self.clear_report_flags();
        self.clear_result();
        self.clear_debug_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASubmitPlayerReportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASubmitPlayerReportResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAReportCountsRequest {
    // message fields
    target_account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAReportCountsRequest {}

impl CMsgDOTAReportCountsRequest {
    pub fn new() -> CMsgDOTAReportCountsRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAReportCountsRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAReportCountsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAReportCountsRequest,
        };
        unsafe {
            instance.get(CMsgDOTAReportCountsRequest::new)
        }
    }

    // optional uint32 target_account_id = 1;

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    fn get_target_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_account_id
    }

    fn mut_target_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_account_id
    }
}

impl ::protobuf::Message for CMsgDOTAReportCountsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAReportCountsRequest {
    fn new() -> CMsgDOTAReportCountsRequest {
        CMsgDOTAReportCountsRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAReportCountsRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_account_id",
                    CMsgDOTAReportCountsRequest::get_target_account_id_for_reflect,
                    CMsgDOTAReportCountsRequest::mut_target_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAReportCountsRequest>(
                    "CMsgDOTAReportCountsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAReportCountsRequest {
    fn clear(&mut self) {
        self.clear_target_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAReportCountsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAReportCountsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAReportCountsResponse {
    // message fields
    target_account_id: ::std::option::Option<u32>,
    leadership_count: ::std::option::Option<u32>,
    teaching_count: ::std::option::Option<u32>,
    friendly_count: ::std::option::Option<u32>,
    forgiving_count: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAReportCountsResponse {}

impl CMsgDOTAReportCountsResponse {
    pub fn new() -> CMsgDOTAReportCountsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAReportCountsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAReportCountsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAReportCountsResponse,
        };
        unsafe {
            instance.get(CMsgDOTAReportCountsResponse::new)
        }
    }

    // optional uint32 target_account_id = 1;

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    fn get_target_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_account_id
    }

    fn mut_target_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_account_id
    }

    // optional uint32 leadership_count = 2;

    pub fn clear_leadership_count(&mut self) {
        self.leadership_count = ::std::option::Option::None;
    }

    pub fn has_leadership_count(&self) -> bool {
        self.leadership_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leadership_count(&mut self, v: u32) {
        self.leadership_count = ::std::option::Option::Some(v);
    }

    pub fn get_leadership_count(&self) -> u32 {
        self.leadership_count.unwrap_or(0)
    }

    fn get_leadership_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.leadership_count
    }

    fn mut_leadership_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.leadership_count
    }

    // optional uint32 teaching_count = 3;

    pub fn clear_teaching_count(&mut self) {
        self.teaching_count = ::std::option::Option::None;
    }

    pub fn has_teaching_count(&self) -> bool {
        self.teaching_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teaching_count(&mut self, v: u32) {
        self.teaching_count = ::std::option::Option::Some(v);
    }

    pub fn get_teaching_count(&self) -> u32 {
        self.teaching_count.unwrap_or(0)
    }

    fn get_teaching_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.teaching_count
    }

    fn mut_teaching_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.teaching_count
    }

    // optional uint32 friendly_count = 4;

    pub fn clear_friendly_count(&mut self) {
        self.friendly_count = ::std::option::Option::None;
    }

    pub fn has_friendly_count(&self) -> bool {
        self.friendly_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendly_count(&mut self, v: u32) {
        self.friendly_count = ::std::option::Option::Some(v);
    }

    pub fn get_friendly_count(&self) -> u32 {
        self.friendly_count.unwrap_or(0)
    }

    fn get_friendly_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.friendly_count
    }

    fn mut_friendly_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.friendly_count
    }

    // optional uint32 forgiving_count = 5;

    pub fn clear_forgiving_count(&mut self) {
        self.forgiving_count = ::std::option::Option::None;
    }

    pub fn has_forgiving_count(&self) -> bool {
        self.forgiving_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forgiving_count(&mut self, v: u32) {
        self.forgiving_count = ::std::option::Option::Some(v);
    }

    pub fn get_forgiving_count(&self) -> u32 {
        self.forgiving_count.unwrap_or(0)
    }

    fn get_forgiving_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.forgiving_count
    }

    fn mut_forgiving_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.forgiving_count
    }
}

impl ::protobuf::Message for CMsgDOTAReportCountsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leadership_count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.teaching_count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.friendly_count = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.forgiving_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leadership_count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.teaching_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friendly_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.forgiving_count {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.leadership_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.teaching_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.friendly_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.forgiving_count {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAReportCountsResponse {
    fn new() -> CMsgDOTAReportCountsResponse {
        CMsgDOTAReportCountsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAReportCountsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_account_id",
                    CMsgDOTAReportCountsResponse::get_target_account_id_for_reflect,
                    CMsgDOTAReportCountsResponse::mut_target_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "leadership_count",
                    CMsgDOTAReportCountsResponse::get_leadership_count_for_reflect,
                    CMsgDOTAReportCountsResponse::mut_leadership_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "teaching_count",
                    CMsgDOTAReportCountsResponse::get_teaching_count_for_reflect,
                    CMsgDOTAReportCountsResponse::mut_teaching_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "friendly_count",
                    CMsgDOTAReportCountsResponse::get_friendly_count_for_reflect,
                    CMsgDOTAReportCountsResponse::mut_friendly_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "forgiving_count",
                    CMsgDOTAReportCountsResponse::get_forgiving_count_for_reflect,
                    CMsgDOTAReportCountsResponse::mut_forgiving_count_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAReportCountsResponse>(
                    "CMsgDOTAReportCountsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAReportCountsResponse {
    fn clear(&mut self) {
        self.clear_target_account_id();
        self.clear_leadership_count();
        self.clear_teaching_count();
        self.clear_friendly_count();
        self.clear_forgiving_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAReportCountsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAReportCountsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASubmitLobbyMVPVote {
    // message fields
    target_account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASubmitLobbyMVPVote {}

impl CMsgDOTASubmitLobbyMVPVote {
    pub fn new() -> CMsgDOTASubmitLobbyMVPVote {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASubmitLobbyMVPVote {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASubmitLobbyMVPVote> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASubmitLobbyMVPVote,
        };
        unsafe {
            instance.get(CMsgDOTASubmitLobbyMVPVote::new)
        }
    }

    // optional uint32 target_account_id = 1;

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    fn get_target_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_account_id
    }

    fn mut_target_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_account_id
    }
}

impl ::protobuf::Message for CMsgDOTASubmitLobbyMVPVote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASubmitLobbyMVPVote {
    fn new() -> CMsgDOTASubmitLobbyMVPVote {
        CMsgDOTASubmitLobbyMVPVote::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASubmitLobbyMVPVote>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_account_id",
                    CMsgDOTASubmitLobbyMVPVote::get_target_account_id_for_reflect,
                    CMsgDOTASubmitLobbyMVPVote::mut_target_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASubmitLobbyMVPVote>(
                    "CMsgDOTASubmitLobbyMVPVote",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASubmitLobbyMVPVote {
    fn clear(&mut self) {
        self.clear_target_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASubmitLobbyMVPVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASubmitLobbyMVPVote {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASubmitLobbyMVPVoteResponse {
    // message fields
    target_account_id: ::std::option::Option<u32>,
    eresult: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASubmitLobbyMVPVoteResponse {}

impl CMsgDOTASubmitLobbyMVPVoteResponse {
    pub fn new() -> CMsgDOTASubmitLobbyMVPVoteResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASubmitLobbyMVPVoteResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASubmitLobbyMVPVoteResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASubmitLobbyMVPVoteResponse,
        };
        unsafe {
            instance.get(CMsgDOTASubmitLobbyMVPVoteResponse::new)
        }
    }

    // optional uint32 target_account_id = 1;

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    fn get_target_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_account_id
    }

    fn mut_target_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_account_id
    }

    // optional uint32 eresult = 2;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    fn get_eresult_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.eresult
    }

    fn mut_eresult_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.eresult
    }
}

impl ::protobuf::Message for CMsgDOTASubmitLobbyMVPVoteResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASubmitLobbyMVPVoteResponse {
    fn new() -> CMsgDOTASubmitLobbyMVPVoteResponse {
        CMsgDOTASubmitLobbyMVPVoteResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASubmitLobbyMVPVoteResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_account_id",
                    CMsgDOTASubmitLobbyMVPVoteResponse::get_target_account_id_for_reflect,
                    CMsgDOTASubmitLobbyMVPVoteResponse::mut_target_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "eresult",
                    CMsgDOTASubmitLobbyMVPVoteResponse::get_eresult_for_reflect,
                    CMsgDOTASubmitLobbyMVPVoteResponse::mut_eresult_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASubmitLobbyMVPVoteResponse>(
                    "CMsgDOTASubmitLobbyMVPVoteResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASubmitLobbyMVPVoteResponse {
    fn clear(&mut self) {
        self.clear_target_account_id();
        self.clear_eresult();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASubmitLobbyMVPVoteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASubmitLobbyMVPVoteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALobbyMVPNotifyRecipient {
    // message fields
    voter_account_id: ::std::option::Option<u32>,
    recipient_account_id: ::std::option::Option<u32>,
    num_votes: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALobbyMVPNotifyRecipient {}

impl CMsgDOTALobbyMVPNotifyRecipient {
    pub fn new() -> CMsgDOTALobbyMVPNotifyRecipient {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALobbyMVPNotifyRecipient {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALobbyMVPNotifyRecipient> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALobbyMVPNotifyRecipient,
        };
        unsafe {
            instance.get(CMsgDOTALobbyMVPNotifyRecipient::new)
        }
    }

    // optional uint32 voter_account_id = 1;

    pub fn clear_voter_account_id(&mut self) {
        self.voter_account_id = ::std::option::Option::None;
    }

    pub fn has_voter_account_id(&self) -> bool {
        self.voter_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voter_account_id(&mut self, v: u32) {
        self.voter_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_voter_account_id(&self) -> u32 {
        self.voter_account_id.unwrap_or(0)
    }

    fn get_voter_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.voter_account_id
    }

    fn mut_voter_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.voter_account_id
    }

    // optional uint32 recipient_account_id = 2;

    pub fn clear_recipient_account_id(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
    }

    pub fn has_recipient_account_id(&self) -> bool {
        self.recipient_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_account_id(&mut self, v: u32) {
        self.recipient_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_recipient_account_id(&self) -> u32 {
        self.recipient_account_id.unwrap_or(0)
    }

    fn get_recipient_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.recipient_account_id
    }

    fn mut_recipient_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.recipient_account_id
    }

    // optional uint32 num_votes = 3;

    pub fn clear_num_votes(&mut self) {
        self.num_votes = ::std::option::Option::None;
    }

    pub fn has_num_votes(&self) -> bool {
        self.num_votes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_votes(&mut self, v: u32) {
        self.num_votes = ::std::option::Option::Some(v);
    }

    pub fn get_num_votes(&self) -> u32 {
        self.num_votes.unwrap_or(0)
    }

    fn get_num_votes_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.num_votes
    }

    fn mut_num_votes_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.num_votes
    }
}

impl ::protobuf::Message for CMsgDOTALobbyMVPNotifyRecipient {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.voter_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recipient_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_votes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.voter_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.recipient_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_votes {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.voter_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.recipient_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_votes {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALobbyMVPNotifyRecipient {
    fn new() -> CMsgDOTALobbyMVPNotifyRecipient {
        CMsgDOTALobbyMVPNotifyRecipient::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALobbyMVPNotifyRecipient>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "voter_account_id",
                    CMsgDOTALobbyMVPNotifyRecipient::get_voter_account_id_for_reflect,
                    CMsgDOTALobbyMVPNotifyRecipient::mut_voter_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "recipient_account_id",
                    CMsgDOTALobbyMVPNotifyRecipient::get_recipient_account_id_for_reflect,
                    CMsgDOTALobbyMVPNotifyRecipient::mut_recipient_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_votes",
                    CMsgDOTALobbyMVPNotifyRecipient::get_num_votes_for_reflect,
                    CMsgDOTALobbyMVPNotifyRecipient::mut_num_votes_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALobbyMVPNotifyRecipient>(
                    "CMsgDOTALobbyMVPNotifyRecipient",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALobbyMVPNotifyRecipient {
    fn clear(&mut self) {
        self.clear_voter_account_id();
        self.clear_recipient_account_id();
        self.clear_num_votes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALobbyMVPNotifyRecipient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALobbyMVPNotifyRecipient {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALobbyMVPAwarded {
    // message fields
    mvp_account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALobbyMVPAwarded {}

impl CMsgDOTALobbyMVPAwarded {
    pub fn new() -> CMsgDOTALobbyMVPAwarded {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALobbyMVPAwarded {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALobbyMVPAwarded> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALobbyMVPAwarded,
        };
        unsafe {
            instance.get(CMsgDOTALobbyMVPAwarded::new)
        }
    }

    // optional uint32 mvp_account_id = 1;

    pub fn clear_mvp_account_id(&mut self) {
        self.mvp_account_id = ::std::option::Option::None;
    }

    pub fn has_mvp_account_id(&self) -> bool {
        self.mvp_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mvp_account_id(&mut self, v: u32) {
        self.mvp_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_mvp_account_id(&self) -> u32 {
        self.mvp_account_id.unwrap_or(0)
    }

    fn get_mvp_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mvp_account_id
    }

    fn mut_mvp_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mvp_account_id
    }
}

impl ::protobuf::Message for CMsgDOTALobbyMVPAwarded {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mvp_account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mvp_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mvp_account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALobbyMVPAwarded {
    fn new() -> CMsgDOTALobbyMVPAwarded {
        CMsgDOTALobbyMVPAwarded::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALobbyMVPAwarded>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mvp_account_id",
                    CMsgDOTALobbyMVPAwarded::get_mvp_account_id_for_reflect,
                    CMsgDOTALobbyMVPAwarded::mut_mvp_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALobbyMVPAwarded>(
                    "CMsgDOTALobbyMVPAwarded",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALobbyMVPAwarded {
    fn clear(&mut self) {
        self.clear_mvp_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALobbyMVPAwarded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALobbyMVPAwarded {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAKickedFromMatchmakingQueue {
    // message fields
    match_type: ::std::option::Option<super::dota_shared_enums::MatchType>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAKickedFromMatchmakingQueue {}

impl CMsgDOTAKickedFromMatchmakingQueue {
    pub fn new() -> CMsgDOTAKickedFromMatchmakingQueue {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAKickedFromMatchmakingQueue {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAKickedFromMatchmakingQueue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAKickedFromMatchmakingQueue,
        };
        unsafe {
            instance.get(CMsgDOTAKickedFromMatchmakingQueue::new)
        }
    }

    // optional .MatchType match_type = 1;

    pub fn clear_match_type(&mut self) {
        self.match_type = ::std::option::Option::None;
    }

    pub fn has_match_type(&self) -> bool {
        self.match_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_type(&mut self, v: super::dota_shared_enums::MatchType) {
        self.match_type = ::std::option::Option::Some(v);
    }

    pub fn get_match_type(&self) -> super::dota_shared_enums::MatchType {
        self.match_type.unwrap_or(super::dota_shared_enums::MatchType::MATCH_TYPE_CASUAL)
    }

    fn get_match_type_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::MatchType> {
        &self.match_type
    }

    fn mut_match_type_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::MatchType> {
        &mut self.match_type
    }
}

impl ::protobuf::Message for CMsgDOTAKickedFromMatchmakingQueue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.match_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_type {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAKickedFromMatchmakingQueue {
    fn new() -> CMsgDOTAKickedFromMatchmakingQueue {
        CMsgDOTAKickedFromMatchmakingQueue::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAKickedFromMatchmakingQueue>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::MatchType>>(
                    "match_type",
                    CMsgDOTAKickedFromMatchmakingQueue::get_match_type_for_reflect,
                    CMsgDOTAKickedFromMatchmakingQueue::mut_match_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAKickedFromMatchmakingQueue>(
                    "CMsgDOTAKickedFromMatchmakingQueue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAKickedFromMatchmakingQueue {
    fn clear(&mut self) {
        self.clear_match_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAKickedFromMatchmakingQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAKickedFromMatchmakingQueue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARequestSaveGames {
    // message fields
    server_region: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARequestSaveGames {}

impl CMsgDOTARequestSaveGames {
    pub fn new() -> CMsgDOTARequestSaveGames {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARequestSaveGames {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARequestSaveGames> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARequestSaveGames,
        };
        unsafe {
            instance.get(CMsgDOTARequestSaveGames::new)
        }
    }

    // optional uint32 server_region = 1;

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    pub fn get_server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    fn get_server_region_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_region
    }

    fn mut_server_region_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_region
    }
}

impl ::protobuf::Message for CMsgDOTARequestSaveGames {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_region = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_region {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_region {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARequestSaveGames {
    fn new() -> CMsgDOTARequestSaveGames {
        CMsgDOTARequestSaveGames::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARequestSaveGames>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_region",
                    CMsgDOTARequestSaveGames::get_server_region_for_reflect,
                    CMsgDOTARequestSaveGames::mut_server_region_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARequestSaveGames>(
                    "CMsgDOTARequestSaveGames",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARequestSaveGames {
    fn clear(&mut self) {
        self.clear_server_region();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARequestSaveGames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARequestSaveGames {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARequestSaveGamesResponse {
    // message fields
    steam_id: ::std::option::Option<u64>,
    save_games: ::protobuf::RepeatedField<super::dota_shared_enums::CDOTASaveGame>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARequestSaveGamesResponse {}

impl CMsgDOTARequestSaveGamesResponse {
    pub fn new() -> CMsgDOTARequestSaveGamesResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARequestSaveGamesResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARequestSaveGamesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARequestSaveGamesResponse,
        };
        unsafe {
            instance.get(CMsgDOTARequestSaveGamesResponse::new)
        }
    }

    // optional fixed64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    fn get_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.steam_id
    }

    fn mut_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.steam_id
    }

    // repeated .CDOTASaveGame save_games = 2;

    pub fn clear_save_games(&mut self) {
        self.save_games.clear();
    }

    // Param is passed by value, moved
    pub fn set_save_games(&mut self, v: ::protobuf::RepeatedField<super::dota_shared_enums::CDOTASaveGame>) {
        self.save_games = v;
    }

    // Mutable pointer to the field.
    pub fn mut_save_games(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_shared_enums::CDOTASaveGame> {
        &mut self.save_games
    }

    // Take field
    pub fn take_save_games(&mut self) -> ::protobuf::RepeatedField<super::dota_shared_enums::CDOTASaveGame> {
        ::std::mem::replace(&mut self.save_games, ::protobuf::RepeatedField::new())
    }

    pub fn get_save_games(&self) -> &[super::dota_shared_enums::CDOTASaveGame] {
        &self.save_games
    }

    fn get_save_games_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_shared_enums::CDOTASaveGame> {
        &self.save_games
    }

    fn mut_save_games_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_shared_enums::CDOTASaveGame> {
        &mut self.save_games
    }
}

impl ::protobuf::Message for CMsgDOTARequestSaveGamesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.save_games {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.save_games)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        for value in &self.save_games {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        for v in &self.save_games {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARequestSaveGamesResponse {
    fn new() -> CMsgDOTARequestSaveGamesResponse {
        CMsgDOTARequestSaveGamesResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARequestSaveGamesResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steam_id",
                    CMsgDOTARequestSaveGamesResponse::get_steam_id_for_reflect,
                    CMsgDOTARequestSaveGamesResponse::mut_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_shared_enums::CDOTASaveGame>>(
                    "save_games",
                    CMsgDOTARequestSaveGamesResponse::get_save_games_for_reflect,
                    CMsgDOTARequestSaveGamesResponse::mut_save_games_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARequestSaveGamesResponse>(
                    "CMsgDOTARequestSaveGamesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARequestSaveGamesResponse {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_save_games();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARequestSaveGamesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARequestSaveGamesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCMatchDetailsRequest {
    // message fields
    match_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCMatchDetailsRequest {}

impl CMsgGCMatchDetailsRequest {
    pub fn new() -> CMsgGCMatchDetailsRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCMatchDetailsRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCMatchDetailsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCMatchDetailsRequest,
        };
        unsafe {
            instance.get(CMsgGCMatchDetailsRequest::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }
}

impl ::protobuf::Message for CMsgGCMatchDetailsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCMatchDetailsRequest {
    fn new() -> CMsgGCMatchDetailsRequest {
        CMsgGCMatchDetailsRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCMatchDetailsRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgGCMatchDetailsRequest::get_match_id_for_reflect,
                    CMsgGCMatchDetailsRequest::mut_match_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCMatchDetailsRequest>(
                    "CMsgGCMatchDetailsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCMatchDetailsRequest {
    fn clear(&mut self) {
        self.clear_match_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCMatchDetailsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCMatchDetailsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCMatchDetailsResponse {
    // message fields
    result: ::std::option::Option<u32>,
    field_match: ::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgDOTAMatch>,
    vote: ::std::option::Option<super::dota_shared_enums::DOTAMatchVote>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCMatchDetailsResponse {}

impl CMsgGCMatchDetailsResponse {
    pub fn new() -> CMsgGCMatchDetailsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCMatchDetailsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCMatchDetailsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCMatchDetailsResponse,
        };
        unsafe {
            instance.get(CMsgGCMatchDetailsResponse::new)
        }
    }

    // optional uint32 result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.result
    }

    // optional .CMsgDOTAMatch match = 2;

    pub fn clear_field_match(&mut self) {
        self.field_match.clear();
    }

    pub fn has_field_match(&self) -> bool {
        self.field_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_match(&mut self, v: super::dota_gcmessages_common::CMsgDOTAMatch) {
        self.field_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_match(&mut self) -> &mut super::dota_gcmessages_common::CMsgDOTAMatch {
        if self.field_match.is_none() {
            self.field_match.set_default();
        }
        self.field_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_match(&mut self) -> super::dota_gcmessages_common::CMsgDOTAMatch {
        self.field_match.take().unwrap_or_else(|| super::dota_gcmessages_common::CMsgDOTAMatch::new())
    }

    pub fn get_field_match(&self) -> &super::dota_gcmessages_common::CMsgDOTAMatch {
        self.field_match.as_ref().unwrap_or_else(|| super::dota_gcmessages_common::CMsgDOTAMatch::default_instance())
    }

    fn get_field_match_for_reflect(&self) -> &::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &self.field_match
    }

    fn mut_field_match_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &mut self.field_match
    }

    // optional .DOTAMatchVote vote = 3;

    pub fn clear_vote(&mut self) {
        self.vote = ::std::option::Option::None;
    }

    pub fn has_vote(&self) -> bool {
        self.vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: super::dota_shared_enums::DOTAMatchVote) {
        self.vote = ::std::option::Option::Some(v);
    }

    pub fn get_vote(&self) -> super::dota_shared_enums::DOTAMatchVote {
        self.vote.unwrap_or(super::dota_shared_enums::DOTAMatchVote::DOTAMatchVote_INVALID)
    }

    fn get_vote_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::DOTAMatchVote> {
        &self.vote
    }

    fn mut_vote_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::DOTAMatchVote> {
        &mut self.vote
    }
}

impl ::protobuf::Message for CMsgGCMatchDetailsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.field_match {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_match)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.vote = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.field_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.vote {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.field_match.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.vote {
            os.write_enum(3, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCMatchDetailsResponse {
    fn new() -> CMsgGCMatchDetailsResponse {
        CMsgGCMatchDetailsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCMatchDetailsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "result",
                    CMsgGCMatchDetailsResponse::get_result_for_reflect,
                    CMsgGCMatchDetailsResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMsgDOTAMatch>>(
                    "match",
                    CMsgGCMatchDetailsResponse::get_field_match_for_reflect,
                    CMsgGCMatchDetailsResponse::mut_field_match_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::DOTAMatchVote>>(
                    "vote",
                    CMsgGCMatchDetailsResponse::get_vote_for_reflect,
                    CMsgGCMatchDetailsResponse::mut_vote_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCMatchDetailsResponse>(
                    "CMsgGCMatchDetailsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCMatchDetailsResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_field_match();
        self.clear_vote();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCMatchDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCMatchDetailsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerToGCMatchDetailsRequest {
    // message fields
    match_ids: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerToGCMatchDetailsRequest {}

impl CMsgServerToGCMatchDetailsRequest {
    pub fn new() -> CMsgServerToGCMatchDetailsRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerToGCMatchDetailsRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerToGCMatchDetailsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerToGCMatchDetailsRequest,
        };
        unsafe {
            instance.get(CMsgServerToGCMatchDetailsRequest::new)
        }
    }

    // repeated uint64 match_ids = 1;

    pub fn clear_match_ids(&mut self) {
        self.match_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_match_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.match_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_match_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.match_ids
    }

    // Take field
    pub fn take_match_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.match_ids, ::std::vec::Vec::new())
    }

    pub fn get_match_ids(&self) -> &[u64] {
        &self.match_ids
    }

    fn get_match_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.match_ids
    }

    fn mut_match_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.match_ids
    }
}

impl ::protobuf::Message for CMsgServerToGCMatchDetailsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.match_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.match_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.match_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerToGCMatchDetailsRequest {
    fn new() -> CMsgServerToGCMatchDetailsRequest {
        CMsgServerToGCMatchDetailsRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerToGCMatchDetailsRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_ids",
                    CMsgServerToGCMatchDetailsRequest::get_match_ids_for_reflect,
                    CMsgServerToGCMatchDetailsRequest::mut_match_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerToGCMatchDetailsRequest>(
                    "CMsgServerToGCMatchDetailsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerToGCMatchDetailsRequest {
    fn clear(&mut self) {
        self.clear_match_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerToGCMatchDetailsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerToGCMatchDetailsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToServerMatchDetailsResponse {
    // message fields
    matches: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToServerMatchDetailsResponse {}

impl CMsgGCToServerMatchDetailsResponse {
    pub fn new() -> CMsgGCToServerMatchDetailsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToServerMatchDetailsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToServerMatchDetailsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToServerMatchDetailsResponse,
        };
        unsafe {
            instance.get(CMsgGCToServerMatchDetailsResponse::new)
        }
    }

    // repeated .CMsgDOTAMatch matches = 1;

    pub fn clear_matches(&mut self) {
        self.matches.clear();
    }

    // Param is passed by value, moved
    pub fn set_matches(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch>) {
        self.matches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matches(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &mut self.matches
    }

    // Take field
    pub fn take_matches(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        ::std::mem::replace(&mut self.matches, ::protobuf::RepeatedField::new())
    }

    pub fn get_matches(&self) -> &[super::dota_gcmessages_common::CMsgDOTAMatch] {
        &self.matches
    }

    fn get_matches_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &self.matches
    }

    fn mut_matches_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &mut self.matches
    }
}

impl ::protobuf::Message for CMsgGCToServerMatchDetailsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.matches {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matches)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.matches {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToServerMatchDetailsResponse {
    fn new() -> CMsgGCToServerMatchDetailsResponse {
        CMsgGCToServerMatchDetailsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToServerMatchDetailsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMsgDOTAMatch>>(
                    "matches",
                    CMsgGCToServerMatchDetailsResponse::get_matches_for_reflect,
                    CMsgGCToServerMatchDetailsResponse::mut_matches_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToServerMatchDetailsResponse>(
                    "CMsgGCToServerMatchDetailsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToServerMatchDetailsResponse {
    fn clear(&mut self) {
        self.clear_matches();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToServerMatchDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToServerMatchDetailsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileRequest {
    // message fields
    account_id: ::std::option::Option<u32>,
    request_name: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileRequest {}

impl CMsgDOTAProfileRequest {
    pub fn new() -> CMsgDOTAProfileRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileRequest,
        };
        unsafe {
            instance.get(CMsgDOTAProfileRequest::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional bool request_name = 2;

    pub fn clear_request_name(&mut self) {
        self.request_name = ::std::option::Option::None;
    }

    pub fn has_request_name(&self) -> bool {
        self.request_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_name(&mut self, v: bool) {
        self.request_name = ::std::option::Option::Some(v);
    }

    pub fn get_request_name(&self) -> bool {
        self.request_name.unwrap_or(false)
    }

    fn get_request_name_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.request_name
    }

    fn mut_request_name_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.request_name
    }
}

impl ::protobuf::Message for CMsgDOTAProfileRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.request_name = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_name {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.request_name {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileRequest {
    fn new() -> CMsgDOTAProfileRequest {
        CMsgDOTAProfileRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAProfileRequest::get_account_id_for_reflect,
                    CMsgDOTAProfileRequest::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "request_name",
                    CMsgDOTAProfileRequest::get_request_name_for_reflect,
                    CMsgDOTAProfileRequest::mut_request_name_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileRequest>(
                    "CMsgDOTAProfileRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileRequest {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_request_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileResponse {
    // message fields
    result: ::std::option::Option<u32>,
    game_account_client: ::protobuf::SingularPtrField<super::dota_gcmessages_common::CSODOTAGameAccountClient>,
    latest_matches: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch>,
    heroes: ::protobuf::RepeatedField<CMsgDOTAProfileResponse_PlayedHero>,
    player_name: ::protobuf::SingularField<::std::string::String>,
    team_name: ::protobuf::SingularField<::std::string::String>,
    team_tag: ::protobuf::SingularField<::std::string::String>,
    team_logo: ::std::option::Option<u64>,
    showcase_hero: ::protobuf::SingularPtrField<CMsgDOTAProfileResponse_ShowcaseHero>,
    league_passes: ::protobuf::RepeatedField<CMsgDOTAProfileResponse_LeaguePass>,
    event_tickets: ::protobuf::RepeatedField<CMsgDOTAProfileResponse_EventTicket>,
    team_id: ::std::option::Option<u32>,
    has_passport: ::std::option::Option<bool>,
    featured_items: ::protobuf::RepeatedField<CMsgDOTAProfileResponse_FeaturedItem>,
    abandon_percent: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileResponse {}

impl CMsgDOTAProfileResponse {
    pub fn new() -> CMsgDOTAProfileResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileResponse,
        };
        unsafe {
            instance.get(CMsgDOTAProfileResponse::new)
        }
    }

    // optional uint32 result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.result
    }

    // optional .CSODOTAGameAccountClient game_account_client = 2;

    pub fn clear_game_account_client(&mut self) {
        self.game_account_client.clear();
    }

    pub fn has_game_account_client(&self) -> bool {
        self.game_account_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_account_client(&mut self, v: super::dota_gcmessages_common::CSODOTAGameAccountClient) {
        self.game_account_client = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_account_client(&mut self) -> &mut super::dota_gcmessages_common::CSODOTAGameAccountClient {
        if self.game_account_client.is_none() {
            self.game_account_client.set_default();
        }
        self.game_account_client.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_account_client(&mut self) -> super::dota_gcmessages_common::CSODOTAGameAccountClient {
        self.game_account_client.take().unwrap_or_else(|| super::dota_gcmessages_common::CSODOTAGameAccountClient::new())
    }

    pub fn get_game_account_client(&self) -> &super::dota_gcmessages_common::CSODOTAGameAccountClient {
        self.game_account_client.as_ref().unwrap_or_else(|| super::dota_gcmessages_common::CSODOTAGameAccountClient::default_instance())
    }

    fn get_game_account_client_for_reflect(&self) -> &::protobuf::SingularPtrField<super::dota_gcmessages_common::CSODOTAGameAccountClient> {
        &self.game_account_client
    }

    fn mut_game_account_client_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::dota_gcmessages_common::CSODOTAGameAccountClient> {
        &mut self.game_account_client
    }

    // repeated .CMsgDOTAMatch latest_matches = 3;

    pub fn clear_latest_matches(&mut self) {
        self.latest_matches.clear();
    }

    // Param is passed by value, moved
    pub fn set_latest_matches(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch>) {
        self.latest_matches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_latest_matches(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &mut self.latest_matches
    }

    // Take field
    pub fn take_latest_matches(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        ::std::mem::replace(&mut self.latest_matches, ::protobuf::RepeatedField::new())
    }

    pub fn get_latest_matches(&self) -> &[super::dota_gcmessages_common::CMsgDOTAMatch] {
        &self.latest_matches
    }

    fn get_latest_matches_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &self.latest_matches
    }

    fn mut_latest_matches_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &mut self.latest_matches
    }

    // repeated .CMsgDOTAProfileResponse.PlayedHero heroes = 4;

    pub fn clear_heroes(&mut self) {
        self.heroes.clear();
    }

    // Param is passed by value, moved
    pub fn set_heroes(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAProfileResponse_PlayedHero>) {
        self.heroes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_heroes(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAProfileResponse_PlayedHero> {
        &mut self.heroes
    }

    // Take field
    pub fn take_heroes(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAProfileResponse_PlayedHero> {
        ::std::mem::replace(&mut self.heroes, ::protobuf::RepeatedField::new())
    }

    pub fn get_heroes(&self) -> &[CMsgDOTAProfileResponse_PlayedHero] {
        &self.heroes
    }

    fn get_heroes_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAProfileResponse_PlayedHero> {
        &self.heroes
    }

    fn mut_heroes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAProfileResponse_PlayedHero> {
        &mut self.heroes
    }

    // optional string player_name = 5;

    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_player_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.player_name
    }

    fn mut_player_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.player_name
    }

    // optional string team_name = 6;

    pub fn clear_team_name(&mut self) {
        self.team_name.clear();
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name.set_default();
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_name
    }

    fn mut_team_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_name
    }

    // optional string team_tag = 7;

    pub fn clear_team_tag(&mut self) {
        self.team_tag.clear();
    }

    pub fn has_team_tag(&self) -> bool {
        self.team_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_tag(&mut self, v: ::std::string::String) {
        self.team_tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_tag(&mut self) -> &mut ::std::string::String {
        if self.team_tag.is_none() {
            self.team_tag.set_default();
        }
        self.team_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_tag(&mut self) -> ::std::string::String {
        self.team_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_tag(&self) -> &str {
        match self.team_tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_tag_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_tag
    }

    fn mut_team_tag_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_tag
    }

    // optional uint64 team_logo = 8;

    pub fn clear_team_logo(&mut self) {
        self.team_logo = ::std::option::Option::None;
    }

    pub fn has_team_logo(&self) -> bool {
        self.team_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_logo(&mut self, v: u64) {
        self.team_logo = ::std::option::Option::Some(v);
    }

    pub fn get_team_logo(&self) -> u64 {
        self.team_logo.unwrap_or(0)
    }

    fn get_team_logo_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.team_logo
    }

    fn mut_team_logo_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.team_logo
    }

    // optional .CMsgDOTAProfileResponse.ShowcaseHero showcase_hero = 9;

    pub fn clear_showcase_hero(&mut self) {
        self.showcase_hero.clear();
    }

    pub fn has_showcase_hero(&self) -> bool {
        self.showcase_hero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase_hero(&mut self, v: CMsgDOTAProfileResponse_ShowcaseHero) {
        self.showcase_hero = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_showcase_hero(&mut self) -> &mut CMsgDOTAProfileResponse_ShowcaseHero {
        if self.showcase_hero.is_none() {
            self.showcase_hero.set_default();
        }
        self.showcase_hero.as_mut().unwrap()
    }

    // Take field
    pub fn take_showcase_hero(&mut self) -> CMsgDOTAProfileResponse_ShowcaseHero {
        self.showcase_hero.take().unwrap_or_else(|| CMsgDOTAProfileResponse_ShowcaseHero::new())
    }

    pub fn get_showcase_hero(&self) -> &CMsgDOTAProfileResponse_ShowcaseHero {
        self.showcase_hero.as_ref().unwrap_or_else(|| CMsgDOTAProfileResponse_ShowcaseHero::default_instance())
    }

    fn get_showcase_hero_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAProfileResponse_ShowcaseHero> {
        &self.showcase_hero
    }

    fn mut_showcase_hero_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAProfileResponse_ShowcaseHero> {
        &mut self.showcase_hero
    }

    // repeated .CMsgDOTAProfileResponse.LeaguePass league_passes = 10;

    pub fn clear_league_passes(&mut self) {
        self.league_passes.clear();
    }

    // Param is passed by value, moved
    pub fn set_league_passes(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAProfileResponse_LeaguePass>) {
        self.league_passes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_league_passes(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAProfileResponse_LeaguePass> {
        &mut self.league_passes
    }

    // Take field
    pub fn take_league_passes(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAProfileResponse_LeaguePass> {
        ::std::mem::replace(&mut self.league_passes, ::protobuf::RepeatedField::new())
    }

    pub fn get_league_passes(&self) -> &[CMsgDOTAProfileResponse_LeaguePass] {
        &self.league_passes
    }

    fn get_league_passes_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAProfileResponse_LeaguePass> {
        &self.league_passes
    }

    fn mut_league_passes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAProfileResponse_LeaguePass> {
        &mut self.league_passes
    }

    // repeated .CMsgDOTAProfileResponse.EventTicket event_tickets = 11;

    pub fn clear_event_tickets(&mut self) {
        self.event_tickets.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_tickets(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAProfileResponse_EventTicket>) {
        self.event_tickets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_event_tickets(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAProfileResponse_EventTicket> {
        &mut self.event_tickets
    }

    // Take field
    pub fn take_event_tickets(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAProfileResponse_EventTicket> {
        ::std::mem::replace(&mut self.event_tickets, ::protobuf::RepeatedField::new())
    }

    pub fn get_event_tickets(&self) -> &[CMsgDOTAProfileResponse_EventTicket] {
        &self.event_tickets
    }

    fn get_event_tickets_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAProfileResponse_EventTicket> {
        &self.event_tickets
    }

    fn mut_event_tickets_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAProfileResponse_EventTicket> {
        &mut self.event_tickets
    }

    // optional uint32 team_id = 12;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_id
    }

    // optional bool has_passport = 13;

    pub fn clear_has_passport(&mut self) {
        self.has_passport = ::std::option::Option::None;
    }

    pub fn has_has_passport(&self) -> bool {
        self.has_passport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_passport(&mut self, v: bool) {
        self.has_passport = ::std::option::Option::Some(v);
    }

    pub fn get_has_passport(&self) -> bool {
        self.has_passport.unwrap_or(false)
    }

    fn get_has_passport_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.has_passport
    }

    fn mut_has_passport_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.has_passport
    }

    // repeated .CMsgDOTAProfileResponse.FeaturedItem featured_items = 14;

    pub fn clear_featured_items(&mut self) {
        self.featured_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_featured_items(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAProfileResponse_FeaturedItem>) {
        self.featured_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_featured_items(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAProfileResponse_FeaturedItem> {
        &mut self.featured_items
    }

    // Take field
    pub fn take_featured_items(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAProfileResponse_FeaturedItem> {
        ::std::mem::replace(&mut self.featured_items, ::protobuf::RepeatedField::new())
    }

    pub fn get_featured_items(&self) -> &[CMsgDOTAProfileResponse_FeaturedItem] {
        &self.featured_items
    }

    fn get_featured_items_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAProfileResponse_FeaturedItem> {
        &self.featured_items
    }

    fn mut_featured_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAProfileResponse_FeaturedItem> {
        &mut self.featured_items
    }

    // optional uint32 abandon_percent = 15;

    pub fn clear_abandon_percent(&mut self) {
        self.abandon_percent = ::std::option::Option::None;
    }

    pub fn has_abandon_percent(&self) -> bool {
        self.abandon_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abandon_percent(&mut self, v: u32) {
        self.abandon_percent = ::std::option::Option::Some(v);
    }

    pub fn get_abandon_percent(&self) -> u32 {
        self.abandon_percent.unwrap_or(0)
    }

    fn get_abandon_percent_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.abandon_percent
    }

    fn mut_abandon_percent_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.abandon_percent
    }
}

impl ::protobuf::Message for CMsgDOTAProfileResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.game_account_client {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.latest_matches {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.heroes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.showcase_hero {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.league_passes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.event_tickets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.featured_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.game_account_client)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.latest_matches)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.heroes)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_name)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_tag)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.team_logo = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.showcase_hero)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.league_passes)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.event_tickets)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_passport = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.featured_items)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.abandon_percent = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.game_account_client.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.latest_matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.heroes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.team_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.team_logo {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.showcase_hero.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.league_passes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.event_tickets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.has_passport {
            my_size += 2;
        }
        for value in &self.featured_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.abandon_percent {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.game_account_client.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.latest_matches {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.heroes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.player_name.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.team_name.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.team_tag.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.team_logo {
            os.write_uint64(8, v)?;
        }
        if let Some(ref v) = self.showcase_hero.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.league_passes {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.event_tickets {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.team_id {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.has_passport {
            os.write_bool(13, v)?;
        }
        for v in &self.featured_items {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.abandon_percent {
            os.write_uint32(15, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileResponse {
    fn new() -> CMsgDOTAProfileResponse {
        CMsgDOTAProfileResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "result",
                    CMsgDOTAProfileResponse::get_result_for_reflect,
                    CMsgDOTAProfileResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CSODOTAGameAccountClient>>(
                    "game_account_client",
                    CMsgDOTAProfileResponse::get_game_account_client_for_reflect,
                    CMsgDOTAProfileResponse::mut_game_account_client_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMsgDOTAMatch>>(
                    "latest_matches",
                    CMsgDOTAProfileResponse::get_latest_matches_for_reflect,
                    CMsgDOTAProfileResponse::mut_latest_matches_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAProfileResponse_PlayedHero>>(
                    "heroes",
                    CMsgDOTAProfileResponse::get_heroes_for_reflect,
                    CMsgDOTAProfileResponse::mut_heroes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "player_name",
                    CMsgDOTAProfileResponse::get_player_name_for_reflect,
                    CMsgDOTAProfileResponse::mut_player_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_name",
                    CMsgDOTAProfileResponse::get_team_name_for_reflect,
                    CMsgDOTAProfileResponse::mut_team_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_tag",
                    CMsgDOTAProfileResponse::get_team_tag_for_reflect,
                    CMsgDOTAProfileResponse::mut_team_tag_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "team_logo",
                    CMsgDOTAProfileResponse::get_team_logo_for_reflect,
                    CMsgDOTAProfileResponse::mut_team_logo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAProfileResponse_ShowcaseHero>>(
                    "showcase_hero",
                    CMsgDOTAProfileResponse::get_showcase_hero_for_reflect,
                    CMsgDOTAProfileResponse::mut_showcase_hero_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAProfileResponse_LeaguePass>>(
                    "league_passes",
                    CMsgDOTAProfileResponse::get_league_passes_for_reflect,
                    CMsgDOTAProfileResponse::mut_league_passes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAProfileResponse_EventTicket>>(
                    "event_tickets",
                    CMsgDOTAProfileResponse::get_event_tickets_for_reflect,
                    CMsgDOTAProfileResponse::mut_event_tickets_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_id",
                    CMsgDOTAProfileResponse::get_team_id_for_reflect,
                    CMsgDOTAProfileResponse::mut_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "has_passport",
                    CMsgDOTAProfileResponse::get_has_passport_for_reflect,
                    CMsgDOTAProfileResponse::mut_has_passport_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAProfileResponse_FeaturedItem>>(
                    "featured_items",
                    CMsgDOTAProfileResponse::get_featured_items_for_reflect,
                    CMsgDOTAProfileResponse::mut_featured_items_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "abandon_percent",
                    CMsgDOTAProfileResponse::get_abandon_percent_for_reflect,
                    CMsgDOTAProfileResponse::mut_abandon_percent_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileResponse>(
                    "CMsgDOTAProfileResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_game_account_client();
        self.clear_latest_matches();
        self.clear_heroes();
        self.clear_player_name();
        self.clear_team_name();
        self.clear_team_tag();
        self.clear_team_logo();
        self.clear_showcase_hero();
        self.clear_league_passes();
        self.clear_event_tickets();
        self.clear_team_id();
        self.clear_has_passport();
        self.clear_featured_items();
        self.clear_abandon_percent();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileResponse_PlayedHero {
    // message fields
    hero_id: ::std::option::Option<u32>,
    wins: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileResponse_PlayedHero {}

impl CMsgDOTAProfileResponse_PlayedHero {
    pub fn new() -> CMsgDOTAProfileResponse_PlayedHero {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileResponse_PlayedHero {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileResponse_PlayedHero> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileResponse_PlayedHero,
        };
        unsafe {
            instance.get(CMsgDOTAProfileResponse_PlayedHero::new)
        }
    }

    // optional uint32 hero_id = 1;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 wins = 2;

    pub fn clear_wins(&mut self) {
        self.wins = ::std::option::Option::None;
    }

    pub fn has_wins(&self) -> bool {
        self.wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: u32) {
        self.wins = ::std::option::Option::Some(v);
    }

    pub fn get_wins(&self) -> u32 {
        self.wins.unwrap_or(0)
    }

    fn get_wins_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.wins
    }

    fn mut_wins_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.wins
    }
}

impl ::protobuf::Message for CMsgDOTAProfileResponse_PlayedHero {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wins = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wins {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.wins {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileResponse_PlayedHero {
    fn new() -> CMsgDOTAProfileResponse_PlayedHero {
        CMsgDOTAProfileResponse_PlayedHero::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileResponse_PlayedHero>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgDOTAProfileResponse_PlayedHero::get_hero_id_for_reflect,
                    CMsgDOTAProfileResponse_PlayedHero::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wins",
                    CMsgDOTAProfileResponse_PlayedHero::get_wins_for_reflect,
                    CMsgDOTAProfileResponse_PlayedHero::mut_wins_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileResponse_PlayedHero>(
                    "CMsgDOTAProfileResponse_PlayedHero",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileResponse_PlayedHero {
    fn clear(&mut self) {
        self.clear_hero_id();
        self.clear_wins();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileResponse_PlayedHero {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileResponse_PlayedHero {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileResponse_ShowcaseHero {
    // message fields
    hero_id: ::std::option::Option<u32>,
    object_data: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileResponse_ShowcaseHero {}

impl CMsgDOTAProfileResponse_ShowcaseHero {
    pub fn new() -> CMsgDOTAProfileResponse_ShowcaseHero {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileResponse_ShowcaseHero {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileResponse_ShowcaseHero> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileResponse_ShowcaseHero,
        };
        unsafe {
            instance.get(CMsgDOTAProfileResponse_ShowcaseHero::new)
        }
    }

    // optional uint32 hero_id = 1;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // repeated bytes object_data = 2;

    pub fn clear_object_data(&mut self) {
        self.object_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_data(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.object_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_object_data(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.object_data
    }

    // Take field
    pub fn take_object_data(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.object_data, ::protobuf::RepeatedField::new())
    }

    pub fn get_object_data(&self) -> &[::std::vec::Vec<u8>] {
        &self.object_data
    }

    fn get_object_data_for_reflect(&self) -> &::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &self.object_data
    }

    fn mut_object_data_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.object_data
    }
}

impl ::protobuf::Message for CMsgDOTAProfileResponse_ShowcaseHero {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.object_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.object_data {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.object_data {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileResponse_ShowcaseHero {
    fn new() -> CMsgDOTAProfileResponse_ShowcaseHero {
        CMsgDOTAProfileResponse_ShowcaseHero::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileResponse_ShowcaseHero>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgDOTAProfileResponse_ShowcaseHero::get_hero_id_for_reflect,
                    CMsgDOTAProfileResponse_ShowcaseHero::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "object_data",
                    CMsgDOTAProfileResponse_ShowcaseHero::get_object_data_for_reflect,
                    CMsgDOTAProfileResponse_ShowcaseHero::mut_object_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileResponse_ShowcaseHero>(
                    "CMsgDOTAProfileResponse_ShowcaseHero",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileResponse_ShowcaseHero {
    fn clear(&mut self) {
        self.clear_hero_id();
        self.clear_object_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileResponse_ShowcaseHero {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileResponse_ShowcaseHero {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileResponse_LeaguePass {
    // message fields
    league_id: ::std::option::Option<u32>,
    item_def: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileResponse_LeaguePass {}

impl CMsgDOTAProfileResponse_LeaguePass {
    pub fn new() -> CMsgDOTAProfileResponse_LeaguePass {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileResponse_LeaguePass {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileResponse_LeaguePass> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileResponse_LeaguePass,
        };
        unsafe {
            instance.get(CMsgDOTAProfileResponse_LeaguePass::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional uint32 item_def = 2;

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    pub fn get_item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    fn get_item_def_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_def
    }

    fn mut_item_def_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_def
    }
}

impl ::protobuf::Message for CMsgDOTAProfileResponse_LeaguePass {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_def {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileResponse_LeaguePass {
    fn new() -> CMsgDOTAProfileResponse_LeaguePass {
        CMsgDOTAProfileResponse_LeaguePass::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileResponse_LeaguePass>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgDOTAProfileResponse_LeaguePass::get_league_id_for_reflect,
                    CMsgDOTAProfileResponse_LeaguePass::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_def",
                    CMsgDOTAProfileResponse_LeaguePass::get_item_def_for_reflect,
                    CMsgDOTAProfileResponse_LeaguePass::mut_item_def_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileResponse_LeaguePass>(
                    "CMsgDOTAProfileResponse_LeaguePass",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileResponse_LeaguePass {
    fn clear(&mut self) {
        self.clear_league_id();
        self.clear_item_def();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileResponse_LeaguePass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileResponse_LeaguePass {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileResponse_EventTicket {
    // message fields
    event_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileResponse_EventTicket {}

impl CMsgDOTAProfileResponse_EventTicket {
    pub fn new() -> CMsgDOTAProfileResponse_EventTicket {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileResponse_EventTicket {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileResponse_EventTicket> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileResponse_EventTicket,
        };
        unsafe {
            instance.get(CMsgDOTAProfileResponse_EventTicket::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }
}

impl ::protobuf::Message for CMsgDOTAProfileResponse_EventTicket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileResponse_EventTicket {
    fn new() -> CMsgDOTAProfileResponse_EventTicket {
        CMsgDOTAProfileResponse_EventTicket::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileResponse_EventTicket>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgDOTAProfileResponse_EventTicket::get_event_id_for_reflect,
                    CMsgDOTAProfileResponse_EventTicket::mut_event_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileResponse_EventTicket>(
                    "CMsgDOTAProfileResponse_EventTicket",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileResponse_EventTicket {
    fn clear(&mut self) {
        self.clear_event_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileResponse_EventTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileResponse_EventTicket {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileResponse_FeaturedItem {
    // message fields
    item_id: ::std::option::Option<u64>,
    object_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    slot_index: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileResponse_FeaturedItem {}

impl CMsgDOTAProfileResponse_FeaturedItem {
    pub fn new() -> CMsgDOTAProfileResponse_FeaturedItem {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileResponse_FeaturedItem {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileResponse_FeaturedItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileResponse_FeaturedItem,
        };
        unsafe {
            instance.get(CMsgDOTAProfileResponse_FeaturedItem::new)
        }
    }

    // optional uint64 item_id = 1;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }

    // optional bytes object_data = 2;

    pub fn clear_object_data(&mut self) {
        self.object_data.clear();
    }

    pub fn has_object_data(&self) -> bool {
        self.object_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.object_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.object_data.is_none() {
            self.object_data.set_default();
        }
        self.object_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_data(&mut self) -> ::std::vec::Vec<u8> {
        self.object_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_object_data(&self) -> &[u8] {
        match self.object_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_object_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.object_data
    }

    fn mut_object_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.object_data
    }

    // optional uint32 slot_index = 3;

    pub fn clear_slot_index(&mut self) {
        self.slot_index = ::std::option::Option::None;
    }

    pub fn has_slot_index(&self) -> bool {
        self.slot_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_index(&mut self, v: u32) {
        self.slot_index = ::std::option::Option::Some(v);
    }

    pub fn get_slot_index(&self) -> u32 {
        self.slot_index.unwrap_or(0)
    }

    fn get_slot_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_index
    }

    fn mut_slot_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_index
    }
}

impl ::protobuf::Message for CMsgDOTAProfileResponse_FeaturedItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.object_data)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.object_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.slot_index {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.object_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.slot_index {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileResponse_FeaturedItem {
    fn new() -> CMsgDOTAProfileResponse_FeaturedItem {
        CMsgDOTAProfileResponse_FeaturedItem::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileResponse_FeaturedItem>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgDOTAProfileResponse_FeaturedItem::get_item_id_for_reflect,
                    CMsgDOTAProfileResponse_FeaturedItem::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "object_data",
                    CMsgDOTAProfileResponse_FeaturedItem::get_object_data_for_reflect,
                    CMsgDOTAProfileResponse_FeaturedItem::mut_object_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_index",
                    CMsgDOTAProfileResponse_FeaturedItem::get_slot_index_for_reflect,
                    CMsgDOTAProfileResponse_FeaturedItem::mut_slot_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileResponse_FeaturedItem>(
                    "CMsgDOTAProfileResponse_FeaturedItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileResponse_FeaturedItem {
    fn clear(&mut self) {
        self.clear_item_id();
        self.clear_object_data();
        self.clear_slot_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileResponse_FeaturedItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileResponse_FeaturedItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileTickets {
    // message fields
    result: ::std::option::Option<u32>,
    account_id: ::std::option::Option<u32>,
    league_passes: ::protobuf::RepeatedField<CMsgDOTAProfileTickets_LeaguePass>,
    event_tickets: ::protobuf::RepeatedField<CMsgDOTAProfileTickets_EventTicket>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileTickets {}

impl CMsgDOTAProfileTickets {
    pub fn new() -> CMsgDOTAProfileTickets {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileTickets {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileTickets> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileTickets,
        };
        unsafe {
            instance.get(CMsgDOTAProfileTickets::new)
        }
    }

    // optional uint32 result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.result
    }

    // optional uint32 account_id = 2;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // repeated .CMsgDOTAProfileTickets.LeaguePass league_passes = 3;

    pub fn clear_league_passes(&mut self) {
        self.league_passes.clear();
    }

    // Param is passed by value, moved
    pub fn set_league_passes(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAProfileTickets_LeaguePass>) {
        self.league_passes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_league_passes(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAProfileTickets_LeaguePass> {
        &mut self.league_passes
    }

    // Take field
    pub fn take_league_passes(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAProfileTickets_LeaguePass> {
        ::std::mem::replace(&mut self.league_passes, ::protobuf::RepeatedField::new())
    }

    pub fn get_league_passes(&self) -> &[CMsgDOTAProfileTickets_LeaguePass] {
        &self.league_passes
    }

    fn get_league_passes_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAProfileTickets_LeaguePass> {
        &self.league_passes
    }

    fn mut_league_passes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAProfileTickets_LeaguePass> {
        &mut self.league_passes
    }

    // repeated .CMsgDOTAProfileTickets.EventTicket event_tickets = 4;

    pub fn clear_event_tickets(&mut self) {
        self.event_tickets.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_tickets(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAProfileTickets_EventTicket>) {
        self.event_tickets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_event_tickets(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAProfileTickets_EventTicket> {
        &mut self.event_tickets
    }

    // Take field
    pub fn take_event_tickets(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAProfileTickets_EventTicket> {
        ::std::mem::replace(&mut self.event_tickets, ::protobuf::RepeatedField::new())
    }

    pub fn get_event_tickets(&self) -> &[CMsgDOTAProfileTickets_EventTicket] {
        &self.event_tickets
    }

    fn get_event_tickets_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAProfileTickets_EventTicket> {
        &self.event_tickets
    }

    fn mut_event_tickets_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAProfileTickets_EventTicket> {
        &mut self.event_tickets
    }
}

impl ::protobuf::Message for CMsgDOTAProfileTickets {
    fn is_initialized(&self) -> bool {
        for v in &self.league_passes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.event_tickets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.league_passes)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.event_tickets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.league_passes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.event_tickets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        for v in &self.league_passes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.event_tickets {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileTickets {
    fn new() -> CMsgDOTAProfileTickets {
        CMsgDOTAProfileTickets::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileTickets>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "result",
                    CMsgDOTAProfileTickets::get_result_for_reflect,
                    CMsgDOTAProfileTickets::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAProfileTickets::get_account_id_for_reflect,
                    CMsgDOTAProfileTickets::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAProfileTickets_LeaguePass>>(
                    "league_passes",
                    CMsgDOTAProfileTickets::get_league_passes_for_reflect,
                    CMsgDOTAProfileTickets::mut_league_passes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAProfileTickets_EventTicket>>(
                    "event_tickets",
                    CMsgDOTAProfileTickets::get_event_tickets_for_reflect,
                    CMsgDOTAProfileTickets::mut_event_tickets_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileTickets>(
                    "CMsgDOTAProfileTickets",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileTickets {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_account_id();
        self.clear_league_passes();
        self.clear_event_tickets();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileTickets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileTickets {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileTickets_LeaguePass {
    // message fields
    league_id: ::std::option::Option<u32>,
    item_def: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileTickets_LeaguePass {}

impl CMsgDOTAProfileTickets_LeaguePass {
    pub fn new() -> CMsgDOTAProfileTickets_LeaguePass {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileTickets_LeaguePass {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileTickets_LeaguePass> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileTickets_LeaguePass,
        };
        unsafe {
            instance.get(CMsgDOTAProfileTickets_LeaguePass::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional uint32 item_def = 2;

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    pub fn get_item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    fn get_item_def_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_def
    }

    fn mut_item_def_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_def
    }
}

impl ::protobuf::Message for CMsgDOTAProfileTickets_LeaguePass {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_def {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileTickets_LeaguePass {
    fn new() -> CMsgDOTAProfileTickets_LeaguePass {
        CMsgDOTAProfileTickets_LeaguePass::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileTickets_LeaguePass>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgDOTAProfileTickets_LeaguePass::get_league_id_for_reflect,
                    CMsgDOTAProfileTickets_LeaguePass::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_def",
                    CMsgDOTAProfileTickets_LeaguePass::get_item_def_for_reflect,
                    CMsgDOTAProfileTickets_LeaguePass::mut_item_def_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileTickets_LeaguePass>(
                    "CMsgDOTAProfileTickets_LeaguePass",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileTickets_LeaguePass {
    fn clear(&mut self) {
        self.clear_league_id();
        self.clear_item_def();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileTickets_LeaguePass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileTickets_LeaguePass {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAProfileTickets_EventTicket {
    // message fields
    event_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAProfileTickets_EventTicket {}

impl CMsgDOTAProfileTickets_EventTicket {
    pub fn new() -> CMsgDOTAProfileTickets_EventTicket {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAProfileTickets_EventTicket {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAProfileTickets_EventTicket> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAProfileTickets_EventTicket,
        };
        unsafe {
            instance.get(CMsgDOTAProfileTickets_EventTicket::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }
}

impl ::protobuf::Message for CMsgDOTAProfileTickets_EventTicket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAProfileTickets_EventTicket {
    fn new() -> CMsgDOTAProfileTickets_EventTicket {
        CMsgDOTAProfileTickets_EventTicket::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAProfileTickets_EventTicket>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgDOTAProfileTickets_EventTicket::get_event_id_for_reflect,
                    CMsgDOTAProfileTickets_EventTicket::mut_event_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAProfileTickets_EventTicket>(
                    "CMsgDOTAProfileTickets_EventTicket",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAProfileTickets_EventTicket {
    fn clear(&mut self) {
        self.clear_event_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAProfileTickets_EventTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAProfileTickets_EventTicket {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetProfileTickets {
    // message fields
    account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetProfileTickets {}

impl CMsgClientToGCGetProfileTickets {
    pub fn new() -> CMsgClientToGCGetProfileTickets {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetProfileTickets {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetProfileTickets> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetProfileTickets,
        };
        unsafe {
            instance.get(CMsgClientToGCGetProfileTickets::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgClientToGCGetProfileTickets {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetProfileTickets {
    fn new() -> CMsgClientToGCGetProfileTickets {
        CMsgClientToGCGetProfileTickets::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetProfileTickets>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgClientToGCGetProfileTickets::get_account_id_for_reflect,
                    CMsgClientToGCGetProfileTickets::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetProfileTickets>(
                    "CMsgClientToGCGetProfileTickets",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetProfileTickets {
    fn clear(&mut self) {
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetProfileTickets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetProfileTickets {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCSteamProfileRequest {
    // message fields
    account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCSteamProfileRequest {}

impl CMsgGCSteamProfileRequest {
    pub fn new() -> CMsgGCSteamProfileRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCSteamProfileRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCSteamProfileRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCSteamProfileRequest,
        };
        unsafe {
            instance.get(CMsgGCSteamProfileRequest::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgGCSteamProfileRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCSteamProfileRequest {
    fn new() -> CMsgGCSteamProfileRequest {
        CMsgGCSteamProfileRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCSteamProfileRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCSteamProfileRequest::get_account_id_for_reflect,
                    CMsgGCSteamProfileRequest::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCSteamProfileRequest>(
                    "CMsgGCSteamProfileRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCSteamProfileRequest {
    fn clear(&mut self) {
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCSteamProfileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCSteamProfileRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCSteamProfileRequestResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCSteamProfileRequestResponse {}

impl CMsgGCSteamProfileRequestResponse {
    pub fn new() -> CMsgGCSteamProfileRequestResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCSteamProfileRequestResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCSteamProfileRequestResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCSteamProfileRequestResponse,
        };
        unsafe {
            instance.get(CMsgGCSteamProfileRequestResponse::new)
        }
    }

    // optional uint32 result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgGCSteamProfileRequestResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCSteamProfileRequestResponse {
    fn new() -> CMsgGCSteamProfileRequestResponse {
        CMsgGCSteamProfileRequestResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCSteamProfileRequestResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "result",
                    CMsgGCSteamProfileRequestResponse::get_result_for_reflect,
                    CMsgGCSteamProfileRequestResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCSteamProfileRequestResponse>(
                    "CMsgGCSteamProfileRequestResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCSteamProfileRequestResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCSteamProfileRequestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCSteamProfileRequestResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAClearNotifySuccessfulReport {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAClearNotifySuccessfulReport {}

impl CMsgDOTAClearNotifySuccessfulReport {
    pub fn new() -> CMsgDOTAClearNotifySuccessfulReport {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAClearNotifySuccessfulReport {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAClearNotifySuccessfulReport> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAClearNotifySuccessfulReport,
        };
        unsafe {
            instance.get(CMsgDOTAClearNotifySuccessfulReport::new)
        }
    }
}

impl ::protobuf::Message for CMsgDOTAClearNotifySuccessfulReport {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAClearNotifySuccessfulReport {
    fn new() -> CMsgDOTAClearNotifySuccessfulReport {
        CMsgDOTAClearNotifySuccessfulReport::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAClearNotifySuccessfulReport>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAClearNotifySuccessfulReport>(
                    "CMsgDOTAClearNotifySuccessfulReport",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAClearNotifySuccessfulReport {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAClearNotifySuccessfulReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAClearNotifySuccessfulReport {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAWelcome {
    // message fields
    store_item_hash: ::std::option::Option<u32>,
    timeplayedconsecutively: ::std::option::Option<u32>,
    allow_3rd_party_match_history: ::std::option::Option<bool>,
    partner_account_type: ::std::option::Option<super::gcsdk_gcmessages::PartnerAccountType>,
    banned_word_list_word_id: ::std::option::Option<u32>,
    partner_account_state: ::std::option::Option<u32>,
    last_time_played: ::std::option::Option<u32>,
    last_ip_address: ::std::option::Option<u32>,
    shutdownlawterminateminutes: ::std::option::Option<u32>,
    banned_word_list_version: ::std::option::Option<u32>,
    profile_private: ::std::option::Option<bool>,
    currency: ::std::option::Option<u32>,
    bang_no: ::std::option::Option<u32>,
    should_request_player_origin: ::std::option::Option<bool>,
    compendium_unlocks: ::std::option::Option<u64>,
    gc_socache_file_version: ::std::option::Option<u32>,
    localization_digests: ::protobuf::RepeatedField<CMsgDOTAWelcome_LocalizationDigest>,
    is_perfect_world_test_account: ::std::option::Option<bool>,
    extra_messages: ::protobuf::RepeatedField<CMsgDOTAWelcome_CExtraMsg>,
    minimum_recent_item_id: ::std::option::Option<u64>,
    active_event: ::std::option::Option<super::dota_shared_enums::EEvent>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAWelcome {}

impl CMsgDOTAWelcome {
    pub fn new() -> CMsgDOTAWelcome {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAWelcome {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAWelcome> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAWelcome,
        };
        unsafe {
            instance.get(CMsgDOTAWelcome::new)
        }
    }

    // optional uint32 store_item_hash = 5;

    pub fn clear_store_item_hash(&mut self) {
        self.store_item_hash = ::std::option::Option::None;
    }

    pub fn has_store_item_hash(&self) -> bool {
        self.store_item_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_item_hash(&mut self, v: u32) {
        self.store_item_hash = ::std::option::Option::Some(v);
    }

    pub fn get_store_item_hash(&self) -> u32 {
        self.store_item_hash.unwrap_or(0)
    }

    fn get_store_item_hash_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.store_item_hash
    }

    fn mut_store_item_hash_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.store_item_hash
    }

    // optional uint32 timeplayedconsecutively = 6;

    pub fn clear_timeplayedconsecutively(&mut self) {
        self.timeplayedconsecutively = ::std::option::Option::None;
    }

    pub fn has_timeplayedconsecutively(&self) -> bool {
        self.timeplayedconsecutively.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeplayedconsecutively(&mut self, v: u32) {
        self.timeplayedconsecutively = ::std::option::Option::Some(v);
    }

    pub fn get_timeplayedconsecutively(&self) -> u32 {
        self.timeplayedconsecutively.unwrap_or(0)
    }

    fn get_timeplayedconsecutively_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timeplayedconsecutively
    }

    fn mut_timeplayedconsecutively_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timeplayedconsecutively
    }

    // optional bool allow_3rd_party_match_history = 7;

    pub fn clear_allow_3rd_party_match_history(&mut self) {
        self.allow_3rd_party_match_history = ::std::option::Option::None;
    }

    pub fn has_allow_3rd_party_match_history(&self) -> bool {
        self.allow_3rd_party_match_history.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_3rd_party_match_history(&mut self, v: bool) {
        self.allow_3rd_party_match_history = ::std::option::Option::Some(v);
    }

    pub fn get_allow_3rd_party_match_history(&self) -> bool {
        self.allow_3rd_party_match_history.unwrap_or(false)
    }

    fn get_allow_3rd_party_match_history_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.allow_3rd_party_match_history
    }

    fn mut_allow_3rd_party_match_history_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.allow_3rd_party_match_history
    }

    // optional .PartnerAccountType partner_account_type = 8;

    pub fn clear_partner_account_type(&mut self) {
        self.partner_account_type = ::std::option::Option::None;
    }

    pub fn has_partner_account_type(&self) -> bool {
        self.partner_account_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner_account_type(&mut self, v: super::gcsdk_gcmessages::PartnerAccountType) {
        self.partner_account_type = ::std::option::Option::Some(v);
    }

    pub fn get_partner_account_type(&self) -> super::gcsdk_gcmessages::PartnerAccountType {
        self.partner_account_type.unwrap_or(super::gcsdk_gcmessages::PartnerAccountType::PARTNER_NONE)
    }

    fn get_partner_account_type_for_reflect(&self) -> &::std::option::Option<super::gcsdk_gcmessages::PartnerAccountType> {
        &self.partner_account_type
    }

    fn mut_partner_account_type_for_reflect(&mut self) -> &mut ::std::option::Option<super::gcsdk_gcmessages::PartnerAccountType> {
        &mut self.partner_account_type
    }

    // optional uint32 banned_word_list_word_id = 9;

    pub fn clear_banned_word_list_word_id(&mut self) {
        self.banned_word_list_word_id = ::std::option::Option::None;
    }

    pub fn has_banned_word_list_word_id(&self) -> bool {
        self.banned_word_list_word_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned_word_list_word_id(&mut self, v: u32) {
        self.banned_word_list_word_id = ::std::option::Option::Some(v);
    }

    pub fn get_banned_word_list_word_id(&self) -> u32 {
        self.banned_word_list_word_id.unwrap_or(0)
    }

    fn get_banned_word_list_word_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.banned_word_list_word_id
    }

    fn mut_banned_word_list_word_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.banned_word_list_word_id
    }

    // optional uint32 partner_account_state = 11;

    pub fn clear_partner_account_state(&mut self) {
        self.partner_account_state = ::std::option::Option::None;
    }

    pub fn has_partner_account_state(&self) -> bool {
        self.partner_account_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner_account_state(&mut self, v: u32) {
        self.partner_account_state = ::std::option::Option::Some(v);
    }

    pub fn get_partner_account_state(&self) -> u32 {
        self.partner_account_state.unwrap_or(0)
    }

    fn get_partner_account_state_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.partner_account_state
    }

    fn mut_partner_account_state_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.partner_account_state
    }

    // optional uint32 last_time_played = 12;

    pub fn clear_last_time_played(&mut self) {
        self.last_time_played = ::std::option::Option::None;
    }

    pub fn has_last_time_played(&self) -> bool {
        self.last_time_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time_played(&mut self, v: u32) {
        self.last_time_played = ::std::option::Option::Some(v);
    }

    pub fn get_last_time_played(&self) -> u32 {
        self.last_time_played.unwrap_or(0)
    }

    fn get_last_time_played_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.last_time_played
    }

    fn mut_last_time_played_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.last_time_played
    }

    // optional uint32 last_ip_address = 13;

    pub fn clear_last_ip_address(&mut self) {
        self.last_ip_address = ::std::option::Option::None;
    }

    pub fn has_last_ip_address(&self) -> bool {
        self.last_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_ip_address(&mut self, v: u32) {
        self.last_ip_address = ::std::option::Option::Some(v);
    }

    pub fn get_last_ip_address(&self) -> u32 {
        self.last_ip_address.unwrap_or(0)
    }

    fn get_last_ip_address_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.last_ip_address
    }

    fn mut_last_ip_address_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.last_ip_address
    }

    // optional uint32 shutdownlawterminateminutes = 15;

    pub fn clear_shutdownlawterminateminutes(&mut self) {
        self.shutdownlawterminateminutes = ::std::option::Option::None;
    }

    pub fn has_shutdownlawterminateminutes(&self) -> bool {
        self.shutdownlawterminateminutes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shutdownlawterminateminutes(&mut self, v: u32) {
        self.shutdownlawterminateminutes = ::std::option::Option::Some(v);
    }

    pub fn get_shutdownlawterminateminutes(&self) -> u32 {
        self.shutdownlawterminateminutes.unwrap_or(0)
    }

    fn get_shutdownlawterminateminutes_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.shutdownlawterminateminutes
    }

    fn mut_shutdownlawterminateminutes_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.shutdownlawterminateminutes
    }

    // optional uint32 banned_word_list_version = 16;

    pub fn clear_banned_word_list_version(&mut self) {
        self.banned_word_list_version = ::std::option::Option::None;
    }

    pub fn has_banned_word_list_version(&self) -> bool {
        self.banned_word_list_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned_word_list_version(&mut self, v: u32) {
        self.banned_word_list_version = ::std::option::Option::Some(v);
    }

    pub fn get_banned_word_list_version(&self) -> u32 {
        self.banned_word_list_version.unwrap_or(0)
    }

    fn get_banned_word_list_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.banned_word_list_version
    }

    fn mut_banned_word_list_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.banned_word_list_version
    }

    // optional bool profile_private = 17;

    pub fn clear_profile_private(&mut self) {
        self.profile_private = ::std::option::Option::None;
    }

    pub fn has_profile_private(&self) -> bool {
        self.profile_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile_private(&mut self, v: bool) {
        self.profile_private = ::std::option::Option::Some(v);
    }

    pub fn get_profile_private(&self) -> bool {
        self.profile_private.unwrap_or(false)
    }

    fn get_profile_private_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.profile_private
    }

    fn mut_profile_private_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.profile_private
    }

    // optional uint32 currency = 18;

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: u32) {
        self.currency = ::std::option::Option::Some(v);
    }

    pub fn get_currency(&self) -> u32 {
        self.currency.unwrap_or(0)
    }

    fn get_currency_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.currency
    }

    fn mut_currency_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.currency
    }

    // optional uint32 bang_no = 19;

    pub fn clear_bang_no(&mut self) {
        self.bang_no = ::std::option::Option::None;
    }

    pub fn has_bang_no(&self) -> bool {
        self.bang_no.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bang_no(&mut self, v: u32) {
        self.bang_no = ::std::option::Option::Some(v);
    }

    pub fn get_bang_no(&self) -> u32 {
        self.bang_no.unwrap_or(0)
    }

    fn get_bang_no_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.bang_no
    }

    fn mut_bang_no_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.bang_no
    }

    // optional bool should_request_player_origin = 20;

    pub fn clear_should_request_player_origin(&mut self) {
        self.should_request_player_origin = ::std::option::Option::None;
    }

    pub fn has_should_request_player_origin(&self) -> bool {
        self.should_request_player_origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_should_request_player_origin(&mut self, v: bool) {
        self.should_request_player_origin = ::std::option::Option::Some(v);
    }

    pub fn get_should_request_player_origin(&self) -> bool {
        self.should_request_player_origin.unwrap_or(false)
    }

    fn get_should_request_player_origin_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.should_request_player_origin
    }

    fn mut_should_request_player_origin_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.should_request_player_origin
    }

    // optional uint64 compendium_unlocks = 21;

    pub fn clear_compendium_unlocks(&mut self) {
        self.compendium_unlocks = ::std::option::Option::None;
    }

    pub fn has_compendium_unlocks(&self) -> bool {
        self.compendium_unlocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compendium_unlocks(&mut self, v: u64) {
        self.compendium_unlocks = ::std::option::Option::Some(v);
    }

    pub fn get_compendium_unlocks(&self) -> u64 {
        self.compendium_unlocks.unwrap_or(0)
    }

    fn get_compendium_unlocks_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.compendium_unlocks
    }

    fn mut_compendium_unlocks_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.compendium_unlocks
    }

    // optional uint32 gc_socache_file_version = 22;

    pub fn clear_gc_socache_file_version(&mut self) {
        self.gc_socache_file_version = ::std::option::Option::None;
    }

    pub fn has_gc_socache_file_version(&self) -> bool {
        self.gc_socache_file_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gc_socache_file_version(&mut self, v: u32) {
        self.gc_socache_file_version = ::std::option::Option::Some(v);
    }

    pub fn get_gc_socache_file_version(&self) -> u32 {
        self.gc_socache_file_version.unwrap_or(0)
    }

    fn get_gc_socache_file_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gc_socache_file_version
    }

    fn mut_gc_socache_file_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gc_socache_file_version
    }

    // repeated .CMsgDOTAWelcome.LocalizationDigest localization_digests = 23;

    pub fn clear_localization_digests(&mut self) {
        self.localization_digests.clear();
    }

    // Param is passed by value, moved
    pub fn set_localization_digests(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAWelcome_LocalizationDigest>) {
        self.localization_digests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_localization_digests(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAWelcome_LocalizationDigest> {
        &mut self.localization_digests
    }

    // Take field
    pub fn take_localization_digests(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAWelcome_LocalizationDigest> {
        ::std::mem::replace(&mut self.localization_digests, ::protobuf::RepeatedField::new())
    }

    pub fn get_localization_digests(&self) -> &[CMsgDOTAWelcome_LocalizationDigest] {
        &self.localization_digests
    }

    fn get_localization_digests_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAWelcome_LocalizationDigest> {
        &self.localization_digests
    }

    fn mut_localization_digests_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAWelcome_LocalizationDigest> {
        &mut self.localization_digests
    }

    // optional bool is_perfect_world_test_account = 24;

    pub fn clear_is_perfect_world_test_account(&mut self) {
        self.is_perfect_world_test_account = ::std::option::Option::None;
    }

    pub fn has_is_perfect_world_test_account(&self) -> bool {
        self.is_perfect_world_test_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_perfect_world_test_account(&mut self, v: bool) {
        self.is_perfect_world_test_account = ::std::option::Option::Some(v);
    }

    pub fn get_is_perfect_world_test_account(&self) -> bool {
        self.is_perfect_world_test_account.unwrap_or(false)
    }

    fn get_is_perfect_world_test_account_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_perfect_world_test_account
    }

    fn mut_is_perfect_world_test_account_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_perfect_world_test_account
    }

    // repeated .CMsgDOTAWelcome.CExtraMsg extra_messages = 26;

    pub fn clear_extra_messages(&mut self) {
        self.extra_messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_messages(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAWelcome_CExtraMsg>) {
        self.extra_messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_messages(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAWelcome_CExtraMsg> {
        &mut self.extra_messages
    }

    // Take field
    pub fn take_extra_messages(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAWelcome_CExtraMsg> {
        ::std::mem::replace(&mut self.extra_messages, ::protobuf::RepeatedField::new())
    }

    pub fn get_extra_messages(&self) -> &[CMsgDOTAWelcome_CExtraMsg] {
        &self.extra_messages
    }

    fn get_extra_messages_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAWelcome_CExtraMsg> {
        &self.extra_messages
    }

    fn mut_extra_messages_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAWelcome_CExtraMsg> {
        &mut self.extra_messages
    }

    // optional uint64 minimum_recent_item_id = 27;

    pub fn clear_minimum_recent_item_id(&mut self) {
        self.minimum_recent_item_id = ::std::option::Option::None;
    }

    pub fn has_minimum_recent_item_id(&self) -> bool {
        self.minimum_recent_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum_recent_item_id(&mut self, v: u64) {
        self.minimum_recent_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_minimum_recent_item_id(&self) -> u64 {
        self.minimum_recent_item_id.unwrap_or(0)
    }

    fn get_minimum_recent_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.minimum_recent_item_id
    }

    fn mut_minimum_recent_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.minimum_recent_item_id
    }

    // optional .EEvent active_event = 28;

    pub fn clear_active_event(&mut self) {
        self.active_event = ::std::option::Option::None;
    }

    pub fn has_active_event(&self) -> bool {
        self.active_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_event(&mut self, v: super::dota_shared_enums::EEvent) {
        self.active_event = ::std::option::Option::Some(v);
    }

    pub fn get_active_event(&self) -> super::dota_shared_enums::EEvent {
        self.active_event.unwrap_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE)
    }

    fn get_active_event_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::EEvent> {
        &self.active_event
    }

    fn mut_active_event_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::EEvent> {
        &mut self.active_event
    }
}

impl ::protobuf::Message for CMsgDOTAWelcome {
    fn is_initialized(&self) -> bool {
        for v in &self.localization_digests {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extra_messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.store_item_hash = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeplayedconsecutively = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_3rd_party_match_history = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.partner_account_type = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.banned_word_list_word_id = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.partner_account_state = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_time_played = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_ip_address = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shutdownlawterminateminutes = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.banned_word_list_version = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.profile_private = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.currency = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bang_no = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.should_request_player_origin = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.compendium_unlocks = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gc_socache_file_version = ::std::option::Option::Some(tmp);
                },
                23 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.localization_digests)?;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_perfect_world_test_account = ::std::option::Option::Some(tmp);
                },
                26 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extra_messages)?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minimum_recent_item_id = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.active_event = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.store_item_hash {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeplayedconsecutively {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.allow_3rd_party_match_history {
            my_size += 2;
        }
        if let Some(v) = self.partner_account_type {
            my_size += ::protobuf::rt::enum_size(8, v);
        }
        if let Some(v) = self.banned_word_list_word_id {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.partner_account_state {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_time_played {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_ip_address {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shutdownlawterminateminutes {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.banned_word_list_version {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.profile_private {
            my_size += 3;
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bang_no {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.should_request_player_origin {
            my_size += 3;
        }
        if let Some(v) = self.compendium_unlocks {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gc_socache_file_version {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.localization_digests {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.is_perfect_world_test_account {
            my_size += 3;
        }
        for value in &self.extra_messages {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.minimum_recent_item_id {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active_event {
            my_size += ::protobuf::rt::enum_size(28, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.store_item_hash {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.timeplayedconsecutively {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.allow_3rd_party_match_history {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.partner_account_type {
            os.write_enum(8, v.value())?;
        }
        if let Some(v) = self.banned_word_list_word_id {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.partner_account_state {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.last_time_played {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.last_ip_address {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.shutdownlawterminateminutes {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.banned_word_list_version {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.profile_private {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.currency {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.bang_no {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.should_request_player_origin {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.compendium_unlocks {
            os.write_uint64(21, v)?;
        }
        if let Some(v) = self.gc_socache_file_version {
            os.write_uint32(22, v)?;
        }
        for v in &self.localization_digests {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.is_perfect_world_test_account {
            os.write_bool(24, v)?;
        }
        for v in &self.extra_messages {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.minimum_recent_item_id {
            os.write_uint64(27, v)?;
        }
        if let Some(v) = self.active_event {
            os.write_enum(28, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAWelcome {
    fn new() -> CMsgDOTAWelcome {
        CMsgDOTAWelcome::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAWelcome>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "store_item_hash",
                    CMsgDOTAWelcome::get_store_item_hash_for_reflect,
                    CMsgDOTAWelcome::mut_store_item_hash_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timeplayedconsecutively",
                    CMsgDOTAWelcome::get_timeplayedconsecutively_for_reflect,
                    CMsgDOTAWelcome::mut_timeplayedconsecutively_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "allow_3rd_party_match_history",
                    CMsgDOTAWelcome::get_allow_3rd_party_match_history_for_reflect,
                    CMsgDOTAWelcome::mut_allow_3rd_party_match_history_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::gcsdk_gcmessages::PartnerAccountType>>(
                    "partner_account_type",
                    CMsgDOTAWelcome::get_partner_account_type_for_reflect,
                    CMsgDOTAWelcome::mut_partner_account_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "banned_word_list_word_id",
                    CMsgDOTAWelcome::get_banned_word_list_word_id_for_reflect,
                    CMsgDOTAWelcome::mut_banned_word_list_word_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "partner_account_state",
                    CMsgDOTAWelcome::get_partner_account_state_for_reflect,
                    CMsgDOTAWelcome::mut_partner_account_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_time_played",
                    CMsgDOTAWelcome::get_last_time_played_for_reflect,
                    CMsgDOTAWelcome::mut_last_time_played_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_ip_address",
                    CMsgDOTAWelcome::get_last_ip_address_for_reflect,
                    CMsgDOTAWelcome::mut_last_ip_address_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "shutdownlawterminateminutes",
                    CMsgDOTAWelcome::get_shutdownlawterminateminutes_for_reflect,
                    CMsgDOTAWelcome::mut_shutdownlawterminateminutes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "banned_word_list_version",
                    CMsgDOTAWelcome::get_banned_word_list_version_for_reflect,
                    CMsgDOTAWelcome::mut_banned_word_list_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "profile_private",
                    CMsgDOTAWelcome::get_profile_private_for_reflect,
                    CMsgDOTAWelcome::mut_profile_private_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "currency",
                    CMsgDOTAWelcome::get_currency_for_reflect,
                    CMsgDOTAWelcome::mut_currency_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bang_no",
                    CMsgDOTAWelcome::get_bang_no_for_reflect,
                    CMsgDOTAWelcome::mut_bang_no_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "should_request_player_origin",
                    CMsgDOTAWelcome::get_should_request_player_origin_for_reflect,
                    CMsgDOTAWelcome::mut_should_request_player_origin_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "compendium_unlocks",
                    CMsgDOTAWelcome::get_compendium_unlocks_for_reflect,
                    CMsgDOTAWelcome::mut_compendium_unlocks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gc_socache_file_version",
                    CMsgDOTAWelcome::get_gc_socache_file_version_for_reflect,
                    CMsgDOTAWelcome::mut_gc_socache_file_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAWelcome_LocalizationDigest>>(
                    "localization_digests",
                    CMsgDOTAWelcome::get_localization_digests_for_reflect,
                    CMsgDOTAWelcome::mut_localization_digests_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_perfect_world_test_account",
                    CMsgDOTAWelcome::get_is_perfect_world_test_account_for_reflect,
                    CMsgDOTAWelcome::mut_is_perfect_world_test_account_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAWelcome_CExtraMsg>>(
                    "extra_messages",
                    CMsgDOTAWelcome::get_extra_messages_for_reflect,
                    CMsgDOTAWelcome::mut_extra_messages_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "minimum_recent_item_id",
                    CMsgDOTAWelcome::get_minimum_recent_item_id_for_reflect,
                    CMsgDOTAWelcome::mut_minimum_recent_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::EEvent>>(
                    "active_event",
                    CMsgDOTAWelcome::get_active_event_for_reflect,
                    CMsgDOTAWelcome::mut_active_event_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAWelcome>(
                    "CMsgDOTAWelcome",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAWelcome {
    fn clear(&mut self) {
        self.clear_store_item_hash();
        self.clear_timeplayedconsecutively();
        self.clear_allow_3rd_party_match_history();
        self.clear_partner_account_type();
        self.clear_banned_word_list_word_id();
        self.clear_partner_account_state();
        self.clear_last_time_played();
        self.clear_last_ip_address();
        self.clear_shutdownlawterminateminutes();
        self.clear_banned_word_list_version();
        self.clear_profile_private();
        self.clear_currency();
        self.clear_bang_no();
        self.clear_should_request_player_origin();
        self.clear_compendium_unlocks();
        self.clear_gc_socache_file_version();
        self.clear_localization_digests();
        self.clear_is_perfect_world_test_account();
        self.clear_extra_messages();
        self.clear_minimum_recent_item_id();
        self.clear_active_event();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAWelcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAWelcome {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAWelcome_LocalizationDigest {
    // message fields
    context: ::protobuf::SingularField<::std::string::String>,
    english_language_file_sha1: ::protobuf::SingularPtrField<super::gcsdk_gcmessages::CMsgSHA1Digest>,
    client_language_file_sha1: ::protobuf::SingularPtrField<super::gcsdk_gcmessages::CMsgSHA1Digest>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAWelcome_LocalizationDigest {}

impl CMsgDOTAWelcome_LocalizationDigest {
    pub fn new() -> CMsgDOTAWelcome_LocalizationDigest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAWelcome_LocalizationDigest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAWelcome_LocalizationDigest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAWelcome_LocalizationDigest,
        };
        unsafe {
            instance.get(CMsgDOTAWelcome_LocalizationDigest::new)
        }
    }

    // optional string context = 1;

    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: ::std::string::String) {
        self.context = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut ::std::string::String {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> ::std::string::String {
        self.context.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_context(&self) -> &str {
        match self.context.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_context_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.context
    }

    fn mut_context_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.context
    }

    // optional .CMsgSHA1Digest english_language_file_sha1 = 2;

    pub fn clear_english_language_file_sha1(&mut self) {
        self.english_language_file_sha1.clear();
    }

    pub fn has_english_language_file_sha1(&self) -> bool {
        self.english_language_file_sha1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_english_language_file_sha1(&mut self, v: super::gcsdk_gcmessages::CMsgSHA1Digest) {
        self.english_language_file_sha1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_english_language_file_sha1(&mut self) -> &mut super::gcsdk_gcmessages::CMsgSHA1Digest {
        if self.english_language_file_sha1.is_none() {
            self.english_language_file_sha1.set_default();
        }
        self.english_language_file_sha1.as_mut().unwrap()
    }

    // Take field
    pub fn take_english_language_file_sha1(&mut self) -> super::gcsdk_gcmessages::CMsgSHA1Digest {
        self.english_language_file_sha1.take().unwrap_or_else(|| super::gcsdk_gcmessages::CMsgSHA1Digest::new())
    }

    pub fn get_english_language_file_sha1(&self) -> &super::gcsdk_gcmessages::CMsgSHA1Digest {
        self.english_language_file_sha1.as_ref().unwrap_or_else(|| super::gcsdk_gcmessages::CMsgSHA1Digest::default_instance())
    }

    fn get_english_language_file_sha1_for_reflect(&self) -> &::protobuf::SingularPtrField<super::gcsdk_gcmessages::CMsgSHA1Digest> {
        &self.english_language_file_sha1
    }

    fn mut_english_language_file_sha1_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::gcsdk_gcmessages::CMsgSHA1Digest> {
        &mut self.english_language_file_sha1
    }

    // optional .CMsgSHA1Digest client_language_file_sha1 = 3;

    pub fn clear_client_language_file_sha1(&mut self) {
        self.client_language_file_sha1.clear();
    }

    pub fn has_client_language_file_sha1(&self) -> bool {
        self.client_language_file_sha1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_language_file_sha1(&mut self, v: super::gcsdk_gcmessages::CMsgSHA1Digest) {
        self.client_language_file_sha1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_language_file_sha1(&mut self) -> &mut super::gcsdk_gcmessages::CMsgSHA1Digest {
        if self.client_language_file_sha1.is_none() {
            self.client_language_file_sha1.set_default();
        }
        self.client_language_file_sha1.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_language_file_sha1(&mut self) -> super::gcsdk_gcmessages::CMsgSHA1Digest {
        self.client_language_file_sha1.take().unwrap_or_else(|| super::gcsdk_gcmessages::CMsgSHA1Digest::new())
    }

    pub fn get_client_language_file_sha1(&self) -> &super::gcsdk_gcmessages::CMsgSHA1Digest {
        self.client_language_file_sha1.as_ref().unwrap_or_else(|| super::gcsdk_gcmessages::CMsgSHA1Digest::default_instance())
    }

    fn get_client_language_file_sha1_for_reflect(&self) -> &::protobuf::SingularPtrField<super::gcsdk_gcmessages::CMsgSHA1Digest> {
        &self.client_language_file_sha1
    }

    fn mut_client_language_file_sha1_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::gcsdk_gcmessages::CMsgSHA1Digest> {
        &mut self.client_language_file_sha1
    }
}

impl ::protobuf::Message for CMsgDOTAWelcome_LocalizationDigest {
    fn is_initialized(&self) -> bool {
        for v in &self.english_language_file_sha1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.client_language_file_sha1 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.english_language_file_sha1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.client_language_file_sha1)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.english_language_file_sha1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.client_language_file_sha1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.english_language_file_sha1.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.client_language_file_sha1.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAWelcome_LocalizationDigest {
    fn new() -> CMsgDOTAWelcome_LocalizationDigest {
        CMsgDOTAWelcome_LocalizationDigest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAWelcome_LocalizationDigest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "context",
                    CMsgDOTAWelcome_LocalizationDigest::get_context_for_reflect,
                    CMsgDOTAWelcome_LocalizationDigest::mut_context_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gcsdk_gcmessages::CMsgSHA1Digest>>(
                    "english_language_file_sha1",
                    CMsgDOTAWelcome_LocalizationDigest::get_english_language_file_sha1_for_reflect,
                    CMsgDOTAWelcome_LocalizationDigest::mut_english_language_file_sha1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gcsdk_gcmessages::CMsgSHA1Digest>>(
                    "client_language_file_sha1",
                    CMsgDOTAWelcome_LocalizationDigest::get_client_language_file_sha1_for_reflect,
                    CMsgDOTAWelcome_LocalizationDigest::mut_client_language_file_sha1_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAWelcome_LocalizationDigest>(
                    "CMsgDOTAWelcome_LocalizationDigest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAWelcome_LocalizationDigest {
    fn clear(&mut self) {
        self.clear_context();
        self.clear_english_language_file_sha1();
        self.clear_client_language_file_sha1();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAWelcome_LocalizationDigest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAWelcome_LocalizationDigest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAWelcome_CExtraMsg {
    // message fields
    id: ::std::option::Option<u32>,
    contents: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAWelcome_CExtraMsg {}

impl CMsgDOTAWelcome_CExtraMsg {
    pub fn new() -> CMsgDOTAWelcome_CExtraMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAWelcome_CExtraMsg {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAWelcome_CExtraMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAWelcome_CExtraMsg,
        };
        unsafe {
            instance.get(CMsgDOTAWelcome_CExtraMsg::new)
        }
    }

    // optional uint32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.id
    }

    // optional bytes contents = 2;

    pub fn clear_contents(&mut self) {
        self.contents.clear();
    }

    pub fn has_contents(&self) -> bool {
        self.contents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contents(&mut self, v: ::std::vec::Vec<u8>) {
        self.contents = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contents(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.contents.is_none() {
            self.contents.set_default();
        }
        self.contents.as_mut().unwrap()
    }

    // Take field
    pub fn take_contents(&mut self) -> ::std::vec::Vec<u8> {
        self.contents.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_contents(&self) -> &[u8] {
        match self.contents.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_contents_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.contents
    }

    fn mut_contents_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.contents
    }
}

impl ::protobuf::Message for CMsgDOTAWelcome_CExtraMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.contents)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.contents.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.contents.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAWelcome_CExtraMsg {
    fn new() -> CMsgDOTAWelcome_CExtraMsg {
        CMsgDOTAWelcome_CExtraMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAWelcome_CExtraMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    CMsgDOTAWelcome_CExtraMsg::get_id_for_reflect,
                    CMsgDOTAWelcome_CExtraMsg::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "contents",
                    CMsgDOTAWelcome_CExtraMsg::get_contents_for_reflect,
                    CMsgDOTAWelcome_CExtraMsg::mut_contents_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAWelcome_CExtraMsg>(
                    "CMsgDOTAWelcome_CExtraMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAWelcome_CExtraMsg {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_contents();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAWelcome_CExtraMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAWelcome_CExtraMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSODOTAGameHeroFavorites {
    // message fields
    account_id: ::std::option::Option<u32>,
    hero_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CSODOTAGameHeroFavorites {}

impl CSODOTAGameHeroFavorites {
    pub fn new() -> CSODOTAGameHeroFavorites {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CSODOTAGameHeroFavorites {
        static mut instance: ::protobuf::lazy::Lazy<CSODOTAGameHeroFavorites> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CSODOTAGameHeroFavorites,
        };
        unsafe {
            instance.get(CSODOTAGameHeroFavorites::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 hero_id = 2;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }
}

impl ::protobuf::Message for CSODOTAGameHeroFavorites {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CSODOTAGameHeroFavorites {
    fn new() -> CSODOTAGameHeroFavorites {
        CSODOTAGameHeroFavorites::new()
    }

    fn descriptor_static(_: ::std::option::Option<CSODOTAGameHeroFavorites>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CSODOTAGameHeroFavorites::get_account_id_for_reflect,
                    CSODOTAGameHeroFavorites::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CSODOTAGameHeroFavorites::get_hero_id_for_reflect,
                    CSODOTAGameHeroFavorites::mut_hero_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CSODOTAGameHeroFavorites>(
                    "CSODOTAGameHeroFavorites",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CSODOTAGameHeroFavorites {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_hero_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSODOTAGameHeroFavorites {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSODOTAGameHeroFavorites {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAHeroFavoritesAdd {
    // message fields
    hero_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAHeroFavoritesAdd {}

impl CMsgDOTAHeroFavoritesAdd {
    pub fn new() -> CMsgDOTAHeroFavoritesAdd {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAHeroFavoritesAdd {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAHeroFavoritesAdd> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAHeroFavoritesAdd,
        };
        unsafe {
            instance.get(CMsgDOTAHeroFavoritesAdd::new)
        }
    }

    // optional uint32 hero_id = 1;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }
}

impl ::protobuf::Message for CMsgDOTAHeroFavoritesAdd {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAHeroFavoritesAdd {
    fn new() -> CMsgDOTAHeroFavoritesAdd {
        CMsgDOTAHeroFavoritesAdd::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAHeroFavoritesAdd>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgDOTAHeroFavoritesAdd::get_hero_id_for_reflect,
                    CMsgDOTAHeroFavoritesAdd::mut_hero_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAHeroFavoritesAdd>(
                    "CMsgDOTAHeroFavoritesAdd",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAHeroFavoritesAdd {
    fn clear(&mut self) {
        self.clear_hero_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAHeroFavoritesAdd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAHeroFavoritesAdd {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAHeroFavoritesRemove {
    // message fields
    hero_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAHeroFavoritesRemove {}

impl CMsgDOTAHeroFavoritesRemove {
    pub fn new() -> CMsgDOTAHeroFavoritesRemove {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAHeroFavoritesRemove {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAHeroFavoritesRemove> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAHeroFavoritesRemove,
        };
        unsafe {
            instance.get(CMsgDOTAHeroFavoritesRemove::new)
        }
    }

    // optional uint32 hero_id = 1;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }
}

impl ::protobuf::Message for CMsgDOTAHeroFavoritesRemove {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAHeroFavoritesRemove {
    fn new() -> CMsgDOTAHeroFavoritesRemove {
        CMsgDOTAHeroFavoritesRemove::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAHeroFavoritesRemove>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgDOTAHeroFavoritesRemove::get_hero_id_for_reflect,
                    CMsgDOTAHeroFavoritesRemove::mut_hero_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAHeroFavoritesRemove>(
                    "CMsgDOTAHeroFavoritesRemove",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAHeroFavoritesRemove {
    fn clear(&mut self) {
        self.clear_hero_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAHeroFavoritesRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAHeroFavoritesRemove {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSetShowcaseHero {
    // message fields
    showcase_hero_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSetShowcaseHero {}

impl CMsgSetShowcaseHero {
    pub fn new() -> CMsgSetShowcaseHero {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSetShowcaseHero {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetShowcaseHero> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetShowcaseHero,
        };
        unsafe {
            instance.get(CMsgSetShowcaseHero::new)
        }
    }

    // optional uint32 showcase_hero_id = 1;

    pub fn clear_showcase_hero_id(&mut self) {
        self.showcase_hero_id = ::std::option::Option::None;
    }

    pub fn has_showcase_hero_id(&self) -> bool {
        self.showcase_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showcase_hero_id(&mut self, v: u32) {
        self.showcase_hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_showcase_hero_id(&self) -> u32 {
        self.showcase_hero_id.unwrap_or(0)
    }

    fn get_showcase_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.showcase_hero_id
    }

    fn mut_showcase_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.showcase_hero_id
    }
}

impl ::protobuf::Message for CMsgSetShowcaseHero {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.showcase_hero_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.showcase_hero_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.showcase_hero_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSetShowcaseHero {
    fn new() -> CMsgSetShowcaseHero {
        CMsgSetShowcaseHero::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSetShowcaseHero>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "showcase_hero_id",
                    CMsgSetShowcaseHero::get_showcase_hero_id_for_reflect,
                    CMsgSetShowcaseHero::mut_showcase_hero_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetShowcaseHero>(
                    "CMsgSetShowcaseHero",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSetShowcaseHero {
    fn clear(&mut self) {
        self.clear_showcase_hero_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetShowcaseHero {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetShowcaseHero {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSetFeaturedItems {
    // message fields
    featured_item_id: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSetFeaturedItems {}

impl CMsgSetFeaturedItems {
    pub fn new() -> CMsgSetFeaturedItems {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSetFeaturedItems {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetFeaturedItems> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetFeaturedItems,
        };
        unsafe {
            instance.get(CMsgSetFeaturedItems::new)
        }
    }

    // repeated uint64 featured_item_id = 1;

    pub fn clear_featured_item_id(&mut self) {
        self.featured_item_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_featured_item_id(&mut self, v: ::std::vec::Vec<u64>) {
        self.featured_item_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_featured_item_id(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.featured_item_id
    }

    // Take field
    pub fn take_featured_item_id(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.featured_item_id, ::std::vec::Vec::new())
    }

    pub fn get_featured_item_id(&self) -> &[u64] {
        &self.featured_item_id
    }

    fn get_featured_item_id_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.featured_item_id
    }

    fn mut_featured_item_id_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.featured_item_id
    }
}

impl ::protobuf::Message for CMsgSetFeaturedItems {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.featured_item_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.featured_item_id {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.featured_item_id {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSetFeaturedItems {
    fn new() -> CMsgSetFeaturedItems {
        CMsgSetFeaturedItems::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSetFeaturedItems>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "featured_item_id",
                    CMsgSetFeaturedItems::get_featured_item_id_for_reflect,
                    CMsgSetFeaturedItems::mut_featured_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetFeaturedItems>(
                    "CMsgSetFeaturedItems",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSetFeaturedItems {
    fn clear(&mut self) {
        self.clear_featured_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetFeaturedItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetFeaturedItems {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFeaturedItems {
    // message fields
    account_id: ::std::option::Option<u32>,
    featured_item_id: ::std::vec::Vec<u64>,
    object_data: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFeaturedItems {}

impl CMsgDOTAFeaturedItems {
    pub fn new() -> CMsgDOTAFeaturedItems {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFeaturedItems {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFeaturedItems> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFeaturedItems,
        };
        unsafe {
            instance.get(CMsgDOTAFeaturedItems::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // repeated uint64 featured_item_id = 2;

    pub fn clear_featured_item_id(&mut self) {
        self.featured_item_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_featured_item_id(&mut self, v: ::std::vec::Vec<u64>) {
        self.featured_item_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_featured_item_id(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.featured_item_id
    }

    // Take field
    pub fn take_featured_item_id(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.featured_item_id, ::std::vec::Vec::new())
    }

    pub fn get_featured_item_id(&self) -> &[u64] {
        &self.featured_item_id
    }

    fn get_featured_item_id_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.featured_item_id
    }

    fn mut_featured_item_id_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.featured_item_id
    }

    // repeated bytes object_data = 3;

    pub fn clear_object_data(&mut self) {
        self.object_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_data(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.object_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_object_data(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.object_data
    }

    // Take field
    pub fn take_object_data(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.object_data, ::protobuf::RepeatedField::new())
    }

    pub fn get_object_data(&self) -> &[::std::vec::Vec<u8>] {
        &self.object_data
    }

    fn get_object_data_for_reflect(&self) -> &::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &self.object_data
    }

    fn mut_object_data_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.object_data
    }
}

impl ::protobuf::Message for CMsgDOTAFeaturedItems {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.featured_item_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.object_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.featured_item_id {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.object_data {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.featured_item_id {
            os.write_uint64(2, *v)?;
        };
        for v in &self.object_data {
            os.write_bytes(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFeaturedItems {
    fn new() -> CMsgDOTAFeaturedItems {
        CMsgDOTAFeaturedItems::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFeaturedItems>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAFeaturedItems::get_account_id_for_reflect,
                    CMsgDOTAFeaturedItems::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "featured_item_id",
                    CMsgDOTAFeaturedItems::get_featured_item_id_for_reflect,
                    CMsgDOTAFeaturedItems::mut_featured_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "object_data",
                    CMsgDOTAFeaturedItems::get_object_data_for_reflect,
                    CMsgDOTAFeaturedItems::mut_object_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFeaturedItems>(
                    "CMsgDOTAFeaturedItems",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFeaturedItems {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_featured_item_id();
        self.clear_object_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFeaturedItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFeaturedItems {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestLeagueInfo {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgRequestLeagueInfo {}

impl CMsgRequestLeagueInfo {
    pub fn new() -> CMsgRequestLeagueInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgRequestLeagueInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRequestLeagueInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRequestLeagueInfo,
        };
        unsafe {
            instance.get(CMsgRequestLeagueInfo::new)
        }
    }
}

impl ::protobuf::Message for CMsgRequestLeagueInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgRequestLeagueInfo {
    fn new() -> CMsgRequestLeagueInfo {
        CMsgRequestLeagueInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgRequestLeagueInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRequestLeagueInfo>(
                    "CMsgRequestLeagueInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgRequestLeagueInfo {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestLeagueInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestLeagueInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDynamicLeagueData {
    // message fields
    league_id: ::std::option::Option<u32>,
    last_match_time: ::std::option::Option<u32>,
    prize_pool_usd: ::std::option::Option<u32>,
    has_live_matches: ::std::option::Option<bool>,
    is_compendium_public: ::std::option::Option<bool>,
    compendium_version: ::std::option::Option<u32>,
    compendium_content_version: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDynamicLeagueData {}

impl CDynamicLeagueData {
    pub fn new() -> CDynamicLeagueData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDynamicLeagueData {
        static mut instance: ::protobuf::lazy::Lazy<CDynamicLeagueData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDynamicLeagueData,
        };
        unsafe {
            instance.get(CDynamicLeagueData::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional fixed32 last_match_time = 2;

    pub fn clear_last_match_time(&mut self) {
        self.last_match_time = ::std::option::Option::None;
    }

    pub fn has_last_match_time(&self) -> bool {
        self.last_match_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_match_time(&mut self, v: u32) {
        self.last_match_time = ::std::option::Option::Some(v);
    }

    pub fn get_last_match_time(&self) -> u32 {
        self.last_match_time.unwrap_or(0)
    }

    fn get_last_match_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.last_match_time
    }

    fn mut_last_match_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.last_match_time
    }

    // optional uint32 prize_pool_usd = 3;

    pub fn clear_prize_pool_usd(&mut self) {
        self.prize_pool_usd = ::std::option::Option::None;
    }

    pub fn has_prize_pool_usd(&self) -> bool {
        self.prize_pool_usd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prize_pool_usd(&mut self, v: u32) {
        self.prize_pool_usd = ::std::option::Option::Some(v);
    }

    pub fn get_prize_pool_usd(&self) -> u32 {
        self.prize_pool_usd.unwrap_or(0)
    }

    fn get_prize_pool_usd_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prize_pool_usd
    }

    fn mut_prize_pool_usd_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prize_pool_usd
    }

    // optional bool has_live_matches = 4;

    pub fn clear_has_live_matches(&mut self) {
        self.has_live_matches = ::std::option::Option::None;
    }

    pub fn has_has_live_matches(&self) -> bool {
        self.has_live_matches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_live_matches(&mut self, v: bool) {
        self.has_live_matches = ::std::option::Option::Some(v);
    }

    pub fn get_has_live_matches(&self) -> bool {
        self.has_live_matches.unwrap_or(false)
    }

    fn get_has_live_matches_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.has_live_matches
    }

    fn mut_has_live_matches_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.has_live_matches
    }

    // optional bool is_compendium_public = 5;

    pub fn clear_is_compendium_public(&mut self) {
        self.is_compendium_public = ::std::option::Option::None;
    }

    pub fn has_is_compendium_public(&self) -> bool {
        self.is_compendium_public.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_compendium_public(&mut self, v: bool) {
        self.is_compendium_public = ::std::option::Option::Some(v);
    }

    pub fn get_is_compendium_public(&self) -> bool {
        self.is_compendium_public.unwrap_or(false)
    }

    fn get_is_compendium_public_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_compendium_public
    }

    fn mut_is_compendium_public_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_compendium_public
    }

    // optional uint32 compendium_version = 6;

    pub fn clear_compendium_version(&mut self) {
        self.compendium_version = ::std::option::Option::None;
    }

    pub fn has_compendium_version(&self) -> bool {
        self.compendium_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compendium_version(&mut self, v: u32) {
        self.compendium_version = ::std::option::Option::Some(v);
    }

    pub fn get_compendium_version(&self) -> u32 {
        self.compendium_version.unwrap_or(0)
    }

    fn get_compendium_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.compendium_version
    }

    fn mut_compendium_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.compendium_version
    }

    // optional uint32 compendium_content_version = 7;

    pub fn clear_compendium_content_version(&mut self) {
        self.compendium_content_version = ::std::option::Option::None;
    }

    pub fn has_compendium_content_version(&self) -> bool {
        self.compendium_content_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compendium_content_version(&mut self, v: u32) {
        self.compendium_content_version = ::std::option::Option::Some(v);
    }

    pub fn get_compendium_content_version(&self) -> u32 {
        self.compendium_content_version.unwrap_or(0)
    }

    fn get_compendium_content_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.compendium_content_version
    }

    fn mut_compendium_content_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.compendium_content_version
    }
}

impl ::protobuf::Message for CDynamicLeagueData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.last_match_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prize_pool_usd = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_live_matches = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_compendium_public = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.compendium_version = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.compendium_content_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_match_time {
            my_size += 5;
        }
        if let Some(v) = self.prize_pool_usd {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.has_live_matches {
            my_size += 2;
        }
        if let Some(v) = self.is_compendium_public {
            my_size += 2;
        }
        if let Some(v) = self.compendium_version {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.compendium_content_version {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_match_time {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.prize_pool_usd {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.has_live_matches {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.is_compendium_public {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.compendium_version {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.compendium_content_version {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDynamicLeagueData {
    fn new() -> CDynamicLeagueData {
        CDynamicLeagueData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDynamicLeagueData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CDynamicLeagueData::get_league_id_for_reflect,
                    CDynamicLeagueData::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "last_match_time",
                    CDynamicLeagueData::get_last_match_time_for_reflect,
                    CDynamicLeagueData::mut_last_match_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prize_pool_usd",
                    CDynamicLeagueData::get_prize_pool_usd_for_reflect,
                    CDynamicLeagueData::mut_prize_pool_usd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "has_live_matches",
                    CDynamicLeagueData::get_has_live_matches_for_reflect,
                    CDynamicLeagueData::mut_has_live_matches_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_compendium_public",
                    CDynamicLeagueData::get_is_compendium_public_for_reflect,
                    CDynamicLeagueData::mut_is_compendium_public_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "compendium_version",
                    CDynamicLeagueData::get_compendium_version_for_reflect,
                    CDynamicLeagueData::mut_compendium_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "compendium_content_version",
                    CDynamicLeagueData::get_compendium_content_version_for_reflect,
                    CDynamicLeagueData::mut_compendium_content_version_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDynamicLeagueData>(
                    "CDynamicLeagueData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDynamicLeagueData {
    fn clear(&mut self) {
        self.clear_league_id();
        self.clear_last_match_time();
        self.clear_prize_pool_usd();
        self.clear_has_live_matches();
        self.clear_is_compendium_public();
        self.clear_compendium_version();
        self.clear_compendium_content_version();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDynamicLeagueData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDynamicLeagueData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStaticLeagueData {
    // message fields
    league_id: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    description: ::protobuf::SingularField<::std::string::String>,
    banner_name: ::protobuf::SingularField<::std::string::String>,
    itemdef_name: ::protobuf::SingularField<::std::string::String>,
    url: ::protobuf::SingularField<::std::string::String>,
    item_def_index: ::std::option::Option<u32>,
    hud_skin_item_def_index: ::std::option::Option<u32>,
    loading_screen_name: ::protobuf::SingularField<::std::string::String>,
    base_prize_pool: ::std::option::Option<u32>,
    is_major: ::std::option::Option<bool>,
    tier: ::std::option::Option<u32>,
    amateur_region: ::std::option::Option<u32>,
    organizer: ::protobuf::SingularField<::std::string::String>,
    start_date: ::std::option::Option<u32>,
    end_date: ::std::option::Option<u32>,
    location: ::protobuf::SingularField<::std::string::String>,
    inventory_image: ::protobuf::SingularField<::std::string::String>,
    square_image: ::protobuf::SingularField<::std::string::String>,
    battle_pass_rollup: ::std::option::Option<bool>,
    base_prize_pool_string: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CStaticLeagueData {}

impl CStaticLeagueData {
    pub fn new() -> CStaticLeagueData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CStaticLeagueData {
        static mut instance: ::protobuf::lazy::Lazy<CStaticLeagueData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CStaticLeagueData,
        };
        unsafe {
            instance.get(CStaticLeagueData::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string description = 3;

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_description_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.description
    }

    fn mut_description_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.description
    }

    // optional string banner_name = 4;

    pub fn clear_banner_name(&mut self) {
        self.banner_name.clear();
    }

    pub fn has_banner_name(&self) -> bool {
        self.banner_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banner_name(&mut self, v: ::std::string::String) {
        self.banner_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_banner_name(&mut self) -> &mut ::std::string::String {
        if self.banner_name.is_none() {
            self.banner_name.set_default();
        }
        self.banner_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_banner_name(&mut self) -> ::std::string::String {
        self.banner_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_banner_name(&self) -> &str {
        match self.banner_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_banner_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.banner_name
    }

    fn mut_banner_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.banner_name
    }

    // optional string itemdef_name = 5;

    pub fn clear_itemdef_name(&mut self) {
        self.itemdef_name.clear();
    }

    pub fn has_itemdef_name(&self) -> bool {
        self.itemdef_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemdef_name(&mut self, v: ::std::string::String) {
        self.itemdef_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_itemdef_name(&mut self) -> &mut ::std::string::String {
        if self.itemdef_name.is_none() {
            self.itemdef_name.set_default();
        }
        self.itemdef_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_itemdef_name(&mut self) -> ::std::string::String {
        self.itemdef_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_itemdef_name(&self) -> &str {
        match self.itemdef_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_itemdef_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.itemdef_name
    }

    fn mut_itemdef_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.itemdef_name
    }

    // optional string url = 6;

    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_url_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.url
    }

    fn mut_url_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.url
    }

    // optional uint32 item_def_index = 7;

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    pub fn get_item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    fn get_item_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_def_index
    }

    fn mut_item_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_def_index
    }

    // optional uint32 hud_skin_item_def_index = 8;

    pub fn clear_hud_skin_item_def_index(&mut self) {
        self.hud_skin_item_def_index = ::std::option::Option::None;
    }

    pub fn has_hud_skin_item_def_index(&self) -> bool {
        self.hud_skin_item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hud_skin_item_def_index(&mut self, v: u32) {
        self.hud_skin_item_def_index = ::std::option::Option::Some(v);
    }

    pub fn get_hud_skin_item_def_index(&self) -> u32 {
        self.hud_skin_item_def_index.unwrap_or(0)
    }

    fn get_hud_skin_item_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hud_skin_item_def_index
    }

    fn mut_hud_skin_item_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hud_skin_item_def_index
    }

    // optional string loading_screen_name = 9;

    pub fn clear_loading_screen_name(&mut self) {
        self.loading_screen_name.clear();
    }

    pub fn has_loading_screen_name(&self) -> bool {
        self.loading_screen_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loading_screen_name(&mut self, v: ::std::string::String) {
        self.loading_screen_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loading_screen_name(&mut self) -> &mut ::std::string::String {
        if self.loading_screen_name.is_none() {
            self.loading_screen_name.set_default();
        }
        self.loading_screen_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_loading_screen_name(&mut self) -> ::std::string::String {
        self.loading_screen_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_loading_screen_name(&self) -> &str {
        match self.loading_screen_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_loading_screen_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.loading_screen_name
    }

    fn mut_loading_screen_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.loading_screen_name
    }

    // optional uint32 base_prize_pool = 10;

    pub fn clear_base_prize_pool(&mut self) {
        self.base_prize_pool = ::std::option::Option::None;
    }

    pub fn has_base_prize_pool(&self) -> bool {
        self.base_prize_pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_prize_pool(&mut self, v: u32) {
        self.base_prize_pool = ::std::option::Option::Some(v);
    }

    pub fn get_base_prize_pool(&self) -> u32 {
        self.base_prize_pool.unwrap_or(0)
    }

    fn get_base_prize_pool_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.base_prize_pool
    }

    fn mut_base_prize_pool_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.base_prize_pool
    }

    // optional bool is_major = 11;

    pub fn clear_is_major(&mut self) {
        self.is_major = ::std::option::Option::None;
    }

    pub fn has_is_major(&self) -> bool {
        self.is_major.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_major(&mut self, v: bool) {
        self.is_major = ::std::option::Option::Some(v);
    }

    pub fn get_is_major(&self) -> bool {
        self.is_major.unwrap_or(false)
    }

    fn get_is_major_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_major
    }

    fn mut_is_major_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_major
    }

    // optional uint32 tier = 13;

    pub fn clear_tier(&mut self) {
        self.tier = ::std::option::Option::None;
    }

    pub fn has_tier(&self) -> bool {
        self.tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tier(&mut self, v: u32) {
        self.tier = ::std::option::Option::Some(v);
    }

    pub fn get_tier(&self) -> u32 {
        self.tier.unwrap_or(0)
    }

    fn get_tier_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tier
    }

    fn mut_tier_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tier
    }

    // optional uint32 amateur_region = 14;

    pub fn clear_amateur_region(&mut self) {
        self.amateur_region = ::std::option::Option::None;
    }

    pub fn has_amateur_region(&self) -> bool {
        self.amateur_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amateur_region(&mut self, v: u32) {
        self.amateur_region = ::std::option::Option::Some(v);
    }

    pub fn get_amateur_region(&self) -> u32 {
        self.amateur_region.unwrap_or(0)
    }

    fn get_amateur_region_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.amateur_region
    }

    fn mut_amateur_region_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.amateur_region
    }

    // optional string organizer = 15;

    pub fn clear_organizer(&mut self) {
        self.organizer.clear();
    }

    pub fn has_organizer(&self) -> bool {
        self.organizer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_organizer(&mut self, v: ::std::string::String) {
        self.organizer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_organizer(&mut self) -> &mut ::std::string::String {
        if self.organizer.is_none() {
            self.organizer.set_default();
        }
        self.organizer.as_mut().unwrap()
    }

    // Take field
    pub fn take_organizer(&mut self) -> ::std::string::String {
        self.organizer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_organizer(&self) -> &str {
        match self.organizer.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_organizer_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.organizer
    }

    fn mut_organizer_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.organizer
    }

    // optional uint32 start_date = 16;

    pub fn clear_start_date(&mut self) {
        self.start_date = ::std::option::Option::None;
    }

    pub fn has_start_date(&self) -> bool {
        self.start_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_date(&mut self, v: u32) {
        self.start_date = ::std::option::Option::Some(v);
    }

    pub fn get_start_date(&self) -> u32 {
        self.start_date.unwrap_or(0)
    }

    fn get_start_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.start_date
    }

    fn mut_start_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.start_date
    }

    // optional uint32 end_date = 17;

    pub fn clear_end_date(&mut self) {
        self.end_date = ::std::option::Option::None;
    }

    pub fn has_end_date(&self) -> bool {
        self.end_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_date(&mut self, v: u32) {
        self.end_date = ::std::option::Option::Some(v);
    }

    pub fn get_end_date(&self) -> u32 {
        self.end_date.unwrap_or(0)
    }

    fn get_end_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.end_date
    }

    fn mut_end_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.end_date
    }

    // optional string location = 18;

    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        self.location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_location(&self) -> &str {
        match self.location.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_location_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.location
    }

    fn mut_location_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.location
    }

    // optional string inventory_image = 19;

    pub fn clear_inventory_image(&mut self) {
        self.inventory_image.clear();
    }

    pub fn has_inventory_image(&self) -> bool {
        self.inventory_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory_image(&mut self, v: ::std::string::String) {
        self.inventory_image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inventory_image(&mut self) -> &mut ::std::string::String {
        if self.inventory_image.is_none() {
            self.inventory_image.set_default();
        }
        self.inventory_image.as_mut().unwrap()
    }

    // Take field
    pub fn take_inventory_image(&mut self) -> ::std::string::String {
        self.inventory_image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_inventory_image(&self) -> &str {
        match self.inventory_image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_inventory_image_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.inventory_image
    }

    fn mut_inventory_image_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.inventory_image
    }

    // optional string square_image = 20;

    pub fn clear_square_image(&mut self) {
        self.square_image.clear();
    }

    pub fn has_square_image(&self) -> bool {
        self.square_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_square_image(&mut self, v: ::std::string::String) {
        self.square_image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_square_image(&mut self) -> &mut ::std::string::String {
        if self.square_image.is_none() {
            self.square_image.set_default();
        }
        self.square_image.as_mut().unwrap()
    }

    // Take field
    pub fn take_square_image(&mut self) -> ::std::string::String {
        self.square_image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_square_image(&self) -> &str {
        match self.square_image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_square_image_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.square_image
    }

    fn mut_square_image_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.square_image
    }

    // optional bool battle_pass_rollup = 21;

    pub fn clear_battle_pass_rollup(&mut self) {
        self.battle_pass_rollup = ::std::option::Option::None;
    }

    pub fn has_battle_pass_rollup(&self) -> bool {
        self.battle_pass_rollup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battle_pass_rollup(&mut self, v: bool) {
        self.battle_pass_rollup = ::std::option::Option::Some(v);
    }

    pub fn get_battle_pass_rollup(&self) -> bool {
        self.battle_pass_rollup.unwrap_or(false)
    }

    fn get_battle_pass_rollup_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.battle_pass_rollup
    }

    fn mut_battle_pass_rollup_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.battle_pass_rollup
    }

    // optional string base_prize_pool_string = 22;

    pub fn clear_base_prize_pool_string(&mut self) {
        self.base_prize_pool_string.clear();
    }

    pub fn has_base_prize_pool_string(&self) -> bool {
        self.base_prize_pool_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_prize_pool_string(&mut self, v: ::std::string::String) {
        self.base_prize_pool_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_prize_pool_string(&mut self) -> &mut ::std::string::String {
        if self.base_prize_pool_string.is_none() {
            self.base_prize_pool_string.set_default();
        }
        self.base_prize_pool_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_base_prize_pool_string(&mut self) -> ::std::string::String {
        self.base_prize_pool_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_base_prize_pool_string(&self) -> &str {
        match self.base_prize_pool_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_base_prize_pool_string_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.base_prize_pool_string
    }

    fn mut_base_prize_pool_string_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.base_prize_pool_string
    }
}

impl ::protobuf::Message for CStaticLeagueData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.banner_name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.itemdef_name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def_index = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hud_skin_item_def_index = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loading_screen_name)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.base_prize_pool = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_major = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tier = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.amateur_region = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.organizer)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_date = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.end_date = ::std::option::Option::Some(tmp);
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.location)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.inventory_image)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.square_image)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.battle_pass_rollup = ::std::option::Option::Some(tmp);
                },
                22 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.base_prize_pool_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.banner_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.itemdef_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hud_skin_item_def_index {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.loading_screen_name.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.base_prize_pool {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_major {
            my_size += 2;
        }
        if let Some(v) = self.tier {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.amateur_region {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.organizer.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.start_date {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end_date {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.location.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(ref v) = self.inventory_image.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(ref v) = self.square_image.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.battle_pass_rollup {
            my_size += 3;
        }
        if let Some(ref v) = self.base_prize_pool_string.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.banner_name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.itemdef_name.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.item_def_index {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.hud_skin_item_def_index {
            os.write_uint32(8, v)?;
        }
        if let Some(ref v) = self.loading_screen_name.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.base_prize_pool {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.is_major {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.tier {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.amateur_region {
            os.write_uint32(14, v)?;
        }
        if let Some(ref v) = self.organizer.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(v) = self.start_date {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.end_date {
            os.write_uint32(17, v)?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_string(18, &v)?;
        }
        if let Some(ref v) = self.inventory_image.as_ref() {
            os.write_string(19, &v)?;
        }
        if let Some(ref v) = self.square_image.as_ref() {
            os.write_string(20, &v)?;
        }
        if let Some(v) = self.battle_pass_rollup {
            os.write_bool(21, v)?;
        }
        if let Some(ref v) = self.base_prize_pool_string.as_ref() {
            os.write_string(22, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CStaticLeagueData {
    fn new() -> CStaticLeagueData {
        CStaticLeagueData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CStaticLeagueData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CStaticLeagueData::get_league_id_for_reflect,
                    CStaticLeagueData::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CStaticLeagueData::get_name_for_reflect,
                    CStaticLeagueData::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    CStaticLeagueData::get_description_for_reflect,
                    CStaticLeagueData::mut_description_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "banner_name",
                    CStaticLeagueData::get_banner_name_for_reflect,
                    CStaticLeagueData::mut_banner_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "itemdef_name",
                    CStaticLeagueData::get_itemdef_name_for_reflect,
                    CStaticLeagueData::mut_itemdef_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    CStaticLeagueData::get_url_for_reflect,
                    CStaticLeagueData::mut_url_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_def_index",
                    CStaticLeagueData::get_item_def_index_for_reflect,
                    CStaticLeagueData::mut_item_def_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hud_skin_item_def_index",
                    CStaticLeagueData::get_hud_skin_item_def_index_for_reflect,
                    CStaticLeagueData::mut_hud_skin_item_def_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "loading_screen_name",
                    CStaticLeagueData::get_loading_screen_name_for_reflect,
                    CStaticLeagueData::mut_loading_screen_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "base_prize_pool",
                    CStaticLeagueData::get_base_prize_pool_for_reflect,
                    CStaticLeagueData::mut_base_prize_pool_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_major",
                    CStaticLeagueData::get_is_major_for_reflect,
                    CStaticLeagueData::mut_is_major_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tier",
                    CStaticLeagueData::get_tier_for_reflect,
                    CStaticLeagueData::mut_tier_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "amateur_region",
                    CStaticLeagueData::get_amateur_region_for_reflect,
                    CStaticLeagueData::mut_amateur_region_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "organizer",
                    CStaticLeagueData::get_organizer_for_reflect,
                    CStaticLeagueData::mut_organizer_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "start_date",
                    CStaticLeagueData::get_start_date_for_reflect,
                    CStaticLeagueData::mut_start_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "end_date",
                    CStaticLeagueData::get_end_date_for_reflect,
                    CStaticLeagueData::mut_end_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "location",
                    CStaticLeagueData::get_location_for_reflect,
                    CStaticLeagueData::mut_location_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "inventory_image",
                    CStaticLeagueData::get_inventory_image_for_reflect,
                    CStaticLeagueData::mut_inventory_image_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "square_image",
                    CStaticLeagueData::get_square_image_for_reflect,
                    CStaticLeagueData::mut_square_image_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "battle_pass_rollup",
                    CStaticLeagueData::get_battle_pass_rollup_for_reflect,
                    CStaticLeagueData::mut_battle_pass_rollup_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "base_prize_pool_string",
                    CStaticLeagueData::get_base_prize_pool_string_for_reflect,
                    CStaticLeagueData::mut_base_prize_pool_string_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CStaticLeagueData>(
                    "CStaticLeagueData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CStaticLeagueData {
    fn clear(&mut self) {
        self.clear_league_id();
        self.clear_name();
        self.clear_description();
        self.clear_banner_name();
        self.clear_itemdef_name();
        self.clear_url();
        self.clear_item_def_index();
        self.clear_hud_skin_item_def_index();
        self.clear_loading_screen_name();
        self.clear_base_prize_pool();
        self.clear_is_major();
        self.clear_tier();
        self.clear_amateur_region();
        self.clear_organizer();
        self.clear_start_date();
        self.clear_end_date();
        self.clear_location();
        self.clear_inventory_image();
        self.clear_square_image();
        self.clear_battle_pass_rollup();
        self.clear_base_prize_pool_string();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStaticLeagueData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStaticLeagueData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CLeagueData {
    // message fields
    dynamic_data: ::protobuf::SingularPtrField<CDynamicLeagueData>,
    static_data: ::protobuf::SingularPtrField<CStaticLeagueData>,
    is_owned: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CLeagueData {}

impl CLeagueData {
    pub fn new() -> CLeagueData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CLeagueData {
        static mut instance: ::protobuf::lazy::Lazy<CLeagueData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CLeagueData,
        };
        unsafe {
            instance.get(CLeagueData::new)
        }
    }

    // optional .CDynamicLeagueData dynamic_data = 1;

    pub fn clear_dynamic_data(&mut self) {
        self.dynamic_data.clear();
    }

    pub fn has_dynamic_data(&self) -> bool {
        self.dynamic_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynamic_data(&mut self, v: CDynamicLeagueData) {
        self.dynamic_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dynamic_data(&mut self) -> &mut CDynamicLeagueData {
        if self.dynamic_data.is_none() {
            self.dynamic_data.set_default();
        }
        self.dynamic_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_dynamic_data(&mut self) -> CDynamicLeagueData {
        self.dynamic_data.take().unwrap_or_else(|| CDynamicLeagueData::new())
    }

    pub fn get_dynamic_data(&self) -> &CDynamicLeagueData {
        self.dynamic_data.as_ref().unwrap_or_else(|| CDynamicLeagueData::default_instance())
    }

    fn get_dynamic_data_for_reflect(&self) -> &::protobuf::SingularPtrField<CDynamicLeagueData> {
        &self.dynamic_data
    }

    fn mut_dynamic_data_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDynamicLeagueData> {
        &mut self.dynamic_data
    }

    // optional .CStaticLeagueData static_data = 2;

    pub fn clear_static_data(&mut self) {
        self.static_data.clear();
    }

    pub fn has_static_data(&self) -> bool {
        self.static_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_static_data(&mut self, v: CStaticLeagueData) {
        self.static_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_static_data(&mut self) -> &mut CStaticLeagueData {
        if self.static_data.is_none() {
            self.static_data.set_default();
        }
        self.static_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_static_data(&mut self) -> CStaticLeagueData {
        self.static_data.take().unwrap_or_else(|| CStaticLeagueData::new())
    }

    pub fn get_static_data(&self) -> &CStaticLeagueData {
        self.static_data.as_ref().unwrap_or_else(|| CStaticLeagueData::default_instance())
    }

    fn get_static_data_for_reflect(&self) -> &::protobuf::SingularPtrField<CStaticLeagueData> {
        &self.static_data
    }

    fn mut_static_data_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CStaticLeagueData> {
        &mut self.static_data
    }

    // optional bool is_owned = 3;

    pub fn clear_is_owned(&mut self) {
        self.is_owned = ::std::option::Option::None;
    }

    pub fn has_is_owned(&self) -> bool {
        self.is_owned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_owned(&mut self, v: bool) {
        self.is_owned = ::std::option::Option::Some(v);
    }

    pub fn get_is_owned(&self) -> bool {
        self.is_owned.unwrap_or(false)
    }

    fn get_is_owned_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_owned
    }

    fn mut_is_owned_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_owned
    }
}

impl ::protobuf::Message for CLeagueData {
    fn is_initialized(&self) -> bool {
        for v in &self.dynamic_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.static_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dynamic_data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.static_data)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_owned = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dynamic_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.static_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.is_owned {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dynamic_data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.static_data.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.is_owned {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CLeagueData {
    fn new() -> CLeagueData {
        CLeagueData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CLeagueData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDynamicLeagueData>>(
                    "dynamic_data",
                    CLeagueData::get_dynamic_data_for_reflect,
                    CLeagueData::mut_dynamic_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CStaticLeagueData>>(
                    "static_data",
                    CLeagueData::get_static_data_for_reflect,
                    CLeagueData::mut_static_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_owned",
                    CLeagueData::get_is_owned_for_reflect,
                    CLeagueData::mut_is_owned_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CLeagueData>(
                    "CLeagueData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CLeagueData {
    fn clear(&mut self) {
        self.clear_dynamic_data();
        self.clear_static_data();
        self.clear_is_owned();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CLeagueData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CLeagueData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgResponseLeagueStaticData {
    // message fields
    leagues: ::protobuf::RepeatedField<CStaticLeagueData>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgResponseLeagueStaticData {}

impl CMsgResponseLeagueStaticData {
    pub fn new() -> CMsgResponseLeagueStaticData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgResponseLeagueStaticData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgResponseLeagueStaticData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgResponseLeagueStaticData,
        };
        unsafe {
            instance.get(CMsgResponseLeagueStaticData::new)
        }
    }

    // repeated .CStaticLeagueData leagues = 1;

    pub fn clear_leagues(&mut self) {
        self.leagues.clear();
    }

    // Param is passed by value, moved
    pub fn set_leagues(&mut self, v: ::protobuf::RepeatedField<CStaticLeagueData>) {
        self.leagues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_leagues(&mut self) -> &mut ::protobuf::RepeatedField<CStaticLeagueData> {
        &mut self.leagues
    }

    // Take field
    pub fn take_leagues(&mut self) -> ::protobuf::RepeatedField<CStaticLeagueData> {
        ::std::mem::replace(&mut self.leagues, ::protobuf::RepeatedField::new())
    }

    pub fn get_leagues(&self) -> &[CStaticLeagueData] {
        &self.leagues
    }

    fn get_leagues_for_reflect(&self) -> &::protobuf::RepeatedField<CStaticLeagueData> {
        &self.leagues
    }

    fn mut_leagues_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CStaticLeagueData> {
        &mut self.leagues
    }
}

impl ::protobuf::Message for CMsgResponseLeagueStaticData {
    fn is_initialized(&self) -> bool {
        for v in &self.leagues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.leagues)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.leagues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.leagues {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgResponseLeagueStaticData {
    fn new() -> CMsgResponseLeagueStaticData {
        CMsgResponseLeagueStaticData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgResponseLeagueStaticData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CStaticLeagueData>>(
                    "leagues",
                    CMsgResponseLeagueStaticData::get_leagues_for_reflect,
                    CMsgResponseLeagueStaticData::mut_leagues_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgResponseLeagueStaticData>(
                    "CMsgResponseLeagueStaticData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgResponseLeagueStaticData {
    fn clear(&mut self) {
        self.clear_leagues();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgResponseLeagueStaticData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgResponseLeagueStaticData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgResponseLeagueInfo {
    // message fields
    leagues: ::protobuf::RepeatedField<CDynamicLeagueData>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgResponseLeagueInfo {}

impl CMsgResponseLeagueInfo {
    pub fn new() -> CMsgResponseLeagueInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgResponseLeagueInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgResponseLeagueInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgResponseLeagueInfo,
        };
        unsafe {
            instance.get(CMsgResponseLeagueInfo::new)
        }
    }

    // repeated .CDynamicLeagueData leagues = 1;

    pub fn clear_leagues(&mut self) {
        self.leagues.clear();
    }

    // Param is passed by value, moved
    pub fn set_leagues(&mut self, v: ::protobuf::RepeatedField<CDynamicLeagueData>) {
        self.leagues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_leagues(&mut self) -> &mut ::protobuf::RepeatedField<CDynamicLeagueData> {
        &mut self.leagues
    }

    // Take field
    pub fn take_leagues(&mut self) -> ::protobuf::RepeatedField<CDynamicLeagueData> {
        ::std::mem::replace(&mut self.leagues, ::protobuf::RepeatedField::new())
    }

    pub fn get_leagues(&self) -> &[CDynamicLeagueData] {
        &self.leagues
    }

    fn get_leagues_for_reflect(&self) -> &::protobuf::RepeatedField<CDynamicLeagueData> {
        &self.leagues
    }

    fn mut_leagues_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDynamicLeagueData> {
        &mut self.leagues
    }
}

impl ::protobuf::Message for CMsgResponseLeagueInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.leagues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.leagues)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.leagues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.leagues {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgResponseLeagueInfo {
    fn new() -> CMsgResponseLeagueInfo {
        CMsgResponseLeagueInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgResponseLeagueInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDynamicLeagueData>>(
                    "leagues",
                    CMsgResponseLeagueInfo::get_leagues_for_reflect,
                    CMsgResponseLeagueInfo::mut_leagues_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgResponseLeagueInfo>(
                    "CMsgResponseLeagueInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgResponseLeagueInfo {
    fn clear(&mut self) {
        self.clear_leagues();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgResponseLeagueInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgResponseLeagueInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAMatchVotes {
    // message fields
    match_id: ::std::option::Option<u64>,
    votes: ::protobuf::RepeatedField<CMsgDOTAMatchVotes_PlayerVote>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAMatchVotes {}

impl CMsgDOTAMatchVotes {
    pub fn new() -> CMsgDOTAMatchVotes {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAMatchVotes {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAMatchVotes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAMatchVotes,
        };
        unsafe {
            instance.get(CMsgDOTAMatchVotes::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // repeated .CMsgDOTAMatchVotes.PlayerVote votes = 2;

    pub fn clear_votes(&mut self) {
        self.votes.clear();
    }

    // Param is passed by value, moved
    pub fn set_votes(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAMatchVotes_PlayerVote>) {
        self.votes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_votes(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAMatchVotes_PlayerVote> {
        &mut self.votes
    }

    // Take field
    pub fn take_votes(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAMatchVotes_PlayerVote> {
        ::std::mem::replace(&mut self.votes, ::protobuf::RepeatedField::new())
    }

    pub fn get_votes(&self) -> &[CMsgDOTAMatchVotes_PlayerVote] {
        &self.votes
    }

    fn get_votes_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAMatchVotes_PlayerVote> {
        &self.votes
    }

    fn mut_votes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAMatchVotes_PlayerVote> {
        &mut self.votes
    }
}

impl ::protobuf::Message for CMsgDOTAMatchVotes {
    fn is_initialized(&self) -> bool {
        for v in &self.votes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.votes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.votes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAMatchVotes {
    fn new() -> CMsgDOTAMatchVotes {
        CMsgDOTAMatchVotes::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAMatchVotes>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgDOTAMatchVotes::get_match_id_for_reflect,
                    CMsgDOTAMatchVotes::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAMatchVotes_PlayerVote>>(
                    "votes",
                    CMsgDOTAMatchVotes::get_votes_for_reflect,
                    CMsgDOTAMatchVotes::mut_votes_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAMatchVotes>(
                    "CMsgDOTAMatchVotes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAMatchVotes {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_votes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAMatchVotes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAMatchVotes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAMatchVotes_PlayerVote {
    // message fields
    account_id: ::std::option::Option<u32>,
    vote: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAMatchVotes_PlayerVote {}

impl CMsgDOTAMatchVotes_PlayerVote {
    pub fn new() -> CMsgDOTAMatchVotes_PlayerVote {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAMatchVotes_PlayerVote {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAMatchVotes_PlayerVote> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAMatchVotes_PlayerVote,
        };
        unsafe {
            instance.get(CMsgDOTAMatchVotes_PlayerVote::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 vote = 2;

    pub fn clear_vote(&mut self) {
        self.vote = ::std::option::Option::None;
    }

    pub fn has_vote(&self) -> bool {
        self.vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: u32) {
        self.vote = ::std::option::Option::Some(v);
    }

    pub fn get_vote(&self) -> u32 {
        self.vote.unwrap_or(0)
    }

    fn get_vote_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.vote
    }

    fn mut_vote_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.vote
    }
}

impl ::protobuf::Message for CMsgDOTAMatchVotes_PlayerVote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.vote = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vote {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.vote {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAMatchVotes_PlayerVote {
    fn new() -> CMsgDOTAMatchVotes_PlayerVote {
        CMsgDOTAMatchVotes_PlayerVote::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAMatchVotes_PlayerVote>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAMatchVotes_PlayerVote::get_account_id_for_reflect,
                    CMsgDOTAMatchVotes_PlayerVote::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "vote",
                    CMsgDOTAMatchVotes_PlayerVote::get_vote_for_reflect,
                    CMsgDOTAMatchVotes_PlayerVote::mut_vote_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAMatchVotes_PlayerVote>(
                    "CMsgDOTAMatchVotes_PlayerVote",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAMatchVotes_PlayerVote {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_vote();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAMatchVotes_PlayerVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAMatchVotes_PlayerVote {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCastMatchVote {
    // message fields
    match_id: ::std::option::Option<u64>,
    vote: ::std::option::Option<super::dota_shared_enums::DOTAMatchVote>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgCastMatchVote {}

impl CMsgCastMatchVote {
    pub fn new() -> CMsgCastMatchVote {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgCastMatchVote {
        static mut instance: ::protobuf::lazy::Lazy<CMsgCastMatchVote> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgCastMatchVote,
        };
        unsafe {
            instance.get(CMsgCastMatchVote::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional .DOTAMatchVote vote = 2;

    pub fn clear_vote(&mut self) {
        self.vote = ::std::option::Option::None;
    }

    pub fn has_vote(&self) -> bool {
        self.vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: super::dota_shared_enums::DOTAMatchVote) {
        self.vote = ::std::option::Option::Some(v);
    }

    pub fn get_vote(&self) -> super::dota_shared_enums::DOTAMatchVote {
        self.vote.unwrap_or(super::dota_shared_enums::DOTAMatchVote::DOTAMatchVote_INVALID)
    }

    fn get_vote_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::DOTAMatchVote> {
        &self.vote
    }

    fn mut_vote_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::DOTAMatchVote> {
        &mut self.vote
    }
}

impl ::protobuf::Message for CMsgCastMatchVote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.vote = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vote {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.vote {
            os.write_enum(2, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgCastMatchVote {
    fn new() -> CMsgCastMatchVote {
        CMsgCastMatchVote::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgCastMatchVote>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgCastMatchVote::get_match_id_for_reflect,
                    CMsgCastMatchVote::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::DOTAMatchVote>>(
                    "vote",
                    CMsgCastMatchVote::get_vote_for_reflect,
                    CMsgCastMatchVote::mut_vote_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgCastMatchVote>(
                    "CMsgCastMatchVote",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgCastMatchVote {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_vote();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCastMatchVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCastMatchVote {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRetrieveMatchVote {
    // message fields
    match_id: ::std::option::Option<u64>,
    incremental: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgRetrieveMatchVote {}

impl CMsgRetrieveMatchVote {
    pub fn new() -> CMsgRetrieveMatchVote {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgRetrieveMatchVote {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRetrieveMatchVote> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRetrieveMatchVote,
        };
        unsafe {
            instance.get(CMsgRetrieveMatchVote::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 incremental = 2;

    pub fn clear_incremental(&mut self) {
        self.incremental = ::std::option::Option::None;
    }

    pub fn has_incremental(&self) -> bool {
        self.incremental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_incremental(&mut self, v: u32) {
        self.incremental = ::std::option::Option::Some(v);
    }

    pub fn get_incremental(&self) -> u32 {
        self.incremental.unwrap_or(0)
    }

    fn get_incremental_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.incremental
    }

    fn mut_incremental_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.incremental
    }
}

impl ::protobuf::Message for CMsgRetrieveMatchVote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.incremental = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.incremental {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.incremental {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgRetrieveMatchVote {
    fn new() -> CMsgRetrieveMatchVote {
        CMsgRetrieveMatchVote::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgRetrieveMatchVote>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgRetrieveMatchVote::get_match_id_for_reflect,
                    CMsgRetrieveMatchVote::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "incremental",
                    CMsgRetrieveMatchVote::get_incremental_for_reflect,
                    CMsgRetrieveMatchVote::mut_incremental_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRetrieveMatchVote>(
                    "CMsgRetrieveMatchVote",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgRetrieveMatchVote {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_incremental();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRetrieveMatchVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRetrieveMatchVote {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgMatchVoteResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    vote: ::std::option::Option<super::dota_shared_enums::DOTAMatchVote>,
    positive_votes: ::std::option::Option<u32>,
    negative_votes: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgMatchVoteResponse {}

impl CMsgMatchVoteResponse {
    pub fn new() -> CMsgMatchVoteResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgMatchVoteResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgMatchVoteResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgMatchVoteResponse,
        };
        unsafe {
            instance.get(CMsgMatchVoteResponse::new)
        }
    }

    // optional uint32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    fn get_eresult_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.eresult
    }

    fn mut_eresult_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.eresult
    }

    // optional .DOTAMatchVote vote = 2;

    pub fn clear_vote(&mut self) {
        self.vote = ::std::option::Option::None;
    }

    pub fn has_vote(&self) -> bool {
        self.vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: super::dota_shared_enums::DOTAMatchVote) {
        self.vote = ::std::option::Option::Some(v);
    }

    pub fn get_vote(&self) -> super::dota_shared_enums::DOTAMatchVote {
        self.vote.unwrap_or(super::dota_shared_enums::DOTAMatchVote::DOTAMatchVote_INVALID)
    }

    fn get_vote_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::DOTAMatchVote> {
        &self.vote
    }

    fn mut_vote_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::DOTAMatchVote> {
        &mut self.vote
    }

    // optional uint32 positive_votes = 3;

    pub fn clear_positive_votes(&mut self) {
        self.positive_votes = ::std::option::Option::None;
    }

    pub fn has_positive_votes(&self) -> bool {
        self.positive_votes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positive_votes(&mut self, v: u32) {
        self.positive_votes = ::std::option::Option::Some(v);
    }

    pub fn get_positive_votes(&self) -> u32 {
        self.positive_votes.unwrap_or(0)
    }

    fn get_positive_votes_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.positive_votes
    }

    fn mut_positive_votes_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.positive_votes
    }

    // optional uint32 negative_votes = 4;

    pub fn clear_negative_votes(&mut self) {
        self.negative_votes = ::std::option::Option::None;
    }

    pub fn has_negative_votes(&self) -> bool {
        self.negative_votes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative_votes(&mut self, v: u32) {
        self.negative_votes = ::std::option::Option::Some(v);
    }

    pub fn get_negative_votes(&self) -> u32 {
        self.negative_votes.unwrap_or(0)
    }

    fn get_negative_votes_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.negative_votes
    }

    fn mut_negative_votes_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.negative_votes
    }
}

impl ::protobuf::Message for CMsgMatchVoteResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.vote = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.positive_votes = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.negative_votes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vote {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.positive_votes {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.negative_votes {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.vote {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.positive_votes {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.negative_votes {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgMatchVoteResponse {
    fn new() -> CMsgMatchVoteResponse {
        CMsgMatchVoteResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgMatchVoteResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "eresult",
                    CMsgMatchVoteResponse::get_eresult_for_reflect,
                    CMsgMatchVoteResponse::mut_eresult_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::DOTAMatchVote>>(
                    "vote",
                    CMsgMatchVoteResponse::get_vote_for_reflect,
                    CMsgMatchVoteResponse::mut_vote_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "positive_votes",
                    CMsgMatchVoteResponse::get_positive_votes_for_reflect,
                    CMsgMatchVoteResponse::mut_positive_votes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "negative_votes",
                    CMsgMatchVoteResponse::get_negative_votes_for_reflect,
                    CMsgMatchVoteResponse::mut_negative_votes_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgMatchVoteResponse>(
                    "CMsgMatchVoteResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgMatchVoteResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_vote();
        self.clear_positive_votes();
        self.clear_negative_votes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMatchVoteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMatchVoteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAHallOfFame {
    // message fields
    week: ::std::option::Option<u32>,
    featured_players: ::protobuf::RepeatedField<CMsgDOTAHallOfFame_FeaturedPlayer>,
    featured_farmer: ::protobuf::SingularPtrField<CMsgDOTAHallOfFame_FeaturedFarmer>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAHallOfFame {}

impl CMsgDOTAHallOfFame {
    pub fn new() -> CMsgDOTAHallOfFame {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAHallOfFame {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAHallOfFame> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAHallOfFame,
        };
        unsafe {
            instance.get(CMsgDOTAHallOfFame::new)
        }
    }

    // optional uint32 week = 1;

    pub fn clear_week(&mut self) {
        self.week = ::std::option::Option::None;
    }

    pub fn has_week(&self) -> bool {
        self.week.is_some()
    }

    // Param is passed by value, moved
    pub fn set_week(&mut self, v: u32) {
        self.week = ::std::option::Option::Some(v);
    }

    pub fn get_week(&self) -> u32 {
        self.week.unwrap_or(0)
    }

    fn get_week_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.week
    }

    fn mut_week_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.week
    }

    // repeated .CMsgDOTAHallOfFame.FeaturedPlayer featured_players = 2;

    pub fn clear_featured_players(&mut self) {
        self.featured_players.clear();
    }

    // Param is passed by value, moved
    pub fn set_featured_players(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAHallOfFame_FeaturedPlayer>) {
        self.featured_players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_featured_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAHallOfFame_FeaturedPlayer> {
        &mut self.featured_players
    }

    // Take field
    pub fn take_featured_players(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAHallOfFame_FeaturedPlayer> {
        ::std::mem::replace(&mut self.featured_players, ::protobuf::RepeatedField::new())
    }

    pub fn get_featured_players(&self) -> &[CMsgDOTAHallOfFame_FeaturedPlayer] {
        &self.featured_players
    }

    fn get_featured_players_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAHallOfFame_FeaturedPlayer> {
        &self.featured_players
    }

    fn mut_featured_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAHallOfFame_FeaturedPlayer> {
        &mut self.featured_players
    }

    // optional .CMsgDOTAHallOfFame.FeaturedFarmer featured_farmer = 3;

    pub fn clear_featured_farmer(&mut self) {
        self.featured_farmer.clear();
    }

    pub fn has_featured_farmer(&self) -> bool {
        self.featured_farmer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featured_farmer(&mut self, v: CMsgDOTAHallOfFame_FeaturedFarmer) {
        self.featured_farmer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_featured_farmer(&mut self) -> &mut CMsgDOTAHallOfFame_FeaturedFarmer {
        if self.featured_farmer.is_none() {
            self.featured_farmer.set_default();
        }
        self.featured_farmer.as_mut().unwrap()
    }

    // Take field
    pub fn take_featured_farmer(&mut self) -> CMsgDOTAHallOfFame_FeaturedFarmer {
        self.featured_farmer.take().unwrap_or_else(|| CMsgDOTAHallOfFame_FeaturedFarmer::new())
    }

    pub fn get_featured_farmer(&self) -> &CMsgDOTAHallOfFame_FeaturedFarmer {
        self.featured_farmer.as_ref().unwrap_or_else(|| CMsgDOTAHallOfFame_FeaturedFarmer::default_instance())
    }

    fn get_featured_farmer_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAHallOfFame_FeaturedFarmer> {
        &self.featured_farmer
    }

    fn mut_featured_farmer_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAHallOfFame_FeaturedFarmer> {
        &mut self.featured_farmer
    }
}

impl ::protobuf::Message for CMsgDOTAHallOfFame {
    fn is_initialized(&self) -> bool {
        for v in &self.featured_players {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.featured_farmer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.week = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.featured_players)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.featured_farmer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.week {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.featured_players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.featured_farmer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.week {
            os.write_uint32(1, v)?;
        }
        for v in &self.featured_players {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.featured_farmer.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAHallOfFame {
    fn new() -> CMsgDOTAHallOfFame {
        CMsgDOTAHallOfFame::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAHallOfFame>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "week",
                    CMsgDOTAHallOfFame::get_week_for_reflect,
                    CMsgDOTAHallOfFame::mut_week_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAHallOfFame_FeaturedPlayer>>(
                    "featured_players",
                    CMsgDOTAHallOfFame::get_featured_players_for_reflect,
                    CMsgDOTAHallOfFame::mut_featured_players_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAHallOfFame_FeaturedFarmer>>(
                    "featured_farmer",
                    CMsgDOTAHallOfFame::get_featured_farmer_for_reflect,
                    CMsgDOTAHallOfFame::mut_featured_farmer_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAHallOfFame>(
                    "CMsgDOTAHallOfFame",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAHallOfFame {
    fn clear(&mut self) {
        self.clear_week();
        self.clear_featured_players();
        self.clear_featured_farmer();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAHallOfFame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAHallOfFame {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAHallOfFame_FeaturedPlayer {
    // message fields
    account_id: ::std::option::Option<u32>,
    hero_id: ::std::option::Option<u32>,
    average_scaled_metric: ::std::option::Option<f32>,
    num_games: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAHallOfFame_FeaturedPlayer {}

impl CMsgDOTAHallOfFame_FeaturedPlayer {
    pub fn new() -> CMsgDOTAHallOfFame_FeaturedPlayer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAHallOfFame_FeaturedPlayer {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAHallOfFame_FeaturedPlayer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAHallOfFame_FeaturedPlayer,
        };
        unsafe {
            instance.get(CMsgDOTAHallOfFame_FeaturedPlayer::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 hero_id = 2;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional float average_scaled_metric = 3;

    pub fn clear_average_scaled_metric(&mut self) {
        self.average_scaled_metric = ::std::option::Option::None;
    }

    pub fn has_average_scaled_metric(&self) -> bool {
        self.average_scaled_metric.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_scaled_metric(&mut self, v: f32) {
        self.average_scaled_metric = ::std::option::Option::Some(v);
    }

    pub fn get_average_scaled_metric(&self) -> f32 {
        self.average_scaled_metric.unwrap_or(0.)
    }

    fn get_average_scaled_metric_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.average_scaled_metric
    }

    fn mut_average_scaled_metric_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.average_scaled_metric
    }

    // optional uint32 num_games = 4;

    pub fn clear_num_games(&mut self) {
        self.num_games = ::std::option::Option::None;
    }

    pub fn has_num_games(&self) -> bool {
        self.num_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_games(&mut self, v: u32) {
        self.num_games = ::std::option::Option::Some(v);
    }

    pub fn get_num_games(&self) -> u32 {
        self.num_games.unwrap_or(0)
    }

    fn get_num_games_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.num_games
    }

    fn mut_num_games_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.num_games
    }
}

impl ::protobuf::Message for CMsgDOTAHallOfFame_FeaturedPlayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.average_scaled_metric = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_games = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.average_scaled_metric {
            my_size += 5;
        }
        if let Some(v) = self.num_games {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.average_scaled_metric {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.num_games {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAHallOfFame_FeaturedPlayer {
    fn new() -> CMsgDOTAHallOfFame_FeaturedPlayer {
        CMsgDOTAHallOfFame_FeaturedPlayer::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAHallOfFame_FeaturedPlayer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAHallOfFame_FeaturedPlayer::get_account_id_for_reflect,
                    CMsgDOTAHallOfFame_FeaturedPlayer::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgDOTAHallOfFame_FeaturedPlayer::get_hero_id_for_reflect,
                    CMsgDOTAHallOfFame_FeaturedPlayer::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "average_scaled_metric",
                    CMsgDOTAHallOfFame_FeaturedPlayer::get_average_scaled_metric_for_reflect,
                    CMsgDOTAHallOfFame_FeaturedPlayer::mut_average_scaled_metric_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_games",
                    CMsgDOTAHallOfFame_FeaturedPlayer::get_num_games_for_reflect,
                    CMsgDOTAHallOfFame_FeaturedPlayer::mut_num_games_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAHallOfFame_FeaturedPlayer>(
                    "CMsgDOTAHallOfFame_FeaturedPlayer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAHallOfFame_FeaturedPlayer {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_hero_id();
        self.clear_average_scaled_metric();
        self.clear_num_games();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAHallOfFame_FeaturedPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAHallOfFame_FeaturedPlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAHallOfFame_FeaturedFarmer {
    // message fields
    account_id: ::std::option::Option<u32>,
    hero_id: ::std::option::Option<u32>,
    gold_per_min: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAHallOfFame_FeaturedFarmer {}

impl CMsgDOTAHallOfFame_FeaturedFarmer {
    pub fn new() -> CMsgDOTAHallOfFame_FeaturedFarmer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAHallOfFame_FeaturedFarmer {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAHallOfFame_FeaturedFarmer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAHallOfFame_FeaturedFarmer,
        };
        unsafe {
            instance.get(CMsgDOTAHallOfFame_FeaturedFarmer::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 hero_id = 2;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 gold_per_min = 3;

    pub fn clear_gold_per_min(&mut self) {
        self.gold_per_min = ::std::option::Option::None;
    }

    pub fn has_gold_per_min(&self) -> bool {
        self.gold_per_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_per_min(&mut self, v: u32) {
        self.gold_per_min = ::std::option::Option::Some(v);
    }

    pub fn get_gold_per_min(&self) -> u32 {
        self.gold_per_min.unwrap_or(0)
    }

    fn get_gold_per_min_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gold_per_min
    }

    fn mut_gold_per_min_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gold_per_min
    }

    // optional uint64 match_id = 4;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }
}

impl ::protobuf::Message for CMsgDOTAHallOfFame_FeaturedFarmer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gold_per_min = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gold_per_min {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.gold_per_min {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAHallOfFame_FeaturedFarmer {
    fn new() -> CMsgDOTAHallOfFame_FeaturedFarmer {
        CMsgDOTAHallOfFame_FeaturedFarmer::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAHallOfFame_FeaturedFarmer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAHallOfFame_FeaturedFarmer::get_account_id_for_reflect,
                    CMsgDOTAHallOfFame_FeaturedFarmer::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgDOTAHallOfFame_FeaturedFarmer::get_hero_id_for_reflect,
                    CMsgDOTAHallOfFame_FeaturedFarmer::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gold_per_min",
                    CMsgDOTAHallOfFame_FeaturedFarmer::get_gold_per_min_for_reflect,
                    CMsgDOTAHallOfFame_FeaturedFarmer::mut_gold_per_min_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgDOTAHallOfFame_FeaturedFarmer::get_match_id_for_reflect,
                    CMsgDOTAHallOfFame_FeaturedFarmer::mut_match_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAHallOfFame_FeaturedFarmer>(
                    "CMsgDOTAHallOfFame_FeaturedFarmer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAHallOfFame_FeaturedFarmer {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_hero_id();
        self.clear_gold_per_min();
        self.clear_match_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAHallOfFame_FeaturedFarmer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAHallOfFame_FeaturedFarmer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAHallOfFameRequest {
    // message fields
    week: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAHallOfFameRequest {}

impl CMsgDOTAHallOfFameRequest {
    pub fn new() -> CMsgDOTAHallOfFameRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAHallOfFameRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAHallOfFameRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAHallOfFameRequest,
        };
        unsafe {
            instance.get(CMsgDOTAHallOfFameRequest::new)
        }
    }

    // optional uint32 week = 1;

    pub fn clear_week(&mut self) {
        self.week = ::std::option::Option::None;
    }

    pub fn has_week(&self) -> bool {
        self.week.is_some()
    }

    // Param is passed by value, moved
    pub fn set_week(&mut self, v: u32) {
        self.week = ::std::option::Option::Some(v);
    }

    pub fn get_week(&self) -> u32 {
        self.week.unwrap_or(0)
    }

    fn get_week_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.week
    }

    fn mut_week_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.week
    }
}

impl ::protobuf::Message for CMsgDOTAHallOfFameRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.week = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.week {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.week {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAHallOfFameRequest {
    fn new() -> CMsgDOTAHallOfFameRequest {
        CMsgDOTAHallOfFameRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAHallOfFameRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "week",
                    CMsgDOTAHallOfFameRequest::get_week_for_reflect,
                    CMsgDOTAHallOfFameRequest::mut_week_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAHallOfFameRequest>(
                    "CMsgDOTAHallOfFameRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAHallOfFameRequest {
    fn clear(&mut self) {
        self.clear_week();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAHallOfFameRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAHallOfFameRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAHallOfFameResponse {
    // message fields
    hall_of_fame: ::protobuf::SingularPtrField<CMsgDOTAHallOfFame>,
    eresult: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAHallOfFameResponse {}

impl CMsgDOTAHallOfFameResponse {
    pub fn new() -> CMsgDOTAHallOfFameResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAHallOfFameResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAHallOfFameResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAHallOfFameResponse,
        };
        unsafe {
            instance.get(CMsgDOTAHallOfFameResponse::new)
        }
    }

    // optional .CMsgDOTAHallOfFame hall_of_fame = 1;

    pub fn clear_hall_of_fame(&mut self) {
        self.hall_of_fame.clear();
    }

    pub fn has_hall_of_fame(&self) -> bool {
        self.hall_of_fame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hall_of_fame(&mut self, v: CMsgDOTAHallOfFame) {
        self.hall_of_fame = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hall_of_fame(&mut self) -> &mut CMsgDOTAHallOfFame {
        if self.hall_of_fame.is_none() {
            self.hall_of_fame.set_default();
        }
        self.hall_of_fame.as_mut().unwrap()
    }

    // Take field
    pub fn take_hall_of_fame(&mut self) -> CMsgDOTAHallOfFame {
        self.hall_of_fame.take().unwrap_or_else(|| CMsgDOTAHallOfFame::new())
    }

    pub fn get_hall_of_fame(&self) -> &CMsgDOTAHallOfFame {
        self.hall_of_fame.as_ref().unwrap_or_else(|| CMsgDOTAHallOfFame::default_instance())
    }

    fn get_hall_of_fame_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAHallOfFame> {
        &self.hall_of_fame
    }

    fn mut_hall_of_fame_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAHallOfFame> {
        &mut self.hall_of_fame
    }

    // optional uint32 eresult = 2;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    fn get_eresult_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.eresult
    }

    fn mut_eresult_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.eresult
    }
}

impl ::protobuf::Message for CMsgDOTAHallOfFameResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.hall_of_fame {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hall_of_fame)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hall_of_fame.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hall_of_fame.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAHallOfFameResponse {
    fn new() -> CMsgDOTAHallOfFameResponse {
        CMsgDOTAHallOfFameResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAHallOfFameResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAHallOfFame>>(
                    "hall_of_fame",
                    CMsgDOTAHallOfFameResponse::get_hall_of_fame_for_reflect,
                    CMsgDOTAHallOfFameResponse::mut_hall_of_fame_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "eresult",
                    CMsgDOTAHallOfFameResponse::get_eresult_for_reflect,
                    CMsgDOTAHallOfFameResponse::mut_eresult_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAHallOfFameResponse>(
                    "CMsgDOTAHallOfFameResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAHallOfFameResponse {
    fn clear(&mut self) {
        self.clear_hall_of_fame();
        self.clear_eresult();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAHallOfFameResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAHallOfFameResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAHalloweenHighScoreRequest {
    // message fields
    round: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAHalloweenHighScoreRequest {}

impl CMsgDOTAHalloweenHighScoreRequest {
    pub fn new() -> CMsgDOTAHalloweenHighScoreRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAHalloweenHighScoreRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAHalloweenHighScoreRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAHalloweenHighScoreRequest,
        };
        unsafe {
            instance.get(CMsgDOTAHalloweenHighScoreRequest::new)
        }
    }

    // optional int32 round = 1;

    pub fn clear_round(&mut self) {
        self.round = ::std::option::Option::None;
    }

    pub fn has_round(&self) -> bool {
        self.round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: i32) {
        self.round = ::std::option::Option::Some(v);
    }

    pub fn get_round(&self) -> i32 {
        self.round.unwrap_or(-1i32)
    }

    fn get_round_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.round
    }

    fn mut_round_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.round
    }
}

impl ::protobuf::Message for CMsgDOTAHalloweenHighScoreRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.round = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.round {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.round {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAHalloweenHighScoreRequest {
    fn new() -> CMsgDOTAHalloweenHighScoreRequest {
        CMsgDOTAHalloweenHighScoreRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAHalloweenHighScoreRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "round",
                    CMsgDOTAHalloweenHighScoreRequest::get_round_for_reflect,
                    CMsgDOTAHalloweenHighScoreRequest::mut_round_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAHalloweenHighScoreRequest>(
                    "CMsgDOTAHalloweenHighScoreRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAHalloweenHighScoreRequest {
    fn clear(&mut self) {
        self.clear_round();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAHalloweenHighScoreRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAHalloweenHighScoreRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAHalloweenHighScoreResponse {
    // message fields
    score: ::std::option::Option<u32>,
    field_match: ::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgDOTAMatch>,
    eresult: ::std::option::Option<u32>,
    round: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAHalloweenHighScoreResponse {}

impl CMsgDOTAHalloweenHighScoreResponse {
    pub fn new() -> CMsgDOTAHalloweenHighScoreResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAHalloweenHighScoreResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAHalloweenHighScoreResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAHalloweenHighScoreResponse,
        };
        unsafe {
            instance.get(CMsgDOTAHalloweenHighScoreResponse::new)
        }
    }

    // optional uint32 score = 1;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    fn get_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.score
    }

    fn mut_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.score
    }

    // optional .CMsgDOTAMatch match = 2;

    pub fn clear_field_match(&mut self) {
        self.field_match.clear();
    }

    pub fn has_field_match(&self) -> bool {
        self.field_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_match(&mut self, v: super::dota_gcmessages_common::CMsgDOTAMatch) {
        self.field_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_match(&mut self) -> &mut super::dota_gcmessages_common::CMsgDOTAMatch {
        if self.field_match.is_none() {
            self.field_match.set_default();
        }
        self.field_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_match(&mut self) -> super::dota_gcmessages_common::CMsgDOTAMatch {
        self.field_match.take().unwrap_or_else(|| super::dota_gcmessages_common::CMsgDOTAMatch::new())
    }

    pub fn get_field_match(&self) -> &super::dota_gcmessages_common::CMsgDOTAMatch {
        self.field_match.as_ref().unwrap_or_else(|| super::dota_gcmessages_common::CMsgDOTAMatch::default_instance())
    }

    fn get_field_match_for_reflect(&self) -> &::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &self.field_match
    }

    fn mut_field_match_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::dota_gcmessages_common::CMsgDOTAMatch> {
        &mut self.field_match
    }

    // optional uint32 eresult = 3;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    fn get_eresult_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.eresult
    }

    fn mut_eresult_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.eresult
    }

    // optional int32 round = 4;

    pub fn clear_round(&mut self) {
        self.round = ::std::option::Option::None;
    }

    pub fn has_round(&self) -> bool {
        self.round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: i32) {
        self.round = ::std::option::Option::Some(v);
    }

    pub fn get_round(&self) -> i32 {
        self.round.unwrap_or(0)
    }

    fn get_round_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.round
    }

    fn mut_round_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.round
    }
}

impl ::protobuf::Message for CMsgDOTAHalloweenHighScoreResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.field_match {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_match)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.round = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.field_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.round {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.score {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.field_match.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.round {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAHalloweenHighScoreResponse {
    fn new() -> CMsgDOTAHalloweenHighScoreResponse {
        CMsgDOTAHalloweenHighScoreResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAHalloweenHighScoreResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "score",
                    CMsgDOTAHalloweenHighScoreResponse::get_score_for_reflect,
                    CMsgDOTAHalloweenHighScoreResponse::mut_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMsgDOTAMatch>>(
                    "match",
                    CMsgDOTAHalloweenHighScoreResponse::get_field_match_for_reflect,
                    CMsgDOTAHalloweenHighScoreResponse::mut_field_match_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "eresult",
                    CMsgDOTAHalloweenHighScoreResponse::get_eresult_for_reflect,
                    CMsgDOTAHalloweenHighScoreResponse::mut_eresult_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "round",
                    CMsgDOTAHalloweenHighScoreResponse::get_round_for_reflect,
                    CMsgDOTAHalloweenHighScoreResponse::mut_round_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAHalloweenHighScoreResponse>(
                    "CMsgDOTAHalloweenHighScoreResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAHalloweenHighScoreResponse {
    fn clear(&mut self) {
        self.clear_score();
        self.clear_field_match();
        self.clear_eresult();
        self.clear_round();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAHalloweenHighScoreResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAHalloweenHighScoreResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAStorePromoPagesRequest {
    // message fields
    version_seen: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAStorePromoPagesRequest {}

impl CMsgDOTAStorePromoPagesRequest {
    pub fn new() -> CMsgDOTAStorePromoPagesRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAStorePromoPagesRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAStorePromoPagesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAStorePromoPagesRequest,
        };
        unsafe {
            instance.get(CMsgDOTAStorePromoPagesRequest::new)
        }
    }

    // optional uint32 version_seen = 1;

    pub fn clear_version_seen(&mut self) {
        self.version_seen = ::std::option::Option::None;
    }

    pub fn has_version_seen(&self) -> bool {
        self.version_seen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_seen(&mut self, v: u32) {
        self.version_seen = ::std::option::Option::Some(v);
    }

    pub fn get_version_seen(&self) -> u32 {
        self.version_seen.unwrap_or(0)
    }

    fn get_version_seen_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.version_seen
    }

    fn mut_version_seen_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.version_seen
    }
}

impl ::protobuf::Message for CMsgDOTAStorePromoPagesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version_seen = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version_seen {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version_seen {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAStorePromoPagesRequest {
    fn new() -> CMsgDOTAStorePromoPagesRequest {
        CMsgDOTAStorePromoPagesRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAStorePromoPagesRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version_seen",
                    CMsgDOTAStorePromoPagesRequest::get_version_seen_for_reflect,
                    CMsgDOTAStorePromoPagesRequest::mut_version_seen_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAStorePromoPagesRequest>(
                    "CMsgDOTAStorePromoPagesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAStorePromoPagesRequest {
    fn clear(&mut self) {
        self.clear_version_seen();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAStorePromoPagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAStorePromoPagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAStorePromoPagesResponse {
    // message fields
    pages: ::protobuf::RepeatedField<CMsgDOTAStorePromoPagesResponse_PromoPage>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAStorePromoPagesResponse {}

impl CMsgDOTAStorePromoPagesResponse {
    pub fn new() -> CMsgDOTAStorePromoPagesResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAStorePromoPagesResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAStorePromoPagesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAStorePromoPagesResponse,
        };
        unsafe {
            instance.get(CMsgDOTAStorePromoPagesResponse::new)
        }
    }

    // repeated .CMsgDOTAStorePromoPagesResponse.PromoPage pages = 1;

    pub fn clear_pages(&mut self) {
        self.pages.clear();
    }

    // Param is passed by value, moved
    pub fn set_pages(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAStorePromoPagesResponse_PromoPage>) {
        self.pages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pages(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAStorePromoPagesResponse_PromoPage> {
        &mut self.pages
    }

    // Take field
    pub fn take_pages(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAStorePromoPagesResponse_PromoPage> {
        ::std::mem::replace(&mut self.pages, ::protobuf::RepeatedField::new())
    }

    pub fn get_pages(&self) -> &[CMsgDOTAStorePromoPagesResponse_PromoPage] {
        &self.pages
    }

    fn get_pages_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAStorePromoPagesResponse_PromoPage> {
        &self.pages
    }

    fn mut_pages_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAStorePromoPagesResponse_PromoPage> {
        &mut self.pages
    }
}

impl ::protobuf::Message for CMsgDOTAStorePromoPagesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.pages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.pages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.pages {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAStorePromoPagesResponse {
    fn new() -> CMsgDOTAStorePromoPagesResponse {
        CMsgDOTAStorePromoPagesResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAStorePromoPagesResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAStorePromoPagesResponse_PromoPage>>(
                    "pages",
                    CMsgDOTAStorePromoPagesResponse::get_pages_for_reflect,
                    CMsgDOTAStorePromoPagesResponse::mut_pages_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAStorePromoPagesResponse>(
                    "CMsgDOTAStorePromoPagesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAStorePromoPagesResponse {
    fn clear(&mut self) {
        self.clear_pages();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAStorePromoPagesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAStorePromoPagesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAStorePromoPagesResponse_PromoPage {
    // message fields
    promo_id: ::std::option::Option<u32>,
    title: ::protobuf::SingularField<::std::string::String>,
    url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAStorePromoPagesResponse_PromoPage {}

impl CMsgDOTAStorePromoPagesResponse_PromoPage {
    pub fn new() -> CMsgDOTAStorePromoPagesResponse_PromoPage {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAStorePromoPagesResponse_PromoPage {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAStorePromoPagesResponse_PromoPage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAStorePromoPagesResponse_PromoPage,
        };
        unsafe {
            instance.get(CMsgDOTAStorePromoPagesResponse_PromoPage::new)
        }
    }

    // optional uint32 promo_id = 1;

    pub fn clear_promo_id(&mut self) {
        self.promo_id = ::std::option::Option::None;
    }

    pub fn has_promo_id(&self) -> bool {
        self.promo_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_promo_id(&mut self, v: u32) {
        self.promo_id = ::std::option::Option::Some(v);
    }

    pub fn get_promo_id(&self) -> u32 {
        self.promo_id.unwrap_or(0)
    }

    fn get_promo_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.promo_id
    }

    fn mut_promo_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.promo_id
    }

    // optional string title = 2;

    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_title_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.title
    }

    fn mut_title_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.title
    }

    // optional string url = 3;

    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_url_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.url
    }

    fn mut_url_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.url
    }
}

impl ::protobuf::Message for CMsgDOTAStorePromoPagesResponse_PromoPage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.promo_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.promo_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.promo_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAStorePromoPagesResponse_PromoPage {
    fn new() -> CMsgDOTAStorePromoPagesResponse_PromoPage {
        CMsgDOTAStorePromoPagesResponse_PromoPage::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAStorePromoPagesResponse_PromoPage>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "promo_id",
                    CMsgDOTAStorePromoPagesResponse_PromoPage::get_promo_id_for_reflect,
                    CMsgDOTAStorePromoPagesResponse_PromoPage::mut_promo_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    CMsgDOTAStorePromoPagesResponse_PromoPage::get_title_for_reflect,
                    CMsgDOTAStorePromoPagesResponse_PromoPage::mut_title_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    CMsgDOTAStorePromoPagesResponse_PromoPage::get_url_for_reflect,
                    CMsgDOTAStorePromoPagesResponse_PromoPage::mut_url_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAStorePromoPagesResponse_PromoPage>(
                    "CMsgDOTAStorePromoPagesResponse_PromoPage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAStorePromoPagesResponse_PromoPage {
    fn clear(&mut self) {
        self.clear_promo_id();
        self.clear_title();
        self.clear_url();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAStorePromoPagesResponse_PromoPage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAStorePromoPagesResponse_PromoPage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLeagueScheduleBlockTeamInfo {
    // message fields
    team_id: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    logo: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgLeagueScheduleBlockTeamInfo {}

impl CMsgLeagueScheduleBlockTeamInfo {
    pub fn new() -> CMsgLeagueScheduleBlockTeamInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgLeagueScheduleBlockTeamInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLeagueScheduleBlockTeamInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLeagueScheduleBlockTeamInfo,
        };
        unsafe {
            instance.get(CMsgLeagueScheduleBlockTeamInfo::new)
        }
    }

    // optional uint32 team_id = 1;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_id
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional uint64 logo = 4;

    pub fn clear_logo(&mut self) {
        self.logo = ::std::option::Option::None;
    }

    pub fn has_logo(&self) -> bool {
        self.logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logo(&mut self, v: u64) {
        self.logo = ::std::option::Option::Some(v);
    }

    pub fn get_logo(&self) -> u64 {
        self.logo.unwrap_or(0)
    }

    fn get_logo_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.logo
    }

    fn mut_logo_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.logo
    }
}

impl ::protobuf::Message for CMsgLeagueScheduleBlockTeamInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.logo = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.logo {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.logo {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgLeagueScheduleBlockTeamInfo {
    fn new() -> CMsgLeagueScheduleBlockTeamInfo {
        CMsgLeagueScheduleBlockTeamInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgLeagueScheduleBlockTeamInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_id",
                    CMsgLeagueScheduleBlockTeamInfo::get_team_id_for_reflect,
                    CMsgLeagueScheduleBlockTeamInfo::mut_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgLeagueScheduleBlockTeamInfo::get_name_for_reflect,
                    CMsgLeagueScheduleBlockTeamInfo::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "logo",
                    CMsgLeagueScheduleBlockTeamInfo::get_logo_for_reflect,
                    CMsgLeagueScheduleBlockTeamInfo::mut_logo_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLeagueScheduleBlockTeamInfo>(
                    "CMsgLeagueScheduleBlockTeamInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgLeagueScheduleBlockTeamInfo {
    fn clear(&mut self) {
        self.clear_team_id();
        self.clear_name();
        self.clear_logo();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLeagueScheduleBlockTeamInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLeagueScheduleBlockTeamInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLeagueScheduleBlock {
    // message fields
    block_id: ::std::option::Option<u32>,
    start_time: ::std::option::Option<u32>,
    finals: ::std::option::Option<bool>,
    comment: ::protobuf::SingularField<::std::string::String>,
    teams: ::protobuf::RepeatedField<CMsgLeagueScheduleBlockTeamInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgLeagueScheduleBlock {}

impl CMsgLeagueScheduleBlock {
    pub fn new() -> CMsgLeagueScheduleBlock {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgLeagueScheduleBlock {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLeagueScheduleBlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLeagueScheduleBlock,
        };
        unsafe {
            instance.get(CMsgLeagueScheduleBlock::new)
        }
    }

    // optional uint32 block_id = 1;

    pub fn clear_block_id(&mut self) {
        self.block_id = ::std::option::Option::None;
    }

    pub fn has_block_id(&self) -> bool {
        self.block_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_id(&mut self, v: u32) {
        self.block_id = ::std::option::Option::Some(v);
    }

    pub fn get_block_id(&self) -> u32 {
        self.block_id.unwrap_or(0)
    }

    fn get_block_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.block_id
    }

    fn mut_block_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.block_id
    }

    // optional uint32 start_time = 2;

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    pub fn get_start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    fn get_start_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.start_time
    }

    fn mut_start_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.start_time
    }

    // optional bool finals = 4;

    pub fn clear_finals(&mut self) {
        self.finals = ::std::option::Option::None;
    }

    pub fn has_finals(&self) -> bool {
        self.finals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finals(&mut self, v: bool) {
        self.finals = ::std::option::Option::Some(v);
    }

    pub fn get_finals(&self) -> bool {
        self.finals.unwrap_or(false)
    }

    fn get_finals_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.finals
    }

    fn mut_finals_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.finals
    }

    // optional string comment = 5;

    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment.set_default();
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_comment_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.comment
    }

    fn mut_comment_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.comment
    }

    // repeated .CMsgLeagueScheduleBlockTeamInfo teams = 6;

    pub fn clear_teams(&mut self) {
        self.teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_teams(&mut self, v: ::protobuf::RepeatedField<CMsgLeagueScheduleBlockTeamInfo>) {
        self.teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_teams(&mut self) -> &mut ::protobuf::RepeatedField<CMsgLeagueScheduleBlockTeamInfo> {
        &mut self.teams
    }

    // Take field
    pub fn take_teams(&mut self) -> ::protobuf::RepeatedField<CMsgLeagueScheduleBlockTeamInfo> {
        ::std::mem::replace(&mut self.teams, ::protobuf::RepeatedField::new())
    }

    pub fn get_teams(&self) -> &[CMsgLeagueScheduleBlockTeamInfo] {
        &self.teams
    }

    fn get_teams_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgLeagueScheduleBlockTeamInfo> {
        &self.teams
    }

    fn mut_teams_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgLeagueScheduleBlockTeamInfo> {
        &mut self.teams
    }
}

impl ::protobuf::Message for CMsgLeagueScheduleBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.teams {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.block_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.finals = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.comment)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.teams)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.block_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.finals {
            my_size += 2;
        }
        if let Some(ref v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.block_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.finals {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.comment.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.teams {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgLeagueScheduleBlock {
    fn new() -> CMsgLeagueScheduleBlock {
        CMsgLeagueScheduleBlock::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgLeagueScheduleBlock>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "block_id",
                    CMsgLeagueScheduleBlock::get_block_id_for_reflect,
                    CMsgLeagueScheduleBlock::mut_block_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "start_time",
                    CMsgLeagueScheduleBlock::get_start_time_for_reflect,
                    CMsgLeagueScheduleBlock::mut_start_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "finals",
                    CMsgLeagueScheduleBlock::get_finals_for_reflect,
                    CMsgLeagueScheduleBlock::mut_finals_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "comment",
                    CMsgLeagueScheduleBlock::get_comment_for_reflect,
                    CMsgLeagueScheduleBlock::mut_comment_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgLeagueScheduleBlockTeamInfo>>(
                    "teams",
                    CMsgLeagueScheduleBlock::get_teams_for_reflect,
                    CMsgLeagueScheduleBlock::mut_teams_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLeagueScheduleBlock>(
                    "CMsgLeagueScheduleBlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgLeagueScheduleBlock {
    fn clear(&mut self) {
        self.clear_block_id();
        self.clear_start_time();
        self.clear_finals();
        self.clear_comment();
        self.clear_teams();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLeagueScheduleBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLeagueScheduleBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALeague {
    // message fields
    league_id: ::std::option::Option<u32>,
    schedule: ::protobuf::RepeatedField<CMsgLeagueScheduleBlock>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALeague {}

impl CMsgDOTALeague {
    pub fn new() -> CMsgDOTALeague {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALeague {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALeague> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALeague,
        };
        unsafe {
            instance.get(CMsgDOTALeague::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // repeated .CMsgLeagueScheduleBlock schedule = 2;

    pub fn clear_schedule(&mut self) {
        self.schedule.clear();
    }

    // Param is passed by value, moved
    pub fn set_schedule(&mut self, v: ::protobuf::RepeatedField<CMsgLeagueScheduleBlock>) {
        self.schedule = v;
    }

    // Mutable pointer to the field.
    pub fn mut_schedule(&mut self) -> &mut ::protobuf::RepeatedField<CMsgLeagueScheduleBlock> {
        &mut self.schedule
    }

    // Take field
    pub fn take_schedule(&mut self) -> ::protobuf::RepeatedField<CMsgLeagueScheduleBlock> {
        ::std::mem::replace(&mut self.schedule, ::protobuf::RepeatedField::new())
    }

    pub fn get_schedule(&self) -> &[CMsgLeagueScheduleBlock] {
        &self.schedule
    }

    fn get_schedule_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgLeagueScheduleBlock> {
        &self.schedule
    }

    fn mut_schedule_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgLeagueScheduleBlock> {
        &mut self.schedule
    }
}

impl ::protobuf::Message for CMsgDOTALeague {
    fn is_initialized(&self) -> bool {
        for v in &self.schedule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.schedule)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.schedule {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.schedule {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALeague {
    fn new() -> CMsgDOTALeague {
        CMsgDOTALeague::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALeague>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgDOTALeague::get_league_id_for_reflect,
                    CMsgDOTALeague::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgLeagueScheduleBlock>>(
                    "schedule",
                    CMsgDOTALeague::get_schedule_for_reflect,
                    CMsgDOTALeague::mut_schedule_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALeague>(
                    "CMsgDOTALeague",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALeague {
    fn clear(&mut self) {
        self.clear_league_id();
        self.clear_schedule();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALeague {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeague {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALeagueScheduleRequest {
    // message fields
    league_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALeagueScheduleRequest {}

impl CMsgDOTALeagueScheduleRequest {
    pub fn new() -> CMsgDOTALeagueScheduleRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALeagueScheduleRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALeagueScheduleRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALeagueScheduleRequest,
        };
        unsafe {
            instance.get(CMsgDOTALeagueScheduleRequest::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }
}

impl ::protobuf::Message for CMsgDOTALeagueScheduleRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALeagueScheduleRequest {
    fn new() -> CMsgDOTALeagueScheduleRequest {
        CMsgDOTALeagueScheduleRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALeagueScheduleRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgDOTALeagueScheduleRequest::get_league_id_for_reflect,
                    CMsgDOTALeagueScheduleRequest::mut_league_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALeagueScheduleRequest>(
                    "CMsgDOTALeagueScheduleRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALeagueScheduleRequest {
    fn clear(&mut self) {
        self.clear_league_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALeagueScheduleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeagueScheduleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALeagueScheduleResponse {
    // message fields
    league: ::protobuf::SingularPtrField<CMsgDOTALeague>,
    eresult: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALeagueScheduleResponse {}

impl CMsgDOTALeagueScheduleResponse {
    pub fn new() -> CMsgDOTALeagueScheduleResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALeagueScheduleResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALeagueScheduleResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALeagueScheduleResponse,
        };
        unsafe {
            instance.get(CMsgDOTALeagueScheduleResponse::new)
        }
    }

    // optional .CMsgDOTALeague league = 1;

    pub fn clear_league(&mut self) {
        self.league.clear();
    }

    pub fn has_league(&self) -> bool {
        self.league.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league(&mut self, v: CMsgDOTALeague) {
        self.league = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_league(&mut self) -> &mut CMsgDOTALeague {
        if self.league.is_none() {
            self.league.set_default();
        }
        self.league.as_mut().unwrap()
    }

    // Take field
    pub fn take_league(&mut self) -> CMsgDOTALeague {
        self.league.take().unwrap_or_else(|| CMsgDOTALeague::new())
    }

    pub fn get_league(&self) -> &CMsgDOTALeague {
        self.league.as_ref().unwrap_or_else(|| CMsgDOTALeague::default_instance())
    }

    fn get_league_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTALeague> {
        &self.league
    }

    fn mut_league_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTALeague> {
        &mut self.league
    }

    // optional uint32 eresult = 2;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    fn get_eresult_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.eresult
    }

    fn mut_eresult_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.eresult
    }
}

impl ::protobuf::Message for CMsgDOTALeagueScheduleResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.league {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.league)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.league.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.league.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALeagueScheduleResponse {
    fn new() -> CMsgDOTALeagueScheduleResponse {
        CMsgDOTALeagueScheduleResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALeagueScheduleResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTALeague>>(
                    "league",
                    CMsgDOTALeagueScheduleResponse::get_league_for_reflect,
                    CMsgDOTALeagueScheduleResponse::mut_league_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "eresult",
                    CMsgDOTALeagueScheduleResponse::get_eresult_for_reflect,
                    CMsgDOTALeagueScheduleResponse::mut_eresult_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALeagueScheduleResponse>(
                    "CMsgDOTALeagueScheduleResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALeagueScheduleResponse {
    fn clear(&mut self) {
        self.clear_league();
        self.clear_eresult();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALeagueScheduleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeagueScheduleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALeagueScheduleEdit {
    // message fields
    league_id: ::std::option::Option<u32>,
    schedule: ::protobuf::SingularPtrField<CMsgLeagueScheduleBlock>,
    delete_block: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALeagueScheduleEdit {}

impl CMsgDOTALeagueScheduleEdit {
    pub fn new() -> CMsgDOTALeagueScheduleEdit {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALeagueScheduleEdit {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALeagueScheduleEdit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALeagueScheduleEdit,
        };
        unsafe {
            instance.get(CMsgDOTALeagueScheduleEdit::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional .CMsgLeagueScheduleBlock schedule = 2;

    pub fn clear_schedule(&mut self) {
        self.schedule.clear();
    }

    pub fn has_schedule(&self) -> bool {
        self.schedule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schedule(&mut self, v: CMsgLeagueScheduleBlock) {
        self.schedule = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schedule(&mut self) -> &mut CMsgLeagueScheduleBlock {
        if self.schedule.is_none() {
            self.schedule.set_default();
        }
        self.schedule.as_mut().unwrap()
    }

    // Take field
    pub fn take_schedule(&mut self) -> CMsgLeagueScheduleBlock {
        self.schedule.take().unwrap_or_else(|| CMsgLeagueScheduleBlock::new())
    }

    pub fn get_schedule(&self) -> &CMsgLeagueScheduleBlock {
        self.schedule.as_ref().unwrap_or_else(|| CMsgLeagueScheduleBlock::default_instance())
    }

    fn get_schedule_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgLeagueScheduleBlock> {
        &self.schedule
    }

    fn mut_schedule_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgLeagueScheduleBlock> {
        &mut self.schedule
    }

    // optional bool delete_block = 3;

    pub fn clear_delete_block(&mut self) {
        self.delete_block = ::std::option::Option::None;
    }

    pub fn has_delete_block(&self) -> bool {
        self.delete_block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delete_block(&mut self, v: bool) {
        self.delete_block = ::std::option::Option::Some(v);
    }

    pub fn get_delete_block(&self) -> bool {
        self.delete_block.unwrap_or(false)
    }

    fn get_delete_block_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.delete_block
    }

    fn mut_delete_block_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.delete_block
    }
}

impl ::protobuf::Message for CMsgDOTALeagueScheduleEdit {
    fn is_initialized(&self) -> bool {
        for v in &self.schedule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schedule)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.delete_block = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.schedule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.delete_block {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.schedule.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.delete_block {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALeagueScheduleEdit {
    fn new() -> CMsgDOTALeagueScheduleEdit {
        CMsgDOTALeagueScheduleEdit::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALeagueScheduleEdit>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgDOTALeagueScheduleEdit::get_league_id_for_reflect,
                    CMsgDOTALeagueScheduleEdit::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgLeagueScheduleBlock>>(
                    "schedule",
                    CMsgDOTALeagueScheduleEdit::get_schedule_for_reflect,
                    CMsgDOTALeagueScheduleEdit::mut_schedule_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "delete_block",
                    CMsgDOTALeagueScheduleEdit::get_delete_block_for_reflect,
                    CMsgDOTALeagueScheduleEdit::mut_delete_block_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALeagueScheduleEdit>(
                    "CMsgDOTALeagueScheduleEdit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALeagueScheduleEdit {
    fn clear(&mut self) {
        self.clear_league_id();
        self.clear_schedule();
        self.clear_delete_block();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALeagueScheduleEdit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeagueScheduleEdit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALeagueScheduleEditResponse {
    // message fields
    league: ::protobuf::SingularPtrField<CMsgDOTALeague>,
    eresult: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALeagueScheduleEditResponse {}

impl CMsgDOTALeagueScheduleEditResponse {
    pub fn new() -> CMsgDOTALeagueScheduleEditResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALeagueScheduleEditResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALeagueScheduleEditResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALeagueScheduleEditResponse,
        };
        unsafe {
            instance.get(CMsgDOTALeagueScheduleEditResponse::new)
        }
    }

    // optional .CMsgDOTALeague league = 1;

    pub fn clear_league(&mut self) {
        self.league.clear();
    }

    pub fn has_league(&self) -> bool {
        self.league.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league(&mut self, v: CMsgDOTALeague) {
        self.league = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_league(&mut self) -> &mut CMsgDOTALeague {
        if self.league.is_none() {
            self.league.set_default();
        }
        self.league.as_mut().unwrap()
    }

    // Take field
    pub fn take_league(&mut self) -> CMsgDOTALeague {
        self.league.take().unwrap_or_else(|| CMsgDOTALeague::new())
    }

    pub fn get_league(&self) -> &CMsgDOTALeague {
        self.league.as_ref().unwrap_or_else(|| CMsgDOTALeague::default_instance())
    }

    fn get_league_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTALeague> {
        &self.league
    }

    fn mut_league_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTALeague> {
        &mut self.league
    }

    // optional uint32 eresult = 2;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    fn get_eresult_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.eresult
    }

    fn mut_eresult_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.eresult
    }
}

impl ::protobuf::Message for CMsgDOTALeagueScheduleEditResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.league {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.league)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.league.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.league.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALeagueScheduleEditResponse {
    fn new() -> CMsgDOTALeagueScheduleEditResponse {
        CMsgDOTALeagueScheduleEditResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALeagueScheduleEditResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTALeague>>(
                    "league",
                    CMsgDOTALeagueScheduleEditResponse::get_league_for_reflect,
                    CMsgDOTALeagueScheduleEditResponse::mut_league_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "eresult",
                    CMsgDOTALeagueScheduleEditResponse::get_eresult_for_reflect,
                    CMsgDOTALeagueScheduleEditResponse::mut_eresult_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALeagueScheduleEditResponse>(
                    "CMsgDOTALeagueScheduleEditResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALeagueScheduleEditResponse {
    fn clear(&mut self) {
        self.clear_league();
        self.clear_eresult();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALeagueScheduleEditResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeagueScheduleEditResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALeaguesInMonthRequest {
    // message fields
    month: ::std::option::Option<u32>,
    year: ::std::option::Option<u32>,
    tier: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALeaguesInMonthRequest {}

impl CMsgDOTALeaguesInMonthRequest {
    pub fn new() -> CMsgDOTALeaguesInMonthRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALeaguesInMonthRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALeaguesInMonthRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALeaguesInMonthRequest,
        };
        unsafe {
            instance.get(CMsgDOTALeaguesInMonthRequest::new)
        }
    }

    // optional uint32 month = 1;

    pub fn clear_month(&mut self) {
        self.month = ::std::option::Option::None;
    }

    pub fn has_month(&self) -> bool {
        self.month.is_some()
    }

    // Param is passed by value, moved
    pub fn set_month(&mut self, v: u32) {
        self.month = ::std::option::Option::Some(v);
    }

    pub fn get_month(&self) -> u32 {
        self.month.unwrap_or(0)
    }

    fn get_month_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.month
    }

    fn mut_month_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.month
    }

    // optional uint32 year = 2;

    pub fn clear_year(&mut self) {
        self.year = ::std::option::Option::None;
    }

    pub fn has_year(&self) -> bool {
        self.year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_year(&mut self, v: u32) {
        self.year = ::std::option::Option::Some(v);
    }

    pub fn get_year(&self) -> u32 {
        self.year.unwrap_or(0)
    }

    fn get_year_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.year
    }

    fn mut_year_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.year
    }

    // optional uint32 tier = 3;

    pub fn clear_tier(&mut self) {
        self.tier = ::std::option::Option::None;
    }

    pub fn has_tier(&self) -> bool {
        self.tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tier(&mut self, v: u32) {
        self.tier = ::std::option::Option::Some(v);
    }

    pub fn get_tier(&self) -> u32 {
        self.tier.unwrap_or(0)
    }

    fn get_tier_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tier
    }

    fn mut_tier_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tier
    }
}

impl ::protobuf::Message for CMsgDOTALeaguesInMonthRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.month = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.year = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tier = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.month {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.year {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tier {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.month {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.year {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.tier {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALeaguesInMonthRequest {
    fn new() -> CMsgDOTALeaguesInMonthRequest {
        CMsgDOTALeaguesInMonthRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALeaguesInMonthRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "month",
                    CMsgDOTALeaguesInMonthRequest::get_month_for_reflect,
                    CMsgDOTALeaguesInMonthRequest::mut_month_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "year",
                    CMsgDOTALeaguesInMonthRequest::get_year_for_reflect,
                    CMsgDOTALeaguesInMonthRequest::mut_year_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tier",
                    CMsgDOTALeaguesInMonthRequest::get_tier_for_reflect,
                    CMsgDOTALeaguesInMonthRequest::mut_tier_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALeaguesInMonthRequest>(
                    "CMsgDOTALeaguesInMonthRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALeaguesInMonthRequest {
    fn clear(&mut self) {
        self.clear_month();
        self.clear_year();
        self.clear_tier();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALeaguesInMonthRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeaguesInMonthRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALeaguesInMonthResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    month: ::std::option::Option<u32>,
    year: ::std::option::Option<u32>,
    leagues: ::protobuf::RepeatedField<CMsgDOTALeague>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALeaguesInMonthResponse {}

impl CMsgDOTALeaguesInMonthResponse {
    pub fn new() -> CMsgDOTALeaguesInMonthResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALeaguesInMonthResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALeaguesInMonthResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALeaguesInMonthResponse,
        };
        unsafe {
            instance.get(CMsgDOTALeaguesInMonthResponse::new)
        }
    }

    // optional uint32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    fn get_eresult_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.eresult
    }

    fn mut_eresult_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.eresult
    }

    // optional uint32 month = 2;

    pub fn clear_month(&mut self) {
        self.month = ::std::option::Option::None;
    }

    pub fn has_month(&self) -> bool {
        self.month.is_some()
    }

    // Param is passed by value, moved
    pub fn set_month(&mut self, v: u32) {
        self.month = ::std::option::Option::Some(v);
    }

    pub fn get_month(&self) -> u32 {
        self.month.unwrap_or(0)
    }

    fn get_month_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.month
    }

    fn mut_month_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.month
    }

    // optional uint32 year = 3;

    pub fn clear_year(&mut self) {
        self.year = ::std::option::Option::None;
    }

    pub fn has_year(&self) -> bool {
        self.year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_year(&mut self, v: u32) {
        self.year = ::std::option::Option::Some(v);
    }

    pub fn get_year(&self) -> u32 {
        self.year.unwrap_or(0)
    }

    fn get_year_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.year
    }

    fn mut_year_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.year
    }

    // repeated .CMsgDOTALeague leagues = 4;

    pub fn clear_leagues(&mut self) {
        self.leagues.clear();
    }

    // Param is passed by value, moved
    pub fn set_leagues(&mut self, v: ::protobuf::RepeatedField<CMsgDOTALeague>) {
        self.leagues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_leagues(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTALeague> {
        &mut self.leagues
    }

    // Take field
    pub fn take_leagues(&mut self) -> ::protobuf::RepeatedField<CMsgDOTALeague> {
        ::std::mem::replace(&mut self.leagues, ::protobuf::RepeatedField::new())
    }

    pub fn get_leagues(&self) -> &[CMsgDOTALeague] {
        &self.leagues
    }

    fn get_leagues_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTALeague> {
        &self.leagues
    }

    fn mut_leagues_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTALeague> {
        &mut self.leagues
    }
}

impl ::protobuf::Message for CMsgDOTALeaguesInMonthResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.leagues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.month = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.year = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.leagues)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.month {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.year {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.leagues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.month {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.year {
            os.write_uint32(3, v)?;
        }
        for v in &self.leagues {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALeaguesInMonthResponse {
    fn new() -> CMsgDOTALeaguesInMonthResponse {
        CMsgDOTALeaguesInMonthResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALeaguesInMonthResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "eresult",
                    CMsgDOTALeaguesInMonthResponse::get_eresult_for_reflect,
                    CMsgDOTALeaguesInMonthResponse::mut_eresult_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "month",
                    CMsgDOTALeaguesInMonthResponse::get_month_for_reflect,
                    CMsgDOTALeaguesInMonthResponse::mut_month_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "year",
                    CMsgDOTALeaguesInMonthResponse::get_year_for_reflect,
                    CMsgDOTALeaguesInMonthResponse::mut_year_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTALeague>>(
                    "leagues",
                    CMsgDOTALeaguesInMonthResponse::get_leagues_for_reflect,
                    CMsgDOTALeaguesInMonthResponse::mut_leagues_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALeaguesInMonthResponse>(
                    "CMsgDOTALeaguesInMonthResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALeaguesInMonthResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_month();
        self.clear_year();
        self.clear_leagues();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALeaguesInMonthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALeaguesInMonthResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgMatchmakingMatchGroupInfo {
    // message fields
    players_searching: ::std::option::Option<u32>,
    auto_region_select_ping_penalty: ::std::option::Option<i32>,
    status: ::std::option::Option<super::dota_shared_enums::EMatchGroupServerStatus>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgMatchmakingMatchGroupInfo {}

impl CMsgMatchmakingMatchGroupInfo {
    pub fn new() -> CMsgMatchmakingMatchGroupInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgMatchmakingMatchGroupInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgMatchmakingMatchGroupInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgMatchmakingMatchGroupInfo,
        };
        unsafe {
            instance.get(CMsgMatchmakingMatchGroupInfo::new)
        }
    }

    // optional uint32 players_searching = 1;

    pub fn clear_players_searching(&mut self) {
        self.players_searching = ::std::option::Option::None;
    }

    pub fn has_players_searching(&self) -> bool {
        self.players_searching.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_searching(&mut self, v: u32) {
        self.players_searching = ::std::option::Option::Some(v);
    }

    pub fn get_players_searching(&self) -> u32 {
        self.players_searching.unwrap_or(0)
    }

    fn get_players_searching_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.players_searching
    }

    fn mut_players_searching_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.players_searching
    }

    // optional sint32 auto_region_select_ping_penalty = 2;

    pub fn clear_auto_region_select_ping_penalty(&mut self) {
        self.auto_region_select_ping_penalty = ::std::option::Option::None;
    }

    pub fn has_auto_region_select_ping_penalty(&self) -> bool {
        self.auto_region_select_ping_penalty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_region_select_ping_penalty(&mut self, v: i32) {
        self.auto_region_select_ping_penalty = ::std::option::Option::Some(v);
    }

    pub fn get_auto_region_select_ping_penalty(&self) -> i32 {
        self.auto_region_select_ping_penalty.unwrap_or(0)
    }

    fn get_auto_region_select_ping_penalty_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.auto_region_select_ping_penalty
    }

    fn mut_auto_region_select_ping_penalty_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.auto_region_select_ping_penalty
    }

    // optional .EMatchGroupServerStatus status = 3;

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::dota_shared_enums::EMatchGroupServerStatus) {
        self.status = ::std::option::Option::Some(v);
    }

    pub fn get_status(&self) -> super::dota_shared_enums::EMatchGroupServerStatus {
        self.status.unwrap_or(super::dota_shared_enums::EMatchGroupServerStatus::k_EMatchGroupServerStatus_OK)
    }

    fn get_status_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::EMatchGroupServerStatus> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::EMatchGroupServerStatus> {
        &mut self.status
    }
}

impl ::protobuf::Message for CMsgMatchmakingMatchGroupInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.players_searching = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.auto_region_select_ping_penalty = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.players_searching {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.auto_region_select_ping_penalty {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.players_searching {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.auto_region_select_ping_penalty {
            os.write_sint32(2, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(3, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgMatchmakingMatchGroupInfo {
    fn new() -> CMsgMatchmakingMatchGroupInfo {
        CMsgMatchmakingMatchGroupInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgMatchmakingMatchGroupInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "players_searching",
                    CMsgMatchmakingMatchGroupInfo::get_players_searching_for_reflect,
                    CMsgMatchmakingMatchGroupInfo::mut_players_searching_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "auto_region_select_ping_penalty",
                    CMsgMatchmakingMatchGroupInfo::get_auto_region_select_ping_penalty_for_reflect,
                    CMsgMatchmakingMatchGroupInfo::mut_auto_region_select_ping_penalty_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::EMatchGroupServerStatus>>(
                    "status",
                    CMsgMatchmakingMatchGroupInfo::get_status_for_reflect,
                    CMsgMatchmakingMatchGroupInfo::mut_status_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgMatchmakingMatchGroupInfo>(
                    "CMsgMatchmakingMatchGroupInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgMatchmakingMatchGroupInfo {
    fn clear(&mut self) {
        self.clear_players_searching();
        self.clear_auto_region_select_ping_penalty();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMatchmakingMatchGroupInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMatchmakingMatchGroupInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAMatchmakingStatsRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAMatchmakingStatsRequest {}

impl CMsgDOTAMatchmakingStatsRequest {
    pub fn new() -> CMsgDOTAMatchmakingStatsRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAMatchmakingStatsRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAMatchmakingStatsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAMatchmakingStatsRequest,
        };
        unsafe {
            instance.get(CMsgDOTAMatchmakingStatsRequest::new)
        }
    }
}

impl ::protobuf::Message for CMsgDOTAMatchmakingStatsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAMatchmakingStatsRequest {
    fn new() -> CMsgDOTAMatchmakingStatsRequest {
        CMsgDOTAMatchmakingStatsRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAMatchmakingStatsRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAMatchmakingStatsRequest>(
                    "CMsgDOTAMatchmakingStatsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAMatchmakingStatsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAMatchmakingStatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAMatchmakingStatsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAMatchmakingStatsResponse {
    // message fields
    matchgroups_version: ::std::option::Option<u32>,
    legacy_searching_players_by_group_source2: ::std::vec::Vec<u32>,
    match_groups: ::protobuf::RepeatedField<CMsgMatchmakingMatchGroupInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAMatchmakingStatsResponse {}

impl CMsgDOTAMatchmakingStatsResponse {
    pub fn new() -> CMsgDOTAMatchmakingStatsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAMatchmakingStatsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAMatchmakingStatsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAMatchmakingStatsResponse,
        };
        unsafe {
            instance.get(CMsgDOTAMatchmakingStatsResponse::new)
        }
    }

    // optional uint32 matchgroups_version = 1;

    pub fn clear_matchgroups_version(&mut self) {
        self.matchgroups_version = ::std::option::Option::None;
    }

    pub fn has_matchgroups_version(&self) -> bool {
        self.matchgroups_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchgroups_version(&mut self, v: u32) {
        self.matchgroups_version = ::std::option::Option::Some(v);
    }

    pub fn get_matchgroups_version(&self) -> u32 {
        self.matchgroups_version.unwrap_or(0)
    }

    fn get_matchgroups_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.matchgroups_version
    }

    fn mut_matchgroups_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.matchgroups_version
    }

    // repeated uint32 legacy_searching_players_by_group_source2 = 7;

    pub fn clear_legacy_searching_players_by_group_source2(&mut self) {
        self.legacy_searching_players_by_group_source2.clear();
    }

    // Param is passed by value, moved
    pub fn set_legacy_searching_players_by_group_source2(&mut self, v: ::std::vec::Vec<u32>) {
        self.legacy_searching_players_by_group_source2 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_legacy_searching_players_by_group_source2(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.legacy_searching_players_by_group_source2
    }

    // Take field
    pub fn take_legacy_searching_players_by_group_source2(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.legacy_searching_players_by_group_source2, ::std::vec::Vec::new())
    }

    pub fn get_legacy_searching_players_by_group_source2(&self) -> &[u32] {
        &self.legacy_searching_players_by_group_source2
    }

    fn get_legacy_searching_players_by_group_source2_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.legacy_searching_players_by_group_source2
    }

    fn mut_legacy_searching_players_by_group_source2_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.legacy_searching_players_by_group_source2
    }

    // repeated .CMsgMatchmakingMatchGroupInfo match_groups = 8;

    pub fn clear_match_groups(&mut self) {
        self.match_groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_match_groups(&mut self, v: ::protobuf::RepeatedField<CMsgMatchmakingMatchGroupInfo>) {
        self.match_groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_match_groups(&mut self) -> &mut ::protobuf::RepeatedField<CMsgMatchmakingMatchGroupInfo> {
        &mut self.match_groups
    }

    // Take field
    pub fn take_match_groups(&mut self) -> ::protobuf::RepeatedField<CMsgMatchmakingMatchGroupInfo> {
        ::std::mem::replace(&mut self.match_groups, ::protobuf::RepeatedField::new())
    }

    pub fn get_match_groups(&self) -> &[CMsgMatchmakingMatchGroupInfo] {
        &self.match_groups
    }

    fn get_match_groups_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgMatchmakingMatchGroupInfo> {
        &self.match_groups
    }

    fn mut_match_groups_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgMatchmakingMatchGroupInfo> {
        &mut self.match_groups
    }
}

impl ::protobuf::Message for CMsgDOTAMatchmakingStatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.match_groups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matchgroups_version = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.legacy_searching_players_by_group_source2)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.match_groups)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.matchgroups_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.legacy_searching_players_by_group_source2 {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.match_groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.matchgroups_version {
            os.write_uint32(1, v)?;
        }
        for v in &self.legacy_searching_players_by_group_source2 {
            os.write_uint32(7, *v)?;
        };
        for v in &self.match_groups {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAMatchmakingStatsResponse {
    fn new() -> CMsgDOTAMatchmakingStatsResponse {
        CMsgDOTAMatchmakingStatsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAMatchmakingStatsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "matchgroups_version",
                    CMsgDOTAMatchmakingStatsResponse::get_matchgroups_version_for_reflect,
                    CMsgDOTAMatchmakingStatsResponse::mut_matchgroups_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "legacy_searching_players_by_group_source2",
                    CMsgDOTAMatchmakingStatsResponse::get_legacy_searching_players_by_group_source2_for_reflect,
                    CMsgDOTAMatchmakingStatsResponse::mut_legacy_searching_players_by_group_source2_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgMatchmakingMatchGroupInfo>>(
                    "match_groups",
                    CMsgDOTAMatchmakingStatsResponse::get_match_groups_for_reflect,
                    CMsgDOTAMatchmakingStatsResponse::mut_match_groups_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAMatchmakingStatsResponse>(
                    "CMsgDOTAMatchmakingStatsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAMatchmakingStatsResponse {
    fn clear(&mut self) {
        self.clear_matchgroups_version();
        self.clear_legacy_searching_players_by_group_source2();
        self.clear_match_groups();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAMatchmakingStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAMatchmakingStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAUpdateMatchmakingStats {
    // message fields
    stats: ::protobuf::SingularPtrField<CMsgDOTAMatchmakingStatsResponse>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAUpdateMatchmakingStats {}

impl CMsgDOTAUpdateMatchmakingStats {
    pub fn new() -> CMsgDOTAUpdateMatchmakingStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAUpdateMatchmakingStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAUpdateMatchmakingStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAUpdateMatchmakingStats,
        };
        unsafe {
            instance.get(CMsgDOTAUpdateMatchmakingStats::new)
        }
    }

    // optional .CMsgDOTAMatchmakingStatsResponse stats = 1;

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: CMsgDOTAMatchmakingStatsResponse) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut CMsgDOTAMatchmakingStatsResponse {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> CMsgDOTAMatchmakingStatsResponse {
        self.stats.take().unwrap_or_else(|| CMsgDOTAMatchmakingStatsResponse::new())
    }

    pub fn get_stats(&self) -> &CMsgDOTAMatchmakingStatsResponse {
        self.stats.as_ref().unwrap_or_else(|| CMsgDOTAMatchmakingStatsResponse::default_instance())
    }

    fn get_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAMatchmakingStatsResponse> {
        &self.stats
    }

    fn mut_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAMatchmakingStatsResponse> {
        &mut self.stats
    }
}

impl ::protobuf::Message for CMsgDOTAUpdateMatchmakingStats {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAUpdateMatchmakingStats {
    fn new() -> CMsgDOTAUpdateMatchmakingStats {
        CMsgDOTAUpdateMatchmakingStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAUpdateMatchmakingStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAMatchmakingStatsResponse>>(
                    "stats",
                    CMsgDOTAUpdateMatchmakingStats::get_stats_for_reflect,
                    CMsgDOTAUpdateMatchmakingStats::mut_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAUpdateMatchmakingStats>(
                    "CMsgDOTAUpdateMatchmakingStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAUpdateMatchmakingStats {
    fn clear(&mut self) {
        self.clear_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAUpdateMatchmakingStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAUpdateMatchmakingStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAUpdateMatchManagementStats {
    // message fields
    stats: ::protobuf::SingularPtrField<CMsgDOTAMatchmakingStatsResponse>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAUpdateMatchManagementStats {}

impl CMsgDOTAUpdateMatchManagementStats {
    pub fn new() -> CMsgDOTAUpdateMatchManagementStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAUpdateMatchManagementStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAUpdateMatchManagementStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAUpdateMatchManagementStats,
        };
        unsafe {
            instance.get(CMsgDOTAUpdateMatchManagementStats::new)
        }
    }

    // optional .CMsgDOTAMatchmakingStatsResponse stats = 1;

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: CMsgDOTAMatchmakingStatsResponse) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut CMsgDOTAMatchmakingStatsResponse {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> CMsgDOTAMatchmakingStatsResponse {
        self.stats.take().unwrap_or_else(|| CMsgDOTAMatchmakingStatsResponse::new())
    }

    pub fn get_stats(&self) -> &CMsgDOTAMatchmakingStatsResponse {
        self.stats.as_ref().unwrap_or_else(|| CMsgDOTAMatchmakingStatsResponse::default_instance())
    }

    fn get_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAMatchmakingStatsResponse> {
        &self.stats
    }

    fn mut_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAMatchmakingStatsResponse> {
        &mut self.stats
    }
}

impl ::protobuf::Message for CMsgDOTAUpdateMatchManagementStats {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAUpdateMatchManagementStats {
    fn new() -> CMsgDOTAUpdateMatchManagementStats {
        CMsgDOTAUpdateMatchManagementStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAUpdateMatchManagementStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAMatchmakingStatsResponse>>(
                    "stats",
                    CMsgDOTAUpdateMatchManagementStats::get_stats_for_reflect,
                    CMsgDOTAUpdateMatchManagementStats::mut_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAUpdateMatchManagementStats>(
                    "CMsgDOTAUpdateMatchManagementStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAUpdateMatchManagementStats {
    fn clear(&mut self) {
        self.clear_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAUpdateMatchManagementStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAUpdateMatchManagementStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASetMatchHistoryAccess {
    // message fields
    allow_3rd_party_match_history: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASetMatchHistoryAccess {}

impl CMsgDOTASetMatchHistoryAccess {
    pub fn new() -> CMsgDOTASetMatchHistoryAccess {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASetMatchHistoryAccess {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASetMatchHistoryAccess> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASetMatchHistoryAccess,
        };
        unsafe {
            instance.get(CMsgDOTASetMatchHistoryAccess::new)
        }
    }

    // optional bool allow_3rd_party_match_history = 1;

    pub fn clear_allow_3rd_party_match_history(&mut self) {
        self.allow_3rd_party_match_history = ::std::option::Option::None;
    }

    pub fn has_allow_3rd_party_match_history(&self) -> bool {
        self.allow_3rd_party_match_history.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_3rd_party_match_history(&mut self, v: bool) {
        self.allow_3rd_party_match_history = ::std::option::Option::Some(v);
    }

    pub fn get_allow_3rd_party_match_history(&self) -> bool {
        self.allow_3rd_party_match_history.unwrap_or(false)
    }

    fn get_allow_3rd_party_match_history_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.allow_3rd_party_match_history
    }

    fn mut_allow_3rd_party_match_history_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.allow_3rd_party_match_history
    }
}

impl ::protobuf::Message for CMsgDOTASetMatchHistoryAccess {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_3rd_party_match_history = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.allow_3rd_party_match_history {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.allow_3rd_party_match_history {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASetMatchHistoryAccess {
    fn new() -> CMsgDOTASetMatchHistoryAccess {
        CMsgDOTASetMatchHistoryAccess::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASetMatchHistoryAccess>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "allow_3rd_party_match_history",
                    CMsgDOTASetMatchHistoryAccess::get_allow_3rd_party_match_history_for_reflect,
                    CMsgDOTASetMatchHistoryAccess::mut_allow_3rd_party_match_history_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASetMatchHistoryAccess>(
                    "CMsgDOTASetMatchHistoryAccess",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASetMatchHistoryAccess {
    fn clear(&mut self) {
        self.clear_allow_3rd_party_match_history();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASetMatchHistoryAccess {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASetMatchHistoryAccess {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASetMatchHistoryAccessResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASetMatchHistoryAccessResponse {}

impl CMsgDOTASetMatchHistoryAccessResponse {
    pub fn new() -> CMsgDOTASetMatchHistoryAccessResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASetMatchHistoryAccessResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASetMatchHistoryAccessResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASetMatchHistoryAccessResponse,
        };
        unsafe {
            instance.get(CMsgDOTASetMatchHistoryAccessResponse::new)
        }
    }

    // optional uint32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    fn get_eresult_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.eresult
    }

    fn mut_eresult_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.eresult
    }
}

impl ::protobuf::Message for CMsgDOTASetMatchHistoryAccessResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASetMatchHistoryAccessResponse {
    fn new() -> CMsgDOTASetMatchHistoryAccessResponse {
        CMsgDOTASetMatchHistoryAccessResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASetMatchHistoryAccessResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "eresult",
                    CMsgDOTASetMatchHistoryAccessResponse::get_eresult_for_reflect,
                    CMsgDOTASetMatchHistoryAccessResponse::mut_eresult_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASetMatchHistoryAccessResponse>(
                    "CMsgDOTASetMatchHistoryAccessResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASetMatchHistoryAccessResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASetMatchHistoryAccessResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASetMatchHistoryAccessResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTANotifyAccountFlagsChange {
    // message fields
    accountid: ::std::option::Option<u32>,
    account_flags: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTANotifyAccountFlagsChange {}

impl CMsgDOTANotifyAccountFlagsChange {
    pub fn new() -> CMsgDOTANotifyAccountFlagsChange {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTANotifyAccountFlagsChange {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTANotifyAccountFlagsChange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTANotifyAccountFlagsChange,
        };
        unsafe {
            instance.get(CMsgDOTANotifyAccountFlagsChange::new)
        }
    }

    // optional uint32 accountid = 1;

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    fn get_accountid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.accountid
    }

    fn mut_accountid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.accountid
    }

    // optional uint32 account_flags = 2;

    pub fn clear_account_flags(&mut self) {
        self.account_flags = ::std::option::Option::None;
    }

    pub fn has_account_flags(&self) -> bool {
        self.account_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_flags(&mut self, v: u32) {
        self.account_flags = ::std::option::Option::Some(v);
    }

    pub fn get_account_flags(&self) -> u32 {
        self.account_flags.unwrap_or(0)
    }

    fn get_account_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_flags
    }

    fn mut_account_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_flags
    }
}

impl ::protobuf::Message for CMsgDOTANotifyAccountFlagsChange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_flags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_flags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTANotifyAccountFlagsChange {
    fn new() -> CMsgDOTANotifyAccountFlagsChange {
        CMsgDOTANotifyAccountFlagsChange::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTANotifyAccountFlagsChange>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    CMsgDOTANotifyAccountFlagsChange::get_accountid_for_reflect,
                    CMsgDOTANotifyAccountFlagsChange::mut_accountid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_flags",
                    CMsgDOTANotifyAccountFlagsChange::get_account_flags_for_reflect,
                    CMsgDOTANotifyAccountFlagsChange::mut_account_flags_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTANotifyAccountFlagsChange>(
                    "CMsgDOTANotifyAccountFlagsChange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTANotifyAccountFlagsChange {
    fn clear(&mut self) {
        self.clear_accountid();
        self.clear_account_flags();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTANotifyAccountFlagsChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTANotifyAccountFlagsChange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASetProfilePrivacy {
    // message fields
    profile_private: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASetProfilePrivacy {}

impl CMsgDOTASetProfilePrivacy {
    pub fn new() -> CMsgDOTASetProfilePrivacy {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASetProfilePrivacy {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASetProfilePrivacy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASetProfilePrivacy,
        };
        unsafe {
            instance.get(CMsgDOTASetProfilePrivacy::new)
        }
    }

    // optional bool profile_private = 1;

    pub fn clear_profile_private(&mut self) {
        self.profile_private = ::std::option::Option::None;
    }

    pub fn has_profile_private(&self) -> bool {
        self.profile_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile_private(&mut self, v: bool) {
        self.profile_private = ::std::option::Option::Some(v);
    }

    pub fn get_profile_private(&self) -> bool {
        self.profile_private.unwrap_or(false)
    }

    fn get_profile_private_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.profile_private
    }

    fn mut_profile_private_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.profile_private
    }
}

impl ::protobuf::Message for CMsgDOTASetProfilePrivacy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.profile_private = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.profile_private {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.profile_private {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASetProfilePrivacy {
    fn new() -> CMsgDOTASetProfilePrivacy {
        CMsgDOTASetProfilePrivacy::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASetProfilePrivacy>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "profile_private",
                    CMsgDOTASetProfilePrivacy::get_profile_private_for_reflect,
                    CMsgDOTASetProfilePrivacy::mut_profile_private_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASetProfilePrivacy>(
                    "CMsgDOTASetProfilePrivacy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASetProfilePrivacy {
    fn clear(&mut self) {
        self.clear_profile_private();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASetProfilePrivacy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASetProfilePrivacy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASetProfilePrivacyResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASetProfilePrivacyResponse {}

impl CMsgDOTASetProfilePrivacyResponse {
    pub fn new() -> CMsgDOTASetProfilePrivacyResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASetProfilePrivacyResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASetProfilePrivacyResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASetProfilePrivacyResponse,
        };
        unsafe {
            instance.get(CMsgDOTASetProfilePrivacyResponse::new)
        }
    }

    // optional uint32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    fn get_eresult_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.eresult
    }

    fn mut_eresult_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.eresult
    }
}

impl ::protobuf::Message for CMsgDOTASetProfilePrivacyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASetProfilePrivacyResponse {
    fn new() -> CMsgDOTASetProfilePrivacyResponse {
        CMsgDOTASetProfilePrivacyResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASetProfilePrivacyResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "eresult",
                    CMsgDOTASetProfilePrivacyResponse::get_eresult_for_reflect,
                    CMsgDOTASetProfilePrivacyResponse::mut_eresult_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASetProfilePrivacyResponse>(
                    "CMsgDOTASetProfilePrivacyResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASetProfilePrivacyResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASetProfilePrivacyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASetProfilePrivacyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgUpgradeLeagueItem {
    // message fields
    match_id: ::std::option::Option<u64>,
    league_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgUpgradeLeagueItem {}

impl CMsgUpgradeLeagueItem {
    pub fn new() -> CMsgUpgradeLeagueItem {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgUpgradeLeagueItem {
        static mut instance: ::protobuf::lazy::Lazy<CMsgUpgradeLeagueItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgUpgradeLeagueItem,
        };
        unsafe {
            instance.get(CMsgUpgradeLeagueItem::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 league_id = 2;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }
}

impl ::protobuf::Message for CMsgUpgradeLeagueItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgUpgradeLeagueItem {
    fn new() -> CMsgUpgradeLeagueItem {
        CMsgUpgradeLeagueItem::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgUpgradeLeagueItem>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgUpgradeLeagueItem::get_match_id_for_reflect,
                    CMsgUpgradeLeagueItem::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgUpgradeLeagueItem::get_league_id_for_reflect,
                    CMsgUpgradeLeagueItem::mut_league_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgUpgradeLeagueItem>(
                    "CMsgUpgradeLeagueItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgUpgradeLeagueItem {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_league_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgUpgradeLeagueItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUpgradeLeagueItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgUpgradeLeagueItemResponse {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgUpgradeLeagueItemResponse {}

impl CMsgUpgradeLeagueItemResponse {
    pub fn new() -> CMsgUpgradeLeagueItemResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgUpgradeLeagueItemResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgUpgradeLeagueItemResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgUpgradeLeagueItemResponse,
        };
        unsafe {
            instance.get(CMsgUpgradeLeagueItemResponse::new)
        }
    }
}

impl ::protobuf::Message for CMsgUpgradeLeagueItemResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgUpgradeLeagueItemResponse {
    fn new() -> CMsgUpgradeLeagueItemResponse {
        CMsgUpgradeLeagueItemResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgUpgradeLeagueItemResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgUpgradeLeagueItemResponse>(
                    "CMsgUpgradeLeagueItemResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgUpgradeLeagueItemResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgUpgradeLeagueItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUpgradeLeagueItemResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCWatchDownloadedReplay {
    // message fields
    match_id: ::std::option::Option<u64>,
    watch_type: ::std::option::Option<DOTA_WatchReplayType>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCWatchDownloadedReplay {}

impl CMsgGCWatchDownloadedReplay {
    pub fn new() -> CMsgGCWatchDownloadedReplay {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCWatchDownloadedReplay {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCWatchDownloadedReplay> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCWatchDownloadedReplay,
        };
        unsafe {
            instance.get(CMsgGCWatchDownloadedReplay::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional .DOTA_WatchReplayType watch_type = 2;

    pub fn clear_watch_type(&mut self) {
        self.watch_type = ::std::option::Option::None;
    }

    pub fn has_watch_type(&self) -> bool {
        self.watch_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watch_type(&mut self, v: DOTA_WatchReplayType) {
        self.watch_type = ::std::option::Option::Some(v);
    }

    pub fn get_watch_type(&self) -> DOTA_WatchReplayType {
        self.watch_type.unwrap_or(DOTA_WatchReplayType::DOTA_WATCH_REPLAY_NORMAL)
    }

    fn get_watch_type_for_reflect(&self) -> &::std::option::Option<DOTA_WatchReplayType> {
        &self.watch_type
    }

    fn mut_watch_type_for_reflect(&mut self) -> &mut ::std::option::Option<DOTA_WatchReplayType> {
        &mut self.watch_type
    }
}

impl ::protobuf::Message for CMsgGCWatchDownloadedReplay {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.watch_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.watch_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.watch_type {
            os.write_enum(2, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCWatchDownloadedReplay {
    fn new() -> CMsgGCWatchDownloadedReplay {
        CMsgGCWatchDownloadedReplay::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCWatchDownloadedReplay>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgGCWatchDownloadedReplay::get_match_id_for_reflect,
                    CMsgGCWatchDownloadedReplay::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DOTA_WatchReplayType>>(
                    "watch_type",
                    CMsgGCWatchDownloadedReplay::get_watch_type_for_reflect,
                    CMsgGCWatchDownloadedReplay::mut_watch_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCWatchDownloadedReplay>(
                    "CMsgGCWatchDownloadedReplay",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCWatchDownloadedReplay {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_watch_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCWatchDownloadedReplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCWatchDownloadedReplay {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSetMapLocationState {
    // message fields
    location_id: ::std::option::Option<i32>,
    completed: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSetMapLocationState {}

impl CMsgSetMapLocationState {
    pub fn new() -> CMsgSetMapLocationState {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSetMapLocationState {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetMapLocationState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetMapLocationState,
        };
        unsafe {
            instance.get(CMsgSetMapLocationState::new)
        }
    }

    // optional int32 location_id = 1;

    pub fn clear_location_id(&mut self) {
        self.location_id = ::std::option::Option::None;
    }

    pub fn has_location_id(&self) -> bool {
        self.location_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location_id(&mut self, v: i32) {
        self.location_id = ::std::option::Option::Some(v);
    }

    pub fn get_location_id(&self) -> i32 {
        self.location_id.unwrap_or(0)
    }

    fn get_location_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.location_id
    }

    fn mut_location_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.location_id
    }

    // optional bool completed = 2;

    pub fn clear_completed(&mut self) {
        self.completed = ::std::option::Option::None;
    }

    pub fn has_completed(&self) -> bool {
        self.completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed(&mut self, v: bool) {
        self.completed = ::std::option::Option::Some(v);
    }

    pub fn get_completed(&self) -> bool {
        self.completed.unwrap_or(false)
    }

    fn get_completed_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.completed
    }

    fn mut_completed_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.completed
    }
}

impl ::protobuf::Message for CMsgSetMapLocationState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.location_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.completed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.location_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.completed {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.location_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.completed {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSetMapLocationState {
    fn new() -> CMsgSetMapLocationState {
        CMsgSetMapLocationState::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSetMapLocationState>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "location_id",
                    CMsgSetMapLocationState::get_location_id_for_reflect,
                    CMsgSetMapLocationState::mut_location_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "completed",
                    CMsgSetMapLocationState::get_completed_for_reflect,
                    CMsgSetMapLocationState::mut_completed_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetMapLocationState>(
                    "CMsgSetMapLocationState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSetMapLocationState {
    fn clear(&mut self) {
        self.clear_location_id();
        self.clear_completed();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetMapLocationState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetMapLocationState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSetMapLocationStateResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSetMapLocationStateResponse {}

impl CMsgSetMapLocationStateResponse {
    pub fn new() -> CMsgSetMapLocationStateResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSetMapLocationStateResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSetMapLocationStateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSetMapLocationStateResponse,
        };
        unsafe {
            instance.get(CMsgSetMapLocationStateResponse::new)
        }
    }

    // optional uint32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    fn get_eresult_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.eresult
    }

    fn mut_eresult_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.eresult
    }
}

impl ::protobuf::Message for CMsgSetMapLocationStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSetMapLocationStateResponse {
    fn new() -> CMsgSetMapLocationStateResponse {
        CMsgSetMapLocationStateResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSetMapLocationStateResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "eresult",
                    CMsgSetMapLocationStateResponse::get_eresult_for_reflect,
                    CMsgSetMapLocationStateResponse::mut_eresult_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSetMapLocationStateResponse>(
                    "CMsgSetMapLocationStateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSetMapLocationStateResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetMapLocationStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetMapLocationStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgResetMapLocations {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgResetMapLocations {}

impl CMsgResetMapLocations {
    pub fn new() -> CMsgResetMapLocations {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgResetMapLocations {
        static mut instance: ::protobuf::lazy::Lazy<CMsgResetMapLocations> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgResetMapLocations,
        };
        unsafe {
            instance.get(CMsgResetMapLocations::new)
        }
    }
}

impl ::protobuf::Message for CMsgResetMapLocations {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgResetMapLocations {
    fn new() -> CMsgResetMapLocations {
        CMsgResetMapLocations::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgResetMapLocations>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgResetMapLocations>(
                    "CMsgResetMapLocations",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgResetMapLocations {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgResetMapLocations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgResetMapLocations {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgResetMapLocationsResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgResetMapLocationsResponse {}

impl CMsgResetMapLocationsResponse {
    pub fn new() -> CMsgResetMapLocationsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgResetMapLocationsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgResetMapLocationsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgResetMapLocationsResponse,
        };
        unsafe {
            instance.get(CMsgResetMapLocationsResponse::new)
        }
    }

    // optional uint32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    fn get_eresult_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.eresult
    }

    fn mut_eresult_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.eresult
    }
}

impl ::protobuf::Message for CMsgResetMapLocationsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgResetMapLocationsResponse {
    fn new() -> CMsgResetMapLocationsResponse {
        CMsgResetMapLocationsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgResetMapLocationsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "eresult",
                    CMsgResetMapLocationsResponse::get_eresult_for_reflect,
                    CMsgResetMapLocationsResponse::mut_eresult_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgResetMapLocationsResponse>(
                    "CMsgResetMapLocationsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgResetMapLocationsResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgResetMapLocationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgResetMapLocationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRefreshPartnerAccountLink {
    // message fields
    partner_type: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgRefreshPartnerAccountLink {}

impl CMsgRefreshPartnerAccountLink {
    pub fn new() -> CMsgRefreshPartnerAccountLink {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgRefreshPartnerAccountLink {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRefreshPartnerAccountLink> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRefreshPartnerAccountLink,
        };
        unsafe {
            instance.get(CMsgRefreshPartnerAccountLink::new)
        }
    }

    // optional int32 partner_type = 1;

    pub fn clear_partner_type(&mut self) {
        self.partner_type = ::std::option::Option::None;
    }

    pub fn has_partner_type(&self) -> bool {
        self.partner_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner_type(&mut self, v: i32) {
        self.partner_type = ::std::option::Option::Some(v);
    }

    pub fn get_partner_type(&self) -> i32 {
        self.partner_type.unwrap_or(0)
    }

    fn get_partner_type_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.partner_type
    }

    fn mut_partner_type_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.partner_type
    }
}

impl ::protobuf::Message for CMsgRefreshPartnerAccountLink {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.partner_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.partner_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.partner_type {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgRefreshPartnerAccountLink {
    fn new() -> CMsgRefreshPartnerAccountLink {
        CMsgRefreshPartnerAccountLink::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgRefreshPartnerAccountLink>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "partner_type",
                    CMsgRefreshPartnerAccountLink::get_partner_type_for_reflect,
                    CMsgRefreshPartnerAccountLink::mut_partner_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRefreshPartnerAccountLink>(
                    "CMsgRefreshPartnerAccountLink",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgRefreshPartnerAccountLink {
    fn clear(&mut self) {
        self.clear_partner_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRefreshPartnerAccountLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRefreshPartnerAccountLink {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientsRejoinChatChannels {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientsRejoinChatChannels {}

impl CMsgClientsRejoinChatChannels {
    pub fn new() -> CMsgClientsRejoinChatChannels {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientsRejoinChatChannels {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientsRejoinChatChannels> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientsRejoinChatChannels,
        };
        unsafe {
            instance.get(CMsgClientsRejoinChatChannels::new)
        }
    }
}

impl ::protobuf::Message for CMsgClientsRejoinChatChannels {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientsRejoinChatChannels {
    fn new() -> CMsgClientsRejoinChatChannels {
        CMsgClientsRejoinChatChannels::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientsRejoinChatChannels>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientsRejoinChatChannels>(
                    "CMsgClientsRejoinChatChannels",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientsRejoinChatChannels {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientsRejoinChatChannels {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientsRejoinChatChannels {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASendFriendRecruits {
    // message fields
    recruits: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASendFriendRecruits {}

impl CMsgDOTASendFriendRecruits {
    pub fn new() -> CMsgDOTASendFriendRecruits {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASendFriendRecruits {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASendFriendRecruits> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASendFriendRecruits,
        };
        unsafe {
            instance.get(CMsgDOTASendFriendRecruits::new)
        }
    }

    // repeated uint32 recruits = 1;

    pub fn clear_recruits(&mut self) {
        self.recruits.clear();
    }

    // Param is passed by value, moved
    pub fn set_recruits(&mut self, v: ::std::vec::Vec<u32>) {
        self.recruits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recruits(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.recruits
    }

    // Take field
    pub fn take_recruits(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.recruits, ::std::vec::Vec::new())
    }

    pub fn get_recruits(&self) -> &[u32] {
        &self.recruits
    }

    fn get_recruits_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.recruits
    }

    fn mut_recruits_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.recruits
    }
}

impl ::protobuf::Message for CMsgDOTASendFriendRecruits {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.recruits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.recruits {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.recruits {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASendFriendRecruits {
    fn new() -> CMsgDOTASendFriendRecruits {
        CMsgDOTASendFriendRecruits::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASendFriendRecruits>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "recruits",
                    CMsgDOTASendFriendRecruits::get_recruits_for_reflect,
                    CMsgDOTASendFriendRecruits::mut_recruits_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASendFriendRecruits>(
                    "CMsgDOTASendFriendRecruits",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASendFriendRecruits {
    fn clear(&mut self) {
        self.clear_recruits();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASendFriendRecruits {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASendFriendRecruits {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFriendRecruitsRequest {
    // message fields
    account_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFriendRecruitsRequest {}

impl CMsgDOTAFriendRecruitsRequest {
    pub fn new() -> CMsgDOTAFriendRecruitsRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFriendRecruitsRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFriendRecruitsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFriendRecruitsRequest,
        };
        unsafe {
            instance.get(CMsgDOTAFriendRecruitsRequest::new)
        }
    }

    // repeated uint32 account_ids = 1;

    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }

    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }

    fn get_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.account_ids
    }

    fn mut_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }
}

impl ::protobuf::Message for CMsgDOTAFriendRecruitsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFriendRecruitsRequest {
    fn new() -> CMsgDOTAFriendRecruitsRequest {
        CMsgDOTAFriendRecruitsRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFriendRecruitsRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids",
                    CMsgDOTAFriendRecruitsRequest::get_account_ids_for_reflect,
                    CMsgDOTAFriendRecruitsRequest::mut_account_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFriendRecruitsRequest>(
                    "CMsgDOTAFriendRecruitsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFriendRecruitsRequest {
    fn clear(&mut self) {
        self.clear_account_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFriendRecruitsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFriendRecruitsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFriendRecruitsResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAFriendRecruitsResponse_EResult>,
    recruits: ::protobuf::RepeatedField<CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus>,
    recruiters: ::protobuf::RepeatedField<CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFriendRecruitsResponse {}

impl CMsgDOTAFriendRecruitsResponse {
    pub fn new() -> CMsgDOTAFriendRecruitsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFriendRecruitsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFriendRecruitsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFriendRecruitsResponse,
        };
        unsafe {
            instance.get(CMsgDOTAFriendRecruitsResponse::new)
        }
    }

    // optional .CMsgDOTAFriendRecruitsResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAFriendRecruitsResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAFriendRecruitsResponse_EResult {
        self.result.unwrap_or(CMsgDOTAFriendRecruitsResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAFriendRecruitsResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAFriendRecruitsResponse_EResult> {
        &mut self.result
    }

    // repeated .CMsgDOTAFriendRecruitsResponse.FriendRecruitStatus recruits = 2;

    pub fn clear_recruits(&mut self) {
        self.recruits.clear();
    }

    // Param is passed by value, moved
    pub fn set_recruits(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus>) {
        self.recruits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recruits(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus> {
        &mut self.recruits
    }

    // Take field
    pub fn take_recruits(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus> {
        ::std::mem::replace(&mut self.recruits, ::protobuf::RepeatedField::new())
    }

    pub fn get_recruits(&self) -> &[CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus] {
        &self.recruits
    }

    fn get_recruits_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus> {
        &self.recruits
    }

    fn mut_recruits_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus> {
        &mut self.recruits
    }

    // repeated .CMsgDOTAFriendRecruitsResponse.FriendRecruitStatus recruiters = 3;

    pub fn clear_recruiters(&mut self) {
        self.recruiters.clear();
    }

    // Param is passed by value, moved
    pub fn set_recruiters(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus>) {
        self.recruiters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recruiters(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus> {
        &mut self.recruiters
    }

    // Take field
    pub fn take_recruiters(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus> {
        ::std::mem::replace(&mut self.recruiters, ::protobuf::RepeatedField::new())
    }

    pub fn get_recruiters(&self) -> &[CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus] {
        &self.recruiters
    }

    fn get_recruiters_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus> {
        &self.recruiters
    }

    fn mut_recruiters_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus> {
        &mut self.recruiters
    }
}

impl ::protobuf::Message for CMsgDOTAFriendRecruitsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.recruits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.recruiters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.recruits)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.recruiters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.recruits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.recruiters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        for v in &self.recruits {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.recruiters {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFriendRecruitsResponse {
    fn new() -> CMsgDOTAFriendRecruitsResponse {
        CMsgDOTAFriendRecruitsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFriendRecruitsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAFriendRecruitsResponse_EResult>>(
                    "result",
                    CMsgDOTAFriendRecruitsResponse::get_result_for_reflect,
                    CMsgDOTAFriendRecruitsResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus>>(
                    "recruits",
                    CMsgDOTAFriendRecruitsResponse::get_recruits_for_reflect,
                    CMsgDOTAFriendRecruitsResponse::mut_recruits_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus>>(
                    "recruiters",
                    CMsgDOTAFriendRecruitsResponse::get_recruiters_for_reflect,
                    CMsgDOTAFriendRecruitsResponse::mut_recruiters_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFriendRecruitsResponse>(
                    "CMsgDOTAFriendRecruitsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFriendRecruitsResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_recruits();
        self.clear_recruiters();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFriendRecruitsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFriendRecruitsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus {
    // message fields
    account_id: ::std::option::Option<u32>,
    status: ::std::option::Option<u32>,
    levels_earned: ::std::option::Option<u32>,
    bonus: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus {}

impl CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus {
    pub fn new() -> CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus,
        };
        unsafe {
            instance.get(CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 status = 2;

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u32) {
        self.status = ::std::option::Option::Some(v);
    }

    pub fn get_status(&self) -> u32 {
        self.status.unwrap_or(0)
    }

    fn get_status_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.status
    }

    // optional uint32 levels_earned = 3;

    pub fn clear_levels_earned(&mut self) {
        self.levels_earned = ::std::option::Option::None;
    }

    pub fn has_levels_earned(&self) -> bool {
        self.levels_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_levels_earned(&mut self, v: u32) {
        self.levels_earned = ::std::option::Option::Some(v);
    }

    pub fn get_levels_earned(&self) -> u32 {
        self.levels_earned.unwrap_or(0)
    }

    fn get_levels_earned_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.levels_earned
    }

    fn mut_levels_earned_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.levels_earned
    }

    // optional bool bonus = 4;

    pub fn clear_bonus(&mut self) {
        self.bonus = ::std::option::Option::None;
    }

    pub fn has_bonus(&self) -> bool {
        self.bonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus(&mut self, v: bool) {
        self.bonus = ::std::option::Option::Some(v);
    }

    pub fn get_bonus(&self) -> bool {
        self.bonus.unwrap_or(false)
    }

    fn get_bonus_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.bonus
    }

    fn mut_bonus_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.bonus
    }
}

impl ::protobuf::Message for CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.levels_earned = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bonus = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.levels_earned {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bonus {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.status {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.levels_earned {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.bonus {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus {
    fn new() -> CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus {
        CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus::get_account_id_for_reflect,
                    CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "status",
                    CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus::get_status_for_reflect,
                    CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus::mut_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "levels_earned",
                    CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus::get_levels_earned_for_reflect,
                    CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus::mut_levels_earned_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bonus",
                    CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus::get_bonus_for_reflect,
                    CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus::mut_bonus_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus>(
                    "CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_status();
        self.clear_levels_earned();
        self.clear_bonus();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFriendRecruitsResponse_FriendRecruitStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAFriendRecruitsResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAFriendRecruitsResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAFriendRecruitsResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAFriendRecruitsResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAFriendRecruitsResponse_EResult::ERROR_UNSPECIFIED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAFriendRecruitsResponse_EResult] = &[
            CMsgDOTAFriendRecruitsResponse_EResult::SUCCESS,
            CMsgDOTAFriendRecruitsResponse_EResult::ERROR_UNSPECIFIED,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAFriendRecruitsResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAFriendRecruitsResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAFriendRecruitsResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFriendRecruitsResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAFriendRecruitInviteAcceptDecline {
    // message fields
    accepted: ::std::option::Option<bool>,
    account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAFriendRecruitInviteAcceptDecline {}

impl CMsgDOTAFriendRecruitInviteAcceptDecline {
    pub fn new() -> CMsgDOTAFriendRecruitInviteAcceptDecline {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAFriendRecruitInviteAcceptDecline {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAFriendRecruitInviteAcceptDecline> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAFriendRecruitInviteAcceptDecline,
        };
        unsafe {
            instance.get(CMsgDOTAFriendRecruitInviteAcceptDecline::new)
        }
    }

    // optional bool accepted = 1;

    pub fn clear_accepted(&mut self) {
        self.accepted = ::std::option::Option::None;
    }

    pub fn has_accepted(&self) -> bool {
        self.accepted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accepted(&mut self, v: bool) {
        self.accepted = ::std::option::Option::Some(v);
    }

    pub fn get_accepted(&self) -> bool {
        self.accepted.unwrap_or(false)
    }

    fn get_accepted_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.accepted
    }

    fn mut_accepted_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.accepted
    }

    // optional uint32 account_id = 2;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgDOTAFriendRecruitInviteAcceptDecline {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.accepted = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accepted {
            my_size += 2;
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accepted {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAFriendRecruitInviteAcceptDecline {
    fn new() -> CMsgDOTAFriendRecruitInviteAcceptDecline {
        CMsgDOTAFriendRecruitInviteAcceptDecline::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAFriendRecruitInviteAcceptDecline>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "accepted",
                    CMsgDOTAFriendRecruitInviteAcceptDecline::get_accepted_for_reflect,
                    CMsgDOTAFriendRecruitInviteAcceptDecline::mut_accepted_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAFriendRecruitInviteAcceptDecline::get_account_id_for_reflect,
                    CMsgDOTAFriendRecruitInviteAcceptDecline::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAFriendRecruitInviteAcceptDecline>(
                    "CMsgDOTAFriendRecruitInviteAcceptDecline",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAFriendRecruitInviteAcceptDecline {
    fn clear(&mut self) {
        self.clear_accepted();
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAFriendRecruitInviteAcceptDecline {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAFriendRecruitInviteAcceptDecline {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestLeaguePrizePool {
    // message fields
    league_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgRequestLeaguePrizePool {}

impl CMsgRequestLeaguePrizePool {
    pub fn new() -> CMsgRequestLeaguePrizePool {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgRequestLeaguePrizePool {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRequestLeaguePrizePool> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRequestLeaguePrizePool,
        };
        unsafe {
            instance.get(CMsgRequestLeaguePrizePool::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }
}

impl ::protobuf::Message for CMsgRequestLeaguePrizePool {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgRequestLeaguePrizePool {
    fn new() -> CMsgRequestLeaguePrizePool {
        CMsgRequestLeaguePrizePool::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgRequestLeaguePrizePool>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgRequestLeaguePrizePool::get_league_id_for_reflect,
                    CMsgRequestLeaguePrizePool::mut_league_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRequestLeaguePrizePool>(
                    "CMsgRequestLeaguePrizePool",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgRequestLeaguePrizePool {
    fn clear(&mut self) {
        self.clear_league_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestLeaguePrizePool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestLeaguePrizePool {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestLeaguePrizePoolResponse {
    // message fields
    league_id: ::std::option::Option<u32>,
    prize_pool: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgRequestLeaguePrizePoolResponse {}

impl CMsgRequestLeaguePrizePoolResponse {
    pub fn new() -> CMsgRequestLeaguePrizePoolResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgRequestLeaguePrizePoolResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRequestLeaguePrizePoolResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRequestLeaguePrizePoolResponse,
        };
        unsafe {
            instance.get(CMsgRequestLeaguePrizePoolResponse::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional uint32 prize_pool = 2;

    pub fn clear_prize_pool(&mut self) {
        self.prize_pool = ::std::option::Option::None;
    }

    pub fn has_prize_pool(&self) -> bool {
        self.prize_pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prize_pool(&mut self, v: u32) {
        self.prize_pool = ::std::option::Option::Some(v);
    }

    pub fn get_prize_pool(&self) -> u32 {
        self.prize_pool.unwrap_or(0)
    }

    fn get_prize_pool_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prize_pool
    }

    fn mut_prize_pool_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prize_pool
    }
}

impl ::protobuf::Message for CMsgRequestLeaguePrizePoolResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prize_pool = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prize_pool {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.prize_pool {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgRequestLeaguePrizePoolResponse {
    fn new() -> CMsgRequestLeaguePrizePoolResponse {
        CMsgRequestLeaguePrizePoolResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgRequestLeaguePrizePoolResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgRequestLeaguePrizePoolResponse::get_league_id_for_reflect,
                    CMsgRequestLeaguePrizePoolResponse::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prize_pool",
                    CMsgRequestLeaguePrizePoolResponse::get_prize_pool_for_reflect,
                    CMsgRequestLeaguePrizePoolResponse::mut_prize_pool_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRequestLeaguePrizePoolResponse>(
                    "CMsgRequestLeaguePrizePoolResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgRequestLeaguePrizePoolResponse {
    fn clear(&mut self) {
        self.clear_league_id();
        self.clear_prize_pool();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestLeaguePrizePoolResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestLeaguePrizePoolResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCGetHeroStandings {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCGetHeroStandings {}

impl CMsgGCGetHeroStandings {
    pub fn new() -> CMsgGCGetHeroStandings {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCGetHeroStandings {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCGetHeroStandings> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCGetHeroStandings,
        };
        unsafe {
            instance.get(CMsgGCGetHeroStandings::new)
        }
    }
}

impl ::protobuf::Message for CMsgGCGetHeroStandings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCGetHeroStandings {
    fn new() -> CMsgGCGetHeroStandings {
        CMsgGCGetHeroStandings::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCGetHeroStandings>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCGetHeroStandings>(
                    "CMsgGCGetHeroStandings",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCGetHeroStandings {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCGetHeroStandings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCGetHeroStandings {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCGetHeroStandingsResponse {
    // message fields
    standings: ::protobuf::RepeatedField<CMsgGCGetHeroStandingsResponse_Hero>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCGetHeroStandingsResponse {}

impl CMsgGCGetHeroStandingsResponse {
    pub fn new() -> CMsgGCGetHeroStandingsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCGetHeroStandingsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCGetHeroStandingsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCGetHeroStandingsResponse,
        };
        unsafe {
            instance.get(CMsgGCGetHeroStandingsResponse::new)
        }
    }

    // repeated .CMsgGCGetHeroStandingsResponse.Hero standings = 1;

    pub fn clear_standings(&mut self) {
        self.standings.clear();
    }

    // Param is passed by value, moved
    pub fn set_standings(&mut self, v: ::protobuf::RepeatedField<CMsgGCGetHeroStandingsResponse_Hero>) {
        self.standings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_standings(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCGetHeroStandingsResponse_Hero> {
        &mut self.standings
    }

    // Take field
    pub fn take_standings(&mut self) -> ::protobuf::RepeatedField<CMsgGCGetHeroStandingsResponse_Hero> {
        ::std::mem::replace(&mut self.standings, ::protobuf::RepeatedField::new())
    }

    pub fn get_standings(&self) -> &[CMsgGCGetHeroStandingsResponse_Hero] {
        &self.standings
    }

    fn get_standings_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCGetHeroStandingsResponse_Hero> {
        &self.standings
    }

    fn mut_standings_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCGetHeroStandingsResponse_Hero> {
        &mut self.standings
    }
}

impl ::protobuf::Message for CMsgGCGetHeroStandingsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.standings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.standings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.standings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.standings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCGetHeroStandingsResponse {
    fn new() -> CMsgGCGetHeroStandingsResponse {
        CMsgGCGetHeroStandingsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCGetHeroStandingsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCGetHeroStandingsResponse_Hero>>(
                    "standings",
                    CMsgGCGetHeroStandingsResponse::get_standings_for_reflect,
                    CMsgGCGetHeroStandingsResponse::mut_standings_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCGetHeroStandingsResponse>(
                    "CMsgGCGetHeroStandingsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCGetHeroStandingsResponse {
    fn clear(&mut self) {
        self.clear_standings();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCGetHeroStandingsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCGetHeroStandingsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCGetHeroStandingsResponse_Hero {
    // message fields
    hero_id: ::std::option::Option<u32>,
    wins: ::std::option::Option<u32>,
    losses: ::std::option::Option<u32>,
    win_streak: ::std::option::Option<u32>,
    best_win_streak: ::std::option::Option<u32>,
    avg_kills: ::std::option::Option<f32>,
    avg_deaths: ::std::option::Option<f32>,
    avg_assists: ::std::option::Option<f32>,
    avg_gpm: ::std::option::Option<f32>,
    avg_xpm: ::std::option::Option<f32>,
    best_kills: ::std::option::Option<u32>,
    best_assists: ::std::option::Option<u32>,
    best_gpm: ::std::option::Option<u32>,
    best_xpm: ::std::option::Option<u32>,
    performance: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCGetHeroStandingsResponse_Hero {}

impl CMsgGCGetHeroStandingsResponse_Hero {
    pub fn new() -> CMsgGCGetHeroStandingsResponse_Hero {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCGetHeroStandingsResponse_Hero {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCGetHeroStandingsResponse_Hero> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCGetHeroStandingsResponse_Hero,
        };
        unsafe {
            instance.get(CMsgGCGetHeroStandingsResponse_Hero::new)
        }
    }

    // optional uint32 hero_id = 1;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 wins = 2;

    pub fn clear_wins(&mut self) {
        self.wins = ::std::option::Option::None;
    }

    pub fn has_wins(&self) -> bool {
        self.wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: u32) {
        self.wins = ::std::option::Option::Some(v);
    }

    pub fn get_wins(&self) -> u32 {
        self.wins.unwrap_or(0)
    }

    fn get_wins_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.wins
    }

    fn mut_wins_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.wins
    }

    // optional uint32 losses = 3;

    pub fn clear_losses(&mut self) {
        self.losses = ::std::option::Option::None;
    }

    pub fn has_losses(&self) -> bool {
        self.losses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_losses(&mut self, v: u32) {
        self.losses = ::std::option::Option::Some(v);
    }

    pub fn get_losses(&self) -> u32 {
        self.losses.unwrap_or(0)
    }

    fn get_losses_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.losses
    }

    fn mut_losses_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.losses
    }

    // optional uint32 win_streak = 4;

    pub fn clear_win_streak(&mut self) {
        self.win_streak = ::std::option::Option::None;
    }

    pub fn has_win_streak(&self) -> bool {
        self.win_streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win_streak(&mut self, v: u32) {
        self.win_streak = ::std::option::Option::Some(v);
    }

    pub fn get_win_streak(&self) -> u32 {
        self.win_streak.unwrap_or(0)
    }

    fn get_win_streak_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.win_streak
    }

    fn mut_win_streak_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.win_streak
    }

    // optional uint32 best_win_streak = 5;

    pub fn clear_best_win_streak(&mut self) {
        self.best_win_streak = ::std::option::Option::None;
    }

    pub fn has_best_win_streak(&self) -> bool {
        self.best_win_streak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_win_streak(&mut self, v: u32) {
        self.best_win_streak = ::std::option::Option::Some(v);
    }

    pub fn get_best_win_streak(&self) -> u32 {
        self.best_win_streak.unwrap_or(0)
    }

    fn get_best_win_streak_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.best_win_streak
    }

    fn mut_best_win_streak_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.best_win_streak
    }

    // optional float avg_kills = 6;

    pub fn clear_avg_kills(&mut self) {
        self.avg_kills = ::std::option::Option::None;
    }

    pub fn has_avg_kills(&self) -> bool {
        self.avg_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_kills(&mut self, v: f32) {
        self.avg_kills = ::std::option::Option::Some(v);
    }

    pub fn get_avg_kills(&self) -> f32 {
        self.avg_kills.unwrap_or(0.)
    }

    fn get_avg_kills_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.avg_kills
    }

    fn mut_avg_kills_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.avg_kills
    }

    // optional float avg_deaths = 7;

    pub fn clear_avg_deaths(&mut self) {
        self.avg_deaths = ::std::option::Option::None;
    }

    pub fn has_avg_deaths(&self) -> bool {
        self.avg_deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_deaths(&mut self, v: f32) {
        self.avg_deaths = ::std::option::Option::Some(v);
    }

    pub fn get_avg_deaths(&self) -> f32 {
        self.avg_deaths.unwrap_or(0.)
    }

    fn get_avg_deaths_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.avg_deaths
    }

    fn mut_avg_deaths_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.avg_deaths
    }

    // optional float avg_assists = 8;

    pub fn clear_avg_assists(&mut self) {
        self.avg_assists = ::std::option::Option::None;
    }

    pub fn has_avg_assists(&self) -> bool {
        self.avg_assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_assists(&mut self, v: f32) {
        self.avg_assists = ::std::option::Option::Some(v);
    }

    pub fn get_avg_assists(&self) -> f32 {
        self.avg_assists.unwrap_or(0.)
    }

    fn get_avg_assists_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.avg_assists
    }

    fn mut_avg_assists_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.avg_assists
    }

    // optional float avg_gpm = 9;

    pub fn clear_avg_gpm(&mut self) {
        self.avg_gpm = ::std::option::Option::None;
    }

    pub fn has_avg_gpm(&self) -> bool {
        self.avg_gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_gpm(&mut self, v: f32) {
        self.avg_gpm = ::std::option::Option::Some(v);
    }

    pub fn get_avg_gpm(&self) -> f32 {
        self.avg_gpm.unwrap_or(0.)
    }

    fn get_avg_gpm_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.avg_gpm
    }

    fn mut_avg_gpm_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.avg_gpm
    }

    // optional float avg_xpm = 10;

    pub fn clear_avg_xpm(&mut self) {
        self.avg_xpm = ::std::option::Option::None;
    }

    pub fn has_avg_xpm(&self) -> bool {
        self.avg_xpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_xpm(&mut self, v: f32) {
        self.avg_xpm = ::std::option::Option::Some(v);
    }

    pub fn get_avg_xpm(&self) -> f32 {
        self.avg_xpm.unwrap_or(0.)
    }

    fn get_avg_xpm_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.avg_xpm
    }

    fn mut_avg_xpm_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.avg_xpm
    }

    // optional uint32 best_kills = 11;

    pub fn clear_best_kills(&mut self) {
        self.best_kills = ::std::option::Option::None;
    }

    pub fn has_best_kills(&self) -> bool {
        self.best_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_kills(&mut self, v: u32) {
        self.best_kills = ::std::option::Option::Some(v);
    }

    pub fn get_best_kills(&self) -> u32 {
        self.best_kills.unwrap_or(0)
    }

    fn get_best_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.best_kills
    }

    fn mut_best_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.best_kills
    }

    // optional uint32 best_assists = 12;

    pub fn clear_best_assists(&mut self) {
        self.best_assists = ::std::option::Option::None;
    }

    pub fn has_best_assists(&self) -> bool {
        self.best_assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_assists(&mut self, v: u32) {
        self.best_assists = ::std::option::Option::Some(v);
    }

    pub fn get_best_assists(&self) -> u32 {
        self.best_assists.unwrap_or(0)
    }

    fn get_best_assists_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.best_assists
    }

    fn mut_best_assists_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.best_assists
    }

    // optional uint32 best_gpm = 13;

    pub fn clear_best_gpm(&mut self) {
        self.best_gpm = ::std::option::Option::None;
    }

    pub fn has_best_gpm(&self) -> bool {
        self.best_gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_gpm(&mut self, v: u32) {
        self.best_gpm = ::std::option::Option::Some(v);
    }

    pub fn get_best_gpm(&self) -> u32 {
        self.best_gpm.unwrap_or(0)
    }

    fn get_best_gpm_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.best_gpm
    }

    fn mut_best_gpm_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.best_gpm
    }

    // optional uint32 best_xpm = 14;

    pub fn clear_best_xpm(&mut self) {
        self.best_xpm = ::std::option::Option::None;
    }

    pub fn has_best_xpm(&self) -> bool {
        self.best_xpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_xpm(&mut self, v: u32) {
        self.best_xpm = ::std::option::Option::Some(v);
    }

    pub fn get_best_xpm(&self) -> u32 {
        self.best_xpm.unwrap_or(0)
    }

    fn get_best_xpm_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.best_xpm
    }

    fn mut_best_xpm_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.best_xpm
    }

    // optional float performance = 15;

    pub fn clear_performance(&mut self) {
        self.performance = ::std::option::Option::None;
    }

    pub fn has_performance(&self) -> bool {
        self.performance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_performance(&mut self, v: f32) {
        self.performance = ::std::option::Option::Some(v);
    }

    pub fn get_performance(&self) -> f32 {
        self.performance.unwrap_or(0.)
    }

    fn get_performance_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.performance
    }

    fn mut_performance_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.performance
    }
}

impl ::protobuf::Message for CMsgGCGetHeroStandingsResponse_Hero {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wins = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.losses = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.win_streak = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.best_win_streak = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.avg_kills = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.avg_deaths = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.avg_assists = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.avg_gpm = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.avg_xpm = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.best_kills = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.best_assists = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.best_gpm = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.best_xpm = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.performance = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wins {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.losses {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.win_streak {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.best_win_streak {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.avg_kills {
            my_size += 5;
        }
        if let Some(v) = self.avg_deaths {
            my_size += 5;
        }
        if let Some(v) = self.avg_assists {
            my_size += 5;
        }
        if let Some(v) = self.avg_gpm {
            my_size += 5;
        }
        if let Some(v) = self.avg_xpm {
            my_size += 5;
        }
        if let Some(v) = self.best_kills {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.best_assists {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.best_gpm {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.best_xpm {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.performance {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.wins {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.losses {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.win_streak {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.best_win_streak {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.avg_kills {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.avg_deaths {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.avg_assists {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.avg_gpm {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.avg_xpm {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.best_kills {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.best_assists {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.best_gpm {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.best_xpm {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.performance {
            os.write_float(15, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCGetHeroStandingsResponse_Hero {
    fn new() -> CMsgGCGetHeroStandingsResponse_Hero {
        CMsgGCGetHeroStandingsResponse_Hero::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCGetHeroStandingsResponse_Hero>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgGCGetHeroStandingsResponse_Hero::get_hero_id_for_reflect,
                    CMsgGCGetHeroStandingsResponse_Hero::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wins",
                    CMsgGCGetHeroStandingsResponse_Hero::get_wins_for_reflect,
                    CMsgGCGetHeroStandingsResponse_Hero::mut_wins_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "losses",
                    CMsgGCGetHeroStandingsResponse_Hero::get_losses_for_reflect,
                    CMsgGCGetHeroStandingsResponse_Hero::mut_losses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "win_streak",
                    CMsgGCGetHeroStandingsResponse_Hero::get_win_streak_for_reflect,
                    CMsgGCGetHeroStandingsResponse_Hero::mut_win_streak_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "best_win_streak",
                    CMsgGCGetHeroStandingsResponse_Hero::get_best_win_streak_for_reflect,
                    CMsgGCGetHeroStandingsResponse_Hero::mut_best_win_streak_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "avg_kills",
                    CMsgGCGetHeroStandingsResponse_Hero::get_avg_kills_for_reflect,
                    CMsgGCGetHeroStandingsResponse_Hero::mut_avg_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "avg_deaths",
                    CMsgGCGetHeroStandingsResponse_Hero::get_avg_deaths_for_reflect,
                    CMsgGCGetHeroStandingsResponse_Hero::mut_avg_deaths_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "avg_assists",
                    CMsgGCGetHeroStandingsResponse_Hero::get_avg_assists_for_reflect,
                    CMsgGCGetHeroStandingsResponse_Hero::mut_avg_assists_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "avg_gpm",
                    CMsgGCGetHeroStandingsResponse_Hero::get_avg_gpm_for_reflect,
                    CMsgGCGetHeroStandingsResponse_Hero::mut_avg_gpm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "avg_xpm",
                    CMsgGCGetHeroStandingsResponse_Hero::get_avg_xpm_for_reflect,
                    CMsgGCGetHeroStandingsResponse_Hero::mut_avg_xpm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "best_kills",
                    CMsgGCGetHeroStandingsResponse_Hero::get_best_kills_for_reflect,
                    CMsgGCGetHeroStandingsResponse_Hero::mut_best_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "best_assists",
                    CMsgGCGetHeroStandingsResponse_Hero::get_best_assists_for_reflect,
                    CMsgGCGetHeroStandingsResponse_Hero::mut_best_assists_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "best_gpm",
                    CMsgGCGetHeroStandingsResponse_Hero::get_best_gpm_for_reflect,
                    CMsgGCGetHeroStandingsResponse_Hero::mut_best_gpm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "best_xpm",
                    CMsgGCGetHeroStandingsResponse_Hero::get_best_xpm_for_reflect,
                    CMsgGCGetHeroStandingsResponse_Hero::mut_best_xpm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "performance",
                    CMsgGCGetHeroStandingsResponse_Hero::get_performance_for_reflect,
                    CMsgGCGetHeroStandingsResponse_Hero::mut_performance_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCGetHeroStandingsResponse_Hero>(
                    "CMsgGCGetHeroStandingsResponse_Hero",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCGetHeroStandingsResponse_Hero {
    fn clear(&mut self) {
        self.clear_hero_id();
        self.clear_wins();
        self.clear_losses();
        self.clear_win_streak();
        self.clear_best_win_streak();
        self.clear_avg_kills();
        self.clear_avg_deaths();
        self.clear_avg_assists();
        self.clear_avg_gpm();
        self.clear_avg_xpm();
        self.clear_best_kills();
        self.clear_best_assists();
        self.clear_best_gpm();
        self.clear_best_xpm();
        self.clear_performance();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCGetHeroStandingsResponse_Hero {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCGetHeroStandingsResponse_Hero {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCItemEditorReservationsRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCItemEditorReservationsRequest {}

impl CMsgGCItemEditorReservationsRequest {
    pub fn new() -> CMsgGCItemEditorReservationsRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCItemEditorReservationsRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCItemEditorReservationsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCItemEditorReservationsRequest,
        };
        unsafe {
            instance.get(CMsgGCItemEditorReservationsRequest::new)
        }
    }
}

impl ::protobuf::Message for CMsgGCItemEditorReservationsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCItemEditorReservationsRequest {
    fn new() -> CMsgGCItemEditorReservationsRequest {
        CMsgGCItemEditorReservationsRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCItemEditorReservationsRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCItemEditorReservationsRequest>(
                    "CMsgGCItemEditorReservationsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCItemEditorReservationsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCItemEditorReservationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCItemEditorReservationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCItemEditorReservation {
    // message fields
    def_index: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCItemEditorReservation {}

impl CMsgGCItemEditorReservation {
    pub fn new() -> CMsgGCItemEditorReservation {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCItemEditorReservation {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCItemEditorReservation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCItemEditorReservation,
        };
        unsafe {
            instance.get(CMsgGCItemEditorReservation::new)
        }
    }

    // optional uint32 def_index = 1;

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    fn get_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.def_index
    }

    fn mut_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.def_index
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }
}

impl ::protobuf::Message for CMsgGCItemEditorReservation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCItemEditorReservation {
    fn new() -> CMsgGCItemEditorReservation {
        CMsgGCItemEditorReservation::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCItemEditorReservation>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "def_index",
                    CMsgGCItemEditorReservation::get_def_index_for_reflect,
                    CMsgGCItemEditorReservation::mut_def_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgGCItemEditorReservation::get_name_for_reflect,
                    CMsgGCItemEditorReservation::mut_name_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCItemEditorReservation>(
                    "CMsgGCItemEditorReservation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCItemEditorReservation {
    fn clear(&mut self) {
        self.clear_def_index();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCItemEditorReservation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCItemEditorReservation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCItemEditorReservationsResponse {
    // message fields
    reservations: ::protobuf::RepeatedField<CMsgGCItemEditorReservation>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCItemEditorReservationsResponse {}

impl CMsgGCItemEditorReservationsResponse {
    pub fn new() -> CMsgGCItemEditorReservationsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCItemEditorReservationsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCItemEditorReservationsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCItemEditorReservationsResponse,
        };
        unsafe {
            instance.get(CMsgGCItemEditorReservationsResponse::new)
        }
    }

    // repeated .CMsgGCItemEditorReservation reservations = 1;

    pub fn clear_reservations(&mut self) {
        self.reservations.clear();
    }

    // Param is passed by value, moved
    pub fn set_reservations(&mut self, v: ::protobuf::RepeatedField<CMsgGCItemEditorReservation>) {
        self.reservations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reservations(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCItemEditorReservation> {
        &mut self.reservations
    }

    // Take field
    pub fn take_reservations(&mut self) -> ::protobuf::RepeatedField<CMsgGCItemEditorReservation> {
        ::std::mem::replace(&mut self.reservations, ::protobuf::RepeatedField::new())
    }

    pub fn get_reservations(&self) -> &[CMsgGCItemEditorReservation] {
        &self.reservations
    }

    fn get_reservations_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCItemEditorReservation> {
        &self.reservations
    }

    fn mut_reservations_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCItemEditorReservation> {
        &mut self.reservations
    }
}

impl ::protobuf::Message for CMsgGCItemEditorReservationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.reservations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.reservations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.reservations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.reservations {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCItemEditorReservationsResponse {
    fn new() -> CMsgGCItemEditorReservationsResponse {
        CMsgGCItemEditorReservationsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCItemEditorReservationsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCItemEditorReservation>>(
                    "reservations",
                    CMsgGCItemEditorReservationsResponse::get_reservations_for_reflect,
                    CMsgGCItemEditorReservationsResponse::mut_reservations_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCItemEditorReservationsResponse>(
                    "CMsgGCItemEditorReservationsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCItemEditorReservationsResponse {
    fn clear(&mut self) {
        self.clear_reservations();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCItemEditorReservationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCItemEditorReservationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCItemEditorReserveItemDef {
    // message fields
    def_index: ::std::option::Option<u32>,
    username: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCItemEditorReserveItemDef {}

impl CMsgGCItemEditorReserveItemDef {
    pub fn new() -> CMsgGCItemEditorReserveItemDef {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCItemEditorReserveItemDef {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCItemEditorReserveItemDef> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCItemEditorReserveItemDef,
        };
        unsafe {
            instance.get(CMsgGCItemEditorReserveItemDef::new)
        }
    }

    // optional uint32 def_index = 1;

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    fn get_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.def_index
    }

    fn mut_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.def_index
    }

    // optional string username = 2;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        if self.username.is_none() {
            self.username.set_default();
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_username(&self) -> &str {
        match self.username.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_username_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.username
    }

    fn mut_username_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.username
    }
}

impl ::protobuf::Message for CMsgGCItemEditorReserveItemDef {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.username.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.username.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCItemEditorReserveItemDef {
    fn new() -> CMsgGCItemEditorReserveItemDef {
        CMsgGCItemEditorReserveItemDef::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCItemEditorReserveItemDef>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "def_index",
                    CMsgGCItemEditorReserveItemDef::get_def_index_for_reflect,
                    CMsgGCItemEditorReserveItemDef::mut_def_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    CMsgGCItemEditorReserveItemDef::get_username_for_reflect,
                    CMsgGCItemEditorReserveItemDef::mut_username_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCItemEditorReserveItemDef>(
                    "CMsgGCItemEditorReserveItemDef",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCItemEditorReserveItemDef {
    fn clear(&mut self) {
        self.clear_def_index();
        self.clear_username();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCItemEditorReserveItemDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCItemEditorReserveItemDef {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCItemEditorReserveItemDefResponse {
    // message fields
    def_index: ::std::option::Option<u32>,
    username: ::protobuf::SingularField<::std::string::String>,
    result: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCItemEditorReserveItemDefResponse {}

impl CMsgGCItemEditorReserveItemDefResponse {
    pub fn new() -> CMsgGCItemEditorReserveItemDefResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCItemEditorReserveItemDefResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCItemEditorReserveItemDefResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCItemEditorReserveItemDefResponse,
        };
        unsafe {
            instance.get(CMsgGCItemEditorReserveItemDefResponse::new)
        }
    }

    // optional uint32 def_index = 1;

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    fn get_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.def_index
    }

    fn mut_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.def_index
    }

    // optional string username = 2;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        if self.username.is_none() {
            self.username.set_default();
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_username(&self) -> &str {
        match self.username.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_username_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.username
    }

    fn mut_username_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.username
    }

    // optional uint32 result = 3;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgGCItemEditorReserveItemDefResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.username)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.username.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.username.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.result {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCItemEditorReserveItemDefResponse {
    fn new() -> CMsgGCItemEditorReserveItemDefResponse {
        CMsgGCItemEditorReserveItemDefResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCItemEditorReserveItemDefResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "def_index",
                    CMsgGCItemEditorReserveItemDefResponse::get_def_index_for_reflect,
                    CMsgGCItemEditorReserveItemDefResponse::mut_def_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    CMsgGCItemEditorReserveItemDefResponse::get_username_for_reflect,
                    CMsgGCItemEditorReserveItemDefResponse::mut_username_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "result",
                    CMsgGCItemEditorReserveItemDefResponse::get_result_for_reflect,
                    CMsgGCItemEditorReserveItemDefResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCItemEditorReserveItemDefResponse>(
                    "CMsgGCItemEditorReserveItemDefResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCItemEditorReserveItemDefResponse {
    fn clear(&mut self) {
        self.clear_def_index();
        self.clear_username();
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCItemEditorReserveItemDefResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCItemEditorReserveItemDefResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCItemEditorReleaseReservation {
    // message fields
    def_index: ::std::option::Option<u32>,
    username: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCItemEditorReleaseReservation {}

impl CMsgGCItemEditorReleaseReservation {
    pub fn new() -> CMsgGCItemEditorReleaseReservation {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCItemEditorReleaseReservation {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCItemEditorReleaseReservation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCItemEditorReleaseReservation,
        };
        unsafe {
            instance.get(CMsgGCItemEditorReleaseReservation::new)
        }
    }

    // optional uint32 def_index = 1;

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    fn get_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.def_index
    }

    fn mut_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.def_index
    }

    // optional string username = 2;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        if self.username.is_none() {
            self.username.set_default();
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_username(&self) -> &str {
        match self.username.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_username_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.username
    }

    fn mut_username_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.username
    }
}

impl ::protobuf::Message for CMsgGCItemEditorReleaseReservation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.username.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.username.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCItemEditorReleaseReservation {
    fn new() -> CMsgGCItemEditorReleaseReservation {
        CMsgGCItemEditorReleaseReservation::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCItemEditorReleaseReservation>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "def_index",
                    CMsgGCItemEditorReleaseReservation::get_def_index_for_reflect,
                    CMsgGCItemEditorReleaseReservation::mut_def_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    CMsgGCItemEditorReleaseReservation::get_username_for_reflect,
                    CMsgGCItemEditorReleaseReservation::mut_username_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCItemEditorReleaseReservation>(
                    "CMsgGCItemEditorReleaseReservation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCItemEditorReleaseReservation {
    fn clear(&mut self) {
        self.clear_def_index();
        self.clear_username();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCItemEditorReleaseReservation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCItemEditorReleaseReservation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCItemEditorReleaseReservationResponse {
    // message fields
    def_index: ::std::option::Option<u32>,
    released: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCItemEditorReleaseReservationResponse {}

impl CMsgGCItemEditorReleaseReservationResponse {
    pub fn new() -> CMsgGCItemEditorReleaseReservationResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCItemEditorReleaseReservationResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCItemEditorReleaseReservationResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCItemEditorReleaseReservationResponse,
        };
        unsafe {
            instance.get(CMsgGCItemEditorReleaseReservationResponse::new)
        }
    }

    // optional uint32 def_index = 1;

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    fn get_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.def_index
    }

    fn mut_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.def_index
    }

    // optional bool released = 2;

    pub fn clear_released(&mut self) {
        self.released = ::std::option::Option::None;
    }

    pub fn has_released(&self) -> bool {
        self.released.is_some()
    }

    // Param is passed by value, moved
    pub fn set_released(&mut self, v: bool) {
        self.released = ::std::option::Option::Some(v);
    }

    pub fn get_released(&self) -> bool {
        self.released.unwrap_or(false)
    }

    fn get_released_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.released
    }

    fn mut_released_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.released
    }
}

impl ::protobuf::Message for CMsgGCItemEditorReleaseReservationResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.released = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.released {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.released {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCItemEditorReleaseReservationResponse {
    fn new() -> CMsgGCItemEditorReleaseReservationResponse {
        CMsgGCItemEditorReleaseReservationResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCItemEditorReleaseReservationResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "def_index",
                    CMsgGCItemEditorReleaseReservationResponse::get_def_index_for_reflect,
                    CMsgGCItemEditorReleaseReservationResponse::mut_def_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "released",
                    CMsgGCItemEditorReleaseReservationResponse::get_released_for_reflect,
                    CMsgGCItemEditorReleaseReservationResponse::mut_released_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCItemEditorReleaseReservationResponse>(
                    "CMsgGCItemEditorReleaseReservationResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCItemEditorReleaseReservationResponse {
    fn clear(&mut self) {
        self.clear_def_index();
        self.clear_released();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCItemEditorReleaseReservationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCItemEditorReleaseReservationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCItemEditorRequestLeagueInfo {
    // message fields
    league_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCItemEditorRequestLeagueInfo {}

impl CMsgGCItemEditorRequestLeagueInfo {
    pub fn new() -> CMsgGCItemEditorRequestLeagueInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCItemEditorRequestLeagueInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCItemEditorRequestLeagueInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCItemEditorRequestLeagueInfo,
        };
        unsafe {
            instance.get(CMsgGCItemEditorRequestLeagueInfo::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }
}

impl ::protobuf::Message for CMsgGCItemEditorRequestLeagueInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCItemEditorRequestLeagueInfo {
    fn new() -> CMsgGCItemEditorRequestLeagueInfo {
        CMsgGCItemEditorRequestLeagueInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCItemEditorRequestLeagueInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgGCItemEditorRequestLeagueInfo::get_league_id_for_reflect,
                    CMsgGCItemEditorRequestLeagueInfo::mut_league_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCItemEditorRequestLeagueInfo>(
                    "CMsgGCItemEditorRequestLeagueInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCItemEditorRequestLeagueInfo {
    fn clear(&mut self) {
        self.clear_league_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCItemEditorRequestLeagueInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCItemEditorRequestLeagueInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCItemEditorLeagueInfoResponse {
    // message fields
    league_id: ::std::option::Option<u32>,
    league_name: ::protobuf::SingularField<::std::string::String>,
    league_desc: ::protobuf::SingularField<::std::string::String>,
    league_url: ::protobuf::SingularField<::std::string::String>,
    revenue_url: ::protobuf::SingularField<::std::string::String>,
    tier: ::std::option::Option<u32>,
    location: ::std::option::Option<u32>,
    result: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCItemEditorLeagueInfoResponse {}

impl CMsgGCItemEditorLeagueInfoResponse {
    pub fn new() -> CMsgGCItemEditorLeagueInfoResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCItemEditorLeagueInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCItemEditorLeagueInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCItemEditorLeagueInfoResponse,
        };
        unsafe {
            instance.get(CMsgGCItemEditorLeagueInfoResponse::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional string league_name = 2;

    pub fn clear_league_name(&mut self) {
        self.league_name.clear();
    }

    pub fn has_league_name(&self) -> bool {
        self.league_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_name(&mut self, v: ::std::string::String) {
        self.league_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_league_name(&mut self) -> &mut ::std::string::String {
        if self.league_name.is_none() {
            self.league_name.set_default();
        }
        self.league_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_league_name(&mut self) -> ::std::string::String {
        self.league_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_league_name(&self) -> &str {
        match self.league_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_league_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.league_name
    }

    fn mut_league_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.league_name
    }

    // optional string league_desc = 3;

    pub fn clear_league_desc(&mut self) {
        self.league_desc.clear();
    }

    pub fn has_league_desc(&self) -> bool {
        self.league_desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_desc(&mut self, v: ::std::string::String) {
        self.league_desc = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_league_desc(&mut self) -> &mut ::std::string::String {
        if self.league_desc.is_none() {
            self.league_desc.set_default();
        }
        self.league_desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_league_desc(&mut self) -> ::std::string::String {
        self.league_desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_league_desc(&self) -> &str {
        match self.league_desc.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_league_desc_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.league_desc
    }

    fn mut_league_desc_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.league_desc
    }

    // optional string league_url = 4;

    pub fn clear_league_url(&mut self) {
        self.league_url.clear();
    }

    pub fn has_league_url(&self) -> bool {
        self.league_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_url(&mut self, v: ::std::string::String) {
        self.league_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_league_url(&mut self) -> &mut ::std::string::String {
        if self.league_url.is_none() {
            self.league_url.set_default();
        }
        self.league_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_league_url(&mut self) -> ::std::string::String {
        self.league_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_league_url(&self) -> &str {
        match self.league_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_league_url_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.league_url
    }

    fn mut_league_url_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.league_url
    }

    // optional string revenue_url = 5;

    pub fn clear_revenue_url(&mut self) {
        self.revenue_url.clear();
    }

    pub fn has_revenue_url(&self) -> bool {
        self.revenue_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revenue_url(&mut self, v: ::std::string::String) {
        self.revenue_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revenue_url(&mut self) -> &mut ::std::string::String {
        if self.revenue_url.is_none() {
            self.revenue_url.set_default();
        }
        self.revenue_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_revenue_url(&mut self) -> ::std::string::String {
        self.revenue_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_revenue_url(&self) -> &str {
        match self.revenue_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_revenue_url_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.revenue_url
    }

    fn mut_revenue_url_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.revenue_url
    }

    // optional uint32 tier = 6;

    pub fn clear_tier(&mut self) {
        self.tier = ::std::option::Option::None;
    }

    pub fn has_tier(&self) -> bool {
        self.tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tier(&mut self, v: u32) {
        self.tier = ::std::option::Option::Some(v);
    }

    pub fn get_tier(&self) -> u32 {
        self.tier.unwrap_or(0)
    }

    fn get_tier_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tier
    }

    fn mut_tier_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tier
    }

    // optional uint32 location = 7;

    pub fn clear_location(&mut self) {
        self.location = ::std::option::Option::None;
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: u32) {
        self.location = ::std::option::Option::Some(v);
    }

    pub fn get_location(&self) -> u32 {
        self.location.unwrap_or(0)
    }

    fn get_location_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.location
    }

    fn mut_location_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.location
    }

    // optional uint32 result = 8;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgGCItemEditorLeagueInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.league_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.league_desc)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.league_url)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.revenue_url)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tier = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.location = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.league_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.league_desc.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.league_url.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.revenue_url.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.tier {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.location {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.league_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.league_desc.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.league_url.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.revenue_url.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.tier {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.location {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.result {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCItemEditorLeagueInfoResponse {
    fn new() -> CMsgGCItemEditorLeagueInfoResponse {
        CMsgGCItemEditorLeagueInfoResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCItemEditorLeagueInfoResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgGCItemEditorLeagueInfoResponse::get_league_id_for_reflect,
                    CMsgGCItemEditorLeagueInfoResponse::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "league_name",
                    CMsgGCItemEditorLeagueInfoResponse::get_league_name_for_reflect,
                    CMsgGCItemEditorLeagueInfoResponse::mut_league_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "league_desc",
                    CMsgGCItemEditorLeagueInfoResponse::get_league_desc_for_reflect,
                    CMsgGCItemEditorLeagueInfoResponse::mut_league_desc_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "league_url",
                    CMsgGCItemEditorLeagueInfoResponse::get_league_url_for_reflect,
                    CMsgGCItemEditorLeagueInfoResponse::mut_league_url_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "revenue_url",
                    CMsgGCItemEditorLeagueInfoResponse::get_revenue_url_for_reflect,
                    CMsgGCItemEditorLeagueInfoResponse::mut_revenue_url_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tier",
                    CMsgGCItemEditorLeagueInfoResponse::get_tier_for_reflect,
                    CMsgGCItemEditorLeagueInfoResponse::mut_tier_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "location",
                    CMsgGCItemEditorLeagueInfoResponse::get_location_for_reflect,
                    CMsgGCItemEditorLeagueInfoResponse::mut_location_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "result",
                    CMsgGCItemEditorLeagueInfoResponse::get_result_for_reflect,
                    CMsgGCItemEditorLeagueInfoResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCItemEditorLeagueInfoResponse>(
                    "CMsgGCItemEditorLeagueInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCItemEditorLeagueInfoResponse {
    fn clear(&mut self) {
        self.clear_league_id();
        self.clear_league_name();
        self.clear_league_desc();
        self.clear_league_url();
        self.clear_revenue_url();
        self.clear_tier();
        self.clear_location();
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCItemEditorLeagueInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCItemEditorLeagueInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARewardTutorialPrizes {
    // message fields
    location_id: ::std::option::Option<u32>,
    tracking_only: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARewardTutorialPrizes {}

impl CMsgDOTARewardTutorialPrizes {
    pub fn new() -> CMsgDOTARewardTutorialPrizes {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARewardTutorialPrizes {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARewardTutorialPrizes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARewardTutorialPrizes,
        };
        unsafe {
            instance.get(CMsgDOTARewardTutorialPrizes::new)
        }
    }

    // optional uint32 location_id = 1;

    pub fn clear_location_id(&mut self) {
        self.location_id = ::std::option::Option::None;
    }

    pub fn has_location_id(&self) -> bool {
        self.location_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location_id(&mut self, v: u32) {
        self.location_id = ::std::option::Option::Some(v);
    }

    pub fn get_location_id(&self) -> u32 {
        self.location_id.unwrap_or(0)
    }

    fn get_location_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.location_id
    }

    fn mut_location_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.location_id
    }

    // optional bool tracking_only = 2;

    pub fn clear_tracking_only(&mut self) {
        self.tracking_only = ::std::option::Option::None;
    }

    pub fn has_tracking_only(&self) -> bool {
        self.tracking_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tracking_only(&mut self, v: bool) {
        self.tracking_only = ::std::option::Option::Some(v);
    }

    pub fn get_tracking_only(&self) -> bool {
        self.tracking_only.unwrap_or(false)
    }

    fn get_tracking_only_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.tracking_only
    }

    fn mut_tracking_only_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.tracking_only
    }
}

impl ::protobuf::Message for CMsgDOTARewardTutorialPrizes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.location_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tracking_only = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.location_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tracking_only {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.location_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tracking_only {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARewardTutorialPrizes {
    fn new() -> CMsgDOTARewardTutorialPrizes {
        CMsgDOTARewardTutorialPrizes::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARewardTutorialPrizes>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "location_id",
                    CMsgDOTARewardTutorialPrizes::get_location_id_for_reflect,
                    CMsgDOTARewardTutorialPrizes::mut_location_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "tracking_only",
                    CMsgDOTARewardTutorialPrizes::get_tracking_only_for_reflect,
                    CMsgDOTARewardTutorialPrizes::mut_tracking_only_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARewardTutorialPrizes>(
                    "CMsgDOTARewardTutorialPrizes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARewardTutorialPrizes {
    fn clear(&mut self) {
        self.clear_location_id();
        self.clear_tracking_only();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARewardTutorialPrizes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARewardTutorialPrizes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALastHitChallengeHighScorePost {
    // message fields
    hero_id: ::std::option::Option<u32>,
    high_score: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALastHitChallengeHighScorePost {}

impl CMsgDOTALastHitChallengeHighScorePost {
    pub fn new() -> CMsgDOTALastHitChallengeHighScorePost {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALastHitChallengeHighScorePost {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALastHitChallengeHighScorePost> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALastHitChallengeHighScorePost,
        };
        unsafe {
            instance.get(CMsgDOTALastHitChallengeHighScorePost::new)
        }
    }

    // optional uint32 hero_id = 1;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 high_score = 2;

    pub fn clear_high_score(&mut self) {
        self.high_score = ::std::option::Option::None;
    }

    pub fn has_high_score(&self) -> bool {
        self.high_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_score(&mut self, v: u32) {
        self.high_score = ::std::option::Option::Some(v);
    }

    pub fn get_high_score(&self) -> u32 {
        self.high_score.unwrap_or(0)
    }

    fn get_high_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.high_score
    }

    fn mut_high_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.high_score
    }
}

impl ::protobuf::Message for CMsgDOTALastHitChallengeHighScorePost {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.high_score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.high_score {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.high_score {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALastHitChallengeHighScorePost {
    fn new() -> CMsgDOTALastHitChallengeHighScorePost {
        CMsgDOTALastHitChallengeHighScorePost::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALastHitChallengeHighScorePost>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgDOTALastHitChallengeHighScorePost::get_hero_id_for_reflect,
                    CMsgDOTALastHitChallengeHighScorePost::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "high_score",
                    CMsgDOTALastHitChallengeHighScorePost::get_high_score_for_reflect,
                    CMsgDOTALastHitChallengeHighScorePost::mut_high_score_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALastHitChallengeHighScorePost>(
                    "CMsgDOTALastHitChallengeHighScorePost",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALastHitChallengeHighScorePost {
    fn clear(&mut self) {
        self.clear_hero_id();
        self.clear_high_score();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALastHitChallengeHighScorePost {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALastHitChallengeHighScorePost {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALastHitChallengeHighScoreRequest {
    // message fields
    hero_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALastHitChallengeHighScoreRequest {}

impl CMsgDOTALastHitChallengeHighScoreRequest {
    pub fn new() -> CMsgDOTALastHitChallengeHighScoreRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALastHitChallengeHighScoreRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALastHitChallengeHighScoreRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALastHitChallengeHighScoreRequest,
        };
        unsafe {
            instance.get(CMsgDOTALastHitChallengeHighScoreRequest::new)
        }
    }

    // optional uint32 hero_id = 1;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }
}

impl ::protobuf::Message for CMsgDOTALastHitChallengeHighScoreRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALastHitChallengeHighScoreRequest {
    fn new() -> CMsgDOTALastHitChallengeHighScoreRequest {
        CMsgDOTALastHitChallengeHighScoreRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALastHitChallengeHighScoreRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgDOTALastHitChallengeHighScoreRequest::get_hero_id_for_reflect,
                    CMsgDOTALastHitChallengeHighScoreRequest::mut_hero_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALastHitChallengeHighScoreRequest>(
                    "CMsgDOTALastHitChallengeHighScoreRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALastHitChallengeHighScoreRequest {
    fn clear(&mut self) {
        self.clear_hero_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALastHitChallengeHighScoreRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALastHitChallengeHighScoreRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALastHitChallengeHighScoreResponse {
    // message fields
    score: ::std::option::Option<u32>,
    eresult: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALastHitChallengeHighScoreResponse {}

impl CMsgDOTALastHitChallengeHighScoreResponse {
    pub fn new() -> CMsgDOTALastHitChallengeHighScoreResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALastHitChallengeHighScoreResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALastHitChallengeHighScoreResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALastHitChallengeHighScoreResponse,
        };
        unsafe {
            instance.get(CMsgDOTALastHitChallengeHighScoreResponse::new)
        }
    }

    // optional uint32 score = 1;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    fn get_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.score
    }

    fn mut_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.score
    }

    // optional uint32 eresult = 2;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    fn get_eresult_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.eresult
    }

    fn mut_eresult_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.eresult
    }
}

impl ::protobuf::Message for CMsgDOTALastHitChallengeHighScoreResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.score {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALastHitChallengeHighScoreResponse {
    fn new() -> CMsgDOTALastHitChallengeHighScoreResponse {
        CMsgDOTALastHitChallengeHighScoreResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALastHitChallengeHighScoreResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "score",
                    CMsgDOTALastHitChallengeHighScoreResponse::get_score_for_reflect,
                    CMsgDOTALastHitChallengeHighScoreResponse::mut_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "eresult",
                    CMsgDOTALastHitChallengeHighScoreResponse::get_eresult_for_reflect,
                    CMsgDOTALastHitChallengeHighScoreResponse::mut_eresult_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALastHitChallengeHighScoreResponse>(
                    "CMsgDOTALastHitChallengeHighScoreResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALastHitChallengeHighScoreResponse {
    fn clear(&mut self) {
        self.clear_score();
        self.clear_eresult();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALastHitChallengeHighScoreResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALastHitChallengeHighScoreResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgFlipLobbyTeams {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgFlipLobbyTeams {}

impl CMsgFlipLobbyTeams {
    pub fn new() -> CMsgFlipLobbyTeams {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgFlipLobbyTeams {
        static mut instance: ::protobuf::lazy::Lazy<CMsgFlipLobbyTeams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgFlipLobbyTeams,
        };
        unsafe {
            instance.get(CMsgFlipLobbyTeams::new)
        }
    }
}

impl ::protobuf::Message for CMsgFlipLobbyTeams {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgFlipLobbyTeams {
    fn new() -> CMsgFlipLobbyTeams {
        CMsgFlipLobbyTeams::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgFlipLobbyTeams>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgFlipLobbyTeams>(
                    "CMsgFlipLobbyTeams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgFlipLobbyTeams {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFlipLobbyTeams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFlipLobbyTeams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPresentedClientTerminateDlg {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgPresentedClientTerminateDlg {}

impl CMsgPresentedClientTerminateDlg {
    pub fn new() -> CMsgPresentedClientTerminateDlg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgPresentedClientTerminateDlg {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPresentedClientTerminateDlg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPresentedClientTerminateDlg,
        };
        unsafe {
            instance.get(CMsgPresentedClientTerminateDlg::new)
        }
    }
}

impl ::protobuf::Message for CMsgPresentedClientTerminateDlg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgPresentedClientTerminateDlg {
    fn new() -> CMsgPresentedClientTerminateDlg {
        CMsgPresentedClientTerminateDlg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgPresentedClientTerminateDlg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPresentedClientTerminateDlg>(
                    "CMsgPresentedClientTerminateDlg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgPresentedClientTerminateDlg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPresentedClientTerminateDlg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPresentedClientTerminateDlg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCLobbyUpdateBroadcastChannelInfo {
    // message fields
    channel_id: ::std::option::Option<u32>,
    country_code: ::protobuf::SingularField<::std::string::String>,
    description: ::protobuf::SingularField<::std::string::String>,
    language_code: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCLobbyUpdateBroadcastChannelInfo {}

impl CMsgGCLobbyUpdateBroadcastChannelInfo {
    pub fn new() -> CMsgGCLobbyUpdateBroadcastChannelInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCLobbyUpdateBroadcastChannelInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCLobbyUpdateBroadcastChannelInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCLobbyUpdateBroadcastChannelInfo,
        };
        unsafe {
            instance.get(CMsgGCLobbyUpdateBroadcastChannelInfo::new)
        }
    }

    // optional uint32 channel_id = 1;

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    pub fn get_channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    fn get_channel_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.channel_id
    }

    fn mut_channel_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.channel_id
    }

    // optional string country_code = 2;

    pub fn clear_country_code(&mut self) {
        self.country_code.clear();
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code.set_default();
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_country_code_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.country_code
    }

    fn mut_country_code_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.country_code
    }

    // optional string description = 3;

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_description_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.description
    }

    fn mut_description_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.description
    }

    // optional string language_code = 4;

    pub fn clear_language_code(&mut self) {
        self.language_code.clear();
    }

    pub fn has_language_code(&self) -> bool {
        self.language_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language_code(&mut self, v: ::std::string::String) {
        self.language_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language_code(&mut self) -> &mut ::std::string::String {
        if self.language_code.is_none() {
            self.language_code.set_default();
        }
        self.language_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_language_code(&mut self) -> ::std::string::String {
        self.language_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_language_code(&self) -> &str {
        match self.language_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_language_code_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.language_code
    }

    fn mut_language_code_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.language_code
    }
}

impl ::protobuf::Message for CMsgGCLobbyUpdateBroadcastChannelInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country_code)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language_code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.channel_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.language_code.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.country_code.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.language_code.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCLobbyUpdateBroadcastChannelInfo {
    fn new() -> CMsgGCLobbyUpdateBroadcastChannelInfo {
        CMsgGCLobbyUpdateBroadcastChannelInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCLobbyUpdateBroadcastChannelInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "channel_id",
                    CMsgGCLobbyUpdateBroadcastChannelInfo::get_channel_id_for_reflect,
                    CMsgGCLobbyUpdateBroadcastChannelInfo::mut_channel_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "country_code",
                    CMsgGCLobbyUpdateBroadcastChannelInfo::get_country_code_for_reflect,
                    CMsgGCLobbyUpdateBroadcastChannelInfo::mut_country_code_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    CMsgGCLobbyUpdateBroadcastChannelInfo::get_description_for_reflect,
                    CMsgGCLobbyUpdateBroadcastChannelInfo::mut_description_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "language_code",
                    CMsgGCLobbyUpdateBroadcastChannelInfo::get_language_code_for_reflect,
                    CMsgGCLobbyUpdateBroadcastChannelInfo::mut_language_code_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCLobbyUpdateBroadcastChannelInfo>(
                    "CMsgGCLobbyUpdateBroadcastChannelInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCLobbyUpdateBroadcastChannelInfo {
    fn clear(&mut self) {
        self.clear_channel_id();
        self.clear_country_code();
        self.clear_description();
        self.clear_language_code();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCLobbyUpdateBroadcastChannelInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCLobbyUpdateBroadcastChannelInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAClaimEventAction {
    // message fields
    event_id: ::std::option::Option<u32>,
    action_id: ::std::option::Option<u32>,
    quantity: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAClaimEventAction {}

impl CMsgDOTAClaimEventAction {
    pub fn new() -> CMsgDOTAClaimEventAction {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAClaimEventAction {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAClaimEventAction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAClaimEventAction,
        };
        unsafe {
            instance.get(CMsgDOTAClaimEventAction::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // optional uint32 action_id = 2;

    pub fn clear_action_id(&mut self) {
        self.action_id = ::std::option::Option::None;
    }

    pub fn has_action_id(&self) -> bool {
        self.action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = ::std::option::Option::Some(v);
    }

    pub fn get_action_id(&self) -> u32 {
        self.action_id.unwrap_or(0)
    }

    fn get_action_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.action_id
    }

    fn mut_action_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.action_id
    }

    // optional uint32 quantity = 3;

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    pub fn get_quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    fn get_quantity_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.quantity
    }

    fn mut_quantity_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.quantity
    }
}

impl ::protobuf::Message for CMsgDOTAClaimEventAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.action_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quantity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.action_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.action_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAClaimEventAction {
    fn new() -> CMsgDOTAClaimEventAction {
        CMsgDOTAClaimEventAction::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAClaimEventAction>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgDOTAClaimEventAction::get_event_id_for_reflect,
                    CMsgDOTAClaimEventAction::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "action_id",
                    CMsgDOTAClaimEventAction::get_action_id_for_reflect,
                    CMsgDOTAClaimEventAction::mut_action_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quantity",
                    CMsgDOTAClaimEventAction::get_quantity_for_reflect,
                    CMsgDOTAClaimEventAction::mut_quantity_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAClaimEventAction>(
                    "CMsgDOTAClaimEventAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAClaimEventAction {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_action_id();
        self.clear_quantity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAClaimEventAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAClaimEventAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAClaimEventActionResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAClaimEventActionResponse_ResultCode>,
    reward_results: ::protobuf::RepeatedField<CMsgDOTAClaimEventActionResponse_GrantedRewardData>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAClaimEventActionResponse {}

impl CMsgDOTAClaimEventActionResponse {
    pub fn new() -> CMsgDOTAClaimEventActionResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAClaimEventActionResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAClaimEventActionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAClaimEventActionResponse,
        };
        unsafe {
            instance.get(CMsgDOTAClaimEventActionResponse::new)
        }
    }

    // optional .CMsgDOTAClaimEventActionResponse.ResultCode result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAClaimEventActionResponse_ResultCode) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAClaimEventActionResponse_ResultCode {
        self.result.unwrap_or(CMsgDOTAClaimEventActionResponse_ResultCode::Success)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAClaimEventActionResponse_ResultCode> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAClaimEventActionResponse_ResultCode> {
        &mut self.result
    }

    // repeated .CMsgDOTAClaimEventActionResponse.GrantedRewardData reward_results = 2;

    pub fn clear_reward_results(&mut self) {
        self.reward_results.clear();
    }

    // Param is passed by value, moved
    pub fn set_reward_results(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAClaimEventActionResponse_GrantedRewardData>) {
        self.reward_results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reward_results(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAClaimEventActionResponse_GrantedRewardData> {
        &mut self.reward_results
    }

    // Take field
    pub fn take_reward_results(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAClaimEventActionResponse_GrantedRewardData> {
        ::std::mem::replace(&mut self.reward_results, ::protobuf::RepeatedField::new())
    }

    pub fn get_reward_results(&self) -> &[CMsgDOTAClaimEventActionResponse_GrantedRewardData] {
        &self.reward_results
    }

    fn get_reward_results_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAClaimEventActionResponse_GrantedRewardData> {
        &self.reward_results
    }

    fn mut_reward_results_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAClaimEventActionResponse_GrantedRewardData> {
        &mut self.reward_results
    }
}

impl ::protobuf::Message for CMsgDOTAClaimEventActionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.reward_results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.reward_results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.reward_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        for v in &self.reward_results {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAClaimEventActionResponse {
    fn new() -> CMsgDOTAClaimEventActionResponse {
        CMsgDOTAClaimEventActionResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAClaimEventActionResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAClaimEventActionResponse_ResultCode>>(
                    "result",
                    CMsgDOTAClaimEventActionResponse::get_result_for_reflect,
                    CMsgDOTAClaimEventActionResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAClaimEventActionResponse_GrantedRewardData>>(
                    "reward_results",
                    CMsgDOTAClaimEventActionResponse::get_reward_results_for_reflect,
                    CMsgDOTAClaimEventActionResponse::mut_reward_results_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAClaimEventActionResponse>(
                    "CMsgDOTAClaimEventActionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAClaimEventActionResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_reward_results();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAClaimEventActionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAClaimEventActionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
    // message fields
    item_def: ::std::option::Option<u32>,
    item_category: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {}

impl CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
    pub fn new() -> CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAClaimEventActionResponse_MysteryItemRewardData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAClaimEventActionResponse_MysteryItemRewardData,
        };
        unsafe {
            instance.get(CMsgDOTAClaimEventActionResponse_MysteryItemRewardData::new)
        }
    }

    // optional uint32 item_def = 1;

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    pub fn get_item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    fn get_item_def_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_def
    }

    fn mut_item_def_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_def
    }

    // optional uint32 item_category = 2;

    pub fn clear_item_category(&mut self) {
        self.item_category = ::std::option::Option::None;
    }

    pub fn has_item_category(&self) -> bool {
        self.item_category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_category(&mut self, v: u32) {
        self.item_category = ::std::option::Option::Some(v);
    }

    pub fn get_item_category(&self) -> u32 {
        self.item_category.unwrap_or(0)
    }

    fn get_item_category_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_category
    }

    fn mut_item_category_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_category
    }
}

impl ::protobuf::Message for CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_category = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_category {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_category {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
    fn new() -> CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
        CMsgDOTAClaimEventActionResponse_MysteryItemRewardData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAClaimEventActionResponse_MysteryItemRewardData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_def",
                    CMsgDOTAClaimEventActionResponse_MysteryItemRewardData::get_item_def_for_reflect,
                    CMsgDOTAClaimEventActionResponse_MysteryItemRewardData::mut_item_def_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_category",
                    CMsgDOTAClaimEventActionResponse_MysteryItemRewardData::get_item_category_for_reflect,
                    CMsgDOTAClaimEventActionResponse_MysteryItemRewardData::mut_item_category_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAClaimEventActionResponse_MysteryItemRewardData>(
                    "CMsgDOTAClaimEventActionResponse_MysteryItemRewardData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
    fn clear(&mut self) {
        self.clear_item_def();
        self.clear_item_category();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAClaimEventActionResponse_LootListRewardData {
    // message fields
    item_def: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAClaimEventActionResponse_LootListRewardData {}

impl CMsgDOTAClaimEventActionResponse_LootListRewardData {
    pub fn new() -> CMsgDOTAClaimEventActionResponse_LootListRewardData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAClaimEventActionResponse_LootListRewardData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAClaimEventActionResponse_LootListRewardData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAClaimEventActionResponse_LootListRewardData,
        };
        unsafe {
            instance.get(CMsgDOTAClaimEventActionResponse_LootListRewardData::new)
        }
    }

    // repeated uint32 item_def = 1;

    pub fn clear_item_def(&mut self) {
        self.item_def.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: ::std::vec::Vec<u32>) {
        self.item_def = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_def(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.item_def
    }

    // Take field
    pub fn take_item_def(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.item_def, ::std::vec::Vec::new())
    }

    pub fn get_item_def(&self) -> &[u32] {
        &self.item_def
    }

    fn get_item_def_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.item_def
    }

    fn mut_item_def_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.item_def
    }
}

impl ::protobuf::Message for CMsgDOTAClaimEventActionResponse_LootListRewardData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.item_def)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item_def {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item_def {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAClaimEventActionResponse_LootListRewardData {
    fn new() -> CMsgDOTAClaimEventActionResponse_LootListRewardData {
        CMsgDOTAClaimEventActionResponse_LootListRewardData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAClaimEventActionResponse_LootListRewardData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_def",
                    CMsgDOTAClaimEventActionResponse_LootListRewardData::get_item_def_for_reflect,
                    CMsgDOTAClaimEventActionResponse_LootListRewardData::mut_item_def_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAClaimEventActionResponse_LootListRewardData>(
                    "CMsgDOTAClaimEventActionResponse_LootListRewardData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAClaimEventActionResponse_LootListRewardData {
    fn clear(&mut self) {
        self.clear_item_def();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAClaimEventActionResponse_LootListRewardData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAClaimEventActionResponse_LootListRewardData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAClaimEventActionResponse_GrantedRewardData {
    // message fields
    grant_index: ::std::option::Option<u32>,
    score_index: ::std::option::Option<u32>,
    reward_index: ::std::option::Option<u32>,
    reward_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAClaimEventActionResponse_GrantedRewardData {}

impl CMsgDOTAClaimEventActionResponse_GrantedRewardData {
    pub fn new() -> CMsgDOTAClaimEventActionResponse_GrantedRewardData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAClaimEventActionResponse_GrantedRewardData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAClaimEventActionResponse_GrantedRewardData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAClaimEventActionResponse_GrantedRewardData,
        };
        unsafe {
            instance.get(CMsgDOTAClaimEventActionResponse_GrantedRewardData::new)
        }
    }

    // optional uint32 grant_index = 1;

    pub fn clear_grant_index(&mut self) {
        self.grant_index = ::std::option::Option::None;
    }

    pub fn has_grant_index(&self) -> bool {
        self.grant_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grant_index(&mut self, v: u32) {
        self.grant_index = ::std::option::Option::Some(v);
    }

    pub fn get_grant_index(&self) -> u32 {
        self.grant_index.unwrap_or(0)
    }

    fn get_grant_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.grant_index
    }

    fn mut_grant_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.grant_index
    }

    // optional uint32 score_index = 2;

    pub fn clear_score_index(&mut self) {
        self.score_index = ::std::option::Option::None;
    }

    pub fn has_score_index(&self) -> bool {
        self.score_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_index(&mut self, v: u32) {
        self.score_index = ::std::option::Option::Some(v);
    }

    pub fn get_score_index(&self) -> u32 {
        self.score_index.unwrap_or(0)
    }

    fn get_score_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.score_index
    }

    fn mut_score_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.score_index
    }

    // optional uint32 reward_index = 3;

    pub fn clear_reward_index(&mut self) {
        self.reward_index = ::std::option::Option::None;
    }

    pub fn has_reward_index(&self) -> bool {
        self.reward_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_index(&mut self, v: u32) {
        self.reward_index = ::std::option::Option::Some(v);
    }

    pub fn get_reward_index(&self) -> u32 {
        self.reward_index.unwrap_or(0)
    }

    fn get_reward_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reward_index
    }

    fn mut_reward_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reward_index
    }

    // optional bytes reward_data = 4;

    pub fn clear_reward_data(&mut self) {
        self.reward_data.clear();
    }

    pub fn has_reward_data(&self) -> bool {
        self.reward_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.reward_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reward_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.reward_data.is_none() {
            self.reward_data.set_default();
        }
        self.reward_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_reward_data(&mut self) -> ::std::vec::Vec<u8> {
        self.reward_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_reward_data(&self) -> &[u8] {
        match self.reward_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_reward_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.reward_data
    }

    fn mut_reward_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.reward_data
    }
}

impl ::protobuf::Message for CMsgDOTAClaimEventActionResponse_GrantedRewardData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.grant_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reward_index = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.reward_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.grant_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reward_index {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.reward_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.grant_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.score_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.reward_index {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.reward_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAClaimEventActionResponse_GrantedRewardData {
    fn new() -> CMsgDOTAClaimEventActionResponse_GrantedRewardData {
        CMsgDOTAClaimEventActionResponse_GrantedRewardData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAClaimEventActionResponse_GrantedRewardData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "grant_index",
                    CMsgDOTAClaimEventActionResponse_GrantedRewardData::get_grant_index_for_reflect,
                    CMsgDOTAClaimEventActionResponse_GrantedRewardData::mut_grant_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "score_index",
                    CMsgDOTAClaimEventActionResponse_GrantedRewardData::get_score_index_for_reflect,
                    CMsgDOTAClaimEventActionResponse_GrantedRewardData::mut_score_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reward_index",
                    CMsgDOTAClaimEventActionResponse_GrantedRewardData::get_reward_index_for_reflect,
                    CMsgDOTAClaimEventActionResponse_GrantedRewardData::mut_reward_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "reward_data",
                    CMsgDOTAClaimEventActionResponse_GrantedRewardData::get_reward_data_for_reflect,
                    CMsgDOTAClaimEventActionResponse_GrantedRewardData::mut_reward_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAClaimEventActionResponse_GrantedRewardData>(
                    "CMsgDOTAClaimEventActionResponse_GrantedRewardData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAClaimEventActionResponse_GrantedRewardData {
    fn clear(&mut self) {
        self.clear_grant_index();
        self.clear_score_index();
        self.clear_reward_index();
        self.clear_reward_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAClaimEventActionResponse_GrantedRewardData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAClaimEventActionResponse_GrantedRewardData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAClaimEventActionResponse_ResultCode {
    Success = 0,
    InvalidEvent = 1,
    EventNotActive = 2,
    InvalidAction = 3,
    ServerError = 4,
    InsufficientPoints = 5,
    InsufficentLevel = 6,
    AlreadyClaimed = 7,
    SDOLockFailure = 8,
    SDOLoadFailure = 9,
    EventNotOwned = 10,
    Timeout = 11,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAClaimEventActionResponse_ResultCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAClaimEventActionResponse_ResultCode> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAClaimEventActionResponse_ResultCode::Success),
            1 => ::std::option::Option::Some(CMsgDOTAClaimEventActionResponse_ResultCode::InvalidEvent),
            2 => ::std::option::Option::Some(CMsgDOTAClaimEventActionResponse_ResultCode::EventNotActive),
            3 => ::std::option::Option::Some(CMsgDOTAClaimEventActionResponse_ResultCode::InvalidAction),
            4 => ::std::option::Option::Some(CMsgDOTAClaimEventActionResponse_ResultCode::ServerError),
            5 => ::std::option::Option::Some(CMsgDOTAClaimEventActionResponse_ResultCode::InsufficientPoints),
            6 => ::std::option::Option::Some(CMsgDOTAClaimEventActionResponse_ResultCode::InsufficentLevel),
            7 => ::std::option::Option::Some(CMsgDOTAClaimEventActionResponse_ResultCode::AlreadyClaimed),
            8 => ::std::option::Option::Some(CMsgDOTAClaimEventActionResponse_ResultCode::SDOLockFailure),
            9 => ::std::option::Option::Some(CMsgDOTAClaimEventActionResponse_ResultCode::SDOLoadFailure),
            10 => ::std::option::Option::Some(CMsgDOTAClaimEventActionResponse_ResultCode::EventNotOwned),
            11 => ::std::option::Option::Some(CMsgDOTAClaimEventActionResponse_ResultCode::Timeout),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAClaimEventActionResponse_ResultCode] = &[
            CMsgDOTAClaimEventActionResponse_ResultCode::Success,
            CMsgDOTAClaimEventActionResponse_ResultCode::InvalidEvent,
            CMsgDOTAClaimEventActionResponse_ResultCode::EventNotActive,
            CMsgDOTAClaimEventActionResponse_ResultCode::InvalidAction,
            CMsgDOTAClaimEventActionResponse_ResultCode::ServerError,
            CMsgDOTAClaimEventActionResponse_ResultCode::InsufficientPoints,
            CMsgDOTAClaimEventActionResponse_ResultCode::InsufficentLevel,
            CMsgDOTAClaimEventActionResponse_ResultCode::AlreadyClaimed,
            CMsgDOTAClaimEventActionResponse_ResultCode::SDOLockFailure,
            CMsgDOTAClaimEventActionResponse_ResultCode::SDOLoadFailure,
            CMsgDOTAClaimEventActionResponse_ResultCode::EventNotOwned,
            CMsgDOTAClaimEventActionResponse_ResultCode::Timeout,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAClaimEventActionResponse_ResultCode>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAClaimEventActionResponse_ResultCode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAClaimEventActionResponse_ResultCode {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAClaimEventActionResponse_ResultCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAGetEventPoints {
    // message fields
    event_id: ::std::option::Option<u32>,
    account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAGetEventPoints {}

impl CMsgDOTAGetEventPoints {
    pub fn new() -> CMsgDOTAGetEventPoints {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAGetEventPoints {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAGetEventPoints> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAGetEventPoints,
        };
        unsafe {
            instance.get(CMsgDOTAGetEventPoints::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // optional uint32 account_id = 2;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgDOTAGetEventPoints {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAGetEventPoints {
    fn new() -> CMsgDOTAGetEventPoints {
        CMsgDOTAGetEventPoints::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAGetEventPoints>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgDOTAGetEventPoints::get_event_id_for_reflect,
                    CMsgDOTAGetEventPoints::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAGetEventPoints::get_account_id_for_reflect,
                    CMsgDOTAGetEventPoints::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAGetEventPoints>(
                    "CMsgDOTAGetEventPoints",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAGetEventPoints {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAGetEventPoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAGetEventPoints {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAGetEventPointsResponse {
    // message fields
    total_points: ::std::option::Option<u32>,
    total_premium_points: ::std::option::Option<u32>,
    event_id: ::std::option::Option<u32>,
    points: ::std::option::Option<u32>,
    premium_points: ::std::option::Option<u32>,
    completed_actions: ::protobuf::RepeatedField<CMsgDOTAGetEventPointsResponse_Action>,
    account_id: ::std::option::Option<u32>,
    owned: ::std::option::Option<bool>,
    audit_action: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAGetEventPointsResponse {}

impl CMsgDOTAGetEventPointsResponse {
    pub fn new() -> CMsgDOTAGetEventPointsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAGetEventPointsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAGetEventPointsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAGetEventPointsResponse,
        };
        unsafe {
            instance.get(CMsgDOTAGetEventPointsResponse::new)
        }
    }

    // optional uint32 total_points = 1;

    pub fn clear_total_points(&mut self) {
        self.total_points = ::std::option::Option::None;
    }

    pub fn has_total_points(&self) -> bool {
        self.total_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_points(&mut self, v: u32) {
        self.total_points = ::std::option::Option::Some(v);
    }

    pub fn get_total_points(&self) -> u32 {
        self.total_points.unwrap_or(0)
    }

    fn get_total_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_points
    }

    fn mut_total_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_points
    }

    // optional uint32 total_premium_points = 2;

    pub fn clear_total_premium_points(&mut self) {
        self.total_premium_points = ::std::option::Option::None;
    }

    pub fn has_total_premium_points(&self) -> bool {
        self.total_premium_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_premium_points(&mut self, v: u32) {
        self.total_premium_points = ::std::option::Option::Some(v);
    }

    pub fn get_total_premium_points(&self) -> u32 {
        self.total_premium_points.unwrap_or(0)
    }

    fn get_total_premium_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_premium_points
    }

    fn mut_total_premium_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_premium_points
    }

    // optional uint32 event_id = 3;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // optional uint32 points = 4;

    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: u32) {
        self.points = ::std::option::Option::Some(v);
    }

    pub fn get_points(&self) -> u32 {
        self.points.unwrap_or(0)
    }

    fn get_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points
    }

    fn mut_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points
    }

    // optional uint32 premium_points = 5;

    pub fn clear_premium_points(&mut self) {
        self.premium_points = ::std::option::Option::None;
    }

    pub fn has_premium_points(&self) -> bool {
        self.premium_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_premium_points(&mut self, v: u32) {
        self.premium_points = ::std::option::Option::Some(v);
    }

    pub fn get_premium_points(&self) -> u32 {
        self.premium_points.unwrap_or(0)
    }

    fn get_premium_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.premium_points
    }

    fn mut_premium_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.premium_points
    }

    // repeated .CMsgDOTAGetEventPointsResponse.Action completed_actions = 6;

    pub fn clear_completed_actions(&mut self) {
        self.completed_actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_completed_actions(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAGetEventPointsResponse_Action>) {
        self.completed_actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_completed_actions(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAGetEventPointsResponse_Action> {
        &mut self.completed_actions
    }

    // Take field
    pub fn take_completed_actions(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAGetEventPointsResponse_Action> {
        ::std::mem::replace(&mut self.completed_actions, ::protobuf::RepeatedField::new())
    }

    pub fn get_completed_actions(&self) -> &[CMsgDOTAGetEventPointsResponse_Action] {
        &self.completed_actions
    }

    fn get_completed_actions_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAGetEventPointsResponse_Action> {
        &self.completed_actions
    }

    fn mut_completed_actions_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAGetEventPointsResponse_Action> {
        &mut self.completed_actions
    }

    // optional uint32 account_id = 7;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional bool owned = 8;

    pub fn clear_owned(&mut self) {
        self.owned = ::std::option::Option::None;
    }

    pub fn has_owned(&self) -> bool {
        self.owned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owned(&mut self, v: bool) {
        self.owned = ::std::option::Option::Some(v);
    }

    pub fn get_owned(&self) -> bool {
        self.owned.unwrap_or(false)
    }

    fn get_owned_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.owned
    }

    fn mut_owned_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.owned
    }

    // optional uint32 audit_action = 9;

    pub fn clear_audit_action(&mut self) {
        self.audit_action = ::std::option::Option::None;
    }

    pub fn has_audit_action(&self) -> bool {
        self.audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_action(&mut self, v: u32) {
        self.audit_action = ::std::option::Option::Some(v);
    }

    pub fn get_audit_action(&self) -> u32 {
        self.audit_action.unwrap_or(0)
    }

    fn get_audit_action_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.audit_action
    }

    fn mut_audit_action_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.audit_action
    }
}

impl ::protobuf::Message for CMsgDOTAGetEventPointsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.completed_actions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_points = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_premium_points = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.premium_points = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.completed_actions)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.owned = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.audit_action = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.total_points {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_premium_points {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.premium_points {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.completed_actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owned {
            my_size += 2;
        }
        if let Some(v) = self.audit_action {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.total_points {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.total_premium_points {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.points {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.premium_points {
            os.write_uint32(5, v)?;
        }
        for v in &self.completed_actions {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.account_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.owned {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.audit_action {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAGetEventPointsResponse {
    fn new() -> CMsgDOTAGetEventPointsResponse {
        CMsgDOTAGetEventPointsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAGetEventPointsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_points",
                    CMsgDOTAGetEventPointsResponse::get_total_points_for_reflect,
                    CMsgDOTAGetEventPointsResponse::mut_total_points_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_premium_points",
                    CMsgDOTAGetEventPointsResponse::get_total_premium_points_for_reflect,
                    CMsgDOTAGetEventPointsResponse::mut_total_premium_points_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgDOTAGetEventPointsResponse::get_event_id_for_reflect,
                    CMsgDOTAGetEventPointsResponse::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points",
                    CMsgDOTAGetEventPointsResponse::get_points_for_reflect,
                    CMsgDOTAGetEventPointsResponse::mut_points_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "premium_points",
                    CMsgDOTAGetEventPointsResponse::get_premium_points_for_reflect,
                    CMsgDOTAGetEventPointsResponse::mut_premium_points_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAGetEventPointsResponse_Action>>(
                    "completed_actions",
                    CMsgDOTAGetEventPointsResponse::get_completed_actions_for_reflect,
                    CMsgDOTAGetEventPointsResponse::mut_completed_actions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAGetEventPointsResponse::get_account_id_for_reflect,
                    CMsgDOTAGetEventPointsResponse::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "owned",
                    CMsgDOTAGetEventPointsResponse::get_owned_for_reflect,
                    CMsgDOTAGetEventPointsResponse::mut_owned_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "audit_action",
                    CMsgDOTAGetEventPointsResponse::get_audit_action_for_reflect,
                    CMsgDOTAGetEventPointsResponse::mut_audit_action_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAGetEventPointsResponse>(
                    "CMsgDOTAGetEventPointsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAGetEventPointsResponse {
    fn clear(&mut self) {
        self.clear_total_points();
        self.clear_total_premium_points();
        self.clear_event_id();
        self.clear_points();
        self.clear_premium_points();
        self.clear_completed_actions();
        self.clear_account_id();
        self.clear_owned();
        self.clear_audit_action();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAGetEventPointsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAGetEventPointsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAGetEventPointsResponse_Action {
    // message fields
    action_id: ::std::option::Option<u32>,
    times_completed: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAGetEventPointsResponse_Action {}

impl CMsgDOTAGetEventPointsResponse_Action {
    pub fn new() -> CMsgDOTAGetEventPointsResponse_Action {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAGetEventPointsResponse_Action {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAGetEventPointsResponse_Action> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAGetEventPointsResponse_Action,
        };
        unsafe {
            instance.get(CMsgDOTAGetEventPointsResponse_Action::new)
        }
    }

    // optional uint32 action_id = 1;

    pub fn clear_action_id(&mut self) {
        self.action_id = ::std::option::Option::None;
    }

    pub fn has_action_id(&self) -> bool {
        self.action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = ::std::option::Option::Some(v);
    }

    pub fn get_action_id(&self) -> u32 {
        self.action_id.unwrap_or(0)
    }

    fn get_action_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.action_id
    }

    fn mut_action_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.action_id
    }

    // optional uint32 times_completed = 2;

    pub fn clear_times_completed(&mut self) {
        self.times_completed = ::std::option::Option::None;
    }

    pub fn has_times_completed(&self) -> bool {
        self.times_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_times_completed(&mut self, v: u32) {
        self.times_completed = ::std::option::Option::Some(v);
    }

    pub fn get_times_completed(&self) -> u32 {
        self.times_completed.unwrap_or(1u32)
    }

    fn get_times_completed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.times_completed
    }

    fn mut_times_completed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.times_completed
    }
}

impl ::protobuf::Message for CMsgDOTAGetEventPointsResponse_Action {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.action_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.times_completed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.times_completed {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.times_completed {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAGetEventPointsResponse_Action {
    fn new() -> CMsgDOTAGetEventPointsResponse_Action {
        CMsgDOTAGetEventPointsResponse_Action::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAGetEventPointsResponse_Action>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "action_id",
                    CMsgDOTAGetEventPointsResponse_Action::get_action_id_for_reflect,
                    CMsgDOTAGetEventPointsResponse_Action::mut_action_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "times_completed",
                    CMsgDOTAGetEventPointsResponse_Action::get_times_completed_for_reflect,
                    CMsgDOTAGetEventPointsResponse_Action::mut_times_completed_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAGetEventPointsResponse_Action>(
                    "CMsgDOTAGetEventPointsResponse_Action",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAGetEventPointsResponse_Action {
    fn clear(&mut self) {
        self.clear_action_id();
        self.clear_times_completed();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAGetEventPointsResponse_Action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAGetEventPointsResponse_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAGetPeriodicResource {
    // message fields
    account_id: ::std::option::Option<u32>,
    periodic_resource_id: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAGetPeriodicResource {}

impl CMsgDOTAGetPeriodicResource {
    pub fn new() -> CMsgDOTAGetPeriodicResource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAGetPeriodicResource {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAGetPeriodicResource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAGetPeriodicResource,
        };
        unsafe {
            instance.get(CMsgDOTAGetPeriodicResource::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 periodic_resource_id = 2;

    pub fn clear_periodic_resource_id(&mut self) {
        self.periodic_resource_id = ::std::option::Option::None;
    }

    pub fn has_periodic_resource_id(&self) -> bool {
        self.periodic_resource_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_periodic_resource_id(&mut self, v: u32) {
        self.periodic_resource_id = ::std::option::Option::Some(v);
    }

    pub fn get_periodic_resource_id(&self) -> u32 {
        self.periodic_resource_id.unwrap_or(0)
    }

    fn get_periodic_resource_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.periodic_resource_id
    }

    fn mut_periodic_resource_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.periodic_resource_id
    }

    // optional uint32 timestamp = 3;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }
}

impl ::protobuf::Message for CMsgDOTAGetPeriodicResource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.periodic_resource_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.periodic_resource_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.periodic_resource_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAGetPeriodicResource {
    fn new() -> CMsgDOTAGetPeriodicResource {
        CMsgDOTAGetPeriodicResource::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAGetPeriodicResource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAGetPeriodicResource::get_account_id_for_reflect,
                    CMsgDOTAGetPeriodicResource::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "periodic_resource_id",
                    CMsgDOTAGetPeriodicResource::get_periodic_resource_id_for_reflect,
                    CMsgDOTAGetPeriodicResource::mut_periodic_resource_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgDOTAGetPeriodicResource::get_timestamp_for_reflect,
                    CMsgDOTAGetPeriodicResource::mut_timestamp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAGetPeriodicResource>(
                    "CMsgDOTAGetPeriodicResource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAGetPeriodicResource {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_periodic_resource_id();
        self.clear_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAGetPeriodicResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAGetPeriodicResource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAGetPeriodicResourceResponse {
    // message fields
    periodic_resource_max: ::std::option::Option<u32>,
    periodic_resource_used: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAGetPeriodicResourceResponse {}

impl CMsgDOTAGetPeriodicResourceResponse {
    pub fn new() -> CMsgDOTAGetPeriodicResourceResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAGetPeriodicResourceResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAGetPeriodicResourceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAGetPeriodicResourceResponse,
        };
        unsafe {
            instance.get(CMsgDOTAGetPeriodicResourceResponse::new)
        }
    }

    // optional uint32 periodic_resource_max = 1;

    pub fn clear_periodic_resource_max(&mut self) {
        self.periodic_resource_max = ::std::option::Option::None;
    }

    pub fn has_periodic_resource_max(&self) -> bool {
        self.periodic_resource_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_periodic_resource_max(&mut self, v: u32) {
        self.periodic_resource_max = ::std::option::Option::Some(v);
    }

    pub fn get_periodic_resource_max(&self) -> u32 {
        self.periodic_resource_max.unwrap_or(0)
    }

    fn get_periodic_resource_max_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.periodic_resource_max
    }

    fn mut_periodic_resource_max_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.periodic_resource_max
    }

    // optional uint32 periodic_resource_used = 2;

    pub fn clear_periodic_resource_used(&mut self) {
        self.periodic_resource_used = ::std::option::Option::None;
    }

    pub fn has_periodic_resource_used(&self) -> bool {
        self.periodic_resource_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_periodic_resource_used(&mut self, v: u32) {
        self.periodic_resource_used = ::std::option::Option::Some(v);
    }

    pub fn get_periodic_resource_used(&self) -> u32 {
        self.periodic_resource_used.unwrap_or(0)
    }

    fn get_periodic_resource_used_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.periodic_resource_used
    }

    fn mut_periodic_resource_used_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.periodic_resource_used
    }
}

impl ::protobuf::Message for CMsgDOTAGetPeriodicResourceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.periodic_resource_max = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.periodic_resource_used = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.periodic_resource_max {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.periodic_resource_used {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.periodic_resource_max {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.periodic_resource_used {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAGetPeriodicResourceResponse {
    fn new() -> CMsgDOTAGetPeriodicResourceResponse {
        CMsgDOTAGetPeriodicResourceResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAGetPeriodicResourceResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "periodic_resource_max",
                    CMsgDOTAGetPeriodicResourceResponse::get_periodic_resource_max_for_reflect,
                    CMsgDOTAGetPeriodicResourceResponse::mut_periodic_resource_max_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "periodic_resource_used",
                    CMsgDOTAGetPeriodicResourceResponse::get_periodic_resource_used_for_reflect,
                    CMsgDOTAGetPeriodicResourceResponse::mut_periodic_resource_used_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAGetPeriodicResourceResponse>(
                    "CMsgDOTAGetPeriodicResourceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAGetPeriodicResourceResponse {
    fn clear(&mut self) {
        self.clear_periodic_resource_max();
        self.clear_periodic_resource_used();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAGetPeriodicResourceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAGetPeriodicResourceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAPeriodicResourceUpdated {
    // message fields
    periodic_resource_key: ::protobuf::SingularPtrField<CMsgDOTAGetPeriodicResource>,
    periodic_resource_value: ::protobuf::SingularPtrField<CMsgDOTAGetPeriodicResourceResponse>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAPeriodicResourceUpdated {}

impl CMsgDOTAPeriodicResourceUpdated {
    pub fn new() -> CMsgDOTAPeriodicResourceUpdated {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAPeriodicResourceUpdated {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAPeriodicResourceUpdated> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAPeriodicResourceUpdated,
        };
        unsafe {
            instance.get(CMsgDOTAPeriodicResourceUpdated::new)
        }
    }

    // optional .CMsgDOTAGetPeriodicResource periodic_resource_key = 1;

    pub fn clear_periodic_resource_key(&mut self) {
        self.periodic_resource_key.clear();
    }

    pub fn has_periodic_resource_key(&self) -> bool {
        self.periodic_resource_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_periodic_resource_key(&mut self, v: CMsgDOTAGetPeriodicResource) {
        self.periodic_resource_key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_periodic_resource_key(&mut self) -> &mut CMsgDOTAGetPeriodicResource {
        if self.periodic_resource_key.is_none() {
            self.periodic_resource_key.set_default();
        }
        self.periodic_resource_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_periodic_resource_key(&mut self) -> CMsgDOTAGetPeriodicResource {
        self.periodic_resource_key.take().unwrap_or_else(|| CMsgDOTAGetPeriodicResource::new())
    }

    pub fn get_periodic_resource_key(&self) -> &CMsgDOTAGetPeriodicResource {
        self.periodic_resource_key.as_ref().unwrap_or_else(|| CMsgDOTAGetPeriodicResource::default_instance())
    }

    fn get_periodic_resource_key_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAGetPeriodicResource> {
        &self.periodic_resource_key
    }

    fn mut_periodic_resource_key_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAGetPeriodicResource> {
        &mut self.periodic_resource_key
    }

    // optional .CMsgDOTAGetPeriodicResourceResponse periodic_resource_value = 2;

    pub fn clear_periodic_resource_value(&mut self) {
        self.periodic_resource_value.clear();
    }

    pub fn has_periodic_resource_value(&self) -> bool {
        self.periodic_resource_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_periodic_resource_value(&mut self, v: CMsgDOTAGetPeriodicResourceResponse) {
        self.periodic_resource_value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_periodic_resource_value(&mut self) -> &mut CMsgDOTAGetPeriodicResourceResponse {
        if self.periodic_resource_value.is_none() {
            self.periodic_resource_value.set_default();
        }
        self.periodic_resource_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_periodic_resource_value(&mut self) -> CMsgDOTAGetPeriodicResourceResponse {
        self.periodic_resource_value.take().unwrap_or_else(|| CMsgDOTAGetPeriodicResourceResponse::new())
    }

    pub fn get_periodic_resource_value(&self) -> &CMsgDOTAGetPeriodicResourceResponse {
        self.periodic_resource_value.as_ref().unwrap_or_else(|| CMsgDOTAGetPeriodicResourceResponse::default_instance())
    }

    fn get_periodic_resource_value_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAGetPeriodicResourceResponse> {
        &self.periodic_resource_value
    }

    fn mut_periodic_resource_value_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAGetPeriodicResourceResponse> {
        &mut self.periodic_resource_value
    }
}

impl ::protobuf::Message for CMsgDOTAPeriodicResourceUpdated {
    fn is_initialized(&self) -> bool {
        for v in &self.periodic_resource_key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.periodic_resource_value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.periodic_resource_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.periodic_resource_value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.periodic_resource_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.periodic_resource_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.periodic_resource_key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.periodic_resource_value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAPeriodicResourceUpdated {
    fn new() -> CMsgDOTAPeriodicResourceUpdated {
        CMsgDOTAPeriodicResourceUpdated::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAPeriodicResourceUpdated>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAGetPeriodicResource>>(
                    "periodic_resource_key",
                    CMsgDOTAPeriodicResourceUpdated::get_periodic_resource_key_for_reflect,
                    CMsgDOTAPeriodicResourceUpdated::mut_periodic_resource_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAGetPeriodicResourceResponse>>(
                    "periodic_resource_value",
                    CMsgDOTAPeriodicResourceUpdated::get_periodic_resource_value_for_reflect,
                    CMsgDOTAPeriodicResourceUpdated::mut_periodic_resource_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAPeriodicResourceUpdated>(
                    "CMsgDOTAPeriodicResourceUpdated",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAPeriodicResourceUpdated {
    fn clear(&mut self) {
        self.clear_periodic_resource_key();
        self.clear_periodic_resource_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAPeriodicResourceUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAPeriodicResourceUpdated {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALiveLeagueGameUpdate {
    // message fields
    live_league_games: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALiveLeagueGameUpdate {}

impl CMsgDOTALiveLeagueGameUpdate {
    pub fn new() -> CMsgDOTALiveLeagueGameUpdate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALiveLeagueGameUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALiveLeagueGameUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALiveLeagueGameUpdate,
        };
        unsafe {
            instance.get(CMsgDOTALiveLeagueGameUpdate::new)
        }
    }

    // optional uint32 live_league_games = 1;

    pub fn clear_live_league_games(&mut self) {
        self.live_league_games = ::std::option::Option::None;
    }

    pub fn has_live_league_games(&self) -> bool {
        self.live_league_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_live_league_games(&mut self, v: u32) {
        self.live_league_games = ::std::option::Option::Some(v);
    }

    pub fn get_live_league_games(&self) -> u32 {
        self.live_league_games.unwrap_or(0)
    }

    fn get_live_league_games_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.live_league_games
    }

    fn mut_live_league_games_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.live_league_games
    }
}

impl ::protobuf::Message for CMsgDOTALiveLeagueGameUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.live_league_games = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.live_league_games {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.live_league_games {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALiveLeagueGameUpdate {
    fn new() -> CMsgDOTALiveLeagueGameUpdate {
        CMsgDOTALiveLeagueGameUpdate::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALiveLeagueGameUpdate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "live_league_games",
                    CMsgDOTALiveLeagueGameUpdate::get_live_league_games_for_reflect,
                    CMsgDOTALiveLeagueGameUpdate::mut_live_league_games_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALiveLeagueGameUpdate>(
                    "CMsgDOTALiveLeagueGameUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALiveLeagueGameUpdate {
    fn clear(&mut self) {
        self.clear_live_league_games();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALiveLeagueGameUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALiveLeagueGameUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTACompendiumSelection {
    // message fields
    selection_index: ::std::option::Option<u32>,
    selection: ::std::option::Option<u32>,
    leagueid: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTACompendiumSelection {}

impl CMsgDOTACompendiumSelection {
    pub fn new() -> CMsgDOTACompendiumSelection {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTACompendiumSelection {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTACompendiumSelection> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTACompendiumSelection,
        };
        unsafe {
            instance.get(CMsgDOTACompendiumSelection::new)
        }
    }

    // optional uint32 selection_index = 1;

    pub fn clear_selection_index(&mut self) {
        self.selection_index = ::std::option::Option::None;
    }

    pub fn has_selection_index(&self) -> bool {
        self.selection_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_index(&mut self, v: u32) {
        self.selection_index = ::std::option::Option::Some(v);
    }

    pub fn get_selection_index(&self) -> u32 {
        self.selection_index.unwrap_or(0)
    }

    fn get_selection_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.selection_index
    }

    fn mut_selection_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.selection_index
    }

    // optional uint32 selection = 2;

    pub fn clear_selection(&mut self) {
        self.selection = ::std::option::Option::None;
    }

    pub fn has_selection(&self) -> bool {
        self.selection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection(&mut self, v: u32) {
        self.selection = ::std::option::Option::Some(v);
    }

    pub fn get_selection(&self) -> u32 {
        self.selection.unwrap_or(0)
    }

    fn get_selection_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.selection
    }

    fn mut_selection_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.selection
    }

    // optional uint32 leagueid = 3;

    pub fn clear_leagueid(&mut self) {
        self.leagueid = ::std::option::Option::None;
    }

    pub fn has_leagueid(&self) -> bool {
        self.leagueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leagueid(&mut self, v: u32) {
        self.leagueid = ::std::option::Option::Some(v);
    }

    pub fn get_leagueid(&self) -> u32 {
        self.leagueid.unwrap_or(0)
    }

    fn get_leagueid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.leagueid
    }

    fn mut_leagueid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.leagueid
    }
}

impl ::protobuf::Message for CMsgDOTACompendiumSelection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.selection_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.selection = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leagueid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.selection_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.selection {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leagueid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.selection_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.selection {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.leagueid {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTACompendiumSelection {
    fn new() -> CMsgDOTACompendiumSelection {
        CMsgDOTACompendiumSelection::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTACompendiumSelection>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "selection_index",
                    CMsgDOTACompendiumSelection::get_selection_index_for_reflect,
                    CMsgDOTACompendiumSelection::mut_selection_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "selection",
                    CMsgDOTACompendiumSelection::get_selection_for_reflect,
                    CMsgDOTACompendiumSelection::mut_selection_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "leagueid",
                    CMsgDOTACompendiumSelection::get_leagueid_for_reflect,
                    CMsgDOTACompendiumSelection::mut_leagueid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTACompendiumSelection>(
                    "CMsgDOTACompendiumSelection",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTACompendiumSelection {
    fn clear(&mut self) {
        self.clear_selection_index();
        self.clear_selection();
        self.clear_leagueid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTACompendiumSelection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTACompendiumSelection {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTACompendiumSelectionResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    extra_selections: ::protobuf::RepeatedField<CMsgDOTACompendiumSelection>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTACompendiumSelectionResponse {}

impl CMsgDOTACompendiumSelectionResponse {
    pub fn new() -> CMsgDOTACompendiumSelectionResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTACompendiumSelectionResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTACompendiumSelectionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTACompendiumSelectionResponse,
        };
        unsafe {
            instance.get(CMsgDOTACompendiumSelectionResponse::new)
        }
    }

    // optional uint32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    fn get_eresult_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.eresult
    }

    fn mut_eresult_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.eresult
    }

    // repeated .CMsgDOTACompendiumSelection extra_selections = 2;

    pub fn clear_extra_selections(&mut self) {
        self.extra_selections.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_selections(&mut self, v: ::protobuf::RepeatedField<CMsgDOTACompendiumSelection>) {
        self.extra_selections = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_selections(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTACompendiumSelection> {
        &mut self.extra_selections
    }

    // Take field
    pub fn take_extra_selections(&mut self) -> ::protobuf::RepeatedField<CMsgDOTACompendiumSelection> {
        ::std::mem::replace(&mut self.extra_selections, ::protobuf::RepeatedField::new())
    }

    pub fn get_extra_selections(&self) -> &[CMsgDOTACompendiumSelection] {
        &self.extra_selections
    }

    fn get_extra_selections_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTACompendiumSelection> {
        &self.extra_selections
    }

    fn mut_extra_selections_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTACompendiumSelection> {
        &mut self.extra_selections
    }
}

impl ::protobuf::Message for CMsgDOTACompendiumSelectionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.extra_selections {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extra_selections)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.extra_selections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        for v in &self.extra_selections {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTACompendiumSelectionResponse {
    fn new() -> CMsgDOTACompendiumSelectionResponse {
        CMsgDOTACompendiumSelectionResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTACompendiumSelectionResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "eresult",
                    CMsgDOTACompendiumSelectionResponse::get_eresult_for_reflect,
                    CMsgDOTACompendiumSelectionResponse::mut_eresult_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTACompendiumSelection>>(
                    "extra_selections",
                    CMsgDOTACompendiumSelectionResponse::get_extra_selections_for_reflect,
                    CMsgDOTACompendiumSelectionResponse::mut_extra_selections_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTACompendiumSelectionResponse>(
                    "CMsgDOTACompendiumSelectionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTACompendiumSelectionResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_extra_selections();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTACompendiumSelectionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTACompendiumSelectionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTACompendiumData {
    // message fields
    selections: ::protobuf::RepeatedField<CMsgDOTACompendiumSelection>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTACompendiumData {}

impl CMsgDOTACompendiumData {
    pub fn new() -> CMsgDOTACompendiumData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTACompendiumData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTACompendiumData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTACompendiumData,
        };
        unsafe {
            instance.get(CMsgDOTACompendiumData::new)
        }
    }

    // repeated .CMsgDOTACompendiumSelection selections = 1;

    pub fn clear_selections(&mut self) {
        self.selections.clear();
    }

    // Param is passed by value, moved
    pub fn set_selections(&mut self, v: ::protobuf::RepeatedField<CMsgDOTACompendiumSelection>) {
        self.selections = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selections(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTACompendiumSelection> {
        &mut self.selections
    }

    // Take field
    pub fn take_selections(&mut self) -> ::protobuf::RepeatedField<CMsgDOTACompendiumSelection> {
        ::std::mem::replace(&mut self.selections, ::protobuf::RepeatedField::new())
    }

    pub fn get_selections(&self) -> &[CMsgDOTACompendiumSelection] {
        &self.selections
    }

    fn get_selections_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTACompendiumSelection> {
        &self.selections
    }

    fn mut_selections_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTACompendiumSelection> {
        &mut self.selections
    }
}

impl ::protobuf::Message for CMsgDOTACompendiumData {
    fn is_initialized(&self) -> bool {
        for v in &self.selections {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.selections)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.selections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.selections {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTACompendiumData {
    fn new() -> CMsgDOTACompendiumData {
        CMsgDOTACompendiumData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTACompendiumData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTACompendiumSelection>>(
                    "selections",
                    CMsgDOTACompendiumData::get_selections_for_reflect,
                    CMsgDOTACompendiumData::mut_selections_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTACompendiumData>(
                    "CMsgDOTACompendiumData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTACompendiumData {
    fn clear(&mut self) {
        self.clear_selections();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTACompendiumData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTACompendiumData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTACompendiumDataRequest {
    // message fields
    account_id: ::std::option::Option<u32>,
    leagueid: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTACompendiumDataRequest {}

impl CMsgDOTACompendiumDataRequest {
    pub fn new() -> CMsgDOTACompendiumDataRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTACompendiumDataRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTACompendiumDataRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTACompendiumDataRequest,
        };
        unsafe {
            instance.get(CMsgDOTACompendiumDataRequest::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 leagueid = 2;

    pub fn clear_leagueid(&mut self) {
        self.leagueid = ::std::option::Option::None;
    }

    pub fn has_leagueid(&self) -> bool {
        self.leagueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leagueid(&mut self, v: u32) {
        self.leagueid = ::std::option::Option::Some(v);
    }

    pub fn get_leagueid(&self) -> u32 {
        self.leagueid.unwrap_or(0)
    }

    fn get_leagueid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.leagueid
    }

    fn mut_leagueid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.leagueid
    }
}

impl ::protobuf::Message for CMsgDOTACompendiumDataRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leagueid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leagueid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.leagueid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTACompendiumDataRequest {
    fn new() -> CMsgDOTACompendiumDataRequest {
        CMsgDOTACompendiumDataRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTACompendiumDataRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTACompendiumDataRequest::get_account_id_for_reflect,
                    CMsgDOTACompendiumDataRequest::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "leagueid",
                    CMsgDOTACompendiumDataRequest::get_leagueid_for_reflect,
                    CMsgDOTACompendiumDataRequest::mut_leagueid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTACompendiumDataRequest>(
                    "CMsgDOTACompendiumDataRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTACompendiumDataRequest {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_leagueid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTACompendiumDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTACompendiumDataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTACompendiumDataResponse {
    // message fields
    account_id: ::std::option::Option<u32>,
    leagueid: ::std::option::Option<u32>,
    result: ::std::option::Option<u32>,
    compendium_data: ::protobuf::SingularPtrField<CMsgDOTACompendiumData>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTACompendiumDataResponse {}

impl CMsgDOTACompendiumDataResponse {
    pub fn new() -> CMsgDOTACompendiumDataResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTACompendiumDataResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTACompendiumDataResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTACompendiumDataResponse,
        };
        unsafe {
            instance.get(CMsgDOTACompendiumDataResponse::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 leagueid = 2;

    pub fn clear_leagueid(&mut self) {
        self.leagueid = ::std::option::Option::None;
    }

    pub fn has_leagueid(&self) -> bool {
        self.leagueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leagueid(&mut self, v: u32) {
        self.leagueid = ::std::option::Option::Some(v);
    }

    pub fn get_leagueid(&self) -> u32 {
        self.leagueid.unwrap_or(0)
    }

    fn get_leagueid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.leagueid
    }

    fn mut_leagueid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.leagueid
    }

    // optional uint32 result = 3;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(2u32)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.result
    }

    // optional .CMsgDOTACompendiumData compendium_data = 4;

    pub fn clear_compendium_data(&mut self) {
        self.compendium_data.clear();
    }

    pub fn has_compendium_data(&self) -> bool {
        self.compendium_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compendium_data(&mut self, v: CMsgDOTACompendiumData) {
        self.compendium_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compendium_data(&mut self) -> &mut CMsgDOTACompendiumData {
        if self.compendium_data.is_none() {
            self.compendium_data.set_default();
        }
        self.compendium_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_compendium_data(&mut self) -> CMsgDOTACompendiumData {
        self.compendium_data.take().unwrap_or_else(|| CMsgDOTACompendiumData::new())
    }

    pub fn get_compendium_data(&self) -> &CMsgDOTACompendiumData {
        self.compendium_data.as_ref().unwrap_or_else(|| CMsgDOTACompendiumData::default_instance())
    }

    fn get_compendium_data_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTACompendiumData> {
        &self.compendium_data
    }

    fn mut_compendium_data_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTACompendiumData> {
        &mut self.compendium_data
    }
}

impl ::protobuf::Message for CMsgDOTACompendiumDataResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.compendium_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leagueid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.compendium_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leagueid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.compendium_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.leagueid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.result {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.compendium_data.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTACompendiumDataResponse {
    fn new() -> CMsgDOTACompendiumDataResponse {
        CMsgDOTACompendiumDataResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTACompendiumDataResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTACompendiumDataResponse::get_account_id_for_reflect,
                    CMsgDOTACompendiumDataResponse::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "leagueid",
                    CMsgDOTACompendiumDataResponse::get_leagueid_for_reflect,
                    CMsgDOTACompendiumDataResponse::mut_leagueid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "result",
                    CMsgDOTACompendiumDataResponse::get_result_for_reflect,
                    CMsgDOTACompendiumDataResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTACompendiumData>>(
                    "compendium_data",
                    CMsgDOTACompendiumDataResponse::get_compendium_data_for_reflect,
                    CMsgDOTACompendiumDataResponse::mut_compendium_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTACompendiumDataResponse>(
                    "CMsgDOTACompendiumDataResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTACompendiumDataResponse {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_leagueid();
        self.clear_result();
        self.clear_compendium_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTACompendiumDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTACompendiumDataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAGetPlayerMatchHistory {
    // message fields
    account_id: ::std::option::Option<u32>,
    start_at_match_id: ::std::option::Option<u64>,
    matches_requested: ::std::option::Option<u32>,
    hero_id: ::std::option::Option<u32>,
    request_id: ::std::option::Option<u32>,
    include_practice_matches: ::std::option::Option<bool>,
    include_custom_games: ::std::option::Option<bool>,
    include_event_games: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAGetPlayerMatchHistory {}

impl CMsgDOTAGetPlayerMatchHistory {
    pub fn new() -> CMsgDOTAGetPlayerMatchHistory {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAGetPlayerMatchHistory {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAGetPlayerMatchHistory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAGetPlayerMatchHistory,
        };
        unsafe {
            instance.get(CMsgDOTAGetPlayerMatchHistory::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint64 start_at_match_id = 2;

    pub fn clear_start_at_match_id(&mut self) {
        self.start_at_match_id = ::std::option::Option::None;
    }

    pub fn has_start_at_match_id(&self) -> bool {
        self.start_at_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_at_match_id(&mut self, v: u64) {
        self.start_at_match_id = ::std::option::Option::Some(v);
    }

    pub fn get_start_at_match_id(&self) -> u64 {
        self.start_at_match_id.unwrap_or(0)
    }

    fn get_start_at_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.start_at_match_id
    }

    fn mut_start_at_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.start_at_match_id
    }

    // optional uint32 matches_requested = 3;

    pub fn clear_matches_requested(&mut self) {
        self.matches_requested = ::std::option::Option::None;
    }

    pub fn has_matches_requested(&self) -> bool {
        self.matches_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matches_requested(&mut self, v: u32) {
        self.matches_requested = ::std::option::Option::Some(v);
    }

    pub fn get_matches_requested(&self) -> u32 {
        self.matches_requested.unwrap_or(0)
    }

    fn get_matches_requested_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.matches_requested
    }

    fn mut_matches_requested_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.matches_requested
    }

    // optional uint32 hero_id = 4;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 request_id = 5;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    fn get_request_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.request_id
    }

    fn mut_request_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.request_id
    }

    // optional bool include_practice_matches = 7;

    pub fn clear_include_practice_matches(&mut self) {
        self.include_practice_matches = ::std::option::Option::None;
    }

    pub fn has_include_practice_matches(&self) -> bool {
        self.include_practice_matches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_practice_matches(&mut self, v: bool) {
        self.include_practice_matches = ::std::option::Option::Some(v);
    }

    pub fn get_include_practice_matches(&self) -> bool {
        self.include_practice_matches.unwrap_or(false)
    }

    fn get_include_practice_matches_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.include_practice_matches
    }

    fn mut_include_practice_matches_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.include_practice_matches
    }

    // optional bool include_custom_games = 8;

    pub fn clear_include_custom_games(&mut self) {
        self.include_custom_games = ::std::option::Option::None;
    }

    pub fn has_include_custom_games(&self) -> bool {
        self.include_custom_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_custom_games(&mut self, v: bool) {
        self.include_custom_games = ::std::option::Option::Some(v);
    }

    pub fn get_include_custom_games(&self) -> bool {
        self.include_custom_games.unwrap_or(false)
    }

    fn get_include_custom_games_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.include_custom_games
    }

    fn mut_include_custom_games_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.include_custom_games
    }

    // optional bool include_event_games = 9;

    pub fn clear_include_event_games(&mut self) {
        self.include_event_games = ::std::option::Option::None;
    }

    pub fn has_include_event_games(&self) -> bool {
        self.include_event_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_event_games(&mut self, v: bool) {
        self.include_event_games = ::std::option::Option::Some(v);
    }

    pub fn get_include_event_games(&self) -> bool {
        self.include_event_games.unwrap_or(false)
    }

    fn get_include_event_games_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.include_event_games
    }

    fn mut_include_event_games_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.include_event_games
    }
}

impl ::protobuf::Message for CMsgDOTAGetPlayerMatchHistory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_at_match_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matches_requested = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_practice_matches = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_custom_games = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_event_games = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_at_match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matches_requested {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.include_practice_matches {
            my_size += 2;
        }
        if let Some(v) = self.include_custom_games {
            my_size += 2;
        }
        if let Some(v) = self.include_event_games {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_at_match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.matches_requested {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.include_practice_matches {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.include_custom_games {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.include_event_games {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAGetPlayerMatchHistory {
    fn new() -> CMsgDOTAGetPlayerMatchHistory {
        CMsgDOTAGetPlayerMatchHistory::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAGetPlayerMatchHistory>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAGetPlayerMatchHistory::get_account_id_for_reflect,
                    CMsgDOTAGetPlayerMatchHistory::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "start_at_match_id",
                    CMsgDOTAGetPlayerMatchHistory::get_start_at_match_id_for_reflect,
                    CMsgDOTAGetPlayerMatchHistory::mut_start_at_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "matches_requested",
                    CMsgDOTAGetPlayerMatchHistory::get_matches_requested_for_reflect,
                    CMsgDOTAGetPlayerMatchHistory::mut_matches_requested_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgDOTAGetPlayerMatchHistory::get_hero_id_for_reflect,
                    CMsgDOTAGetPlayerMatchHistory::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "request_id",
                    CMsgDOTAGetPlayerMatchHistory::get_request_id_for_reflect,
                    CMsgDOTAGetPlayerMatchHistory::mut_request_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "include_practice_matches",
                    CMsgDOTAGetPlayerMatchHistory::get_include_practice_matches_for_reflect,
                    CMsgDOTAGetPlayerMatchHistory::mut_include_practice_matches_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "include_custom_games",
                    CMsgDOTAGetPlayerMatchHistory::get_include_custom_games_for_reflect,
                    CMsgDOTAGetPlayerMatchHistory::mut_include_custom_games_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "include_event_games",
                    CMsgDOTAGetPlayerMatchHistory::get_include_event_games_for_reflect,
                    CMsgDOTAGetPlayerMatchHistory::mut_include_event_games_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAGetPlayerMatchHistory>(
                    "CMsgDOTAGetPlayerMatchHistory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAGetPlayerMatchHistory {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_start_at_match_id();
        self.clear_matches_requested();
        self.clear_hero_id();
        self.clear_request_id();
        self.clear_include_practice_matches();
        self.clear_include_custom_games();
        self.clear_include_event_games();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAGetPlayerMatchHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAGetPlayerMatchHistory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAGetPlayerMatchHistoryResponse {
    // message fields
    matches: ::protobuf::RepeatedField<CMsgDOTAGetPlayerMatchHistoryResponse_Match>,
    request_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAGetPlayerMatchHistoryResponse {}

impl CMsgDOTAGetPlayerMatchHistoryResponse {
    pub fn new() -> CMsgDOTAGetPlayerMatchHistoryResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAGetPlayerMatchHistoryResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAGetPlayerMatchHistoryResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAGetPlayerMatchHistoryResponse,
        };
        unsafe {
            instance.get(CMsgDOTAGetPlayerMatchHistoryResponse::new)
        }
    }

    // repeated .CMsgDOTAGetPlayerMatchHistoryResponse.Match matches = 1;

    pub fn clear_matches(&mut self) {
        self.matches.clear();
    }

    // Param is passed by value, moved
    pub fn set_matches(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAGetPlayerMatchHistoryResponse_Match>) {
        self.matches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matches(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAGetPlayerMatchHistoryResponse_Match> {
        &mut self.matches
    }

    // Take field
    pub fn take_matches(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAGetPlayerMatchHistoryResponse_Match> {
        ::std::mem::replace(&mut self.matches, ::protobuf::RepeatedField::new())
    }

    pub fn get_matches(&self) -> &[CMsgDOTAGetPlayerMatchHistoryResponse_Match] {
        &self.matches
    }

    fn get_matches_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAGetPlayerMatchHistoryResponse_Match> {
        &self.matches
    }

    fn mut_matches_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAGetPlayerMatchHistoryResponse_Match> {
        &mut self.matches
    }

    // optional uint32 request_id = 2;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    fn get_request_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.request_id
    }

    fn mut_request_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.request_id
    }
}

impl ::protobuf::Message for CMsgDOTAGetPlayerMatchHistoryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.matches {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matches)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.matches {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.request_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAGetPlayerMatchHistoryResponse {
    fn new() -> CMsgDOTAGetPlayerMatchHistoryResponse {
        CMsgDOTAGetPlayerMatchHistoryResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAGetPlayerMatchHistoryResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAGetPlayerMatchHistoryResponse_Match>>(
                    "matches",
                    CMsgDOTAGetPlayerMatchHistoryResponse::get_matches_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse::mut_matches_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "request_id",
                    CMsgDOTAGetPlayerMatchHistoryResponse::get_request_id_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse::mut_request_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAGetPlayerMatchHistoryResponse>(
                    "CMsgDOTAGetPlayerMatchHistoryResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAGetPlayerMatchHistoryResponse {
    fn clear(&mut self) {
        self.clear_matches();
        self.clear_request_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAGetPlayerMatchHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAGetPlayerMatchHistoryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAGetPlayerMatchHistoryResponse_Match {
    // message fields
    match_id: ::std::option::Option<u64>,
    start_time: ::std::option::Option<u32>,
    hero_id: ::std::option::Option<u32>,
    winner: ::std::option::Option<bool>,
    game_mode: ::std::option::Option<u32>,
    rank_change: ::std::option::Option<i32>,
    previous_rank: ::std::option::Option<u32>,
    lobby_type: ::std::option::Option<u32>,
    solo_rank: ::std::option::Option<bool>,
    abandon: ::std::option::Option<bool>,
    duration: ::std::option::Option<u32>,
    engine: ::std::option::Option<u32>,
    active_battle_pass: ::std::option::Option<bool>,
    seasonal_rank: ::std::option::Option<bool>,
    tourney_id: ::std::option::Option<u32>,
    tourney_round: ::std::option::Option<u32>,
    tourney_tier: ::std::option::Option<u32>,
    tourney_division: ::std::option::Option<u32>,
    team_id: ::std::option::Option<u32>,
    team_name: ::protobuf::SingularField<::std::string::String>,
    ugc_team_ui_logo: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAGetPlayerMatchHistoryResponse_Match {}

impl CMsgDOTAGetPlayerMatchHistoryResponse_Match {
    pub fn new() -> CMsgDOTAGetPlayerMatchHistoryResponse_Match {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAGetPlayerMatchHistoryResponse_Match {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAGetPlayerMatchHistoryResponse_Match> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAGetPlayerMatchHistoryResponse_Match,
        };
        unsafe {
            instance.get(CMsgDOTAGetPlayerMatchHistoryResponse_Match::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 start_time = 2;

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    pub fn get_start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    fn get_start_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.start_time
    }

    fn mut_start_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.start_time
    }

    // optional uint32 hero_id = 3;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional bool winner = 4;

    pub fn clear_winner(&mut self) {
        self.winner = ::std::option::Option::None;
    }

    pub fn has_winner(&self) -> bool {
        self.winner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winner(&mut self, v: bool) {
        self.winner = ::std::option::Option::Some(v);
    }

    pub fn get_winner(&self) -> bool {
        self.winner.unwrap_or(false)
    }

    fn get_winner_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.winner
    }

    fn mut_winner_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.winner
    }

    // optional uint32 game_mode = 5;

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    pub fn get_game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    fn get_game_mode_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.game_mode
    }

    fn mut_game_mode_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.game_mode
    }

    // optional int32 rank_change = 6;

    pub fn clear_rank_change(&mut self) {
        self.rank_change = ::std::option::Option::None;
    }

    pub fn has_rank_change(&self) -> bool {
        self.rank_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_change(&mut self, v: i32) {
        self.rank_change = ::std::option::Option::Some(v);
    }

    pub fn get_rank_change(&self) -> i32 {
        self.rank_change.unwrap_or(0)
    }

    fn get_rank_change_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.rank_change
    }

    fn mut_rank_change_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.rank_change
    }

    // optional uint32 previous_rank = 7;

    pub fn clear_previous_rank(&mut self) {
        self.previous_rank = ::std::option::Option::None;
    }

    pub fn has_previous_rank(&self) -> bool {
        self.previous_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previous_rank(&mut self, v: u32) {
        self.previous_rank = ::std::option::Option::Some(v);
    }

    pub fn get_previous_rank(&self) -> u32 {
        self.previous_rank.unwrap_or(0)
    }

    fn get_previous_rank_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.previous_rank
    }

    fn mut_previous_rank_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.previous_rank
    }

    // optional uint32 lobby_type = 8;

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    fn get_lobby_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lobby_type
    }

    fn mut_lobby_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lobby_type
    }

    // optional bool solo_rank = 9;

    pub fn clear_solo_rank(&mut self) {
        self.solo_rank = ::std::option::Option::None;
    }

    pub fn has_solo_rank(&self) -> bool {
        self.solo_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solo_rank(&mut self, v: bool) {
        self.solo_rank = ::std::option::Option::Some(v);
    }

    pub fn get_solo_rank(&self) -> bool {
        self.solo_rank.unwrap_or(false)
    }

    fn get_solo_rank_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.solo_rank
    }

    fn mut_solo_rank_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.solo_rank
    }

    // optional bool abandon = 10;

    pub fn clear_abandon(&mut self) {
        self.abandon = ::std::option::Option::None;
    }

    pub fn has_abandon(&self) -> bool {
        self.abandon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abandon(&mut self, v: bool) {
        self.abandon = ::std::option::Option::Some(v);
    }

    pub fn get_abandon(&self) -> bool {
        self.abandon.unwrap_or(false)
    }

    fn get_abandon_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.abandon
    }

    fn mut_abandon_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.abandon
    }

    // optional uint32 duration = 11;

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    pub fn get_duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    fn get_duration_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.duration
    }

    fn mut_duration_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.duration
    }

    // optional uint32 engine = 12;

    pub fn clear_engine(&mut self) {
        self.engine = ::std::option::Option::None;
    }

    pub fn has_engine(&self) -> bool {
        self.engine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engine(&mut self, v: u32) {
        self.engine = ::std::option::Option::Some(v);
    }

    pub fn get_engine(&self) -> u32 {
        self.engine.unwrap_or(0)
    }

    fn get_engine_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.engine
    }

    fn mut_engine_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.engine
    }

    // optional bool active_battle_pass = 13;

    pub fn clear_active_battle_pass(&mut self) {
        self.active_battle_pass = ::std::option::Option::None;
    }

    pub fn has_active_battle_pass(&self) -> bool {
        self.active_battle_pass.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_battle_pass(&mut self, v: bool) {
        self.active_battle_pass = ::std::option::Option::Some(v);
    }

    pub fn get_active_battle_pass(&self) -> bool {
        self.active_battle_pass.unwrap_or(false)
    }

    fn get_active_battle_pass_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.active_battle_pass
    }

    fn mut_active_battle_pass_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.active_battle_pass
    }

    // optional bool seasonal_rank = 14;

    pub fn clear_seasonal_rank(&mut self) {
        self.seasonal_rank = ::std::option::Option::None;
    }

    pub fn has_seasonal_rank(&self) -> bool {
        self.seasonal_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seasonal_rank(&mut self, v: bool) {
        self.seasonal_rank = ::std::option::Option::Some(v);
    }

    pub fn get_seasonal_rank(&self) -> bool {
        self.seasonal_rank.unwrap_or(false)
    }

    fn get_seasonal_rank_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.seasonal_rank
    }

    fn mut_seasonal_rank_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.seasonal_rank
    }

    // optional uint32 tourney_id = 15;

    pub fn clear_tourney_id(&mut self) {
        self.tourney_id = ::std::option::Option::None;
    }

    pub fn has_tourney_id(&self) -> bool {
        self.tourney_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tourney_id(&mut self, v: u32) {
        self.tourney_id = ::std::option::Option::Some(v);
    }

    pub fn get_tourney_id(&self) -> u32 {
        self.tourney_id.unwrap_or(0)
    }

    fn get_tourney_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tourney_id
    }

    fn mut_tourney_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tourney_id
    }

    // optional uint32 tourney_round = 16;

    pub fn clear_tourney_round(&mut self) {
        self.tourney_round = ::std::option::Option::None;
    }

    pub fn has_tourney_round(&self) -> bool {
        self.tourney_round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tourney_round(&mut self, v: u32) {
        self.tourney_round = ::std::option::Option::Some(v);
    }

    pub fn get_tourney_round(&self) -> u32 {
        self.tourney_round.unwrap_or(0)
    }

    fn get_tourney_round_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tourney_round
    }

    fn mut_tourney_round_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tourney_round
    }

    // optional uint32 tourney_tier = 17;

    pub fn clear_tourney_tier(&mut self) {
        self.tourney_tier = ::std::option::Option::None;
    }

    pub fn has_tourney_tier(&self) -> bool {
        self.tourney_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tourney_tier(&mut self, v: u32) {
        self.tourney_tier = ::std::option::Option::Some(v);
    }

    pub fn get_tourney_tier(&self) -> u32 {
        self.tourney_tier.unwrap_or(0)
    }

    fn get_tourney_tier_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tourney_tier
    }

    fn mut_tourney_tier_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tourney_tier
    }

    // optional uint32 tourney_division = 18;

    pub fn clear_tourney_division(&mut self) {
        self.tourney_division = ::std::option::Option::None;
    }

    pub fn has_tourney_division(&self) -> bool {
        self.tourney_division.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tourney_division(&mut self, v: u32) {
        self.tourney_division = ::std::option::Option::Some(v);
    }

    pub fn get_tourney_division(&self) -> u32 {
        self.tourney_division.unwrap_or(0)
    }

    fn get_tourney_division_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tourney_division
    }

    fn mut_tourney_division_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tourney_division
    }

    // optional uint32 team_id = 19;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_id
    }

    // optional string team_name = 20;

    pub fn clear_team_name(&mut self) {
        self.team_name.clear();
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name.set_default();
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_name
    }

    fn mut_team_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_name
    }

    // optional uint64 ugc_team_ui_logo = 21;

    pub fn clear_ugc_team_ui_logo(&mut self) {
        self.ugc_team_ui_logo = ::std::option::Option::None;
    }

    pub fn has_ugc_team_ui_logo(&self) -> bool {
        self.ugc_team_ui_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ugc_team_ui_logo(&mut self, v: u64) {
        self.ugc_team_ui_logo = ::std::option::Option::Some(v);
    }

    pub fn get_ugc_team_ui_logo(&self) -> u64 {
        self.ugc_team_ui_logo.unwrap_or(0)
    }

    fn get_ugc_team_ui_logo_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.ugc_team_ui_logo
    }

    fn mut_ugc_team_ui_logo_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.ugc_team_ui_logo
    }
}

impl ::protobuf::Message for CMsgDOTAGetPlayerMatchHistoryResponse_Match {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.winner = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_mode = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rank_change = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.previous_rank = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lobby_type = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.solo_rank = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.abandon = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.engine = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active_battle_pass = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.seasonal_rank = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tourney_id = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tourney_round = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tourney_tier = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tourney_division = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_name)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ugc_team_ui_logo = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.winner {
            my_size += 2;
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_change {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.previous_rank {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.solo_rank {
            my_size += 2;
        }
        if let Some(v) = self.abandon {
            my_size += 2;
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.engine {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active_battle_pass {
            my_size += 2;
        }
        if let Some(v) = self.seasonal_rank {
            my_size += 2;
        }
        if let Some(v) = self.tourney_id {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tourney_round {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tourney_tier {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tourney_division {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.ugc_team_ui_logo {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.winner {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.rank_change {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.previous_rank {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.solo_rank {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.abandon {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.engine {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.active_battle_pass {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.seasonal_rank {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.tourney_id {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.tourney_round {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.tourney_tier {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.tourney_division {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(19, v)?;
        }
        if let Some(ref v) = self.team_name.as_ref() {
            os.write_string(20, &v)?;
        }
        if let Some(v) = self.ugc_team_ui_logo {
            os.write_uint64(21, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAGetPlayerMatchHistoryResponse_Match {
    fn new() -> CMsgDOTAGetPlayerMatchHistoryResponse_Match {
        CMsgDOTAGetPlayerMatchHistoryResponse_Match::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAGetPlayerMatchHistoryResponse_Match>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_match_id_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "start_time",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_start_time_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_start_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_hero_id_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "winner",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_winner_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_winner_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "game_mode",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_game_mode_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_game_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "rank_change",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_rank_change_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_rank_change_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "previous_rank",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_previous_rank_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_previous_rank_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lobby_type",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_lobby_type_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_lobby_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "solo_rank",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_solo_rank_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_solo_rank_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "abandon",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_abandon_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_abandon_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "duration",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_duration_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_duration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "engine",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_engine_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_engine_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "active_battle_pass",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_active_battle_pass_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_active_battle_pass_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "seasonal_rank",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_seasonal_rank_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_seasonal_rank_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tourney_id",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_tourney_id_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_tourney_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tourney_round",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_tourney_round_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_tourney_round_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tourney_tier",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_tourney_tier_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_tourney_tier_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tourney_division",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_tourney_division_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_tourney_division_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_id",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_team_id_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_name",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_team_name_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_team_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ugc_team_ui_logo",
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::get_ugc_team_ui_logo_for_reflect,
                    CMsgDOTAGetPlayerMatchHistoryResponse_Match::mut_ugc_team_ui_logo_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAGetPlayerMatchHistoryResponse_Match>(
                    "CMsgDOTAGetPlayerMatchHistoryResponse_Match",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAGetPlayerMatchHistoryResponse_Match {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_start_time();
        self.clear_hero_id();
        self.clear_winner();
        self.clear_game_mode();
        self.clear_rank_change();
        self.clear_previous_rank();
        self.clear_lobby_type();
        self.clear_solo_rank();
        self.clear_abandon();
        self.clear_duration();
        self.clear_engine();
        self.clear_active_battle_pass();
        self.clear_seasonal_rank();
        self.clear_tourney_id();
        self.clear_tourney_round();
        self.clear_tourney_tier();
        self.clear_tourney_division();
        self.clear_team_id();
        self.clear_team_name();
        self.clear_ugc_team_ui_logo();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAGetPlayerMatchHistoryResponse_Match {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAGetPlayerMatchHistoryResponse_Match {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAStartDailyHeroChallenge {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAStartDailyHeroChallenge {}

impl CMsgDOTAStartDailyHeroChallenge {
    pub fn new() -> CMsgDOTAStartDailyHeroChallenge {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAStartDailyHeroChallenge {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAStartDailyHeroChallenge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAStartDailyHeroChallenge,
        };
        unsafe {
            instance.get(CMsgDOTAStartDailyHeroChallenge::new)
        }
    }
}

impl ::protobuf::Message for CMsgDOTAStartDailyHeroChallenge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAStartDailyHeroChallenge {
    fn new() -> CMsgDOTAStartDailyHeroChallenge {
        CMsgDOTAStartDailyHeroChallenge::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAStartDailyHeroChallenge>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAStartDailyHeroChallenge>(
                    "CMsgDOTAStartDailyHeroChallenge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAStartDailyHeroChallenge {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAStartDailyHeroChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAStartDailyHeroChallenge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCNotificationsRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCNotificationsRequest {}

impl CMsgGCNotificationsRequest {
    pub fn new() -> CMsgGCNotificationsRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCNotificationsRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCNotificationsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCNotificationsRequest,
        };
        unsafe {
            instance.get(CMsgGCNotificationsRequest::new)
        }
    }
}

impl ::protobuf::Message for CMsgGCNotificationsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCNotificationsRequest {
    fn new() -> CMsgGCNotificationsRequest {
        CMsgGCNotificationsRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCNotificationsRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCNotificationsRequest>(
                    "CMsgGCNotificationsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCNotificationsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCNotificationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNotificationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCNotificationsResponse {
    // message fields
    result: ::std::option::Option<CMsgGCNotificationsResponse_EResult>,
    notifications: ::protobuf::RepeatedField<CMsgGCNotificationsResponse_Notification>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCNotificationsResponse {}

impl CMsgGCNotificationsResponse {
    pub fn new() -> CMsgGCNotificationsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCNotificationsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCNotificationsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCNotificationsResponse,
        };
        unsafe {
            instance.get(CMsgGCNotificationsResponse::new)
        }
    }

    // optional .CMsgGCNotificationsResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgGCNotificationsResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgGCNotificationsResponse_EResult {
        self.result.unwrap_or(CMsgGCNotificationsResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgGCNotificationsResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgGCNotificationsResponse_EResult> {
        &mut self.result
    }

    // repeated .CMsgGCNotificationsResponse.Notification notifications = 2;

    pub fn clear_notifications(&mut self) {
        self.notifications.clear();
    }

    // Param is passed by value, moved
    pub fn set_notifications(&mut self, v: ::protobuf::RepeatedField<CMsgGCNotificationsResponse_Notification>) {
        self.notifications = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notifications(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCNotificationsResponse_Notification> {
        &mut self.notifications
    }

    // Take field
    pub fn take_notifications(&mut self) -> ::protobuf::RepeatedField<CMsgGCNotificationsResponse_Notification> {
        ::std::mem::replace(&mut self.notifications, ::protobuf::RepeatedField::new())
    }

    pub fn get_notifications(&self) -> &[CMsgGCNotificationsResponse_Notification] {
        &self.notifications
    }

    fn get_notifications_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCNotificationsResponse_Notification> {
        &self.notifications
    }

    fn mut_notifications_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCNotificationsResponse_Notification> {
        &mut self.notifications
    }
}

impl ::protobuf::Message for CMsgGCNotificationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.notifications {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.notifications)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.notifications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        for v in &self.notifications {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCNotificationsResponse {
    fn new() -> CMsgGCNotificationsResponse {
        CMsgGCNotificationsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCNotificationsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGCNotificationsResponse_EResult>>(
                    "result",
                    CMsgGCNotificationsResponse::get_result_for_reflect,
                    CMsgGCNotificationsResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCNotificationsResponse_Notification>>(
                    "notifications",
                    CMsgGCNotificationsResponse::get_notifications_for_reflect,
                    CMsgGCNotificationsResponse::mut_notifications_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCNotificationsResponse>(
                    "CMsgGCNotificationsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCNotificationsResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_notifications();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCNotificationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNotificationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCNotificationsResponse_Notification {
    // message fields
    id: ::std::option::Option<u64>,
    field_type: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    reference_a: ::std::option::Option<u32>,
    reference_b: ::std::option::Option<u32>,
    reference_c: ::std::option::Option<u32>,
    message: ::protobuf::SingularField<::std::string::String>,
    unread: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCNotificationsResponse_Notification {}

impl CMsgGCNotificationsResponse_Notification {
    pub fn new() -> CMsgGCNotificationsResponse_Notification {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCNotificationsResponse_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCNotificationsResponse_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCNotificationsResponse_Notification,
        };
        unsafe {
            instance.get(CMsgGCNotificationsResponse_Notification::new)
        }
    }

    // optional uint64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    fn get_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.id
    }

    fn mut_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.id
    }

    // optional uint32 type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.field_type
    }

    // optional uint32 timestamp = 3;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional uint32 reference_a = 4;

    pub fn clear_reference_a(&mut self) {
        self.reference_a = ::std::option::Option::None;
    }

    pub fn has_reference_a(&self) -> bool {
        self.reference_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reference_a(&mut self, v: u32) {
        self.reference_a = ::std::option::Option::Some(v);
    }

    pub fn get_reference_a(&self) -> u32 {
        self.reference_a.unwrap_or(0)
    }

    fn get_reference_a_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reference_a
    }

    fn mut_reference_a_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reference_a
    }

    // optional uint32 reference_b = 5;

    pub fn clear_reference_b(&mut self) {
        self.reference_b = ::std::option::Option::None;
    }

    pub fn has_reference_b(&self) -> bool {
        self.reference_b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reference_b(&mut self, v: u32) {
        self.reference_b = ::std::option::Option::Some(v);
    }

    pub fn get_reference_b(&self) -> u32 {
        self.reference_b.unwrap_or(0)
    }

    fn get_reference_b_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reference_b
    }

    fn mut_reference_b_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reference_b
    }

    // optional uint32 reference_c = 6;

    pub fn clear_reference_c(&mut self) {
        self.reference_c = ::std::option::Option::None;
    }

    pub fn has_reference_c(&self) -> bool {
        self.reference_c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reference_c(&mut self, v: u32) {
        self.reference_c = ::std::option::Option::Some(v);
    }

    pub fn get_reference_c(&self) -> u32 {
        self.reference_c.unwrap_or(0)
    }

    fn get_reference_c_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reference_c
    }

    fn mut_reference_c_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reference_c
    }

    // optional string message = 7;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }

    // optional bool unread = 8;

    pub fn clear_unread(&mut self) {
        self.unread = ::std::option::Option::None;
    }

    pub fn has_unread(&self) -> bool {
        self.unread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread(&mut self, v: bool) {
        self.unread = ::std::option::Option::Some(v);
    }

    pub fn get_unread(&self) -> bool {
        self.unread.unwrap_or(false)
    }

    fn get_unread_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.unread
    }

    fn mut_unread_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.unread
    }
}

impl ::protobuf::Message for CMsgGCNotificationsResponse_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reference_a = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reference_b = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reference_c = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unread = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reference_a {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reference_b {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reference_c {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.unread {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.reference_a {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.reference_b {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.reference_c {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.unread {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCNotificationsResponse_Notification {
    fn new() -> CMsgGCNotificationsResponse_Notification {
        CMsgGCNotificationsResponse_Notification::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCNotificationsResponse_Notification>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "id",
                    CMsgGCNotificationsResponse_Notification::get_id_for_reflect,
                    CMsgGCNotificationsResponse_Notification::mut_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    CMsgGCNotificationsResponse_Notification::get_field_type_for_reflect,
                    CMsgGCNotificationsResponse_Notification::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgGCNotificationsResponse_Notification::get_timestamp_for_reflect,
                    CMsgGCNotificationsResponse_Notification::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reference_a",
                    CMsgGCNotificationsResponse_Notification::get_reference_a_for_reflect,
                    CMsgGCNotificationsResponse_Notification::mut_reference_a_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reference_b",
                    CMsgGCNotificationsResponse_Notification::get_reference_b_for_reflect,
                    CMsgGCNotificationsResponse_Notification::mut_reference_b_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reference_c",
                    CMsgGCNotificationsResponse_Notification::get_reference_c_for_reflect,
                    CMsgGCNotificationsResponse_Notification::mut_reference_c_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    CMsgGCNotificationsResponse_Notification::get_message_for_reflect,
                    CMsgGCNotificationsResponse_Notification::mut_message_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unread",
                    CMsgGCNotificationsResponse_Notification::get_unread_for_reflect,
                    CMsgGCNotificationsResponse_Notification::mut_unread_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCNotificationsResponse_Notification>(
                    "CMsgGCNotificationsResponse_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCNotificationsResponse_Notification {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_field_type();
        self.clear_timestamp();
        self.clear_reference_a();
        self.clear_reference_b();
        self.clear_reference_c();
        self.clear_message();
        self.clear_unread();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCNotificationsResponse_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNotificationsResponse_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGCNotificationsResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
}

impl ::protobuf::ProtobufEnum for CMsgGCNotificationsResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGCNotificationsResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgGCNotificationsResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgGCNotificationsResponse_EResult::ERROR_UNSPECIFIED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGCNotificationsResponse_EResult] = &[
            CMsgGCNotificationsResponse_EResult::SUCCESS,
            CMsgGCNotificationsResponse_EResult::ERROR_UNSPECIFIED,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgGCNotificationsResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgGCNotificationsResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgGCNotificationsResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNotificationsResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCNotificationsMarkReadRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCNotificationsMarkReadRequest {}

impl CMsgGCNotificationsMarkReadRequest {
    pub fn new() -> CMsgGCNotificationsMarkReadRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCNotificationsMarkReadRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCNotificationsMarkReadRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCNotificationsMarkReadRequest,
        };
        unsafe {
            instance.get(CMsgGCNotificationsMarkReadRequest::new)
        }
    }
}

impl ::protobuf::Message for CMsgGCNotificationsMarkReadRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCNotificationsMarkReadRequest {
    fn new() -> CMsgGCNotificationsMarkReadRequest {
        CMsgGCNotificationsMarkReadRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCNotificationsMarkReadRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCNotificationsMarkReadRequest>(
                    "CMsgGCNotificationsMarkReadRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCNotificationsMarkReadRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCNotificationsMarkReadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNotificationsMarkReadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCMarkNotificationListRead {
    // message fields
    notification_ids: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCMarkNotificationListRead {}

impl CMsgClientToGCMarkNotificationListRead {
    pub fn new() -> CMsgClientToGCMarkNotificationListRead {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCMarkNotificationListRead {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCMarkNotificationListRead> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCMarkNotificationListRead,
        };
        unsafe {
            instance.get(CMsgClientToGCMarkNotificationListRead::new)
        }
    }

    // repeated uint64 notification_ids = 1;

    pub fn clear_notification_ids(&mut self) {
        self.notification_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_notification_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.notification_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notification_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.notification_ids
    }

    // Take field
    pub fn take_notification_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.notification_ids, ::std::vec::Vec::new())
    }

    pub fn get_notification_ids(&self) -> &[u64] {
        &self.notification_ids
    }

    fn get_notification_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.notification_ids
    }

    fn mut_notification_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.notification_ids
    }
}

impl ::protobuf::Message for CMsgClientToGCMarkNotificationListRead {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.notification_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.notification_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.notification_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCMarkNotificationListRead {
    fn new() -> CMsgClientToGCMarkNotificationListRead {
        CMsgClientToGCMarkNotificationListRead::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCMarkNotificationListRead>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "notification_ids",
                    CMsgClientToGCMarkNotificationListRead::get_notification_ids_for_reflect,
                    CMsgClientToGCMarkNotificationListRead::mut_notification_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCMarkNotificationListRead>(
                    "CMsgClientToGCMarkNotificationListRead",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCMarkNotificationListRead {
    fn clear(&mut self) {
        self.clear_notification_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCMarkNotificationListRead {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCMarkNotificationListRead {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCLeagueAdminState {
    // message fields
    leagues: ::std::vec::Vec<u32>,
    keys: ::protobuf::RepeatedField<CMsgGCLeagueAdminState_PrivateLeagueKeys>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCLeagueAdminState {}

impl CMsgGCLeagueAdminState {
    pub fn new() -> CMsgGCLeagueAdminState {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCLeagueAdminState {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCLeagueAdminState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCLeagueAdminState,
        };
        unsafe {
            instance.get(CMsgGCLeagueAdminState::new)
        }
    }

    // repeated uint32 leagues = 1;

    pub fn clear_leagues(&mut self) {
        self.leagues.clear();
    }

    // Param is passed by value, moved
    pub fn set_leagues(&mut self, v: ::std::vec::Vec<u32>) {
        self.leagues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_leagues(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.leagues
    }

    // Take field
    pub fn take_leagues(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.leagues, ::std::vec::Vec::new())
    }

    pub fn get_leagues(&self) -> &[u32] {
        &self.leagues
    }

    fn get_leagues_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.leagues
    }

    fn mut_leagues_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.leagues
    }

    // repeated .CMsgGCLeagueAdminState.PrivateLeagueKeys keys = 2;

    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<CMsgGCLeagueAdminState_PrivateLeagueKeys>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCLeagueAdminState_PrivateLeagueKeys> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<CMsgGCLeagueAdminState_PrivateLeagueKeys> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    pub fn get_keys(&self) -> &[CMsgGCLeagueAdminState_PrivateLeagueKeys] {
        &self.keys
    }

    fn get_keys_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCLeagueAdminState_PrivateLeagueKeys> {
        &self.keys
    }

    fn mut_keys_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCLeagueAdminState_PrivateLeagueKeys> {
        &mut self.keys
    }
}

impl ::protobuf::Message for CMsgGCLeagueAdminState {
    fn is_initialized(&self) -> bool {
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.leagues)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.leagues {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.leagues {
            os.write_uint32(1, *v)?;
        };
        for v in &self.keys {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCLeagueAdminState {
    fn new() -> CMsgGCLeagueAdminState {
        CMsgGCLeagueAdminState::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCLeagueAdminState>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "leagues",
                    CMsgGCLeagueAdminState::get_leagues_for_reflect,
                    CMsgGCLeagueAdminState::mut_leagues_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCLeagueAdminState_PrivateLeagueKeys>>(
                    "keys",
                    CMsgGCLeagueAdminState::get_keys_for_reflect,
                    CMsgGCLeagueAdminState::mut_keys_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCLeagueAdminState>(
                    "CMsgGCLeagueAdminState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCLeagueAdminState {
    fn clear(&mut self) {
        self.clear_leagues();
        self.clear_keys();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCLeagueAdminState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCLeagueAdminState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCLeagueAdminState_PrivateLeagueKeys {
    // message fields
    leagueid: ::std::option::Option<u32>,
    privatekey: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCLeagueAdminState_PrivateLeagueKeys {}

impl CMsgGCLeagueAdminState_PrivateLeagueKeys {
    pub fn new() -> CMsgGCLeagueAdminState_PrivateLeagueKeys {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCLeagueAdminState_PrivateLeagueKeys {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCLeagueAdminState_PrivateLeagueKeys> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCLeagueAdminState_PrivateLeagueKeys,
        };
        unsafe {
            instance.get(CMsgGCLeagueAdminState_PrivateLeagueKeys::new)
        }
    }

    // optional uint32 leagueid = 1;

    pub fn clear_leagueid(&mut self) {
        self.leagueid = ::std::option::Option::None;
    }

    pub fn has_leagueid(&self) -> bool {
        self.leagueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leagueid(&mut self, v: u32) {
        self.leagueid = ::std::option::Option::Some(v);
    }

    pub fn get_leagueid(&self) -> u32 {
        self.leagueid.unwrap_or(0)
    }

    fn get_leagueid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.leagueid
    }

    fn mut_leagueid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.leagueid
    }

    // optional uint32 privatekey = 2;

    pub fn clear_privatekey(&mut self) {
        self.privatekey = ::std::option::Option::None;
    }

    pub fn has_privatekey(&self) -> bool {
        self.privatekey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privatekey(&mut self, v: u32) {
        self.privatekey = ::std::option::Option::Some(v);
    }

    pub fn get_privatekey(&self) -> u32 {
        self.privatekey.unwrap_or(0)
    }

    fn get_privatekey_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.privatekey
    }

    fn mut_privatekey_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.privatekey
    }
}

impl ::protobuf::Message for CMsgGCLeagueAdminState_PrivateLeagueKeys {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leagueid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.privatekey = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.leagueid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.privatekey {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.leagueid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.privatekey {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCLeagueAdminState_PrivateLeagueKeys {
    fn new() -> CMsgGCLeagueAdminState_PrivateLeagueKeys {
        CMsgGCLeagueAdminState_PrivateLeagueKeys::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCLeagueAdminState_PrivateLeagueKeys>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "leagueid",
                    CMsgGCLeagueAdminState_PrivateLeagueKeys::get_leagueid_for_reflect,
                    CMsgGCLeagueAdminState_PrivateLeagueKeys::mut_leagueid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "privatekey",
                    CMsgGCLeagueAdminState_PrivateLeagueKeys::get_privatekey_for_reflect,
                    CMsgGCLeagueAdminState_PrivateLeagueKeys::mut_privatekey_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCLeagueAdminState_PrivateLeagueKeys>(
                    "CMsgGCLeagueAdminState_PrivateLeagueKeys",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCLeagueAdminState_PrivateLeagueKeys {
    fn clear(&mut self) {
        self.clear_leagueid();
        self.clear_privatekey();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCLeagueAdminState_PrivateLeagueKeys {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCLeagueAdminState_PrivateLeagueKeys {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCPlayerInfoRequest {
    // message fields
    player_infos: ::protobuf::RepeatedField<CMsgGCPlayerInfoRequest_PlayerInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCPlayerInfoRequest {}

impl CMsgGCPlayerInfoRequest {
    pub fn new() -> CMsgGCPlayerInfoRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCPlayerInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCPlayerInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCPlayerInfoRequest,
        };
        unsafe {
            instance.get(CMsgGCPlayerInfoRequest::new)
        }
    }

    // repeated .CMsgGCPlayerInfoRequest.PlayerInfo player_infos = 1;

    pub fn clear_player_infos(&mut self) {
        self.player_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_infos(&mut self, v: ::protobuf::RepeatedField<CMsgGCPlayerInfoRequest_PlayerInfo>) {
        self.player_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_infos(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCPlayerInfoRequest_PlayerInfo> {
        &mut self.player_infos
    }

    // Take field
    pub fn take_player_infos(&mut self) -> ::protobuf::RepeatedField<CMsgGCPlayerInfoRequest_PlayerInfo> {
        ::std::mem::replace(&mut self.player_infos, ::protobuf::RepeatedField::new())
    }

    pub fn get_player_infos(&self) -> &[CMsgGCPlayerInfoRequest_PlayerInfo] {
        &self.player_infos
    }

    fn get_player_infos_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCPlayerInfoRequest_PlayerInfo> {
        &self.player_infos
    }

    fn mut_player_infos_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCPlayerInfoRequest_PlayerInfo> {
        &mut self.player_infos
    }
}

impl ::protobuf::Message for CMsgGCPlayerInfoRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.player_infos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_infos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.player_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.player_infos {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCPlayerInfoRequest {
    fn new() -> CMsgGCPlayerInfoRequest {
        CMsgGCPlayerInfoRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCPlayerInfoRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCPlayerInfoRequest_PlayerInfo>>(
                    "player_infos",
                    CMsgGCPlayerInfoRequest::get_player_infos_for_reflect,
                    CMsgGCPlayerInfoRequest::mut_player_infos_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCPlayerInfoRequest>(
                    "CMsgGCPlayerInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCPlayerInfoRequest {
    fn clear(&mut self) {
        self.clear_player_infos();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCPlayerInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCPlayerInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCPlayerInfoRequest_PlayerInfo {
    // message fields
    account_id: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCPlayerInfoRequest_PlayerInfo {}

impl CMsgGCPlayerInfoRequest_PlayerInfo {
    pub fn new() -> CMsgGCPlayerInfoRequest_PlayerInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCPlayerInfoRequest_PlayerInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCPlayerInfoRequest_PlayerInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCPlayerInfoRequest_PlayerInfo,
        };
        unsafe {
            instance.get(CMsgGCPlayerInfoRequest_PlayerInfo::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 timestamp = 2;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }
}

impl ::protobuf::Message for CMsgGCPlayerInfoRequest_PlayerInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCPlayerInfoRequest_PlayerInfo {
    fn new() -> CMsgGCPlayerInfoRequest_PlayerInfo {
        CMsgGCPlayerInfoRequest_PlayerInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCPlayerInfoRequest_PlayerInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCPlayerInfoRequest_PlayerInfo::get_account_id_for_reflect,
                    CMsgGCPlayerInfoRequest_PlayerInfo::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgGCPlayerInfoRequest_PlayerInfo::get_timestamp_for_reflect,
                    CMsgGCPlayerInfoRequest_PlayerInfo::mut_timestamp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCPlayerInfoRequest_PlayerInfo>(
                    "CMsgGCPlayerInfoRequest_PlayerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCPlayerInfoRequest_PlayerInfo {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCPlayerInfoRequest_PlayerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCPlayerInfoRequest_PlayerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCPlayerInfoSubmit {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    country_code: ::protobuf::SingularField<::std::string::String>,
    fantasy_role: ::std::option::Option<u32>,
    team_id: ::std::option::Option<u32>,
    sponsor: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCPlayerInfoSubmit {}

impl CMsgGCPlayerInfoSubmit {
    pub fn new() -> CMsgGCPlayerInfoSubmit {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCPlayerInfoSubmit {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCPlayerInfoSubmit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCPlayerInfoSubmit,
        };
        unsafe {
            instance.get(CMsgGCPlayerInfoSubmit::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string country_code = 2;

    pub fn clear_country_code(&mut self) {
        self.country_code.clear();
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code.set_default();
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_country_code_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.country_code
    }

    fn mut_country_code_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.country_code
    }

    // optional uint32 fantasy_role = 3;

    pub fn clear_fantasy_role(&mut self) {
        self.fantasy_role = ::std::option::Option::None;
    }

    pub fn has_fantasy_role(&self) -> bool {
        self.fantasy_role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_role(&mut self, v: u32) {
        self.fantasy_role = ::std::option::Option::Some(v);
    }

    pub fn get_fantasy_role(&self) -> u32 {
        self.fantasy_role.unwrap_or(0)
    }

    fn get_fantasy_role_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.fantasy_role
    }

    fn mut_fantasy_role_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.fantasy_role
    }

    // optional uint32 team_id = 4;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_id
    }

    // optional string sponsor = 5;

    pub fn clear_sponsor(&mut self) {
        self.sponsor.clear();
    }

    pub fn has_sponsor(&self) -> bool {
        self.sponsor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sponsor(&mut self, v: ::std::string::String) {
        self.sponsor = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sponsor(&mut self) -> &mut ::std::string::String {
        if self.sponsor.is_none() {
            self.sponsor.set_default();
        }
        self.sponsor.as_mut().unwrap()
    }

    // Take field
    pub fn take_sponsor(&mut self) -> ::std::string::String {
        self.sponsor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_sponsor(&self) -> &str {
        match self.sponsor.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_sponsor_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.sponsor
    }

    fn mut_sponsor_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.sponsor
    }
}

impl ::protobuf::Message for CMsgGCPlayerInfoSubmit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country_code)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fantasy_role = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sponsor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.fantasy_role {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sponsor.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.country_code.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.fantasy_role {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.sponsor.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCPlayerInfoSubmit {
    fn new() -> CMsgGCPlayerInfoSubmit {
        CMsgGCPlayerInfoSubmit::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCPlayerInfoSubmit>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgGCPlayerInfoSubmit::get_name_for_reflect,
                    CMsgGCPlayerInfoSubmit::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "country_code",
                    CMsgGCPlayerInfoSubmit::get_country_code_for_reflect,
                    CMsgGCPlayerInfoSubmit::mut_country_code_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fantasy_role",
                    CMsgGCPlayerInfoSubmit::get_fantasy_role_for_reflect,
                    CMsgGCPlayerInfoSubmit::mut_fantasy_role_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_id",
                    CMsgGCPlayerInfoSubmit::get_team_id_for_reflect,
                    CMsgGCPlayerInfoSubmit::mut_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sponsor",
                    CMsgGCPlayerInfoSubmit::get_sponsor_for_reflect,
                    CMsgGCPlayerInfoSubmit::mut_sponsor_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCPlayerInfoSubmit>(
                    "CMsgGCPlayerInfoSubmit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCPlayerInfoSubmit {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_country_code();
        self.clear_fantasy_role();
        self.clear_team_id();
        self.clear_sponsor();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCPlayerInfoSubmit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCPlayerInfoSubmit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCPlayerInfoSubmitResponse {
    // message fields
    result: ::std::option::Option<CMsgGCPlayerInfoSubmitResponse_EResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCPlayerInfoSubmitResponse {}

impl CMsgGCPlayerInfoSubmitResponse {
    pub fn new() -> CMsgGCPlayerInfoSubmitResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCPlayerInfoSubmitResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCPlayerInfoSubmitResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCPlayerInfoSubmitResponse,
        };
        unsafe {
            instance.get(CMsgGCPlayerInfoSubmitResponse::new)
        }
    }

    // optional .CMsgGCPlayerInfoSubmitResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgGCPlayerInfoSubmitResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgGCPlayerInfoSubmitResponse_EResult {
        self.result.unwrap_or(CMsgGCPlayerInfoSubmitResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgGCPlayerInfoSubmitResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgGCPlayerInfoSubmitResponse_EResult> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgGCPlayerInfoSubmitResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCPlayerInfoSubmitResponse {
    fn new() -> CMsgGCPlayerInfoSubmitResponse {
        CMsgGCPlayerInfoSubmitResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCPlayerInfoSubmitResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGCPlayerInfoSubmitResponse_EResult>>(
                    "result",
                    CMsgGCPlayerInfoSubmitResponse::get_result_for_reflect,
                    CMsgGCPlayerInfoSubmitResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCPlayerInfoSubmitResponse>(
                    "CMsgGCPlayerInfoSubmitResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCPlayerInfoSubmitResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCPlayerInfoSubmitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCPlayerInfoSubmitResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGCPlayerInfoSubmitResponse_EResult {
    SUCCESS = 0,
    ERROR_UNSPECIFIED = 1,
    ERROR_INFO_LOCKED = 2,
}

impl ::protobuf::ProtobufEnum for CMsgGCPlayerInfoSubmitResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGCPlayerInfoSubmitResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgGCPlayerInfoSubmitResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgGCPlayerInfoSubmitResponse_EResult::ERROR_UNSPECIFIED),
            2 => ::std::option::Option::Some(CMsgGCPlayerInfoSubmitResponse_EResult::ERROR_INFO_LOCKED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGCPlayerInfoSubmitResponse_EResult] = &[
            CMsgGCPlayerInfoSubmitResponse_EResult::SUCCESS,
            CMsgGCPlayerInfoSubmitResponse_EResult::ERROR_UNSPECIFIED,
            CMsgGCPlayerInfoSubmitResponse_EResult::ERROR_INFO_LOCKED,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgGCPlayerInfoSubmitResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgGCPlayerInfoSubmitResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgGCPlayerInfoSubmitResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCPlayerInfoSubmitResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientProvideSurveyResult {
    // message fields
    responses: ::protobuf::RepeatedField<CMsgClientProvideSurveyResult_Response>,
    survey_key: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientProvideSurveyResult {}

impl CMsgClientProvideSurveyResult {
    pub fn new() -> CMsgClientProvideSurveyResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientProvideSurveyResult {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientProvideSurveyResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientProvideSurveyResult,
        };
        unsafe {
            instance.get(CMsgClientProvideSurveyResult::new)
        }
    }

    // repeated .CMsgClientProvideSurveyResult.Response responses = 1;

    pub fn clear_responses(&mut self) {
        self.responses.clear();
    }

    // Param is passed by value, moved
    pub fn set_responses(&mut self, v: ::protobuf::RepeatedField<CMsgClientProvideSurveyResult_Response>) {
        self.responses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_responses(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientProvideSurveyResult_Response> {
        &mut self.responses
    }

    // Take field
    pub fn take_responses(&mut self) -> ::protobuf::RepeatedField<CMsgClientProvideSurveyResult_Response> {
        ::std::mem::replace(&mut self.responses, ::protobuf::RepeatedField::new())
    }

    pub fn get_responses(&self) -> &[CMsgClientProvideSurveyResult_Response] {
        &self.responses
    }

    fn get_responses_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientProvideSurveyResult_Response> {
        &self.responses
    }

    fn mut_responses_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientProvideSurveyResult_Response> {
        &mut self.responses
    }

    // optional uint64 survey_key = 2;

    pub fn clear_survey_key(&mut self) {
        self.survey_key = ::std::option::Option::None;
    }

    pub fn has_survey_key(&self) -> bool {
        self.survey_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_key(&mut self, v: u64) {
        self.survey_key = ::std::option::Option::Some(v);
    }

    pub fn get_survey_key(&self) -> u64 {
        self.survey_key.unwrap_or(0)
    }

    fn get_survey_key_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.survey_key
    }

    fn mut_survey_key_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.survey_key
    }
}

impl ::protobuf::Message for CMsgClientProvideSurveyResult {
    fn is_initialized(&self) -> bool {
        for v in &self.responses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.responses)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.survey_key = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.survey_key {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.responses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.survey_key {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientProvideSurveyResult {
    fn new() -> CMsgClientProvideSurveyResult {
        CMsgClientProvideSurveyResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientProvideSurveyResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientProvideSurveyResult_Response>>(
                    "responses",
                    CMsgClientProvideSurveyResult::get_responses_for_reflect,
                    CMsgClientProvideSurveyResult::mut_responses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "survey_key",
                    CMsgClientProvideSurveyResult::get_survey_key_for_reflect,
                    CMsgClientProvideSurveyResult::mut_survey_key_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientProvideSurveyResult>(
                    "CMsgClientProvideSurveyResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientProvideSurveyResult {
    fn clear(&mut self) {
        self.clear_responses();
        self.clear_survey_key();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientProvideSurveyResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientProvideSurveyResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientProvideSurveyResult_Response {
    // message fields
    question_id: ::std::option::Option<u32>,
    survey_value: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientProvideSurveyResult_Response {}

impl CMsgClientProvideSurveyResult_Response {
    pub fn new() -> CMsgClientProvideSurveyResult_Response {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientProvideSurveyResult_Response {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientProvideSurveyResult_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientProvideSurveyResult_Response,
        };
        unsafe {
            instance.get(CMsgClientProvideSurveyResult_Response::new)
        }
    }

    // optional uint32 question_id = 1;

    pub fn clear_question_id(&mut self) {
        self.question_id = ::std::option::Option::None;
    }

    pub fn has_question_id(&self) -> bool {
        self.question_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question_id(&mut self, v: u32) {
        self.question_id = ::std::option::Option::Some(v);
    }

    pub fn get_question_id(&self) -> u32 {
        self.question_id.unwrap_or(0)
    }

    fn get_question_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.question_id
    }

    fn mut_question_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.question_id
    }

    // optional uint32 survey_value = 2;

    pub fn clear_survey_value(&mut self) {
        self.survey_value = ::std::option::Option::None;
    }

    pub fn has_survey_value(&self) -> bool {
        self.survey_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_value(&mut self, v: u32) {
        self.survey_value = ::std::option::Option::Some(v);
    }

    pub fn get_survey_value(&self) -> u32 {
        self.survey_value.unwrap_or(0)
    }

    fn get_survey_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.survey_value
    }

    fn mut_survey_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.survey_value
    }
}

impl ::protobuf::Message for CMsgClientProvideSurveyResult_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.question_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.survey_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.question_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.survey_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.question_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.survey_value {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientProvideSurveyResult_Response {
    fn new() -> CMsgClientProvideSurveyResult_Response {
        CMsgClientProvideSurveyResult_Response::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientProvideSurveyResult_Response>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "question_id",
                    CMsgClientProvideSurveyResult_Response::get_question_id_for_reflect,
                    CMsgClientProvideSurveyResult_Response::mut_question_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "survey_value",
                    CMsgClientProvideSurveyResult_Response::get_survey_value_for_reflect,
                    CMsgClientProvideSurveyResult_Response::mut_survey_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientProvideSurveyResult_Response>(
                    "CMsgClientProvideSurveyResult_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientProvideSurveyResult_Response {
    fn clear(&mut self) {
        self.clear_question_id();
        self.clear_survey_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientProvideSurveyResult_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientProvideSurveyResult_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAEmoticonAccessSDO {
    // message fields
    account_id: ::std::option::Option<u32>,
    unlocked_emoticons: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAEmoticonAccessSDO {}

impl CMsgDOTAEmoticonAccessSDO {
    pub fn new() -> CMsgDOTAEmoticonAccessSDO {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAEmoticonAccessSDO {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAEmoticonAccessSDO> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAEmoticonAccessSDO,
        };
        unsafe {
            instance.get(CMsgDOTAEmoticonAccessSDO::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional bytes unlocked_emoticons = 2;

    pub fn clear_unlocked_emoticons(&mut self) {
        self.unlocked_emoticons.clear();
    }

    pub fn has_unlocked_emoticons(&self) -> bool {
        self.unlocked_emoticons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unlocked_emoticons(&mut self, v: ::std::vec::Vec<u8>) {
        self.unlocked_emoticons = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unlocked_emoticons(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.unlocked_emoticons.is_none() {
            self.unlocked_emoticons.set_default();
        }
        self.unlocked_emoticons.as_mut().unwrap()
    }

    // Take field
    pub fn take_unlocked_emoticons(&mut self) -> ::std::vec::Vec<u8> {
        self.unlocked_emoticons.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_unlocked_emoticons(&self) -> &[u8] {
        match self.unlocked_emoticons.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_unlocked_emoticons_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.unlocked_emoticons
    }

    fn mut_unlocked_emoticons_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.unlocked_emoticons
    }
}

impl ::protobuf::Message for CMsgDOTAEmoticonAccessSDO {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.unlocked_emoticons)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.unlocked_emoticons.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.unlocked_emoticons.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAEmoticonAccessSDO {
    fn new() -> CMsgDOTAEmoticonAccessSDO {
        CMsgDOTAEmoticonAccessSDO::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAEmoticonAccessSDO>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgDOTAEmoticonAccessSDO::get_account_id_for_reflect,
                    CMsgDOTAEmoticonAccessSDO::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "unlocked_emoticons",
                    CMsgDOTAEmoticonAccessSDO::get_unlocked_emoticons_for_reflect,
                    CMsgDOTAEmoticonAccessSDO::mut_unlocked_emoticons_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAEmoticonAccessSDO>(
                    "CMsgDOTAEmoticonAccessSDO",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAEmoticonAccessSDO {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_unlocked_emoticons();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAEmoticonAccessSDO {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAEmoticonAccessSDO {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCEmoticonDataRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCEmoticonDataRequest {}

impl CMsgClientToGCEmoticonDataRequest {
    pub fn new() -> CMsgClientToGCEmoticonDataRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCEmoticonDataRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCEmoticonDataRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCEmoticonDataRequest,
        };
        unsafe {
            instance.get(CMsgClientToGCEmoticonDataRequest::new)
        }
    }
}

impl ::protobuf::Message for CMsgClientToGCEmoticonDataRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCEmoticonDataRequest {
    fn new() -> CMsgClientToGCEmoticonDataRequest {
        CMsgClientToGCEmoticonDataRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCEmoticonDataRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCEmoticonDataRequest>(
                    "CMsgClientToGCEmoticonDataRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCEmoticonDataRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCEmoticonDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCEmoticonDataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientEmoticonData {
    // message fields
    emoticon_access: ::protobuf::SingularPtrField<CMsgDOTAEmoticonAccessSDO>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientEmoticonData {}

impl CMsgGCToClientEmoticonData {
    pub fn new() -> CMsgGCToClientEmoticonData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientEmoticonData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientEmoticonData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientEmoticonData,
        };
        unsafe {
            instance.get(CMsgGCToClientEmoticonData::new)
        }
    }

    // optional .CMsgDOTAEmoticonAccessSDO emoticon_access = 1;

    pub fn clear_emoticon_access(&mut self) {
        self.emoticon_access.clear();
    }

    pub fn has_emoticon_access(&self) -> bool {
        self.emoticon_access.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emoticon_access(&mut self, v: CMsgDOTAEmoticonAccessSDO) {
        self.emoticon_access = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emoticon_access(&mut self) -> &mut CMsgDOTAEmoticonAccessSDO {
        if self.emoticon_access.is_none() {
            self.emoticon_access.set_default();
        }
        self.emoticon_access.as_mut().unwrap()
    }

    // Take field
    pub fn take_emoticon_access(&mut self) -> CMsgDOTAEmoticonAccessSDO {
        self.emoticon_access.take().unwrap_or_else(|| CMsgDOTAEmoticonAccessSDO::new())
    }

    pub fn get_emoticon_access(&self) -> &CMsgDOTAEmoticonAccessSDO {
        self.emoticon_access.as_ref().unwrap_or_else(|| CMsgDOTAEmoticonAccessSDO::default_instance())
    }

    fn get_emoticon_access_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAEmoticonAccessSDO> {
        &self.emoticon_access
    }

    fn mut_emoticon_access_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAEmoticonAccessSDO> {
        &mut self.emoticon_access
    }
}

impl ::protobuf::Message for CMsgGCToClientEmoticonData {
    fn is_initialized(&self) -> bool {
        for v in &self.emoticon_access {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.emoticon_access)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.emoticon_access.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.emoticon_access.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientEmoticonData {
    fn new() -> CMsgGCToClientEmoticonData {
        CMsgGCToClientEmoticonData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientEmoticonData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAEmoticonAccessSDO>>(
                    "emoticon_access",
                    CMsgGCToClientEmoticonData::get_emoticon_access_for_reflect,
                    CMsgGCToClientEmoticonData::mut_emoticon_access_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientEmoticonData>(
                    "CMsgGCToClientEmoticonData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientEmoticonData {
    fn clear(&mut self) {
        self.clear_emoticon_access();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientEmoticonData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientEmoticonData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCTrackDialogResult {
    // message fields
    dialog_id: ::std::option::Option<u32>,
    value: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCTrackDialogResult {}

impl CMsgClientToGCTrackDialogResult {
    pub fn new() -> CMsgClientToGCTrackDialogResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCTrackDialogResult {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCTrackDialogResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCTrackDialogResult,
        };
        unsafe {
            instance.get(CMsgClientToGCTrackDialogResult::new)
        }
    }

    // optional uint32 dialog_id = 1;

    pub fn clear_dialog_id(&mut self) {
        self.dialog_id = ::std::option::Option::None;
    }

    pub fn has_dialog_id(&self) -> bool {
        self.dialog_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dialog_id(&mut self, v: u32) {
        self.dialog_id = ::std::option::Option::Some(v);
    }

    pub fn get_dialog_id(&self) -> u32 {
        self.dialog_id.unwrap_or(0)
    }

    fn get_dialog_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.dialog_id
    }

    fn mut_dialog_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.dialog_id
    }

    // optional uint32 value = 2;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.value
    }
}

impl ::protobuf::Message for CMsgClientToGCTrackDialogResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dialog_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dialog_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dialog_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCTrackDialogResult {
    fn new() -> CMsgClientToGCTrackDialogResult {
        CMsgClientToGCTrackDialogResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCTrackDialogResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dialog_id",
                    CMsgClientToGCTrackDialogResult::get_dialog_id_for_reflect,
                    CMsgClientToGCTrackDialogResult::mut_dialog_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "value",
                    CMsgClientToGCTrackDialogResult::get_value_for_reflect,
                    CMsgClientToGCTrackDialogResult::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCTrackDialogResult>(
                    "CMsgClientToGCTrackDialogResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCTrackDialogResult {
    fn clear(&mut self) {
        self.clear_dialog_id();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCTrackDialogResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCTrackDialogResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientTournamentItemDrop {
    // message fields
    item_def: ::std::option::Option<u32>,
    event_type: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientTournamentItemDrop {}

impl CMsgGCToClientTournamentItemDrop {
    pub fn new() -> CMsgGCToClientTournamentItemDrop {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientTournamentItemDrop {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientTournamentItemDrop> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientTournamentItemDrop,
        };
        unsafe {
            instance.get(CMsgGCToClientTournamentItemDrop::new)
        }
    }

    // optional uint32 item_def = 1;

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    pub fn get_item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    fn get_item_def_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_def
    }

    fn mut_item_def_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_def
    }

    // optional uint32 event_type = 2;

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    pub fn get_event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }

    fn get_event_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_type
    }

    fn mut_event_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_type
    }
}

impl ::protobuf::Message for CMsgGCToClientTournamentItemDrop {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientTournamentItemDrop {
    fn new() -> CMsgGCToClientTournamentItemDrop {
        CMsgGCToClientTournamentItemDrop::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientTournamentItemDrop>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_def",
                    CMsgGCToClientTournamentItemDrop::get_item_def_for_reflect,
                    CMsgGCToClientTournamentItemDrop::mut_item_def_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_type",
                    CMsgGCToClientTournamentItemDrop::get_event_type_for_reflect,
                    CMsgGCToClientTournamentItemDrop::mut_event_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientTournamentItemDrop>(
                    "CMsgGCToClientTournamentItemDrop",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientTournamentItemDrop {
    fn clear(&mut self) {
        self.clear_item_def();
        self.clear_event_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientTournamentItemDrop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientTournamentItemDrop {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCSetAdditionalEquips {
    // message fields
    equips: ::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCSetAdditionalEquips {}

impl CMsgClientToGCSetAdditionalEquips {
    pub fn new() -> CMsgClientToGCSetAdditionalEquips {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCSetAdditionalEquips {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCSetAdditionalEquips> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCSetAdditionalEquips,
        };
        unsafe {
            instance.get(CMsgClientToGCSetAdditionalEquips::new)
        }
    }

    // repeated .CAdditionalEquipSlot equips = 1;

    pub fn clear_equips(&mut self) {
        self.equips.clear();
    }

    // Param is passed by value, moved
    pub fn set_equips(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot>) {
        self.equips = v;
    }

    // Mutable pointer to the field.
    pub fn mut_equips(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot> {
        &mut self.equips
    }

    // Take field
    pub fn take_equips(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot> {
        ::std::mem::replace(&mut self.equips, ::protobuf::RepeatedField::new())
    }

    pub fn get_equips(&self) -> &[super::dota_gcmessages_common::CAdditionalEquipSlot] {
        &self.equips
    }

    fn get_equips_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot> {
        &self.equips
    }

    fn mut_equips_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot> {
        &mut self.equips
    }
}

impl ::protobuf::Message for CMsgClientToGCSetAdditionalEquips {
    fn is_initialized(&self) -> bool {
        for v in &self.equips {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.equips)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.equips {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.equips {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCSetAdditionalEquips {
    fn new() -> CMsgClientToGCSetAdditionalEquips {
        CMsgClientToGCSetAdditionalEquips::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCSetAdditionalEquips>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CAdditionalEquipSlot>>(
                    "equips",
                    CMsgClientToGCSetAdditionalEquips::get_equips_for_reflect,
                    CMsgClientToGCSetAdditionalEquips::mut_equips_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCSetAdditionalEquips>(
                    "CMsgClientToGCSetAdditionalEquips",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCSetAdditionalEquips {
    fn clear(&mut self) {
        self.clear_equips();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCSetAdditionalEquips {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetAdditionalEquips {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCSetAdditionalEquipsResponse {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCSetAdditionalEquipsResponse {}

impl CMsgClientToGCSetAdditionalEquipsResponse {
    pub fn new() -> CMsgClientToGCSetAdditionalEquipsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCSetAdditionalEquipsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCSetAdditionalEquipsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCSetAdditionalEquipsResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCSetAdditionalEquipsResponse::new)
        }
    }
}

impl ::protobuf::Message for CMsgClientToGCSetAdditionalEquipsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCSetAdditionalEquipsResponse {
    fn new() -> CMsgClientToGCSetAdditionalEquipsResponse {
        CMsgClientToGCSetAdditionalEquipsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCSetAdditionalEquipsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCSetAdditionalEquipsResponse>(
                    "CMsgClientToGCSetAdditionalEquipsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCSetAdditionalEquipsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCSetAdditionalEquipsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetAdditionalEquipsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetAdditionalEquips {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetAdditionalEquips {}

impl CMsgClientToGCGetAdditionalEquips {
    pub fn new() -> CMsgClientToGCGetAdditionalEquips {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetAdditionalEquips {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetAdditionalEquips> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetAdditionalEquips,
        };
        unsafe {
            instance.get(CMsgClientToGCGetAdditionalEquips::new)
        }
    }
}

impl ::protobuf::Message for CMsgClientToGCGetAdditionalEquips {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetAdditionalEquips {
    fn new() -> CMsgClientToGCGetAdditionalEquips {
        CMsgClientToGCGetAdditionalEquips::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetAdditionalEquips>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetAdditionalEquips>(
                    "CMsgClientToGCGetAdditionalEquips",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetAdditionalEquips {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetAdditionalEquips {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetAdditionalEquips {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetAdditionalEquipsResponse {
    // message fields
    equips: ::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetAdditionalEquipsResponse {}

impl CMsgClientToGCGetAdditionalEquipsResponse {
    pub fn new() -> CMsgClientToGCGetAdditionalEquipsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetAdditionalEquipsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetAdditionalEquipsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetAdditionalEquipsResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCGetAdditionalEquipsResponse::new)
        }
    }

    // repeated .CAdditionalEquipSlot equips = 1;

    pub fn clear_equips(&mut self) {
        self.equips.clear();
    }

    // Param is passed by value, moved
    pub fn set_equips(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot>) {
        self.equips = v;
    }

    // Mutable pointer to the field.
    pub fn mut_equips(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot> {
        &mut self.equips
    }

    // Take field
    pub fn take_equips(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot> {
        ::std::mem::replace(&mut self.equips, ::protobuf::RepeatedField::new())
    }

    pub fn get_equips(&self) -> &[super::dota_gcmessages_common::CAdditionalEquipSlot] {
        &self.equips
    }

    fn get_equips_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot> {
        &self.equips
    }

    fn mut_equips_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CAdditionalEquipSlot> {
        &mut self.equips
    }
}

impl ::protobuf::Message for CMsgClientToGCGetAdditionalEquipsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.equips {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.equips)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.equips {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.equips {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetAdditionalEquipsResponse {
    fn new() -> CMsgClientToGCGetAdditionalEquipsResponse {
        CMsgClientToGCGetAdditionalEquipsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetAdditionalEquipsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CAdditionalEquipSlot>>(
                    "equips",
                    CMsgClientToGCGetAdditionalEquipsResponse::get_equips_for_reflect,
                    CMsgClientToGCGetAdditionalEquipsResponse::mut_equips_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetAdditionalEquipsResponse>(
                    "CMsgClientToGCGetAdditionalEquipsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetAdditionalEquipsResponse {
    fn clear(&mut self) {
        self.clear_equips();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetAdditionalEquipsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetAdditionalEquipsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetAllHeroOrder {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetAllHeroOrder {}

impl CMsgClientToGCGetAllHeroOrder {
    pub fn new() -> CMsgClientToGCGetAllHeroOrder {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetAllHeroOrder {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetAllHeroOrder> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetAllHeroOrder,
        };
        unsafe {
            instance.get(CMsgClientToGCGetAllHeroOrder::new)
        }
    }
}

impl ::protobuf::Message for CMsgClientToGCGetAllHeroOrder {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetAllHeroOrder {
    fn new() -> CMsgClientToGCGetAllHeroOrder {
        CMsgClientToGCGetAllHeroOrder::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetAllHeroOrder>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetAllHeroOrder>(
                    "CMsgClientToGCGetAllHeroOrder",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetAllHeroOrder {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetAllHeroOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetAllHeroOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetAllHeroOrderResponse {
    // message fields
    hero_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetAllHeroOrderResponse {}

impl CMsgClientToGCGetAllHeroOrderResponse {
    pub fn new() -> CMsgClientToGCGetAllHeroOrderResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetAllHeroOrderResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetAllHeroOrderResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetAllHeroOrderResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCGetAllHeroOrderResponse::new)
        }
    }

    // repeated uint32 hero_ids = 1;

    pub fn clear_hero_ids(&mut self) {
        self.hero_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_hero_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.hero_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hero_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.hero_ids
    }

    // Take field
    pub fn take_hero_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.hero_ids, ::std::vec::Vec::new())
    }

    pub fn get_hero_ids(&self) -> &[u32] {
        &self.hero_ids
    }

    fn get_hero_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.hero_ids
    }

    fn mut_hero_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.hero_ids
    }
}

impl ::protobuf::Message for CMsgClientToGCGetAllHeroOrderResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.hero_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.hero_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.hero_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetAllHeroOrderResponse {
    fn new() -> CMsgClientToGCGetAllHeroOrderResponse {
        CMsgClientToGCGetAllHeroOrderResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetAllHeroOrderResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_ids",
                    CMsgClientToGCGetAllHeroOrderResponse::get_hero_ids_for_reflect,
                    CMsgClientToGCGetAllHeroOrderResponse::mut_hero_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetAllHeroOrderResponse>(
                    "CMsgClientToGCGetAllHeroOrderResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetAllHeroOrderResponse {
    fn clear(&mut self) {
        self.clear_hero_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetAllHeroOrderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetAllHeroOrderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetAllHeroProgress {
    // message fields
    account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetAllHeroProgress {}

impl CMsgClientToGCGetAllHeroProgress {
    pub fn new() -> CMsgClientToGCGetAllHeroProgress {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetAllHeroProgress {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetAllHeroProgress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetAllHeroProgress,
        };
        unsafe {
            instance.get(CMsgClientToGCGetAllHeroProgress::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgClientToGCGetAllHeroProgress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetAllHeroProgress {
    fn new() -> CMsgClientToGCGetAllHeroProgress {
        CMsgClientToGCGetAllHeroProgress::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetAllHeroProgress>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgClientToGCGetAllHeroProgress::get_account_id_for_reflect,
                    CMsgClientToGCGetAllHeroProgress::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetAllHeroProgress>(
                    "CMsgClientToGCGetAllHeroProgress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetAllHeroProgress {
    fn clear(&mut self) {
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetAllHeroProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetAllHeroProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetAllHeroProgressResponse {
    // message fields
    account_id: ::std::option::Option<u32>,
    curr_hero_id: ::std::option::Option<u32>,
    laps_completed: ::std::option::Option<u32>,
    curr_hero_games: ::std::option::Option<u32>,
    curr_lap_time_started: ::std::option::Option<u32>,
    curr_lap_games: ::std::option::Option<u32>,
    best_lap_games: ::std::option::Option<u32>,
    best_lap_time: ::std::option::Option<u32>,
    lap_heroes_completed: ::std::option::Option<u32>,
    lap_heroes_remaining: ::std::option::Option<u32>,
    next_hero_id: ::std::option::Option<u32>,
    prev_hero_id: ::std::option::Option<u32>,
    prev_hero_games: ::std::option::Option<u32>,
    prev_avg_tries: ::std::option::Option<f32>,
    curr_avg_tries: ::std::option::Option<f32>,
    next_avg_tries: ::std::option::Option<f32>,
    full_lap_avg_tries: ::std::option::Option<f32>,
    curr_lap_avg_tries: ::std::option::Option<f32>,
    profile_name: ::protobuf::SingularField<::std::string::String>,
    start_hero_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetAllHeroProgressResponse {}

impl CMsgClientToGCGetAllHeroProgressResponse {
    pub fn new() -> CMsgClientToGCGetAllHeroProgressResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetAllHeroProgressResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetAllHeroProgressResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetAllHeroProgressResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCGetAllHeroProgressResponse::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 curr_hero_id = 2;

    pub fn clear_curr_hero_id(&mut self) {
        self.curr_hero_id = ::std::option::Option::None;
    }

    pub fn has_curr_hero_id(&self) -> bool {
        self.curr_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curr_hero_id(&mut self, v: u32) {
        self.curr_hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_curr_hero_id(&self) -> u32 {
        self.curr_hero_id.unwrap_or(0)
    }

    fn get_curr_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.curr_hero_id
    }

    fn mut_curr_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.curr_hero_id
    }

    // optional uint32 laps_completed = 3;

    pub fn clear_laps_completed(&mut self) {
        self.laps_completed = ::std::option::Option::None;
    }

    pub fn has_laps_completed(&self) -> bool {
        self.laps_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_laps_completed(&mut self, v: u32) {
        self.laps_completed = ::std::option::Option::Some(v);
    }

    pub fn get_laps_completed(&self) -> u32 {
        self.laps_completed.unwrap_or(0)
    }

    fn get_laps_completed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.laps_completed
    }

    fn mut_laps_completed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.laps_completed
    }

    // optional uint32 curr_hero_games = 4;

    pub fn clear_curr_hero_games(&mut self) {
        self.curr_hero_games = ::std::option::Option::None;
    }

    pub fn has_curr_hero_games(&self) -> bool {
        self.curr_hero_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curr_hero_games(&mut self, v: u32) {
        self.curr_hero_games = ::std::option::Option::Some(v);
    }

    pub fn get_curr_hero_games(&self) -> u32 {
        self.curr_hero_games.unwrap_or(0)
    }

    fn get_curr_hero_games_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.curr_hero_games
    }

    fn mut_curr_hero_games_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.curr_hero_games
    }

    // optional uint32 curr_lap_time_started = 5;

    pub fn clear_curr_lap_time_started(&mut self) {
        self.curr_lap_time_started = ::std::option::Option::None;
    }

    pub fn has_curr_lap_time_started(&self) -> bool {
        self.curr_lap_time_started.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curr_lap_time_started(&mut self, v: u32) {
        self.curr_lap_time_started = ::std::option::Option::Some(v);
    }

    pub fn get_curr_lap_time_started(&self) -> u32 {
        self.curr_lap_time_started.unwrap_or(0)
    }

    fn get_curr_lap_time_started_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.curr_lap_time_started
    }

    fn mut_curr_lap_time_started_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.curr_lap_time_started
    }

    // optional uint32 curr_lap_games = 6;

    pub fn clear_curr_lap_games(&mut self) {
        self.curr_lap_games = ::std::option::Option::None;
    }

    pub fn has_curr_lap_games(&self) -> bool {
        self.curr_lap_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curr_lap_games(&mut self, v: u32) {
        self.curr_lap_games = ::std::option::Option::Some(v);
    }

    pub fn get_curr_lap_games(&self) -> u32 {
        self.curr_lap_games.unwrap_or(0)
    }

    fn get_curr_lap_games_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.curr_lap_games
    }

    fn mut_curr_lap_games_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.curr_lap_games
    }

    // optional uint32 best_lap_games = 7;

    pub fn clear_best_lap_games(&mut self) {
        self.best_lap_games = ::std::option::Option::None;
    }

    pub fn has_best_lap_games(&self) -> bool {
        self.best_lap_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_lap_games(&mut self, v: u32) {
        self.best_lap_games = ::std::option::Option::Some(v);
    }

    pub fn get_best_lap_games(&self) -> u32 {
        self.best_lap_games.unwrap_or(0)
    }

    fn get_best_lap_games_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.best_lap_games
    }

    fn mut_best_lap_games_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.best_lap_games
    }

    // optional uint32 best_lap_time = 8;

    pub fn clear_best_lap_time(&mut self) {
        self.best_lap_time = ::std::option::Option::None;
    }

    pub fn has_best_lap_time(&self) -> bool {
        self.best_lap_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_lap_time(&mut self, v: u32) {
        self.best_lap_time = ::std::option::Option::Some(v);
    }

    pub fn get_best_lap_time(&self) -> u32 {
        self.best_lap_time.unwrap_or(0)
    }

    fn get_best_lap_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.best_lap_time
    }

    fn mut_best_lap_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.best_lap_time
    }

    // optional uint32 lap_heroes_completed = 9;

    pub fn clear_lap_heroes_completed(&mut self) {
        self.lap_heroes_completed = ::std::option::Option::None;
    }

    pub fn has_lap_heroes_completed(&self) -> bool {
        self.lap_heroes_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lap_heroes_completed(&mut self, v: u32) {
        self.lap_heroes_completed = ::std::option::Option::Some(v);
    }

    pub fn get_lap_heroes_completed(&self) -> u32 {
        self.lap_heroes_completed.unwrap_or(0)
    }

    fn get_lap_heroes_completed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lap_heroes_completed
    }

    fn mut_lap_heroes_completed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lap_heroes_completed
    }

    // optional uint32 lap_heroes_remaining = 10;

    pub fn clear_lap_heroes_remaining(&mut self) {
        self.lap_heroes_remaining = ::std::option::Option::None;
    }

    pub fn has_lap_heroes_remaining(&self) -> bool {
        self.lap_heroes_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lap_heroes_remaining(&mut self, v: u32) {
        self.lap_heroes_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_lap_heroes_remaining(&self) -> u32 {
        self.lap_heroes_remaining.unwrap_or(0)
    }

    fn get_lap_heroes_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lap_heroes_remaining
    }

    fn mut_lap_heroes_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lap_heroes_remaining
    }

    // optional uint32 next_hero_id = 11;

    pub fn clear_next_hero_id(&mut self) {
        self.next_hero_id = ::std::option::Option::None;
    }

    pub fn has_next_hero_id(&self) -> bool {
        self.next_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_hero_id(&mut self, v: u32) {
        self.next_hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_next_hero_id(&self) -> u32 {
        self.next_hero_id.unwrap_or(0)
    }

    fn get_next_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.next_hero_id
    }

    fn mut_next_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.next_hero_id
    }

    // optional uint32 prev_hero_id = 12;

    pub fn clear_prev_hero_id(&mut self) {
        self.prev_hero_id = ::std::option::Option::None;
    }

    pub fn has_prev_hero_id(&self) -> bool {
        self.prev_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prev_hero_id(&mut self, v: u32) {
        self.prev_hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_prev_hero_id(&self) -> u32 {
        self.prev_hero_id.unwrap_or(0)
    }

    fn get_prev_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prev_hero_id
    }

    fn mut_prev_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prev_hero_id
    }

    // optional uint32 prev_hero_games = 13;

    pub fn clear_prev_hero_games(&mut self) {
        self.prev_hero_games = ::std::option::Option::None;
    }

    pub fn has_prev_hero_games(&self) -> bool {
        self.prev_hero_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prev_hero_games(&mut self, v: u32) {
        self.prev_hero_games = ::std::option::Option::Some(v);
    }

    pub fn get_prev_hero_games(&self) -> u32 {
        self.prev_hero_games.unwrap_or(0)
    }

    fn get_prev_hero_games_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prev_hero_games
    }

    fn mut_prev_hero_games_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prev_hero_games
    }

    // optional float prev_avg_tries = 14;

    pub fn clear_prev_avg_tries(&mut self) {
        self.prev_avg_tries = ::std::option::Option::None;
    }

    pub fn has_prev_avg_tries(&self) -> bool {
        self.prev_avg_tries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prev_avg_tries(&mut self, v: f32) {
        self.prev_avg_tries = ::std::option::Option::Some(v);
    }

    pub fn get_prev_avg_tries(&self) -> f32 {
        self.prev_avg_tries.unwrap_or(0.)
    }

    fn get_prev_avg_tries_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.prev_avg_tries
    }

    fn mut_prev_avg_tries_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.prev_avg_tries
    }

    // optional float curr_avg_tries = 15;

    pub fn clear_curr_avg_tries(&mut self) {
        self.curr_avg_tries = ::std::option::Option::None;
    }

    pub fn has_curr_avg_tries(&self) -> bool {
        self.curr_avg_tries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curr_avg_tries(&mut self, v: f32) {
        self.curr_avg_tries = ::std::option::Option::Some(v);
    }

    pub fn get_curr_avg_tries(&self) -> f32 {
        self.curr_avg_tries.unwrap_or(0.)
    }

    fn get_curr_avg_tries_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.curr_avg_tries
    }

    fn mut_curr_avg_tries_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.curr_avg_tries
    }

    // optional float next_avg_tries = 16;

    pub fn clear_next_avg_tries(&mut self) {
        self.next_avg_tries = ::std::option::Option::None;
    }

    pub fn has_next_avg_tries(&self) -> bool {
        self.next_avg_tries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_avg_tries(&mut self, v: f32) {
        self.next_avg_tries = ::std::option::Option::Some(v);
    }

    pub fn get_next_avg_tries(&self) -> f32 {
        self.next_avg_tries.unwrap_or(0.)
    }

    fn get_next_avg_tries_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.next_avg_tries
    }

    fn mut_next_avg_tries_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.next_avg_tries
    }

    // optional float full_lap_avg_tries = 17;

    pub fn clear_full_lap_avg_tries(&mut self) {
        self.full_lap_avg_tries = ::std::option::Option::None;
    }

    pub fn has_full_lap_avg_tries(&self) -> bool {
        self.full_lap_avg_tries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_lap_avg_tries(&mut self, v: f32) {
        self.full_lap_avg_tries = ::std::option::Option::Some(v);
    }

    pub fn get_full_lap_avg_tries(&self) -> f32 {
        self.full_lap_avg_tries.unwrap_or(0.)
    }

    fn get_full_lap_avg_tries_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.full_lap_avg_tries
    }

    fn mut_full_lap_avg_tries_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.full_lap_avg_tries
    }

    // optional float curr_lap_avg_tries = 18;

    pub fn clear_curr_lap_avg_tries(&mut self) {
        self.curr_lap_avg_tries = ::std::option::Option::None;
    }

    pub fn has_curr_lap_avg_tries(&self) -> bool {
        self.curr_lap_avg_tries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curr_lap_avg_tries(&mut self, v: f32) {
        self.curr_lap_avg_tries = ::std::option::Option::Some(v);
    }

    pub fn get_curr_lap_avg_tries(&self) -> f32 {
        self.curr_lap_avg_tries.unwrap_or(0.)
    }

    fn get_curr_lap_avg_tries_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.curr_lap_avg_tries
    }

    fn mut_curr_lap_avg_tries_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.curr_lap_avg_tries
    }

    // optional string profile_name = 19;

    pub fn clear_profile_name(&mut self) {
        self.profile_name.clear();
    }

    pub fn has_profile_name(&self) -> bool {
        self.profile_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile_name(&mut self, v: ::std::string::String) {
        self.profile_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profile_name(&mut self) -> &mut ::std::string::String {
        if self.profile_name.is_none() {
            self.profile_name.set_default();
        }
        self.profile_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_profile_name(&mut self) -> ::std::string::String {
        self.profile_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_profile_name(&self) -> &str {
        match self.profile_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_profile_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.profile_name
    }

    fn mut_profile_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.profile_name
    }

    // optional uint32 start_hero_id = 20;

    pub fn clear_start_hero_id(&mut self) {
        self.start_hero_id = ::std::option::Option::None;
    }

    pub fn has_start_hero_id(&self) -> bool {
        self.start_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_hero_id(&mut self, v: u32) {
        self.start_hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_start_hero_id(&self) -> u32 {
        self.start_hero_id.unwrap_or(0)
    }

    fn get_start_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.start_hero_id
    }

    fn mut_start_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.start_hero_id
    }
}

impl ::protobuf::Message for CMsgClientToGCGetAllHeroProgressResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.curr_hero_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.laps_completed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.curr_hero_games = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.curr_lap_time_started = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.curr_lap_games = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.best_lap_games = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.best_lap_time = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lap_heroes_completed = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lap_heroes_remaining = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.next_hero_id = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prev_hero_id = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prev_hero_games = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.prev_avg_tries = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.curr_avg_tries = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.next_avg_tries = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.full_lap_avg_tries = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.curr_lap_avg_tries = ::std::option::Option::Some(tmp);
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.profile_name)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_hero_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.curr_hero_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.laps_completed {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.curr_hero_games {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.curr_lap_time_started {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.curr_lap_games {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.best_lap_games {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.best_lap_time {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lap_heroes_completed {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lap_heroes_remaining {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.next_hero_id {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prev_hero_id {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prev_hero_games {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prev_avg_tries {
            my_size += 5;
        }
        if let Some(v) = self.curr_avg_tries {
            my_size += 5;
        }
        if let Some(v) = self.next_avg_tries {
            my_size += 6;
        }
        if let Some(v) = self.full_lap_avg_tries {
            my_size += 6;
        }
        if let Some(v) = self.curr_lap_avg_tries {
            my_size += 6;
        }
        if let Some(ref v) = self.profile_name.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(v) = self.start_hero_id {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.curr_hero_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.laps_completed {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.curr_hero_games {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.curr_lap_time_started {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.curr_lap_games {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.best_lap_games {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.best_lap_time {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.lap_heroes_completed {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.lap_heroes_remaining {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.next_hero_id {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.prev_hero_id {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.prev_hero_games {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.prev_avg_tries {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.curr_avg_tries {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.next_avg_tries {
            os.write_float(16, v)?;
        }
        if let Some(v) = self.full_lap_avg_tries {
            os.write_float(17, v)?;
        }
        if let Some(v) = self.curr_lap_avg_tries {
            os.write_float(18, v)?;
        }
        if let Some(ref v) = self.profile_name.as_ref() {
            os.write_string(19, &v)?;
        }
        if let Some(v) = self.start_hero_id {
            os.write_uint32(20, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetAllHeroProgressResponse {
    fn new() -> CMsgClientToGCGetAllHeroProgressResponse {
        CMsgClientToGCGetAllHeroProgressResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetAllHeroProgressResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgClientToGCGetAllHeroProgressResponse::get_account_id_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "curr_hero_id",
                    CMsgClientToGCGetAllHeroProgressResponse::get_curr_hero_id_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_curr_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "laps_completed",
                    CMsgClientToGCGetAllHeroProgressResponse::get_laps_completed_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_laps_completed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "curr_hero_games",
                    CMsgClientToGCGetAllHeroProgressResponse::get_curr_hero_games_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_curr_hero_games_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "curr_lap_time_started",
                    CMsgClientToGCGetAllHeroProgressResponse::get_curr_lap_time_started_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_curr_lap_time_started_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "curr_lap_games",
                    CMsgClientToGCGetAllHeroProgressResponse::get_curr_lap_games_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_curr_lap_games_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "best_lap_games",
                    CMsgClientToGCGetAllHeroProgressResponse::get_best_lap_games_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_best_lap_games_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "best_lap_time",
                    CMsgClientToGCGetAllHeroProgressResponse::get_best_lap_time_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_best_lap_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lap_heroes_completed",
                    CMsgClientToGCGetAllHeroProgressResponse::get_lap_heroes_completed_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_lap_heroes_completed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lap_heroes_remaining",
                    CMsgClientToGCGetAllHeroProgressResponse::get_lap_heroes_remaining_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_lap_heroes_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "next_hero_id",
                    CMsgClientToGCGetAllHeroProgressResponse::get_next_hero_id_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_next_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prev_hero_id",
                    CMsgClientToGCGetAllHeroProgressResponse::get_prev_hero_id_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_prev_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prev_hero_games",
                    CMsgClientToGCGetAllHeroProgressResponse::get_prev_hero_games_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_prev_hero_games_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "prev_avg_tries",
                    CMsgClientToGCGetAllHeroProgressResponse::get_prev_avg_tries_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_prev_avg_tries_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "curr_avg_tries",
                    CMsgClientToGCGetAllHeroProgressResponse::get_curr_avg_tries_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_curr_avg_tries_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "next_avg_tries",
                    CMsgClientToGCGetAllHeroProgressResponse::get_next_avg_tries_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_next_avg_tries_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "full_lap_avg_tries",
                    CMsgClientToGCGetAllHeroProgressResponse::get_full_lap_avg_tries_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_full_lap_avg_tries_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "curr_lap_avg_tries",
                    CMsgClientToGCGetAllHeroProgressResponse::get_curr_lap_avg_tries_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_curr_lap_avg_tries_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "profile_name",
                    CMsgClientToGCGetAllHeroProgressResponse::get_profile_name_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_profile_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "start_hero_id",
                    CMsgClientToGCGetAllHeroProgressResponse::get_start_hero_id_for_reflect,
                    CMsgClientToGCGetAllHeroProgressResponse::mut_start_hero_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetAllHeroProgressResponse>(
                    "CMsgClientToGCGetAllHeroProgressResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetAllHeroProgressResponse {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_curr_hero_id();
        self.clear_laps_completed();
        self.clear_curr_hero_games();
        self.clear_curr_lap_time_started();
        self.clear_curr_lap_games();
        self.clear_best_lap_games();
        self.clear_best_lap_time();
        self.clear_lap_heroes_completed();
        self.clear_lap_heroes_remaining();
        self.clear_next_hero_id();
        self.clear_prev_hero_id();
        self.clear_prev_hero_games();
        self.clear_prev_avg_tries();
        self.clear_curr_avg_tries();
        self.clear_next_avg_tries();
        self.clear_full_lap_avg_tries();
        self.clear_curr_lap_avg_tries();
        self.clear_profile_name();
        self.clear_start_hero_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetAllHeroProgressResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetAllHeroProgressResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetTrophyList {
    // message fields
    account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetTrophyList {}

impl CMsgClientToGCGetTrophyList {
    pub fn new() -> CMsgClientToGCGetTrophyList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetTrophyList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetTrophyList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetTrophyList,
        };
        unsafe {
            instance.get(CMsgClientToGCGetTrophyList::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgClientToGCGetTrophyList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetTrophyList {
    fn new() -> CMsgClientToGCGetTrophyList {
        CMsgClientToGCGetTrophyList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetTrophyList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgClientToGCGetTrophyList::get_account_id_for_reflect,
                    CMsgClientToGCGetTrophyList::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetTrophyList>(
                    "CMsgClientToGCGetTrophyList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetTrophyList {
    fn clear(&mut self) {
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetTrophyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetTrophyList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetTrophyListResponse {
    // message fields
    account_id: ::std::option::Option<u32>,
    trophies: ::protobuf::RepeatedField<CMsgClientToGCGetTrophyListResponse_Trophy>,
    profile_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetTrophyListResponse {}

impl CMsgClientToGCGetTrophyListResponse {
    pub fn new() -> CMsgClientToGCGetTrophyListResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetTrophyListResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetTrophyListResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetTrophyListResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCGetTrophyListResponse::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // repeated .CMsgClientToGCGetTrophyListResponse.Trophy trophies = 2;

    pub fn clear_trophies(&mut self) {
        self.trophies.clear();
    }

    // Param is passed by value, moved
    pub fn set_trophies(&mut self, v: ::protobuf::RepeatedField<CMsgClientToGCGetTrophyListResponse_Trophy>) {
        self.trophies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trophies(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCGetTrophyListResponse_Trophy> {
        &mut self.trophies
    }

    // Take field
    pub fn take_trophies(&mut self) -> ::protobuf::RepeatedField<CMsgClientToGCGetTrophyListResponse_Trophy> {
        ::std::mem::replace(&mut self.trophies, ::protobuf::RepeatedField::new())
    }

    pub fn get_trophies(&self) -> &[CMsgClientToGCGetTrophyListResponse_Trophy] {
        &self.trophies
    }

    fn get_trophies_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientToGCGetTrophyListResponse_Trophy> {
        &self.trophies
    }

    fn mut_trophies_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCGetTrophyListResponse_Trophy> {
        &mut self.trophies
    }

    // optional string profile_name = 3;

    pub fn clear_profile_name(&mut self) {
        self.profile_name.clear();
    }

    pub fn has_profile_name(&self) -> bool {
        self.profile_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile_name(&mut self, v: ::std::string::String) {
        self.profile_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profile_name(&mut self) -> &mut ::std::string::String {
        if self.profile_name.is_none() {
            self.profile_name.set_default();
        }
        self.profile_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_profile_name(&mut self) -> ::std::string::String {
        self.profile_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_profile_name(&self) -> &str {
        match self.profile_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_profile_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.profile_name
    }

    fn mut_profile_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.profile_name
    }
}

impl ::protobuf::Message for CMsgClientToGCGetTrophyListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.trophies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trophies)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.profile_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.trophies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.profile_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.trophies {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.profile_name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetTrophyListResponse {
    fn new() -> CMsgClientToGCGetTrophyListResponse {
        CMsgClientToGCGetTrophyListResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetTrophyListResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgClientToGCGetTrophyListResponse::get_account_id_for_reflect,
                    CMsgClientToGCGetTrophyListResponse::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCGetTrophyListResponse_Trophy>>(
                    "trophies",
                    CMsgClientToGCGetTrophyListResponse::get_trophies_for_reflect,
                    CMsgClientToGCGetTrophyListResponse::mut_trophies_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "profile_name",
                    CMsgClientToGCGetTrophyListResponse::get_profile_name_for_reflect,
                    CMsgClientToGCGetTrophyListResponse::mut_profile_name_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetTrophyListResponse>(
                    "CMsgClientToGCGetTrophyListResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetTrophyListResponse {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_trophies();
        self.clear_profile_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetTrophyListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetTrophyListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetTrophyListResponse_Trophy {
    // message fields
    trophy_id: ::std::option::Option<u32>,
    trophy_score: ::std::option::Option<u32>,
    last_updated: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetTrophyListResponse_Trophy {}

impl CMsgClientToGCGetTrophyListResponse_Trophy {
    pub fn new() -> CMsgClientToGCGetTrophyListResponse_Trophy {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetTrophyListResponse_Trophy {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetTrophyListResponse_Trophy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetTrophyListResponse_Trophy,
        };
        unsafe {
            instance.get(CMsgClientToGCGetTrophyListResponse_Trophy::new)
        }
    }

    // optional uint32 trophy_id = 1;

    pub fn clear_trophy_id(&mut self) {
        self.trophy_id = ::std::option::Option::None;
    }

    pub fn has_trophy_id(&self) -> bool {
        self.trophy_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trophy_id(&mut self, v: u32) {
        self.trophy_id = ::std::option::Option::Some(v);
    }

    pub fn get_trophy_id(&self) -> u32 {
        self.trophy_id.unwrap_or(0)
    }

    fn get_trophy_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.trophy_id
    }

    fn mut_trophy_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.trophy_id
    }

    // optional uint32 trophy_score = 2;

    pub fn clear_trophy_score(&mut self) {
        self.trophy_score = ::std::option::Option::None;
    }

    pub fn has_trophy_score(&self) -> bool {
        self.trophy_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trophy_score(&mut self, v: u32) {
        self.trophy_score = ::std::option::Option::Some(v);
    }

    pub fn get_trophy_score(&self) -> u32 {
        self.trophy_score.unwrap_or(0)
    }

    fn get_trophy_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.trophy_score
    }

    fn mut_trophy_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.trophy_score
    }

    // optional uint32 last_updated = 3;

    pub fn clear_last_updated(&mut self) {
        self.last_updated = ::std::option::Option::None;
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: u32) {
        self.last_updated = ::std::option::Option::Some(v);
    }

    pub fn get_last_updated(&self) -> u32 {
        self.last_updated.unwrap_or(0)
    }

    fn get_last_updated_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.last_updated
    }

    fn mut_last_updated_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.last_updated
    }
}

impl ::protobuf::Message for CMsgClientToGCGetTrophyListResponse_Trophy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.trophy_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.trophy_score = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_updated = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.trophy_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.trophy_score {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_updated {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.trophy_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.trophy_score {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.last_updated {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetTrophyListResponse_Trophy {
    fn new() -> CMsgClientToGCGetTrophyListResponse_Trophy {
        CMsgClientToGCGetTrophyListResponse_Trophy::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetTrophyListResponse_Trophy>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "trophy_id",
                    CMsgClientToGCGetTrophyListResponse_Trophy::get_trophy_id_for_reflect,
                    CMsgClientToGCGetTrophyListResponse_Trophy::mut_trophy_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "trophy_score",
                    CMsgClientToGCGetTrophyListResponse_Trophy::get_trophy_score_for_reflect,
                    CMsgClientToGCGetTrophyListResponse_Trophy::mut_trophy_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_updated",
                    CMsgClientToGCGetTrophyListResponse_Trophy::get_last_updated_for_reflect,
                    CMsgClientToGCGetTrophyListResponse_Trophy::mut_last_updated_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetTrophyListResponse_Trophy>(
                    "CMsgClientToGCGetTrophyListResponse_Trophy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetTrophyListResponse_Trophy {
    fn clear(&mut self) {
        self.clear_trophy_id();
        self.clear_trophy_score();
        self.clear_last_updated();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetTrophyListResponse_Trophy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetTrophyListResponse_Trophy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientTrophyAwarded {
    // message fields
    trophy_id: ::std::option::Option<u32>,
    trophy_score: ::std::option::Option<u32>,
    trophy_old_score: ::std::option::Option<u32>,
    last_updated: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientTrophyAwarded {}

impl CMsgGCToClientTrophyAwarded {
    pub fn new() -> CMsgGCToClientTrophyAwarded {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientTrophyAwarded {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientTrophyAwarded> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientTrophyAwarded,
        };
        unsafe {
            instance.get(CMsgGCToClientTrophyAwarded::new)
        }
    }

    // optional uint32 trophy_id = 1;

    pub fn clear_trophy_id(&mut self) {
        self.trophy_id = ::std::option::Option::None;
    }

    pub fn has_trophy_id(&self) -> bool {
        self.trophy_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trophy_id(&mut self, v: u32) {
        self.trophy_id = ::std::option::Option::Some(v);
    }

    pub fn get_trophy_id(&self) -> u32 {
        self.trophy_id.unwrap_or(0)
    }

    fn get_trophy_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.trophy_id
    }

    fn mut_trophy_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.trophy_id
    }

    // optional uint32 trophy_score = 2;

    pub fn clear_trophy_score(&mut self) {
        self.trophy_score = ::std::option::Option::None;
    }

    pub fn has_trophy_score(&self) -> bool {
        self.trophy_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trophy_score(&mut self, v: u32) {
        self.trophy_score = ::std::option::Option::Some(v);
    }

    pub fn get_trophy_score(&self) -> u32 {
        self.trophy_score.unwrap_or(0)
    }

    fn get_trophy_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.trophy_score
    }

    fn mut_trophy_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.trophy_score
    }

    // optional uint32 trophy_old_score = 3;

    pub fn clear_trophy_old_score(&mut self) {
        self.trophy_old_score = ::std::option::Option::None;
    }

    pub fn has_trophy_old_score(&self) -> bool {
        self.trophy_old_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trophy_old_score(&mut self, v: u32) {
        self.trophy_old_score = ::std::option::Option::Some(v);
    }

    pub fn get_trophy_old_score(&self) -> u32 {
        self.trophy_old_score.unwrap_or(0)
    }

    fn get_trophy_old_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.trophy_old_score
    }

    fn mut_trophy_old_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.trophy_old_score
    }

    // optional uint32 last_updated = 4;

    pub fn clear_last_updated(&mut self) {
        self.last_updated = ::std::option::Option::None;
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: u32) {
        self.last_updated = ::std::option::Option::Some(v);
    }

    pub fn get_last_updated(&self) -> u32 {
        self.last_updated.unwrap_or(0)
    }

    fn get_last_updated_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.last_updated
    }

    fn mut_last_updated_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.last_updated
    }
}

impl ::protobuf::Message for CMsgGCToClientTrophyAwarded {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.trophy_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.trophy_score = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.trophy_old_score = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_updated = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.trophy_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.trophy_score {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.trophy_old_score {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_updated {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.trophy_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.trophy_score {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.trophy_old_score {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.last_updated {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientTrophyAwarded {
    fn new() -> CMsgGCToClientTrophyAwarded {
        CMsgGCToClientTrophyAwarded::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientTrophyAwarded>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "trophy_id",
                    CMsgGCToClientTrophyAwarded::get_trophy_id_for_reflect,
                    CMsgGCToClientTrophyAwarded::mut_trophy_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "trophy_score",
                    CMsgGCToClientTrophyAwarded::get_trophy_score_for_reflect,
                    CMsgGCToClientTrophyAwarded::mut_trophy_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "trophy_old_score",
                    CMsgGCToClientTrophyAwarded::get_trophy_old_score_for_reflect,
                    CMsgGCToClientTrophyAwarded::mut_trophy_old_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_updated",
                    CMsgGCToClientTrophyAwarded::get_last_updated_for_reflect,
                    CMsgGCToClientTrophyAwarded::mut_last_updated_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientTrophyAwarded>(
                    "CMsgGCToClientTrophyAwarded",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientTrophyAwarded {
    fn clear(&mut self) {
        self.clear_trophy_id();
        self.clear_trophy_score();
        self.clear_trophy_old_score();
        self.clear_last_updated();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientTrophyAwarded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientTrophyAwarded {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetProfileCard {
    // message fields
    account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetProfileCard {}

impl CMsgClientToGCGetProfileCard {
    pub fn new() -> CMsgClientToGCGetProfileCard {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetProfileCard {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetProfileCard> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetProfileCard,
        };
        unsafe {
            instance.get(CMsgClientToGCGetProfileCard::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgClientToGCGetProfileCard {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetProfileCard {
    fn new() -> CMsgClientToGCGetProfileCard {
        CMsgClientToGCGetProfileCard::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetProfileCard>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgClientToGCGetProfileCard::get_account_id_for_reflect,
                    CMsgClientToGCGetProfileCard::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetProfileCard>(
                    "CMsgClientToGCGetProfileCard",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetProfileCard {
    fn clear(&mut self) {
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetProfileCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetProfileCard {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCSetProfileCardSlots {
    // message fields
    slots: ::protobuf::RepeatedField<CMsgClientToGCSetProfileCardSlots_CardSlot>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCSetProfileCardSlots {}

impl CMsgClientToGCSetProfileCardSlots {
    pub fn new() -> CMsgClientToGCSetProfileCardSlots {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCSetProfileCardSlots {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCSetProfileCardSlots> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCSetProfileCardSlots,
        };
        unsafe {
            instance.get(CMsgClientToGCSetProfileCardSlots::new)
        }
    }

    // repeated .CMsgClientToGCSetProfileCardSlots.CardSlot slots = 1;

    pub fn clear_slots(&mut self) {
        self.slots.clear();
    }

    // Param is passed by value, moved
    pub fn set_slots(&mut self, v: ::protobuf::RepeatedField<CMsgClientToGCSetProfileCardSlots_CardSlot>) {
        self.slots = v;
    }

    // Mutable pointer to the field.
    pub fn mut_slots(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCSetProfileCardSlots_CardSlot> {
        &mut self.slots
    }

    // Take field
    pub fn take_slots(&mut self) -> ::protobuf::RepeatedField<CMsgClientToGCSetProfileCardSlots_CardSlot> {
        ::std::mem::replace(&mut self.slots, ::protobuf::RepeatedField::new())
    }

    pub fn get_slots(&self) -> &[CMsgClientToGCSetProfileCardSlots_CardSlot] {
        &self.slots
    }

    fn get_slots_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientToGCSetProfileCardSlots_CardSlot> {
        &self.slots
    }

    fn mut_slots_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCSetProfileCardSlots_CardSlot> {
        &mut self.slots
    }
}

impl ::protobuf::Message for CMsgClientToGCSetProfileCardSlots {
    fn is_initialized(&self) -> bool {
        for v in &self.slots {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.slots)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.slots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.slots {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCSetProfileCardSlots {
    fn new() -> CMsgClientToGCSetProfileCardSlots {
        CMsgClientToGCSetProfileCardSlots::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCSetProfileCardSlots>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCSetProfileCardSlots_CardSlot>>(
                    "slots",
                    CMsgClientToGCSetProfileCardSlots::get_slots_for_reflect,
                    CMsgClientToGCSetProfileCardSlots::mut_slots_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCSetProfileCardSlots>(
                    "CMsgClientToGCSetProfileCardSlots",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCSetProfileCardSlots {
    fn clear(&mut self) {
        self.clear_slots();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCSetProfileCardSlots {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetProfileCardSlots {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCSetProfileCardSlots_CardSlot {
    // message fields
    slot_id: ::std::option::Option<u32>,
    slot_type: ::std::option::Option<super::dota_shared_enums::EProfileCardSlotType>,
    slot_value: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCSetProfileCardSlots_CardSlot {}

impl CMsgClientToGCSetProfileCardSlots_CardSlot {
    pub fn new() -> CMsgClientToGCSetProfileCardSlots_CardSlot {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCSetProfileCardSlots_CardSlot {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCSetProfileCardSlots_CardSlot> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCSetProfileCardSlots_CardSlot,
        };
        unsafe {
            instance.get(CMsgClientToGCSetProfileCardSlots_CardSlot::new)
        }
    }

    // optional uint32 slot_id = 1;

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    pub fn get_slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    fn get_slot_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_id
    }

    fn mut_slot_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_id
    }

    // optional .EProfileCardSlotType slot_type = 2;

    pub fn clear_slot_type(&mut self) {
        self.slot_type = ::std::option::Option::None;
    }

    pub fn has_slot_type(&self) -> bool {
        self.slot_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_type(&mut self, v: super::dota_shared_enums::EProfileCardSlotType) {
        self.slot_type = ::std::option::Option::Some(v);
    }

    pub fn get_slot_type(&self) -> super::dota_shared_enums::EProfileCardSlotType {
        self.slot_type.unwrap_or(super::dota_shared_enums::EProfileCardSlotType::k_EProfileCardSlotType_Empty)
    }

    fn get_slot_type_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::EProfileCardSlotType> {
        &self.slot_type
    }

    fn mut_slot_type_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::EProfileCardSlotType> {
        &mut self.slot_type
    }

    // optional uint64 slot_value = 3;

    pub fn clear_slot_value(&mut self) {
        self.slot_value = ::std::option::Option::None;
    }

    pub fn has_slot_value(&self) -> bool {
        self.slot_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_value(&mut self, v: u64) {
        self.slot_value = ::std::option::Option::Some(v);
    }

    pub fn get_slot_value(&self) -> u64 {
        self.slot_value.unwrap_or(0)
    }

    fn get_slot_value_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.slot_value
    }

    fn mut_slot_value_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.slot_value
    }
}

impl ::protobuf::Message for CMsgClientToGCSetProfileCardSlots_CardSlot {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.slot_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.slot_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.slot_value {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.slot_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.slot_type {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.slot_value {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCSetProfileCardSlots_CardSlot {
    fn new() -> CMsgClientToGCSetProfileCardSlots_CardSlot {
        CMsgClientToGCSetProfileCardSlots_CardSlot::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCSetProfileCardSlots_CardSlot>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_id",
                    CMsgClientToGCSetProfileCardSlots_CardSlot::get_slot_id_for_reflect,
                    CMsgClientToGCSetProfileCardSlots_CardSlot::mut_slot_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::EProfileCardSlotType>>(
                    "slot_type",
                    CMsgClientToGCSetProfileCardSlots_CardSlot::get_slot_type_for_reflect,
                    CMsgClientToGCSetProfileCardSlots_CardSlot::mut_slot_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "slot_value",
                    CMsgClientToGCSetProfileCardSlots_CardSlot::get_slot_value_for_reflect,
                    CMsgClientToGCSetProfileCardSlots_CardSlot::mut_slot_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCSetProfileCardSlots_CardSlot>(
                    "CMsgClientToGCSetProfileCardSlots_CardSlot",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCSetProfileCardSlots_CardSlot {
    fn clear(&mut self) {
        self.clear_slot_id();
        self.clear_slot_type();
        self.clear_slot_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCSetProfileCardSlots_CardSlot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetProfileCardSlots_CardSlot {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetProfileCardStats {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetProfileCardStats {}

impl CMsgClientToGCGetProfileCardStats {
    pub fn new() -> CMsgClientToGCGetProfileCardStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetProfileCardStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetProfileCardStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetProfileCardStats,
        };
        unsafe {
            instance.get(CMsgClientToGCGetProfileCardStats::new)
        }
    }
}

impl ::protobuf::Message for CMsgClientToGCGetProfileCardStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetProfileCardStats {
    fn new() -> CMsgClientToGCGetProfileCardStats {
        CMsgClientToGCGetProfileCardStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetProfileCardStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetProfileCardStats>(
                    "CMsgClientToGCGetProfileCardStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetProfileCardStats {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetProfileCardStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetProfileCardStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCCreateHeroStatue {
    // message fields
    source_item: ::std::option::Option<u64>,
    hero_id: ::std::option::Option<u32>,
    sequence_name: ::protobuf::SingularField<::std::string::String>,
    cycle: ::std::option::Option<f32>,
    wearables: ::std::vec::Vec<u32>,
    inscription: ::protobuf::SingularField<::std::string::String>,
    styles: ::std::vec::Vec<u32>,
    reforger_item: ::std::option::Option<u64>,
    tournament_drop: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCCreateHeroStatue {}

impl CMsgClientToGCCreateHeroStatue {
    pub fn new() -> CMsgClientToGCCreateHeroStatue {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCCreateHeroStatue {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCCreateHeroStatue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCCreateHeroStatue,
        };
        unsafe {
            instance.get(CMsgClientToGCCreateHeroStatue::new)
        }
    }

    // optional uint64 source_item = 1;

    pub fn clear_source_item(&mut self) {
        self.source_item = ::std::option::Option::None;
    }

    pub fn has_source_item(&self) -> bool {
        self.source_item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_item(&mut self, v: u64) {
        self.source_item = ::std::option::Option::Some(v);
    }

    pub fn get_source_item(&self) -> u64 {
        self.source_item.unwrap_or(0)
    }

    fn get_source_item_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.source_item
    }

    fn mut_source_item_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.source_item
    }

    // optional uint32 hero_id = 3;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional string sequence_name = 4;

    pub fn clear_sequence_name(&mut self) {
        self.sequence_name.clear();
    }

    pub fn has_sequence_name(&self) -> bool {
        self.sequence_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_name(&mut self, v: ::std::string::String) {
        self.sequence_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequence_name(&mut self) -> &mut ::std::string::String {
        if self.sequence_name.is_none() {
            self.sequence_name.set_default();
        }
        self.sequence_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sequence_name(&mut self) -> ::std::string::String {
        self.sequence_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_sequence_name(&self) -> &str {
        match self.sequence_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_sequence_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.sequence_name
    }

    fn mut_sequence_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.sequence_name
    }

    // optional float cycle = 5;

    pub fn clear_cycle(&mut self) {
        self.cycle = ::std::option::Option::None;
    }

    pub fn has_cycle(&self) -> bool {
        self.cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cycle(&mut self, v: f32) {
        self.cycle = ::std::option::Option::Some(v);
    }

    pub fn get_cycle(&self) -> f32 {
        self.cycle.unwrap_or(0.)
    }

    fn get_cycle_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.cycle
    }

    fn mut_cycle_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.cycle
    }

    // repeated uint32 wearables = 6;

    pub fn clear_wearables(&mut self) {
        self.wearables.clear();
    }

    // Param is passed by value, moved
    pub fn set_wearables(&mut self, v: ::std::vec::Vec<u32>) {
        self.wearables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_wearables(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.wearables
    }

    // Take field
    pub fn take_wearables(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.wearables, ::std::vec::Vec::new())
    }

    pub fn get_wearables(&self) -> &[u32] {
        &self.wearables
    }

    fn get_wearables_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.wearables
    }

    fn mut_wearables_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.wearables
    }

    // optional string inscription = 7;

    pub fn clear_inscription(&mut self) {
        self.inscription.clear();
    }

    pub fn has_inscription(&self) -> bool {
        self.inscription.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inscription(&mut self, v: ::std::string::String) {
        self.inscription = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inscription(&mut self) -> &mut ::std::string::String {
        if self.inscription.is_none() {
            self.inscription.set_default();
        }
        self.inscription.as_mut().unwrap()
    }

    // Take field
    pub fn take_inscription(&mut self) -> ::std::string::String {
        self.inscription.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_inscription(&self) -> &str {
        match self.inscription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_inscription_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.inscription
    }

    fn mut_inscription_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.inscription
    }

    // repeated uint32 styles = 8;

    pub fn clear_styles(&mut self) {
        self.styles.clear();
    }

    // Param is passed by value, moved
    pub fn set_styles(&mut self, v: ::std::vec::Vec<u32>) {
        self.styles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_styles(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.styles
    }

    // Take field
    pub fn take_styles(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.styles, ::std::vec::Vec::new())
    }

    pub fn get_styles(&self) -> &[u32] {
        &self.styles
    }

    fn get_styles_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.styles
    }

    fn mut_styles_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.styles
    }

    // optional uint64 reforger_item = 9;

    pub fn clear_reforger_item(&mut self) {
        self.reforger_item = ::std::option::Option::None;
    }

    pub fn has_reforger_item(&self) -> bool {
        self.reforger_item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reforger_item(&mut self, v: u64) {
        self.reforger_item = ::std::option::Option::Some(v);
    }

    pub fn get_reforger_item(&self) -> u64 {
        self.reforger_item.unwrap_or(0)
    }

    fn get_reforger_item_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.reforger_item
    }

    fn mut_reforger_item_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.reforger_item
    }

    // optional bool tournament_drop = 10;

    pub fn clear_tournament_drop(&mut self) {
        self.tournament_drop = ::std::option::Option::None;
    }

    pub fn has_tournament_drop(&self) -> bool {
        self.tournament_drop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_drop(&mut self, v: bool) {
        self.tournament_drop = ::std::option::Option::Some(v);
    }

    pub fn get_tournament_drop(&self) -> bool {
        self.tournament_drop.unwrap_or(false)
    }

    fn get_tournament_drop_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.tournament_drop
    }

    fn mut_tournament_drop_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.tournament_drop
    }
}

impl ::protobuf::Message for CMsgClientToGCCreateHeroStatue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.source_item = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sequence_name)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cycle = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.wearables)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.inscription)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.styles)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.reforger_item = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tournament_drop = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.source_item {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sequence_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.cycle {
            my_size += 5;
        }
        for value in &self.wearables {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.inscription.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        for value in &self.styles {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.reforger_item {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tournament_drop {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.source_item {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.sequence_name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.cycle {
            os.write_float(5, v)?;
        }
        for v in &self.wearables {
            os.write_uint32(6, *v)?;
        };
        if let Some(ref v) = self.inscription.as_ref() {
            os.write_string(7, &v)?;
        }
        for v in &self.styles {
            os.write_uint32(8, *v)?;
        };
        if let Some(v) = self.reforger_item {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.tournament_drop {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCCreateHeroStatue {
    fn new() -> CMsgClientToGCCreateHeroStatue {
        CMsgClientToGCCreateHeroStatue::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCCreateHeroStatue>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "source_item",
                    CMsgClientToGCCreateHeroStatue::get_source_item_for_reflect,
                    CMsgClientToGCCreateHeroStatue::mut_source_item_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgClientToGCCreateHeroStatue::get_hero_id_for_reflect,
                    CMsgClientToGCCreateHeroStatue::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sequence_name",
                    CMsgClientToGCCreateHeroStatue::get_sequence_name_for_reflect,
                    CMsgClientToGCCreateHeroStatue::mut_sequence_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "cycle",
                    CMsgClientToGCCreateHeroStatue::get_cycle_for_reflect,
                    CMsgClientToGCCreateHeroStatue::mut_cycle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wearables",
                    CMsgClientToGCCreateHeroStatue::get_wearables_for_reflect,
                    CMsgClientToGCCreateHeroStatue::mut_wearables_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "inscription",
                    CMsgClientToGCCreateHeroStatue::get_inscription_for_reflect,
                    CMsgClientToGCCreateHeroStatue::mut_inscription_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "styles",
                    CMsgClientToGCCreateHeroStatue::get_styles_for_reflect,
                    CMsgClientToGCCreateHeroStatue::mut_styles_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "reforger_item",
                    CMsgClientToGCCreateHeroStatue::get_reforger_item_for_reflect,
                    CMsgClientToGCCreateHeroStatue::mut_reforger_item_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "tournament_drop",
                    CMsgClientToGCCreateHeroStatue::get_tournament_drop_for_reflect,
                    CMsgClientToGCCreateHeroStatue::mut_tournament_drop_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCCreateHeroStatue>(
                    "CMsgClientToGCCreateHeroStatue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCCreateHeroStatue {
    fn clear(&mut self) {
        self.clear_source_item();
        self.clear_hero_id();
        self.clear_sequence_name();
        self.clear_cycle();
        self.clear_wearables();
        self.clear_inscription();
        self.clear_styles();
        self.clear_reforger_item();
        self.clear_tournament_drop();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCCreateHeroStatue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCreateHeroStatue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientHeroStatueCreateResult {
    // message fields
    resulting_item: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientHeroStatueCreateResult {}

impl CMsgGCToClientHeroStatueCreateResult {
    pub fn new() -> CMsgGCToClientHeroStatueCreateResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientHeroStatueCreateResult {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientHeroStatueCreateResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientHeroStatueCreateResult,
        };
        unsafe {
            instance.get(CMsgGCToClientHeroStatueCreateResult::new)
        }
    }

    // optional uint64 resulting_item = 1;

    pub fn clear_resulting_item(&mut self) {
        self.resulting_item = ::std::option::Option::None;
    }

    pub fn has_resulting_item(&self) -> bool {
        self.resulting_item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resulting_item(&mut self, v: u64) {
        self.resulting_item = ::std::option::Option::Some(v);
    }

    pub fn get_resulting_item(&self) -> u64 {
        self.resulting_item.unwrap_or(0)
    }

    fn get_resulting_item_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.resulting_item
    }

    fn mut_resulting_item_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.resulting_item
    }
}

impl ::protobuf::Message for CMsgGCToClientHeroStatueCreateResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.resulting_item = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.resulting_item {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.resulting_item {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientHeroStatueCreateResult {
    fn new() -> CMsgGCToClientHeroStatueCreateResult {
        CMsgGCToClientHeroStatueCreateResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientHeroStatueCreateResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "resulting_item",
                    CMsgGCToClientHeroStatueCreateResult::get_resulting_item_for_reflect,
                    CMsgGCToClientHeroStatueCreateResult::mut_resulting_item_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientHeroStatueCreateResult>(
                    "CMsgGCToClientHeroStatueCreateResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientHeroStatueCreateResult {
    fn clear(&mut self) {
        self.clear_resulting_item();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientHeroStatueCreateResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientHeroStatueCreateResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRecordCompendiumStats {
    // message fields
    league_id: ::std::option::Option<u32>,
    view_duration_s: ::std::option::Option<u32>,
    videos_viewed: ::std::option::Option<u32>,
    page_turns: ::std::option::Option<u32>,
    links_followed: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRecordCompendiumStats {}

impl CMsgClientToGCRecordCompendiumStats {
    pub fn new() -> CMsgClientToGCRecordCompendiumStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRecordCompendiumStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRecordCompendiumStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRecordCompendiumStats,
        };
        unsafe {
            instance.get(CMsgClientToGCRecordCompendiumStats::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional uint32 view_duration_s = 2;

    pub fn clear_view_duration_s(&mut self) {
        self.view_duration_s = ::std::option::Option::None;
    }

    pub fn has_view_duration_s(&self) -> bool {
        self.view_duration_s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_duration_s(&mut self, v: u32) {
        self.view_duration_s = ::std::option::Option::Some(v);
    }

    pub fn get_view_duration_s(&self) -> u32 {
        self.view_duration_s.unwrap_or(0)
    }

    fn get_view_duration_s_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.view_duration_s
    }

    fn mut_view_duration_s_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.view_duration_s
    }

    // optional uint32 videos_viewed = 3;

    pub fn clear_videos_viewed(&mut self) {
        self.videos_viewed = ::std::option::Option::None;
    }

    pub fn has_videos_viewed(&self) -> bool {
        self.videos_viewed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_videos_viewed(&mut self, v: u32) {
        self.videos_viewed = ::std::option::Option::Some(v);
    }

    pub fn get_videos_viewed(&self) -> u32 {
        self.videos_viewed.unwrap_or(0)
    }

    fn get_videos_viewed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.videos_viewed
    }

    fn mut_videos_viewed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.videos_viewed
    }

    // optional uint32 page_turns = 4;

    pub fn clear_page_turns(&mut self) {
        self.page_turns = ::std::option::Option::None;
    }

    pub fn has_page_turns(&self) -> bool {
        self.page_turns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_turns(&mut self, v: u32) {
        self.page_turns = ::std::option::Option::Some(v);
    }

    pub fn get_page_turns(&self) -> u32 {
        self.page_turns.unwrap_or(0)
    }

    fn get_page_turns_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.page_turns
    }

    fn mut_page_turns_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.page_turns
    }

    // optional uint32 links_followed = 5;

    pub fn clear_links_followed(&mut self) {
        self.links_followed = ::std::option::Option::None;
    }

    pub fn has_links_followed(&self) -> bool {
        self.links_followed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_links_followed(&mut self, v: u32) {
        self.links_followed = ::std::option::Option::Some(v);
    }

    pub fn get_links_followed(&self) -> u32 {
        self.links_followed.unwrap_or(0)
    }

    fn get_links_followed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.links_followed
    }

    fn mut_links_followed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.links_followed
    }
}

impl ::protobuf::Message for CMsgClientToGCRecordCompendiumStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.view_duration_s = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.videos_viewed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_turns = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.links_followed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.view_duration_s {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.videos_viewed {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.page_turns {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.links_followed {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.view_duration_s {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.videos_viewed {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.page_turns {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.links_followed {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRecordCompendiumStats {
    fn new() -> CMsgClientToGCRecordCompendiumStats {
        CMsgClientToGCRecordCompendiumStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRecordCompendiumStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgClientToGCRecordCompendiumStats::get_league_id_for_reflect,
                    CMsgClientToGCRecordCompendiumStats::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "view_duration_s",
                    CMsgClientToGCRecordCompendiumStats::get_view_duration_s_for_reflect,
                    CMsgClientToGCRecordCompendiumStats::mut_view_duration_s_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "videos_viewed",
                    CMsgClientToGCRecordCompendiumStats::get_videos_viewed_for_reflect,
                    CMsgClientToGCRecordCompendiumStats::mut_videos_viewed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "page_turns",
                    CMsgClientToGCRecordCompendiumStats::get_page_turns_for_reflect,
                    CMsgClientToGCRecordCompendiumStats::mut_page_turns_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "links_followed",
                    CMsgClientToGCRecordCompendiumStats::get_links_followed_for_reflect,
                    CMsgClientToGCRecordCompendiumStats::mut_links_followed_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRecordCompendiumStats>(
                    "CMsgClientToGCRecordCompendiumStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRecordCompendiumStats {
    fn clear(&mut self) {
        self.clear_league_id();
        self.clear_view_duration_s();
        self.clear_videos_viewed();
        self.clear_page_turns();
        self.clear_links_followed();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRecordCompendiumStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRecordCompendiumStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientEventStatusChanged {
    // message fields
    active_event: ::std::option::Option<super::dota_shared_enums::EEvent>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientEventStatusChanged {}

impl CMsgGCToClientEventStatusChanged {
    pub fn new() -> CMsgGCToClientEventStatusChanged {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientEventStatusChanged {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientEventStatusChanged> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientEventStatusChanged,
        };
        unsafe {
            instance.get(CMsgGCToClientEventStatusChanged::new)
        }
    }

    // optional .EEvent active_event = 2;

    pub fn clear_active_event(&mut self) {
        self.active_event = ::std::option::Option::None;
    }

    pub fn has_active_event(&self) -> bool {
        self.active_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_event(&mut self, v: super::dota_shared_enums::EEvent) {
        self.active_event = ::std::option::Option::Some(v);
    }

    pub fn get_active_event(&self) -> super::dota_shared_enums::EEvent {
        self.active_event.unwrap_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE)
    }

    fn get_active_event_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::EEvent> {
        &self.active_event
    }

    fn mut_active_event_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::EEvent> {
        &mut self.active_event
    }
}

impl ::protobuf::Message for CMsgGCToClientEventStatusChanged {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.active_event = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.active_event {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.active_event {
            os.write_enum(2, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientEventStatusChanged {
    fn new() -> CMsgGCToClientEventStatusChanged {
        CMsgGCToClientEventStatusChanged::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientEventStatusChanged>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::EEvent>>(
                    "active_event",
                    CMsgGCToClientEventStatusChanged::get_active_event_for_reflect,
                    CMsgGCToClientEventStatusChanged::mut_active_event_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientEventStatusChanged>(
                    "CMsgGCToClientEventStatusChanged",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientEventStatusChanged {
    fn clear(&mut self) {
        self.clear_active_event();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientEventStatusChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientEventStatusChanged {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCPlayerStatsRequest {
    // message fields
    account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCPlayerStatsRequest {}

impl CMsgClientToGCPlayerStatsRequest {
    pub fn new() -> CMsgClientToGCPlayerStatsRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCPlayerStatsRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCPlayerStatsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCPlayerStatsRequest,
        };
        unsafe {
            instance.get(CMsgClientToGCPlayerStatsRequest::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgClientToGCPlayerStatsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCPlayerStatsRequest {
    fn new() -> CMsgClientToGCPlayerStatsRequest {
        CMsgClientToGCPlayerStatsRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCPlayerStatsRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgClientToGCPlayerStatsRequest::get_account_id_for_reflect,
                    CMsgClientToGCPlayerStatsRequest::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCPlayerStatsRequest>(
                    "CMsgClientToGCPlayerStatsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCPlayerStatsRequest {
    fn clear(&mut self) {
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCPlayerStatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCPlayerStatsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientPlayerStatsResponse {
    // message fields
    account_id: ::std::option::Option<u32>,
    player_stats: ::std::vec::Vec<f32>,
    match_count: ::std::option::Option<u32>,
    mean_gpm: ::std::option::Option<f32>,
    mean_xppm: ::std::option::Option<f32>,
    mean_lasthits: ::std::option::Option<f32>,
    rampages: ::std::option::Option<u32>,
    triple_kills: ::std::option::Option<u32>,
    first_blood_claimed: ::std::option::Option<u32>,
    first_blood_given: ::std::option::Option<u32>,
    couriers_killed: ::std::option::Option<u32>,
    aegises_snatched: ::std::option::Option<u32>,
    cheeses_eaten: ::std::option::Option<u32>,
    creeps_stacked: ::std::option::Option<u32>,
    fight_score: ::std::option::Option<f32>,
    farm_score: ::std::option::Option<f32>,
    support_score: ::std::option::Option<f32>,
    push_score: ::std::option::Option<f32>,
    versatility_score: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientPlayerStatsResponse {}

impl CMsgGCToClientPlayerStatsResponse {
    pub fn new() -> CMsgGCToClientPlayerStatsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientPlayerStatsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientPlayerStatsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientPlayerStatsResponse,
        };
        unsafe {
            instance.get(CMsgGCToClientPlayerStatsResponse::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // repeated float player_stats = 2;

    pub fn clear_player_stats(&mut self) {
        self.player_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_stats(&mut self, v: ::std::vec::Vec<f32>) {
        self.player_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_stats(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.player_stats
    }

    // Take field
    pub fn take_player_stats(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.player_stats, ::std::vec::Vec::new())
    }

    pub fn get_player_stats(&self) -> &[f32] {
        &self.player_stats
    }

    fn get_player_stats_for_reflect(&self) -> &::std::vec::Vec<f32> {
        &self.player_stats
    }

    fn mut_player_stats_for_reflect(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.player_stats
    }

    // optional uint32 match_count = 3;

    pub fn clear_match_count(&mut self) {
        self.match_count = ::std::option::Option::None;
    }

    pub fn has_match_count(&self) -> bool {
        self.match_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_count(&mut self, v: u32) {
        self.match_count = ::std::option::Option::Some(v);
    }

    pub fn get_match_count(&self) -> u32 {
        self.match_count.unwrap_or(0)
    }

    fn get_match_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.match_count
    }

    fn mut_match_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.match_count
    }

    // optional float mean_gpm = 4;

    pub fn clear_mean_gpm(&mut self) {
        self.mean_gpm = ::std::option::Option::None;
    }

    pub fn has_mean_gpm(&self) -> bool {
        self.mean_gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mean_gpm(&mut self, v: f32) {
        self.mean_gpm = ::std::option::Option::Some(v);
    }

    pub fn get_mean_gpm(&self) -> f32 {
        self.mean_gpm.unwrap_or(0.)
    }

    fn get_mean_gpm_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.mean_gpm
    }

    fn mut_mean_gpm_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.mean_gpm
    }

    // optional float mean_xppm = 5;

    pub fn clear_mean_xppm(&mut self) {
        self.mean_xppm = ::std::option::Option::None;
    }

    pub fn has_mean_xppm(&self) -> bool {
        self.mean_xppm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mean_xppm(&mut self, v: f32) {
        self.mean_xppm = ::std::option::Option::Some(v);
    }

    pub fn get_mean_xppm(&self) -> f32 {
        self.mean_xppm.unwrap_or(0.)
    }

    fn get_mean_xppm_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.mean_xppm
    }

    fn mut_mean_xppm_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.mean_xppm
    }

    // optional float mean_lasthits = 6;

    pub fn clear_mean_lasthits(&mut self) {
        self.mean_lasthits = ::std::option::Option::None;
    }

    pub fn has_mean_lasthits(&self) -> bool {
        self.mean_lasthits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mean_lasthits(&mut self, v: f32) {
        self.mean_lasthits = ::std::option::Option::Some(v);
    }

    pub fn get_mean_lasthits(&self) -> f32 {
        self.mean_lasthits.unwrap_or(0.)
    }

    fn get_mean_lasthits_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.mean_lasthits
    }

    fn mut_mean_lasthits_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.mean_lasthits
    }

    // optional uint32 rampages = 7;

    pub fn clear_rampages(&mut self) {
        self.rampages = ::std::option::Option::None;
    }

    pub fn has_rampages(&self) -> bool {
        self.rampages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampages(&mut self, v: u32) {
        self.rampages = ::std::option::Option::Some(v);
    }

    pub fn get_rampages(&self) -> u32 {
        self.rampages.unwrap_or(0)
    }

    fn get_rampages_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rampages
    }

    fn mut_rampages_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rampages
    }

    // optional uint32 triple_kills = 8;

    pub fn clear_triple_kills(&mut self) {
        self.triple_kills = ::std::option::Option::None;
    }

    pub fn has_triple_kills(&self) -> bool {
        self.triple_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_triple_kills(&mut self, v: u32) {
        self.triple_kills = ::std::option::Option::Some(v);
    }

    pub fn get_triple_kills(&self) -> u32 {
        self.triple_kills.unwrap_or(0)
    }

    fn get_triple_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.triple_kills
    }

    fn mut_triple_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.triple_kills
    }

    // optional uint32 first_blood_claimed = 9;

    pub fn clear_first_blood_claimed(&mut self) {
        self.first_blood_claimed = ::std::option::Option::None;
    }

    pub fn has_first_blood_claimed(&self) -> bool {
        self.first_blood_claimed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_claimed(&mut self, v: u32) {
        self.first_blood_claimed = ::std::option::Option::Some(v);
    }

    pub fn get_first_blood_claimed(&self) -> u32 {
        self.first_blood_claimed.unwrap_or(0)
    }

    fn get_first_blood_claimed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.first_blood_claimed
    }

    fn mut_first_blood_claimed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.first_blood_claimed
    }

    // optional uint32 first_blood_given = 10;

    pub fn clear_first_blood_given(&mut self) {
        self.first_blood_given = ::std::option::Option::None;
    }

    pub fn has_first_blood_given(&self) -> bool {
        self.first_blood_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_given(&mut self, v: u32) {
        self.first_blood_given = ::std::option::Option::Some(v);
    }

    pub fn get_first_blood_given(&self) -> u32 {
        self.first_blood_given.unwrap_or(0)
    }

    fn get_first_blood_given_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.first_blood_given
    }

    fn mut_first_blood_given_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.first_blood_given
    }

    // optional uint32 couriers_killed = 11;

    pub fn clear_couriers_killed(&mut self) {
        self.couriers_killed = ::std::option::Option::None;
    }

    pub fn has_couriers_killed(&self) -> bool {
        self.couriers_killed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_couriers_killed(&mut self, v: u32) {
        self.couriers_killed = ::std::option::Option::Some(v);
    }

    pub fn get_couriers_killed(&self) -> u32 {
        self.couriers_killed.unwrap_or(0)
    }

    fn get_couriers_killed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.couriers_killed
    }

    fn mut_couriers_killed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.couriers_killed
    }

    // optional uint32 aegises_snatched = 12;

    pub fn clear_aegises_snatched(&mut self) {
        self.aegises_snatched = ::std::option::Option::None;
    }

    pub fn has_aegises_snatched(&self) -> bool {
        self.aegises_snatched.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aegises_snatched(&mut self, v: u32) {
        self.aegises_snatched = ::std::option::Option::Some(v);
    }

    pub fn get_aegises_snatched(&self) -> u32 {
        self.aegises_snatched.unwrap_or(0)
    }

    fn get_aegises_snatched_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.aegises_snatched
    }

    fn mut_aegises_snatched_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.aegises_snatched
    }

    // optional uint32 cheeses_eaten = 13;

    pub fn clear_cheeses_eaten(&mut self) {
        self.cheeses_eaten = ::std::option::Option::None;
    }

    pub fn has_cheeses_eaten(&self) -> bool {
        self.cheeses_eaten.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheeses_eaten(&mut self, v: u32) {
        self.cheeses_eaten = ::std::option::Option::Some(v);
    }

    pub fn get_cheeses_eaten(&self) -> u32 {
        self.cheeses_eaten.unwrap_or(0)
    }

    fn get_cheeses_eaten_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cheeses_eaten
    }

    fn mut_cheeses_eaten_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cheeses_eaten
    }

    // optional uint32 creeps_stacked = 14;

    pub fn clear_creeps_stacked(&mut self) {
        self.creeps_stacked = ::std::option::Option::None;
    }

    pub fn has_creeps_stacked(&self) -> bool {
        self.creeps_stacked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creeps_stacked(&mut self, v: u32) {
        self.creeps_stacked = ::std::option::Option::Some(v);
    }

    pub fn get_creeps_stacked(&self) -> u32 {
        self.creeps_stacked.unwrap_or(0)
    }

    fn get_creeps_stacked_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.creeps_stacked
    }

    fn mut_creeps_stacked_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.creeps_stacked
    }

    // optional float fight_score = 15;

    pub fn clear_fight_score(&mut self) {
        self.fight_score = ::std::option::Option::None;
    }

    pub fn has_fight_score(&self) -> bool {
        self.fight_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fight_score(&mut self, v: f32) {
        self.fight_score = ::std::option::Option::Some(v);
    }

    pub fn get_fight_score(&self) -> f32 {
        self.fight_score.unwrap_or(0.)
    }

    fn get_fight_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.fight_score
    }

    fn mut_fight_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.fight_score
    }

    // optional float farm_score = 16;

    pub fn clear_farm_score(&mut self) {
        self.farm_score = ::std::option::Option::None;
    }

    pub fn has_farm_score(&self) -> bool {
        self.farm_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_farm_score(&mut self, v: f32) {
        self.farm_score = ::std::option::Option::Some(v);
    }

    pub fn get_farm_score(&self) -> f32 {
        self.farm_score.unwrap_or(0.)
    }

    fn get_farm_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.farm_score
    }

    fn mut_farm_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.farm_score
    }

    // optional float support_score = 17;

    pub fn clear_support_score(&mut self) {
        self.support_score = ::std::option::Option::None;
    }

    pub fn has_support_score(&self) -> bool {
        self.support_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_score(&mut self, v: f32) {
        self.support_score = ::std::option::Option::Some(v);
    }

    pub fn get_support_score(&self) -> f32 {
        self.support_score.unwrap_or(0.)
    }

    fn get_support_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.support_score
    }

    fn mut_support_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.support_score
    }

    // optional float push_score = 18;

    pub fn clear_push_score(&mut self) {
        self.push_score = ::std::option::Option::None;
    }

    pub fn has_push_score(&self) -> bool {
        self.push_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_score(&mut self, v: f32) {
        self.push_score = ::std::option::Option::Some(v);
    }

    pub fn get_push_score(&self) -> f32 {
        self.push_score.unwrap_or(0.)
    }

    fn get_push_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.push_score
    }

    fn mut_push_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.push_score
    }

    // optional float versatility_score = 19;

    pub fn clear_versatility_score(&mut self) {
        self.versatility_score = ::std::option::Option::None;
    }

    pub fn has_versatility_score(&self) -> bool {
        self.versatility_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_versatility_score(&mut self, v: f32) {
        self.versatility_score = ::std::option::Option::Some(v);
    }

    pub fn get_versatility_score(&self) -> f32 {
        self.versatility_score.unwrap_or(0.)
    }

    fn get_versatility_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.versatility_score
    }

    fn mut_versatility_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.versatility_score
    }
}

impl ::protobuf::Message for CMsgGCToClientPlayerStatsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.player_stats)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.match_count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.mean_gpm = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.mean_xppm = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.mean_lasthits = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rampages = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.triple_kills = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_blood_claimed = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_blood_given = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.couriers_killed = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.aegises_snatched = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cheeses_eaten = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.creeps_stacked = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.fight_score = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.farm_score = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.support_score = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.push_score = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.versatility_score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 5 * self.player_stats.len() as u32;
        if let Some(v) = self.match_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mean_gpm {
            my_size += 5;
        }
        if let Some(v) = self.mean_xppm {
            my_size += 5;
        }
        if let Some(v) = self.mean_lasthits {
            my_size += 5;
        }
        if let Some(v) = self.rampages {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.triple_kills {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.first_blood_claimed {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.first_blood_given {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.couriers_killed {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.aegises_snatched {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cheeses_eaten {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.creeps_stacked {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fight_score {
            my_size += 5;
        }
        if let Some(v) = self.farm_score {
            my_size += 6;
        }
        if let Some(v) = self.support_score {
            my_size += 6;
        }
        if let Some(v) = self.push_score {
            my_size += 6;
        }
        if let Some(v) = self.versatility_score {
            my_size += 6;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.player_stats {
            os.write_float(2, *v)?;
        };
        if let Some(v) = self.match_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.mean_gpm {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.mean_xppm {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.mean_lasthits {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.rampages {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.triple_kills {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.first_blood_claimed {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.first_blood_given {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.couriers_killed {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.aegises_snatched {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.cheeses_eaten {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.creeps_stacked {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.fight_score {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.farm_score {
            os.write_float(16, v)?;
        }
        if let Some(v) = self.support_score {
            os.write_float(17, v)?;
        }
        if let Some(v) = self.push_score {
            os.write_float(18, v)?;
        }
        if let Some(v) = self.versatility_score {
            os.write_float(19, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientPlayerStatsResponse {
    fn new() -> CMsgGCToClientPlayerStatsResponse {
        CMsgGCToClientPlayerStatsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientPlayerStatsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCToClientPlayerStatsResponse::get_account_id_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "player_stats",
                    CMsgGCToClientPlayerStatsResponse::get_player_stats_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_player_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "match_count",
                    CMsgGCToClientPlayerStatsResponse::get_match_count_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_match_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "mean_gpm",
                    CMsgGCToClientPlayerStatsResponse::get_mean_gpm_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_mean_gpm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "mean_xppm",
                    CMsgGCToClientPlayerStatsResponse::get_mean_xppm_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_mean_xppm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "mean_lasthits",
                    CMsgGCToClientPlayerStatsResponse::get_mean_lasthits_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_mean_lasthits_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rampages",
                    CMsgGCToClientPlayerStatsResponse::get_rampages_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_rampages_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "triple_kills",
                    CMsgGCToClientPlayerStatsResponse::get_triple_kills_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_triple_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "first_blood_claimed",
                    CMsgGCToClientPlayerStatsResponse::get_first_blood_claimed_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_first_blood_claimed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "first_blood_given",
                    CMsgGCToClientPlayerStatsResponse::get_first_blood_given_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_first_blood_given_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "couriers_killed",
                    CMsgGCToClientPlayerStatsResponse::get_couriers_killed_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_couriers_killed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "aegises_snatched",
                    CMsgGCToClientPlayerStatsResponse::get_aegises_snatched_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_aegises_snatched_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cheeses_eaten",
                    CMsgGCToClientPlayerStatsResponse::get_cheeses_eaten_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_cheeses_eaten_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "creeps_stacked",
                    CMsgGCToClientPlayerStatsResponse::get_creeps_stacked_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_creeps_stacked_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "fight_score",
                    CMsgGCToClientPlayerStatsResponse::get_fight_score_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_fight_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "farm_score",
                    CMsgGCToClientPlayerStatsResponse::get_farm_score_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_farm_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "support_score",
                    CMsgGCToClientPlayerStatsResponse::get_support_score_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_support_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "push_score",
                    CMsgGCToClientPlayerStatsResponse::get_push_score_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_push_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "versatility_score",
                    CMsgGCToClientPlayerStatsResponse::get_versatility_score_for_reflect,
                    CMsgGCToClientPlayerStatsResponse::mut_versatility_score_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientPlayerStatsResponse>(
                    "CMsgGCToClientPlayerStatsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientPlayerStatsResponse {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_player_stats();
        self.clear_match_count();
        self.clear_mean_gpm();
        self.clear_mean_xppm();
        self.clear_mean_lasthits();
        self.clear_rampages();
        self.clear_triple_kills();
        self.clear_first_blood_claimed();
        self.clear_first_blood_given();
        self.clear_couriers_killed();
        self.clear_aegises_snatched();
        self.clear_cheeses_eaten();
        self.clear_creeps_stacked();
        self.clear_fight_score();
        self.clear_farm_score();
        self.clear_support_score();
        self.clear_push_score();
        self.clear_versatility_score();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientPlayerStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientPlayerStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCCustomGamePlayerCountRequest {
    // message fields
    custom_game_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCCustomGamePlayerCountRequest {}

impl CMsgClientToGCCustomGamePlayerCountRequest {
    pub fn new() -> CMsgClientToGCCustomGamePlayerCountRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCCustomGamePlayerCountRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCCustomGamePlayerCountRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCCustomGamePlayerCountRequest,
        };
        unsafe {
            instance.get(CMsgClientToGCCustomGamePlayerCountRequest::new)
        }
    }

    // optional uint64 custom_game_id = 1;

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    pub fn get_custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    fn get_custom_game_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.custom_game_id
    }

    fn mut_custom_game_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.custom_game_id
    }
}

impl ::protobuf::Message for CMsgClientToGCCustomGamePlayerCountRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.custom_game_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.custom_game_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.custom_game_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCCustomGamePlayerCountRequest {
    fn new() -> CMsgClientToGCCustomGamePlayerCountRequest {
        CMsgClientToGCCustomGamePlayerCountRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCCustomGamePlayerCountRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "custom_game_id",
                    CMsgClientToGCCustomGamePlayerCountRequest::get_custom_game_id_for_reflect,
                    CMsgClientToGCCustomGamePlayerCountRequest::mut_custom_game_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCCustomGamePlayerCountRequest>(
                    "CMsgClientToGCCustomGamePlayerCountRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCCustomGamePlayerCountRequest {
    fn clear(&mut self) {
        self.clear_custom_game_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCCustomGamePlayerCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCustomGamePlayerCountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientCustomGamePlayerCountResponse {
    // message fields
    custom_game_id: ::std::option::Option<u64>,
    player_count: ::std::option::Option<u64>,
    spectator_count: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientCustomGamePlayerCountResponse {}

impl CMsgGCToClientCustomGamePlayerCountResponse {
    pub fn new() -> CMsgGCToClientCustomGamePlayerCountResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientCustomGamePlayerCountResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientCustomGamePlayerCountResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientCustomGamePlayerCountResponse,
        };
        unsafe {
            instance.get(CMsgGCToClientCustomGamePlayerCountResponse::new)
        }
    }

    // optional uint64 custom_game_id = 1;

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    pub fn get_custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    fn get_custom_game_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.custom_game_id
    }

    fn mut_custom_game_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.custom_game_id
    }

    // optional uint64 player_count = 2;

    pub fn clear_player_count(&mut self) {
        self.player_count = ::std::option::Option::None;
    }

    pub fn has_player_count(&self) -> bool {
        self.player_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_count(&mut self, v: u64) {
        self.player_count = ::std::option::Option::Some(v);
    }

    pub fn get_player_count(&self) -> u64 {
        self.player_count.unwrap_or(0)
    }

    fn get_player_count_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.player_count
    }

    fn mut_player_count_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.player_count
    }

    // optional uint64 spectator_count = 3;

    pub fn clear_spectator_count(&mut self) {
        self.spectator_count = ::std::option::Option::None;
    }

    pub fn has_spectator_count(&self) -> bool {
        self.spectator_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectator_count(&mut self, v: u64) {
        self.spectator_count = ::std::option::Option::Some(v);
    }

    pub fn get_spectator_count(&self) -> u64 {
        self.spectator_count.unwrap_or(0)
    }

    fn get_spectator_count_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.spectator_count
    }

    fn mut_spectator_count_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.spectator_count
    }
}

impl ::protobuf::Message for CMsgGCToClientCustomGamePlayerCountResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.custom_game_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.player_count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.spectator_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.custom_game_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.spectator_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.custom_game_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.player_count {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.spectator_count {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientCustomGamePlayerCountResponse {
    fn new() -> CMsgGCToClientCustomGamePlayerCountResponse {
        CMsgGCToClientCustomGamePlayerCountResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientCustomGamePlayerCountResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "custom_game_id",
                    CMsgGCToClientCustomGamePlayerCountResponse::get_custom_game_id_for_reflect,
                    CMsgGCToClientCustomGamePlayerCountResponse::mut_custom_game_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "player_count",
                    CMsgGCToClientCustomGamePlayerCountResponse::get_player_count_for_reflect,
                    CMsgGCToClientCustomGamePlayerCountResponse::mut_player_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "spectator_count",
                    CMsgGCToClientCustomGamePlayerCountResponse::get_spectator_count_for_reflect,
                    CMsgGCToClientCustomGamePlayerCountResponse::mut_spectator_count_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientCustomGamePlayerCountResponse>(
                    "CMsgGCToClientCustomGamePlayerCountResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientCustomGamePlayerCountResponse {
    fn clear(&mut self) {
        self.clear_custom_game_id();
        self.clear_player_count();
        self.clear_spectator_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientCustomGamePlayerCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientCustomGamePlayerCountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCCustomGamesFriendsPlayedRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCCustomGamesFriendsPlayedRequest {}

impl CMsgClientToGCCustomGamesFriendsPlayedRequest {
    pub fn new() -> CMsgClientToGCCustomGamesFriendsPlayedRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCCustomGamesFriendsPlayedRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCCustomGamesFriendsPlayedRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCCustomGamesFriendsPlayedRequest,
        };
        unsafe {
            instance.get(CMsgClientToGCCustomGamesFriendsPlayedRequest::new)
        }
    }
}

impl ::protobuf::Message for CMsgClientToGCCustomGamesFriendsPlayedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCCustomGamesFriendsPlayedRequest {
    fn new() -> CMsgClientToGCCustomGamesFriendsPlayedRequest {
        CMsgClientToGCCustomGamesFriendsPlayedRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCCustomGamesFriendsPlayedRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCCustomGamesFriendsPlayedRequest>(
                    "CMsgClientToGCCustomGamesFriendsPlayedRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCCustomGamesFriendsPlayedRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCCustomGamesFriendsPlayedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCustomGamesFriendsPlayedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientCustomGamesFriendsPlayedResponse {
    // message fields
    account_id: ::std::option::Option<u32>,
    games: ::protobuf::RepeatedField<CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientCustomGamesFriendsPlayedResponse {}

impl CMsgGCToClientCustomGamesFriendsPlayedResponse {
    pub fn new() -> CMsgGCToClientCustomGamesFriendsPlayedResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientCustomGamesFriendsPlayedResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientCustomGamesFriendsPlayedResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientCustomGamesFriendsPlayedResponse,
        };
        unsafe {
            instance.get(CMsgGCToClientCustomGamesFriendsPlayedResponse::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // repeated .CMsgGCToClientCustomGamesFriendsPlayedResponse.CustomGame games = 2;

    pub fn clear_games(&mut self) {
        self.games.clear();
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: ::protobuf::RepeatedField<CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame>) {
        self.games = v;
    }

    // Mutable pointer to the field.
    pub fn mut_games(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame> {
        &mut self.games
    }

    // Take field
    pub fn take_games(&mut self) -> ::protobuf::RepeatedField<CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame> {
        ::std::mem::replace(&mut self.games, ::protobuf::RepeatedField::new())
    }

    pub fn get_games(&self) -> &[CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame] {
        &self.games
    }

    fn get_games_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame> {
        &self.games
    }

    fn mut_games_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame> {
        &mut self.games
    }
}

impl ::protobuf::Message for CMsgGCToClientCustomGamesFriendsPlayedResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.games {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.games)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.games {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.games {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientCustomGamesFriendsPlayedResponse {
    fn new() -> CMsgGCToClientCustomGamesFriendsPlayedResponse {
        CMsgGCToClientCustomGamesFriendsPlayedResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientCustomGamesFriendsPlayedResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCToClientCustomGamesFriendsPlayedResponse::get_account_id_for_reflect,
                    CMsgGCToClientCustomGamesFriendsPlayedResponse::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame>>(
                    "games",
                    CMsgGCToClientCustomGamesFriendsPlayedResponse::get_games_for_reflect,
                    CMsgGCToClientCustomGamesFriendsPlayedResponse::mut_games_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientCustomGamesFriendsPlayedResponse>(
                    "CMsgGCToClientCustomGamesFriendsPlayedResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientCustomGamesFriendsPlayedResponse {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_games();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientCustomGamesFriendsPlayedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientCustomGamesFriendsPlayedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame {
    // message fields
    custom_game_id: ::std::option::Option<u64>,
    account_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame {}

impl CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame {
    pub fn new() -> CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame,
        };
        unsafe {
            instance.get(CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame::new)
        }
    }

    // optional uint64 custom_game_id = 1;

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    pub fn get_custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    fn get_custom_game_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.custom_game_id
    }

    fn mut_custom_game_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.custom_game_id
    }

    // repeated uint32 account_ids = 2;

    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }

    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }

    fn get_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.account_ids
    }

    fn mut_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }
}

impl ::protobuf::Message for CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.custom_game_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.custom_game_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.custom_game_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.account_ids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame {
    fn new() -> CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame {
        CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "custom_game_id",
                    CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame::get_custom_game_id_for_reflect,
                    CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame::mut_custom_game_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids",
                    CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame::get_account_ids_for_reflect,
                    CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame::mut_account_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame>(
                    "CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame {
    fn clear(&mut self) {
        self.clear_custom_game_id();
        self.clear_account_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientCustomGamesFriendsPlayedResponse_CustomGame {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCSocialFeedPostCommentRequest {
    // message fields
    event_id: ::std::option::Option<u64>,
    comment: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCSocialFeedPostCommentRequest {}

impl CMsgClientToGCSocialFeedPostCommentRequest {
    pub fn new() -> CMsgClientToGCSocialFeedPostCommentRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCSocialFeedPostCommentRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCSocialFeedPostCommentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCSocialFeedPostCommentRequest,
        };
        unsafe {
            instance.get(CMsgClientToGCSocialFeedPostCommentRequest::new)
        }
    }

    // optional uint64 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u64) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u64 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.event_id
    }

    // optional string comment = 2;

    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment.set_default();
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_comment_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.comment
    }

    fn mut_comment_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.comment
    }
}

impl ::protobuf::Message for CMsgClientToGCSocialFeedPostCommentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.comment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.comment.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCSocialFeedPostCommentRequest {
    fn new() -> CMsgClientToGCSocialFeedPostCommentRequest {
        CMsgClientToGCSocialFeedPostCommentRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCSocialFeedPostCommentRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "event_id",
                    CMsgClientToGCSocialFeedPostCommentRequest::get_event_id_for_reflect,
                    CMsgClientToGCSocialFeedPostCommentRequest::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "comment",
                    CMsgClientToGCSocialFeedPostCommentRequest::get_comment_for_reflect,
                    CMsgClientToGCSocialFeedPostCommentRequest::mut_comment_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCSocialFeedPostCommentRequest>(
                    "CMsgClientToGCSocialFeedPostCommentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCSocialFeedPostCommentRequest {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_comment();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCSocialFeedPostCommentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSocialFeedPostCommentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientSocialFeedPostCommentResponse {
    // message fields
    success: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientSocialFeedPostCommentResponse {}

impl CMsgGCToClientSocialFeedPostCommentResponse {
    pub fn new() -> CMsgGCToClientSocialFeedPostCommentResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientSocialFeedPostCommentResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientSocialFeedPostCommentResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientSocialFeedPostCommentResponse,
        };
        unsafe {
            instance.get(CMsgGCToClientSocialFeedPostCommentResponse::new)
        }
    }

    // optional bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    fn get_success_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.success
    }

    fn mut_success_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.success
    }
}

impl ::protobuf::Message for CMsgGCToClientSocialFeedPostCommentResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientSocialFeedPostCommentResponse {
    fn new() -> CMsgGCToClientSocialFeedPostCommentResponse {
        CMsgGCToClientSocialFeedPostCommentResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientSocialFeedPostCommentResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    CMsgGCToClientSocialFeedPostCommentResponse::get_success_for_reflect,
                    CMsgGCToClientSocialFeedPostCommentResponse::mut_success_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientSocialFeedPostCommentResponse>(
                    "CMsgGCToClientSocialFeedPostCommentResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientSocialFeedPostCommentResponse {
    fn clear(&mut self) {
        self.clear_success();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientSocialFeedPostCommentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientSocialFeedPostCommentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCSocialFeedPostMessageRequest {
    // message fields
    message: ::protobuf::SingularField<::std::string::String>,
    match_id: ::std::option::Option<u64>,
    match_timestamp: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCSocialFeedPostMessageRequest {}

impl CMsgClientToGCSocialFeedPostMessageRequest {
    pub fn new() -> CMsgClientToGCSocialFeedPostMessageRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCSocialFeedPostMessageRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCSocialFeedPostMessageRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCSocialFeedPostMessageRequest,
        };
        unsafe {
            instance.get(CMsgClientToGCSocialFeedPostMessageRequest::new)
        }
    }

    // optional string message = 1;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }

    // optional uint64 match_id = 2;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 match_timestamp = 3;

    pub fn clear_match_timestamp(&mut self) {
        self.match_timestamp = ::std::option::Option::None;
    }

    pub fn has_match_timestamp(&self) -> bool {
        self.match_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_timestamp(&mut self, v: u32) {
        self.match_timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_match_timestamp(&self) -> u32 {
        self.match_timestamp.unwrap_or(0)
    }

    fn get_match_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.match_timestamp
    }

    fn mut_match_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.match_timestamp
    }
}

impl ::protobuf::Message for CMsgClientToGCSocialFeedPostMessageRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.match_timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.match_timestamp {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCSocialFeedPostMessageRequest {
    fn new() -> CMsgClientToGCSocialFeedPostMessageRequest {
        CMsgClientToGCSocialFeedPostMessageRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCSocialFeedPostMessageRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    CMsgClientToGCSocialFeedPostMessageRequest::get_message_for_reflect,
                    CMsgClientToGCSocialFeedPostMessageRequest::mut_message_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgClientToGCSocialFeedPostMessageRequest::get_match_id_for_reflect,
                    CMsgClientToGCSocialFeedPostMessageRequest::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "match_timestamp",
                    CMsgClientToGCSocialFeedPostMessageRequest::get_match_timestamp_for_reflect,
                    CMsgClientToGCSocialFeedPostMessageRequest::mut_match_timestamp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCSocialFeedPostMessageRequest>(
                    "CMsgClientToGCSocialFeedPostMessageRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCSocialFeedPostMessageRequest {
    fn clear(&mut self) {
        self.clear_message();
        self.clear_match_id();
        self.clear_match_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCSocialFeedPostMessageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSocialFeedPostMessageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientSocialFeedPostMessageResponse {
    // message fields
    success: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientSocialFeedPostMessageResponse {}

impl CMsgGCToClientSocialFeedPostMessageResponse {
    pub fn new() -> CMsgGCToClientSocialFeedPostMessageResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientSocialFeedPostMessageResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientSocialFeedPostMessageResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientSocialFeedPostMessageResponse,
        };
        unsafe {
            instance.get(CMsgGCToClientSocialFeedPostMessageResponse::new)
        }
    }

    // optional bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    fn get_success_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.success
    }

    fn mut_success_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.success
    }
}

impl ::protobuf::Message for CMsgGCToClientSocialFeedPostMessageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientSocialFeedPostMessageResponse {
    fn new() -> CMsgGCToClientSocialFeedPostMessageResponse {
        CMsgGCToClientSocialFeedPostMessageResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientSocialFeedPostMessageResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    CMsgGCToClientSocialFeedPostMessageResponse::get_success_for_reflect,
                    CMsgGCToClientSocialFeedPostMessageResponse::mut_success_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientSocialFeedPostMessageResponse>(
                    "CMsgGCToClientSocialFeedPostMessageResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientSocialFeedPostMessageResponse {
    fn clear(&mut self) {
        self.clear_success();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientSocialFeedPostMessageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientSocialFeedPostMessageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCFriendsPlayedCustomGameRequest {
    // message fields
    custom_game_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCFriendsPlayedCustomGameRequest {}

impl CMsgClientToGCFriendsPlayedCustomGameRequest {
    pub fn new() -> CMsgClientToGCFriendsPlayedCustomGameRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCFriendsPlayedCustomGameRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCFriendsPlayedCustomGameRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCFriendsPlayedCustomGameRequest,
        };
        unsafe {
            instance.get(CMsgClientToGCFriendsPlayedCustomGameRequest::new)
        }
    }

    // optional uint64 custom_game_id = 1;

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    pub fn get_custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    fn get_custom_game_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.custom_game_id
    }

    fn mut_custom_game_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.custom_game_id
    }
}

impl ::protobuf::Message for CMsgClientToGCFriendsPlayedCustomGameRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.custom_game_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.custom_game_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.custom_game_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCFriendsPlayedCustomGameRequest {
    fn new() -> CMsgClientToGCFriendsPlayedCustomGameRequest {
        CMsgClientToGCFriendsPlayedCustomGameRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCFriendsPlayedCustomGameRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "custom_game_id",
                    CMsgClientToGCFriendsPlayedCustomGameRequest::get_custom_game_id_for_reflect,
                    CMsgClientToGCFriendsPlayedCustomGameRequest::mut_custom_game_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCFriendsPlayedCustomGameRequest>(
                    "CMsgClientToGCFriendsPlayedCustomGameRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCFriendsPlayedCustomGameRequest {
    fn clear(&mut self) {
        self.clear_custom_game_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCFriendsPlayedCustomGameRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCFriendsPlayedCustomGameRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientFriendsPlayedCustomGameResponse {
    // message fields
    custom_game_id: ::std::option::Option<u64>,
    account_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientFriendsPlayedCustomGameResponse {}

impl CMsgGCToClientFriendsPlayedCustomGameResponse {
    pub fn new() -> CMsgGCToClientFriendsPlayedCustomGameResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientFriendsPlayedCustomGameResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientFriendsPlayedCustomGameResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientFriendsPlayedCustomGameResponse,
        };
        unsafe {
            instance.get(CMsgGCToClientFriendsPlayedCustomGameResponse::new)
        }
    }

    // optional uint64 custom_game_id = 1;

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    pub fn get_custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    fn get_custom_game_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.custom_game_id
    }

    fn mut_custom_game_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.custom_game_id
    }

    // repeated uint32 account_ids = 2;

    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }

    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }

    fn get_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.account_ids
    }

    fn mut_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }
}

impl ::protobuf::Message for CMsgGCToClientFriendsPlayedCustomGameResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.custom_game_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.custom_game_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.custom_game_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.account_ids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientFriendsPlayedCustomGameResponse {
    fn new() -> CMsgGCToClientFriendsPlayedCustomGameResponse {
        CMsgGCToClientFriendsPlayedCustomGameResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientFriendsPlayedCustomGameResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "custom_game_id",
                    CMsgGCToClientFriendsPlayedCustomGameResponse::get_custom_game_id_for_reflect,
                    CMsgGCToClientFriendsPlayedCustomGameResponse::mut_custom_game_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_ids",
                    CMsgGCToClientFriendsPlayedCustomGameResponse::get_account_ids_for_reflect,
                    CMsgGCToClientFriendsPlayedCustomGameResponse::mut_account_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientFriendsPlayedCustomGameResponse>(
                    "CMsgGCToClientFriendsPlayedCustomGameResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientFriendsPlayedCustomGameResponse {
    fn clear(&mut self) {
        self.clear_custom_game_id();
        self.clear_account_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientFriendsPlayedCustomGameResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientFriendsPlayedCustomGameResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCFeaturedHeroesRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCFeaturedHeroesRequest {}

impl CMsgClientToGCFeaturedHeroesRequest {
    pub fn new() -> CMsgClientToGCFeaturedHeroesRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCFeaturedHeroesRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCFeaturedHeroesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCFeaturedHeroesRequest,
        };
        unsafe {
            instance.get(CMsgClientToGCFeaturedHeroesRequest::new)
        }
    }
}

impl ::protobuf::Message for CMsgClientToGCFeaturedHeroesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCFeaturedHeroesRequest {
    fn new() -> CMsgClientToGCFeaturedHeroesRequest {
        CMsgClientToGCFeaturedHeroesRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCFeaturedHeroesRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCFeaturedHeroesRequest>(
                    "CMsgClientToGCFeaturedHeroesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCFeaturedHeroesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCFeaturedHeroesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCFeaturedHeroesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientFeaturedHeroesResponse {
    // message fields
    categories: ::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_Category>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientFeaturedHeroesResponse {}

impl CMsgGCToClientFeaturedHeroesResponse {
    pub fn new() -> CMsgGCToClientFeaturedHeroesResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientFeaturedHeroesResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientFeaturedHeroesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientFeaturedHeroesResponse,
        };
        unsafe {
            instance.get(CMsgGCToClientFeaturedHeroesResponse::new)
        }
    }

    // repeated .CMsgGCToClientFeaturedHeroesResponse.Category categories = 1;

    pub fn clear_categories(&mut self) {
        self.categories.clear();
    }

    // Param is passed by value, moved
    pub fn set_categories(&mut self, v: ::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_Category>) {
        self.categories = v;
    }

    // Mutable pointer to the field.
    pub fn mut_categories(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_Category> {
        &mut self.categories
    }

    // Take field
    pub fn take_categories(&mut self) -> ::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_Category> {
        ::std::mem::replace(&mut self.categories, ::protobuf::RepeatedField::new())
    }

    pub fn get_categories(&self) -> &[CMsgGCToClientFeaturedHeroesResponse_Category] {
        &self.categories
    }

    fn get_categories_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_Category> {
        &self.categories
    }

    fn mut_categories_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_Category> {
        &mut self.categories
    }
}

impl ::protobuf::Message for CMsgGCToClientFeaturedHeroesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.categories {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.categories)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.categories {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.categories {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientFeaturedHeroesResponse {
    fn new() -> CMsgGCToClientFeaturedHeroesResponse {
        CMsgGCToClientFeaturedHeroesResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientFeaturedHeroesResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientFeaturedHeroesResponse_Category>>(
                    "categories",
                    CMsgGCToClientFeaturedHeroesResponse::get_categories_for_reflect,
                    CMsgGCToClientFeaturedHeroesResponse::mut_categories_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientFeaturedHeroesResponse>(
                    "CMsgGCToClientFeaturedHeroesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientFeaturedHeroesResponse {
    fn clear(&mut self) {
        self.clear_categories();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientFeaturedHeroesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientFeaturedHeroesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientFeaturedHeroesResponse_DataField {
    // message fields
    data_type: ::std::option::Option<EFeaturedHeroDataType>,
    uint32_value: ::std::option::Option<u32>,
    uint64_value: ::std::option::Option<u64>,
    string_value: ::protobuf::SingularField<::std::string::String>,
    float_value: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientFeaturedHeroesResponse_DataField {}

impl CMsgGCToClientFeaturedHeroesResponse_DataField {
    pub fn new() -> CMsgGCToClientFeaturedHeroesResponse_DataField {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientFeaturedHeroesResponse_DataField {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientFeaturedHeroesResponse_DataField> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientFeaturedHeroesResponse_DataField,
        };
        unsafe {
            instance.get(CMsgGCToClientFeaturedHeroesResponse_DataField::new)
        }
    }

    // optional .EFeaturedHeroDataType data_type = 1;

    pub fn clear_data_type(&mut self) {
        self.data_type = ::std::option::Option::None;
    }

    pub fn has_data_type(&self) -> bool {
        self.data_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: EFeaturedHeroDataType) {
        self.data_type = ::std::option::Option::Some(v);
    }

    pub fn get_data_type(&self) -> EFeaturedHeroDataType {
        self.data_type.unwrap_or(EFeaturedHeroDataType::k_EFeaturedHeroDataType_HeroID)
    }

    fn get_data_type_for_reflect(&self) -> &::std::option::Option<EFeaturedHeroDataType> {
        &self.data_type
    }

    fn mut_data_type_for_reflect(&mut self) -> &mut ::std::option::Option<EFeaturedHeroDataType> {
        &mut self.data_type
    }

    // optional uint32 uint32_value = 2;

    pub fn clear_uint32_value(&mut self) {
        self.uint32_value = ::std::option::Option::None;
    }

    pub fn has_uint32_value(&self) -> bool {
        self.uint32_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uint32_value(&mut self, v: u32) {
        self.uint32_value = ::std::option::Option::Some(v);
    }

    pub fn get_uint32_value(&self) -> u32 {
        self.uint32_value.unwrap_or(0)
    }

    fn get_uint32_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.uint32_value
    }

    fn mut_uint32_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.uint32_value
    }

    // optional uint64 uint64_value = 3;

    pub fn clear_uint64_value(&mut self) {
        self.uint64_value = ::std::option::Option::None;
    }

    pub fn has_uint64_value(&self) -> bool {
        self.uint64_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uint64_value(&mut self, v: u64) {
        self.uint64_value = ::std::option::Option::Some(v);
    }

    pub fn get_uint64_value(&self) -> u64 {
        self.uint64_value.unwrap_or(0)
    }

    fn get_uint64_value_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.uint64_value
    }

    fn mut_uint64_value_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.uint64_value
    }

    // optional string string_value = 4;

    pub fn clear_string_value(&mut self) {
        self.string_value.clear();
    }

    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.string_value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if self.string_value.is_none() {
            self.string_value.set_default();
        }
        self.string_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_string_value(&self) -> &str {
        match self.string_value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_string_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.string_value
    }

    fn mut_string_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.string_value
    }

    // optional float float_value = 5;

    pub fn clear_float_value(&mut self) {
        self.float_value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        self.float_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.float_value = ::std::option::Option::Some(v);
    }

    pub fn get_float_value(&self) -> f32 {
        self.float_value.unwrap_or(0.)
    }

    fn get_float_value_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.float_value
    }

    fn mut_float_value_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.float_value
    }
}

impl ::protobuf::Message for CMsgGCToClientFeaturedHeroesResponse_DataField {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.data_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.uint32_value = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.uint64_value = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.string_value)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.float_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.uint32_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.uint64_value {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.string_value.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.float_value {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.uint32_value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.uint64_value {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.string_value.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.float_value {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientFeaturedHeroesResponse_DataField {
    fn new() -> CMsgGCToClientFeaturedHeroesResponse_DataField {
        CMsgGCToClientFeaturedHeroesResponse_DataField::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientFeaturedHeroesResponse_DataField>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EFeaturedHeroDataType>>(
                    "data_type",
                    CMsgGCToClientFeaturedHeroesResponse_DataField::get_data_type_for_reflect,
                    CMsgGCToClientFeaturedHeroesResponse_DataField::mut_data_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "uint32_value",
                    CMsgGCToClientFeaturedHeroesResponse_DataField::get_uint32_value_for_reflect,
                    CMsgGCToClientFeaturedHeroesResponse_DataField::mut_uint32_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "uint64_value",
                    CMsgGCToClientFeaturedHeroesResponse_DataField::get_uint64_value_for_reflect,
                    CMsgGCToClientFeaturedHeroesResponse_DataField::mut_uint64_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "string_value",
                    CMsgGCToClientFeaturedHeroesResponse_DataField::get_string_value_for_reflect,
                    CMsgGCToClientFeaturedHeroesResponse_DataField::mut_string_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "float_value",
                    CMsgGCToClientFeaturedHeroesResponse_DataField::get_float_value_for_reflect,
                    CMsgGCToClientFeaturedHeroesResponse_DataField::mut_float_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientFeaturedHeroesResponse_DataField>(
                    "CMsgGCToClientFeaturedHeroesResponse_DataField",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientFeaturedHeroesResponse_DataField {
    fn clear(&mut self) {
        self.clear_data_type();
        self.clear_uint32_value();
        self.clear_uint64_value();
        self.clear_string_value();
        self.clear_float_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientFeaturedHeroesResponse_DataField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientFeaturedHeroesResponse_DataField {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientFeaturedHeroesResponse_FeaturedHero {
    // message fields
    data_fields: ::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_DataField>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientFeaturedHeroesResponse_FeaturedHero {}

impl CMsgGCToClientFeaturedHeroesResponse_FeaturedHero {
    pub fn new() -> CMsgGCToClientFeaturedHeroesResponse_FeaturedHero {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientFeaturedHeroesResponse_FeaturedHero {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientFeaturedHeroesResponse_FeaturedHero> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientFeaturedHeroesResponse_FeaturedHero,
        };
        unsafe {
            instance.get(CMsgGCToClientFeaturedHeroesResponse_FeaturedHero::new)
        }
    }

    // repeated .CMsgGCToClientFeaturedHeroesResponse.DataField data_fields = 1;

    pub fn clear_data_fields(&mut self) {
        self.data_fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_fields(&mut self, v: ::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_DataField>) {
        self.data_fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data_fields(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_DataField> {
        &mut self.data_fields
    }

    // Take field
    pub fn take_data_fields(&mut self) -> ::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_DataField> {
        ::std::mem::replace(&mut self.data_fields, ::protobuf::RepeatedField::new())
    }

    pub fn get_data_fields(&self) -> &[CMsgGCToClientFeaturedHeroesResponse_DataField] {
        &self.data_fields
    }

    fn get_data_fields_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_DataField> {
        &self.data_fields
    }

    fn mut_data_fields_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_DataField> {
        &mut self.data_fields
    }
}

impl ::protobuf::Message for CMsgGCToClientFeaturedHeroesResponse_FeaturedHero {
    fn is_initialized(&self) -> bool {
        for v in &self.data_fields {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data_fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.data_fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.data_fields {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientFeaturedHeroesResponse_FeaturedHero {
    fn new() -> CMsgGCToClientFeaturedHeroesResponse_FeaturedHero {
        CMsgGCToClientFeaturedHeroesResponse_FeaturedHero::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientFeaturedHeroesResponse_FeaturedHero>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientFeaturedHeroesResponse_DataField>>(
                    "data_fields",
                    CMsgGCToClientFeaturedHeroesResponse_FeaturedHero::get_data_fields_for_reflect,
                    CMsgGCToClientFeaturedHeroesResponse_FeaturedHero::mut_data_fields_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientFeaturedHeroesResponse_FeaturedHero>(
                    "CMsgGCToClientFeaturedHeroesResponse_FeaturedHero",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientFeaturedHeroesResponse_FeaturedHero {
    fn clear(&mut self) {
        self.clear_data_fields();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientFeaturedHeroesResponse_FeaturedHero {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientFeaturedHeroesResponse_FeaturedHero {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientFeaturedHeroesResponse_Category {
    // message fields
    category_weight: ::std::option::Option<i32>,
    text_fields: ::std::vec::Vec<EFeaturedHeroTextField>,
    featured_heroes: ::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_FeaturedHero>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientFeaturedHeroesResponse_Category {}

impl CMsgGCToClientFeaturedHeroesResponse_Category {
    pub fn new() -> CMsgGCToClientFeaturedHeroesResponse_Category {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientFeaturedHeroesResponse_Category {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientFeaturedHeroesResponse_Category> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientFeaturedHeroesResponse_Category,
        };
        unsafe {
            instance.get(CMsgGCToClientFeaturedHeroesResponse_Category::new)
        }
    }

    // optional int32 category_weight = 1;

    pub fn clear_category_weight(&mut self) {
        self.category_weight = ::std::option::Option::None;
    }

    pub fn has_category_weight(&self) -> bool {
        self.category_weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category_weight(&mut self, v: i32) {
        self.category_weight = ::std::option::Option::Some(v);
    }

    pub fn get_category_weight(&self) -> i32 {
        self.category_weight.unwrap_or(0)
    }

    fn get_category_weight_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.category_weight
    }

    fn mut_category_weight_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.category_weight
    }

    // repeated .EFeaturedHeroTextField text_fields = 2;

    pub fn clear_text_fields(&mut self) {
        self.text_fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_text_fields(&mut self, v: ::std::vec::Vec<EFeaturedHeroTextField>) {
        self.text_fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_text_fields(&mut self) -> &mut ::std::vec::Vec<EFeaturedHeroTextField> {
        &mut self.text_fields
    }

    // Take field
    pub fn take_text_fields(&mut self) -> ::std::vec::Vec<EFeaturedHeroTextField> {
        ::std::mem::replace(&mut self.text_fields, ::std::vec::Vec::new())
    }

    pub fn get_text_fields(&self) -> &[EFeaturedHeroTextField] {
        &self.text_fields
    }

    fn get_text_fields_for_reflect(&self) -> &::std::vec::Vec<EFeaturedHeroTextField> {
        &self.text_fields
    }

    fn mut_text_fields_for_reflect(&mut self) -> &mut ::std::vec::Vec<EFeaturedHeroTextField> {
        &mut self.text_fields
    }

    // repeated .CMsgGCToClientFeaturedHeroesResponse.FeaturedHero featured_heroes = 3;

    pub fn clear_featured_heroes(&mut self) {
        self.featured_heroes.clear();
    }

    // Param is passed by value, moved
    pub fn set_featured_heroes(&mut self, v: ::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_FeaturedHero>) {
        self.featured_heroes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_featured_heroes(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_FeaturedHero> {
        &mut self.featured_heroes
    }

    // Take field
    pub fn take_featured_heroes(&mut self) -> ::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_FeaturedHero> {
        ::std::mem::replace(&mut self.featured_heroes, ::protobuf::RepeatedField::new())
    }

    pub fn get_featured_heroes(&self) -> &[CMsgGCToClientFeaturedHeroesResponse_FeaturedHero] {
        &self.featured_heroes
    }

    fn get_featured_heroes_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_FeaturedHero> {
        &self.featured_heroes
    }

    fn mut_featured_heroes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientFeaturedHeroesResponse_FeaturedHero> {
        &mut self.featured_heroes
    }
}

impl ::protobuf::Message for CMsgGCToClientFeaturedHeroesResponse_Category {
    fn is_initialized(&self) -> bool {
        for v in &self.featured_heroes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.category_weight = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_enum_into(wire_type, is, &mut self.text_fields)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.featured_heroes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.category_weight {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.text_fields {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        for value in &self.featured_heroes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.category_weight {
            os.write_int32(1, v)?;
        }
        for v in &self.text_fields {
            os.write_enum(2, v.value())?;
        };
        for v in &self.featured_heroes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientFeaturedHeroesResponse_Category {
    fn new() -> CMsgGCToClientFeaturedHeroesResponse_Category {
        CMsgGCToClientFeaturedHeroesResponse_Category::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientFeaturedHeroesResponse_Category>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "category_weight",
                    CMsgGCToClientFeaturedHeroesResponse_Category::get_category_weight_for_reflect,
                    CMsgGCToClientFeaturedHeroesResponse_Category::mut_category_weight_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EFeaturedHeroTextField>>(
                    "text_fields",
                    CMsgGCToClientFeaturedHeroesResponse_Category::get_text_fields_for_reflect,
                    CMsgGCToClientFeaturedHeroesResponse_Category::mut_text_fields_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientFeaturedHeroesResponse_FeaturedHero>>(
                    "featured_heroes",
                    CMsgGCToClientFeaturedHeroesResponse_Category::get_featured_heroes_for_reflect,
                    CMsgGCToClientFeaturedHeroesResponse_Category::mut_featured_heroes_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientFeaturedHeroesResponse_Category>(
                    "CMsgGCToClientFeaturedHeroesResponse_Category",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientFeaturedHeroesResponse_Category {
    fn clear(&mut self) {
        self.clear_category_weight();
        self.clear_text_fields();
        self.clear_featured_heroes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientFeaturedHeroesResponse_Category {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientFeaturedHeroesResponse_Category {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCSocialMatchPostCommentRequest {
    // message fields
    match_id: ::std::option::Option<u64>,
    comment: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCSocialMatchPostCommentRequest {}

impl CMsgClientToGCSocialMatchPostCommentRequest {
    pub fn new() -> CMsgClientToGCSocialMatchPostCommentRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCSocialMatchPostCommentRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCSocialMatchPostCommentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCSocialMatchPostCommentRequest,
        };
        unsafe {
            instance.get(CMsgClientToGCSocialMatchPostCommentRequest::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional string comment = 2;

    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment.set_default();
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_comment_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.comment
    }

    fn mut_comment_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.comment
    }
}

impl ::protobuf::Message for CMsgClientToGCSocialMatchPostCommentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.comment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.comment.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCSocialMatchPostCommentRequest {
    fn new() -> CMsgClientToGCSocialMatchPostCommentRequest {
        CMsgClientToGCSocialMatchPostCommentRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCSocialMatchPostCommentRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgClientToGCSocialMatchPostCommentRequest::get_match_id_for_reflect,
                    CMsgClientToGCSocialMatchPostCommentRequest::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "comment",
                    CMsgClientToGCSocialMatchPostCommentRequest::get_comment_for_reflect,
                    CMsgClientToGCSocialMatchPostCommentRequest::mut_comment_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCSocialMatchPostCommentRequest>(
                    "CMsgClientToGCSocialMatchPostCommentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCSocialMatchPostCommentRequest {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_comment();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCSocialMatchPostCommentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSocialMatchPostCommentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientSocialMatchPostCommentResponse {
    // message fields
    success: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientSocialMatchPostCommentResponse {}

impl CMsgGCToClientSocialMatchPostCommentResponse {
    pub fn new() -> CMsgGCToClientSocialMatchPostCommentResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientSocialMatchPostCommentResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientSocialMatchPostCommentResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientSocialMatchPostCommentResponse,
        };
        unsafe {
            instance.get(CMsgGCToClientSocialMatchPostCommentResponse::new)
        }
    }

    // optional bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    fn get_success_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.success
    }

    fn mut_success_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.success
    }
}

impl ::protobuf::Message for CMsgGCToClientSocialMatchPostCommentResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientSocialMatchPostCommentResponse {
    fn new() -> CMsgGCToClientSocialMatchPostCommentResponse {
        CMsgGCToClientSocialMatchPostCommentResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientSocialMatchPostCommentResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    CMsgGCToClientSocialMatchPostCommentResponse::get_success_for_reflect,
                    CMsgGCToClientSocialMatchPostCommentResponse::mut_success_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientSocialMatchPostCommentResponse>(
                    "CMsgGCToClientSocialMatchPostCommentResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientSocialMatchPostCommentResponse {
    fn clear(&mut self) {
        self.clear_success();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientSocialMatchPostCommentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientSocialMatchPostCommentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCSocialMatchDetailsRequest {
    // message fields
    match_id: ::std::option::Option<u64>,
    pagination_timestamp: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCSocialMatchDetailsRequest {}

impl CMsgClientToGCSocialMatchDetailsRequest {
    pub fn new() -> CMsgClientToGCSocialMatchDetailsRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCSocialMatchDetailsRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCSocialMatchDetailsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCSocialMatchDetailsRequest,
        };
        unsafe {
            instance.get(CMsgClientToGCSocialMatchDetailsRequest::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 pagination_timestamp = 2;

    pub fn clear_pagination_timestamp(&mut self) {
        self.pagination_timestamp = ::std::option::Option::None;
    }

    pub fn has_pagination_timestamp(&self) -> bool {
        self.pagination_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination_timestamp(&mut self, v: u32) {
        self.pagination_timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_pagination_timestamp(&self) -> u32 {
        self.pagination_timestamp.unwrap_or(0)
    }

    fn get_pagination_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.pagination_timestamp
    }

    fn mut_pagination_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.pagination_timestamp
    }
}

impl ::protobuf::Message for CMsgClientToGCSocialMatchDetailsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pagination_timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pagination_timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.pagination_timestamp {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCSocialMatchDetailsRequest {
    fn new() -> CMsgClientToGCSocialMatchDetailsRequest {
        CMsgClientToGCSocialMatchDetailsRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCSocialMatchDetailsRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgClientToGCSocialMatchDetailsRequest::get_match_id_for_reflect,
                    CMsgClientToGCSocialMatchDetailsRequest::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pagination_timestamp",
                    CMsgClientToGCSocialMatchDetailsRequest::get_pagination_timestamp_for_reflect,
                    CMsgClientToGCSocialMatchDetailsRequest::mut_pagination_timestamp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCSocialMatchDetailsRequest>(
                    "CMsgClientToGCSocialMatchDetailsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCSocialMatchDetailsRequest {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_pagination_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCSocialMatchDetailsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSocialMatchDetailsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientSocialMatchDetailsResponse {
    // message fields
    success: ::std::option::Option<bool>,
    comments: ::protobuf::RepeatedField<CMsgGCToClientSocialMatchDetailsResponse_Comment>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientSocialMatchDetailsResponse {}

impl CMsgGCToClientSocialMatchDetailsResponse {
    pub fn new() -> CMsgGCToClientSocialMatchDetailsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientSocialMatchDetailsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientSocialMatchDetailsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientSocialMatchDetailsResponse,
        };
        unsafe {
            instance.get(CMsgGCToClientSocialMatchDetailsResponse::new)
        }
    }

    // optional bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    fn get_success_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.success
    }

    fn mut_success_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.success
    }

    // repeated .CMsgGCToClientSocialMatchDetailsResponse.Comment comments = 2;

    pub fn clear_comments(&mut self) {
        self.comments.clear();
    }

    // Param is passed by value, moved
    pub fn set_comments(&mut self, v: ::protobuf::RepeatedField<CMsgGCToClientSocialMatchDetailsResponse_Comment>) {
        self.comments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_comments(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientSocialMatchDetailsResponse_Comment> {
        &mut self.comments
    }

    // Take field
    pub fn take_comments(&mut self) -> ::protobuf::RepeatedField<CMsgGCToClientSocialMatchDetailsResponse_Comment> {
        ::std::mem::replace(&mut self.comments, ::protobuf::RepeatedField::new())
    }

    pub fn get_comments(&self) -> &[CMsgGCToClientSocialMatchDetailsResponse_Comment] {
        &self.comments
    }

    fn get_comments_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCToClientSocialMatchDetailsResponse_Comment> {
        &self.comments
    }

    fn mut_comments_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientSocialMatchDetailsResponse_Comment> {
        &mut self.comments
    }
}

impl ::protobuf::Message for CMsgGCToClientSocialMatchDetailsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.comments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.comments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        for value in &self.comments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        for v in &self.comments {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientSocialMatchDetailsResponse {
    fn new() -> CMsgGCToClientSocialMatchDetailsResponse {
        CMsgGCToClientSocialMatchDetailsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientSocialMatchDetailsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    CMsgGCToClientSocialMatchDetailsResponse::get_success_for_reflect,
                    CMsgGCToClientSocialMatchDetailsResponse::mut_success_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientSocialMatchDetailsResponse_Comment>>(
                    "comments",
                    CMsgGCToClientSocialMatchDetailsResponse::get_comments_for_reflect,
                    CMsgGCToClientSocialMatchDetailsResponse::mut_comments_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientSocialMatchDetailsResponse>(
                    "CMsgGCToClientSocialMatchDetailsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientSocialMatchDetailsResponse {
    fn clear(&mut self) {
        self.clear_success();
        self.clear_comments();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientSocialMatchDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientSocialMatchDetailsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientSocialMatchDetailsResponse_Comment {
    // message fields
    account_id: ::std::option::Option<u32>,
    persona_name: ::protobuf::SingularField<::std::string::String>,
    timestamp: ::std::option::Option<u32>,
    comment: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientSocialMatchDetailsResponse_Comment {}

impl CMsgGCToClientSocialMatchDetailsResponse_Comment {
    pub fn new() -> CMsgGCToClientSocialMatchDetailsResponse_Comment {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientSocialMatchDetailsResponse_Comment {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientSocialMatchDetailsResponse_Comment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientSocialMatchDetailsResponse_Comment,
        };
        unsafe {
            instance.get(CMsgGCToClientSocialMatchDetailsResponse_Comment::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional string persona_name = 2;

    pub fn clear_persona_name(&mut self) {
        self.persona_name.clear();
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name(&mut self) -> &mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name.set_default();
        }
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_persona_name(&self) -> &str {
        match self.persona_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_persona_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.persona_name
    }

    fn mut_persona_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.persona_name
    }

    // optional uint32 timestamp = 3;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional string comment = 4;

    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment.set_default();
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_comment_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.comment
    }

    fn mut_comment_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.comment
    }
}

impl ::protobuf::Message for CMsgGCToClientSocialMatchDetailsResponse_Comment {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.comment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.persona_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.persona_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.comment.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientSocialMatchDetailsResponse_Comment {
    fn new() -> CMsgGCToClientSocialMatchDetailsResponse_Comment {
        CMsgGCToClientSocialMatchDetailsResponse_Comment::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientSocialMatchDetailsResponse_Comment>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCToClientSocialMatchDetailsResponse_Comment::get_account_id_for_reflect,
                    CMsgGCToClientSocialMatchDetailsResponse_Comment::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "persona_name",
                    CMsgGCToClientSocialMatchDetailsResponse_Comment::get_persona_name_for_reflect,
                    CMsgGCToClientSocialMatchDetailsResponse_Comment::mut_persona_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgGCToClientSocialMatchDetailsResponse_Comment::get_timestamp_for_reflect,
                    CMsgGCToClientSocialMatchDetailsResponse_Comment::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "comment",
                    CMsgGCToClientSocialMatchDetailsResponse_Comment::get_comment_for_reflect,
                    CMsgGCToClientSocialMatchDetailsResponse_Comment::mut_comment_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientSocialMatchDetailsResponse_Comment>(
                    "CMsgGCToClientSocialMatchDetailsResponse_Comment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientSocialMatchDetailsResponse_Comment {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_persona_name();
        self.clear_timestamp();
        self.clear_comment();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientSocialMatchDetailsResponse_Comment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientSocialMatchDetailsResponse_Comment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAPartyRichPresence {
    // message fields
    party_id: ::std::option::Option<u64>,
    party_state: ::std::option::Option<super::dota_gcmessages_common_match_management::CSODOTAParty_State>,
    open: ::std::option::Option<bool>,
    low_priority: ::std::option::Option<bool>,
    team_id: ::std::option::Option<u32>,
    team_name: ::protobuf::SingularField<::std::string::String>,
    ugc_team_ui_logo: ::std::option::Option<u64>,
    members: ::protobuf::RepeatedField<CMsgDOTAPartyRichPresence_Member>,
    weekend_tourney: ::protobuf::SingularPtrField<CMsgDOTAPartyRichPresence_WeekendTourney>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAPartyRichPresence {}

impl CMsgDOTAPartyRichPresence {
    pub fn new() -> CMsgDOTAPartyRichPresence {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAPartyRichPresence {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAPartyRichPresence> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAPartyRichPresence,
        };
        unsafe {
            instance.get(CMsgDOTAPartyRichPresence::new)
        }
    }

    // optional fixed64 party_id = 1;

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    pub fn get_party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    fn get_party_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.party_id
    }

    fn mut_party_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.party_id
    }

    // optional .CSODOTAParty.State party_state = 2;

    pub fn clear_party_state(&mut self) {
        self.party_state = ::std::option::Option::None;
    }

    pub fn has_party_state(&self) -> bool {
        self.party_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_state(&mut self, v: super::dota_gcmessages_common_match_management::CSODOTAParty_State) {
        self.party_state = ::std::option::Option::Some(v);
    }

    pub fn get_party_state(&self) -> super::dota_gcmessages_common_match_management::CSODOTAParty_State {
        self.party_state.unwrap_or(super::dota_gcmessages_common_match_management::CSODOTAParty_State::UI)
    }

    fn get_party_state_for_reflect(&self) -> &::std::option::Option<super::dota_gcmessages_common_match_management::CSODOTAParty_State> {
        &self.party_state
    }

    fn mut_party_state_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_gcmessages_common_match_management::CSODOTAParty_State> {
        &mut self.party_state
    }

    // optional bool open = 3;

    pub fn clear_open(&mut self) {
        self.open = ::std::option::Option::None;
    }

    pub fn has_open(&self) -> bool {
        self.open.is_some()
    }

    // Param is passed by value, moved
    pub fn set_open(&mut self, v: bool) {
        self.open = ::std::option::Option::Some(v);
    }

    pub fn get_open(&self) -> bool {
        self.open.unwrap_or(false)
    }

    fn get_open_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.open
    }

    fn mut_open_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.open
    }

    // optional bool low_priority = 5;

    pub fn clear_low_priority(&mut self) {
        self.low_priority = ::std::option::Option::None;
    }

    pub fn has_low_priority(&self) -> bool {
        self.low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority(&mut self, v: bool) {
        self.low_priority = ::std::option::Option::Some(v);
    }

    pub fn get_low_priority(&self) -> bool {
        self.low_priority.unwrap_or(false)
    }

    fn get_low_priority_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.low_priority
    }

    fn mut_low_priority_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.low_priority
    }

    // optional uint32 team_id = 7;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_id
    }

    // optional string team_name = 8;

    pub fn clear_team_name(&mut self) {
        self.team_name.clear();
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name.set_default();
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_name
    }

    fn mut_team_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_name
    }

    // optional uint64 ugc_team_ui_logo = 9;

    pub fn clear_ugc_team_ui_logo(&mut self) {
        self.ugc_team_ui_logo = ::std::option::Option::None;
    }

    pub fn has_ugc_team_ui_logo(&self) -> bool {
        self.ugc_team_ui_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ugc_team_ui_logo(&mut self, v: u64) {
        self.ugc_team_ui_logo = ::std::option::Option::Some(v);
    }

    pub fn get_ugc_team_ui_logo(&self) -> u64 {
        self.ugc_team_ui_logo.unwrap_or(0)
    }

    fn get_ugc_team_ui_logo_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.ugc_team_ui_logo
    }

    fn mut_ugc_team_ui_logo_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.ugc_team_ui_logo
    }

    // repeated .CMsgDOTAPartyRichPresence.Member members = 4;

    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAPartyRichPresence_Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAPartyRichPresence_Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAPartyRichPresence_Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    pub fn get_members(&self) -> &[CMsgDOTAPartyRichPresence_Member] {
        &self.members
    }

    fn get_members_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAPartyRichPresence_Member> {
        &self.members
    }

    fn mut_members_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAPartyRichPresence_Member> {
        &mut self.members
    }

    // optional .CMsgDOTAPartyRichPresence.WeekendTourney weekend_tourney = 6;

    pub fn clear_weekend_tourney(&mut self) {
        self.weekend_tourney.clear();
    }

    pub fn has_weekend_tourney(&self) -> bool {
        self.weekend_tourney.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weekend_tourney(&mut self, v: CMsgDOTAPartyRichPresence_WeekendTourney) {
        self.weekend_tourney = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_weekend_tourney(&mut self) -> &mut CMsgDOTAPartyRichPresence_WeekendTourney {
        if self.weekend_tourney.is_none() {
            self.weekend_tourney.set_default();
        }
        self.weekend_tourney.as_mut().unwrap()
    }

    // Take field
    pub fn take_weekend_tourney(&mut self) -> CMsgDOTAPartyRichPresence_WeekendTourney {
        self.weekend_tourney.take().unwrap_or_else(|| CMsgDOTAPartyRichPresence_WeekendTourney::new())
    }

    pub fn get_weekend_tourney(&self) -> &CMsgDOTAPartyRichPresence_WeekendTourney {
        self.weekend_tourney.as_ref().unwrap_or_else(|| CMsgDOTAPartyRichPresence_WeekendTourney::default_instance())
    }

    fn get_weekend_tourney_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAPartyRichPresence_WeekendTourney> {
        &self.weekend_tourney
    }

    fn mut_weekend_tourney_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAPartyRichPresence_WeekendTourney> {
        &mut self.weekend_tourney
    }
}

impl ::protobuf::Message for CMsgDOTAPartyRichPresence {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.weekend_tourney {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.party_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.party_state = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.open = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.low_priority = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_name)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ugc_team_ui_logo = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.weekend_tourney)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 9;
        }
        if let Some(v) = self.party_state {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.open {
            my_size += 2;
        }
        if let Some(v) = self.low_priority {
            my_size += 2;
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.ugc_team_ui_logo {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.weekend_tourney.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.party_state {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.open {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.low_priority {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.team_name.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.ugc_team_ui_logo {
            os.write_uint64(9, v)?;
        }
        for v in &self.members {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.weekend_tourney.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAPartyRichPresence {
    fn new() -> CMsgDOTAPartyRichPresence {
        CMsgDOTAPartyRichPresence::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAPartyRichPresence>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "party_id",
                    CMsgDOTAPartyRichPresence::get_party_id_for_reflect,
                    CMsgDOTAPartyRichPresence::mut_party_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_gcmessages_common_match_management::CSODOTAParty_State>>(
                    "party_state",
                    CMsgDOTAPartyRichPresence::get_party_state_for_reflect,
                    CMsgDOTAPartyRichPresence::mut_party_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "open",
                    CMsgDOTAPartyRichPresence::get_open_for_reflect,
                    CMsgDOTAPartyRichPresence::mut_open_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "low_priority",
                    CMsgDOTAPartyRichPresence::get_low_priority_for_reflect,
                    CMsgDOTAPartyRichPresence::mut_low_priority_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_id",
                    CMsgDOTAPartyRichPresence::get_team_id_for_reflect,
                    CMsgDOTAPartyRichPresence::mut_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_name",
                    CMsgDOTAPartyRichPresence::get_team_name_for_reflect,
                    CMsgDOTAPartyRichPresence::mut_team_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ugc_team_ui_logo",
                    CMsgDOTAPartyRichPresence::get_ugc_team_ui_logo_for_reflect,
                    CMsgDOTAPartyRichPresence::mut_ugc_team_ui_logo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAPartyRichPresence_Member>>(
                    "members",
                    CMsgDOTAPartyRichPresence::get_members_for_reflect,
                    CMsgDOTAPartyRichPresence::mut_members_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAPartyRichPresence_WeekendTourney>>(
                    "weekend_tourney",
                    CMsgDOTAPartyRichPresence::get_weekend_tourney_for_reflect,
                    CMsgDOTAPartyRichPresence::mut_weekend_tourney_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAPartyRichPresence>(
                    "CMsgDOTAPartyRichPresence",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAPartyRichPresence {
    fn clear(&mut self) {
        self.clear_party_id();
        self.clear_party_state();
        self.clear_open();
        self.clear_low_priority();
        self.clear_team_id();
        self.clear_team_name();
        self.clear_ugc_team_ui_logo();
        self.clear_members();
        self.clear_weekend_tourney();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAPartyRichPresence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAPartyRichPresence {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAPartyRichPresence_Member {
    // message fields
    steam_id: ::std::option::Option<u64>,
    coach: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAPartyRichPresence_Member {}

impl CMsgDOTAPartyRichPresence_Member {
    pub fn new() -> CMsgDOTAPartyRichPresence_Member {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAPartyRichPresence_Member {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAPartyRichPresence_Member> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAPartyRichPresence_Member,
        };
        unsafe {
            instance.get(CMsgDOTAPartyRichPresence_Member::new)
        }
    }

    // optional fixed64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    fn get_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.steam_id
    }

    fn mut_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.steam_id
    }

    // optional bool coach = 2;

    pub fn clear_coach(&mut self) {
        self.coach = ::std::option::Option::None;
    }

    pub fn has_coach(&self) -> bool {
        self.coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coach(&mut self, v: bool) {
        self.coach = ::std::option::Option::Some(v);
    }

    pub fn get_coach(&self) -> bool {
        self.coach.unwrap_or(false)
    }

    fn get_coach_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.coach
    }

    fn mut_coach_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.coach
    }
}

impl ::protobuf::Message for CMsgDOTAPartyRichPresence_Member {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.coach = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.coach {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.coach {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAPartyRichPresence_Member {
    fn new() -> CMsgDOTAPartyRichPresence_Member {
        CMsgDOTAPartyRichPresence_Member::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAPartyRichPresence_Member>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steam_id",
                    CMsgDOTAPartyRichPresence_Member::get_steam_id_for_reflect,
                    CMsgDOTAPartyRichPresence_Member::mut_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "coach",
                    CMsgDOTAPartyRichPresence_Member::get_coach_for_reflect,
                    CMsgDOTAPartyRichPresence_Member::mut_coach_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAPartyRichPresence_Member>(
                    "CMsgDOTAPartyRichPresence_Member",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAPartyRichPresence_Member {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_coach();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAPartyRichPresence_Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAPartyRichPresence_Member {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAPartyRichPresence_WeekendTourney {
    // message fields
    division: ::std::option::Option<u32>,
    skill_level: ::std::option::Option<u32>,
    round: ::std::option::Option<u32>,
    tournament_id: ::std::option::Option<u32>,
    state_seq_num: ::std::option::Option<u32>,
    event: ::std::option::Option<EWeekendTourneyRichPresenceEvent>,
    event_round: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAPartyRichPresence_WeekendTourney {}

impl CMsgDOTAPartyRichPresence_WeekendTourney {
    pub fn new() -> CMsgDOTAPartyRichPresence_WeekendTourney {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAPartyRichPresence_WeekendTourney {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAPartyRichPresence_WeekendTourney> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAPartyRichPresence_WeekendTourney,
        };
        unsafe {
            instance.get(CMsgDOTAPartyRichPresence_WeekendTourney::new)
        }
    }

    // optional uint32 division = 1;

    pub fn clear_division(&mut self) {
        self.division = ::std::option::Option::None;
    }

    pub fn has_division(&self) -> bool {
        self.division.is_some()
    }

    // Param is passed by value, moved
    pub fn set_division(&mut self, v: u32) {
        self.division = ::std::option::Option::Some(v);
    }

    pub fn get_division(&self) -> u32 {
        self.division.unwrap_or(0)
    }

    fn get_division_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.division
    }

    fn mut_division_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.division
    }

    // optional uint32 skill_level = 2;

    pub fn clear_skill_level(&mut self) {
        self.skill_level = ::std::option::Option::None;
    }

    pub fn has_skill_level(&self) -> bool {
        self.skill_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skill_level(&mut self, v: u32) {
        self.skill_level = ::std::option::Option::Some(v);
    }

    pub fn get_skill_level(&self) -> u32 {
        self.skill_level.unwrap_or(0)
    }

    fn get_skill_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.skill_level
    }

    fn mut_skill_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.skill_level
    }

    // optional uint32 round = 3;

    pub fn clear_round(&mut self) {
        self.round = ::std::option::Option::None;
    }

    pub fn has_round(&self) -> bool {
        self.round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: u32) {
        self.round = ::std::option::Option::Some(v);
    }

    pub fn get_round(&self) -> u32 {
        self.round.unwrap_or(0)
    }

    fn get_round_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.round
    }

    fn mut_round_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.round
    }

    // optional uint32 tournament_id = 4;

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id = ::std::option::Option::None;
    }

    pub fn has_tournament_id(&self) -> bool {
        self.tournament_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: u32) {
        self.tournament_id = ::std::option::Option::Some(v);
    }

    pub fn get_tournament_id(&self) -> u32 {
        self.tournament_id.unwrap_or(0)
    }

    fn get_tournament_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tournament_id
    }

    fn mut_tournament_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tournament_id
    }

    // optional uint32 state_seq_num = 5;

    pub fn clear_state_seq_num(&mut self) {
        self.state_seq_num = ::std::option::Option::None;
    }

    pub fn has_state_seq_num(&self) -> bool {
        self.state_seq_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_seq_num(&mut self, v: u32) {
        self.state_seq_num = ::std::option::Option::Some(v);
    }

    pub fn get_state_seq_num(&self) -> u32 {
        self.state_seq_num.unwrap_or(0)
    }

    fn get_state_seq_num_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.state_seq_num
    }

    fn mut_state_seq_num_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.state_seq_num
    }

    // optional .EWeekendTourneyRichPresenceEvent event = 6;

    pub fn clear_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: EWeekendTourneyRichPresenceEvent) {
        self.event = ::std::option::Option::Some(v);
    }

    pub fn get_event(&self) -> EWeekendTourneyRichPresenceEvent {
        self.event.unwrap_or(EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_None)
    }

    fn get_event_for_reflect(&self) -> &::std::option::Option<EWeekendTourneyRichPresenceEvent> {
        &self.event
    }

    fn mut_event_for_reflect(&mut self) -> &mut ::std::option::Option<EWeekendTourneyRichPresenceEvent> {
        &mut self.event
    }

    // optional uint32 event_round = 7;

    pub fn clear_event_round(&mut self) {
        self.event_round = ::std::option::Option::None;
    }

    pub fn has_event_round(&self) -> bool {
        self.event_round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_round(&mut self, v: u32) {
        self.event_round = ::std::option::Option::Some(v);
    }

    pub fn get_event_round(&self) -> u32 {
        self.event_round.unwrap_or(0)
    }

    fn get_event_round_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_round
    }

    fn mut_event_round_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_round
    }
}

impl ::protobuf::Message for CMsgDOTAPartyRichPresence_WeekendTourney {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.division = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.skill_level = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.round = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tournament_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.state_seq_num = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.event = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_round = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.division {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.skill_level {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.round {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tournament_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.state_seq_num {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(v) = self.event_round {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.division {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.skill_level {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.round {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tournament_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.state_seq_num {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.event {
            os.write_enum(6, v.value())?;
        }
        if let Some(v) = self.event_round {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAPartyRichPresence_WeekendTourney {
    fn new() -> CMsgDOTAPartyRichPresence_WeekendTourney {
        CMsgDOTAPartyRichPresence_WeekendTourney::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAPartyRichPresence_WeekendTourney>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "division",
                    CMsgDOTAPartyRichPresence_WeekendTourney::get_division_for_reflect,
                    CMsgDOTAPartyRichPresence_WeekendTourney::mut_division_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "skill_level",
                    CMsgDOTAPartyRichPresence_WeekendTourney::get_skill_level_for_reflect,
                    CMsgDOTAPartyRichPresence_WeekendTourney::mut_skill_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "round",
                    CMsgDOTAPartyRichPresence_WeekendTourney::get_round_for_reflect,
                    CMsgDOTAPartyRichPresence_WeekendTourney::mut_round_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tournament_id",
                    CMsgDOTAPartyRichPresence_WeekendTourney::get_tournament_id_for_reflect,
                    CMsgDOTAPartyRichPresence_WeekendTourney::mut_tournament_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "state_seq_num",
                    CMsgDOTAPartyRichPresence_WeekendTourney::get_state_seq_num_for_reflect,
                    CMsgDOTAPartyRichPresence_WeekendTourney::mut_state_seq_num_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EWeekendTourneyRichPresenceEvent>>(
                    "event",
                    CMsgDOTAPartyRichPresence_WeekendTourney::get_event_for_reflect,
                    CMsgDOTAPartyRichPresence_WeekendTourney::mut_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_round",
                    CMsgDOTAPartyRichPresence_WeekendTourney::get_event_round_for_reflect,
                    CMsgDOTAPartyRichPresence_WeekendTourney::mut_event_round_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAPartyRichPresence_WeekendTourney>(
                    "CMsgDOTAPartyRichPresence_WeekendTourney",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAPartyRichPresence_WeekendTourney {
    fn clear(&mut self) {
        self.clear_division();
        self.clear_skill_level();
        self.clear_round();
        self.clear_tournament_id();
        self.clear_state_seq_num();
        self.clear_event();
        self.clear_event_round();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAPartyRichPresence_WeekendTourney {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAPartyRichPresence_WeekendTourney {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTALobbyRichPresence {
    // message fields
    lobby_id: ::std::option::Option<u64>,
    lobby_state: ::std::option::Option<super::dota_gcmessages_common_match_management::CSODOTALobby_State>,
    password: ::std::option::Option<bool>,
    game_mode: ::std::option::Option<super::dota_shared_enums::DOTA_GameMode>,
    member_count: ::std::option::Option<u32>,
    max_member_count: ::std::option::Option<u32>,
    custom_game_id: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    lobby_type: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTALobbyRichPresence {}

impl CMsgDOTALobbyRichPresence {
    pub fn new() -> CMsgDOTALobbyRichPresence {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTALobbyRichPresence {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTALobbyRichPresence> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTALobbyRichPresence,
        };
        unsafe {
            instance.get(CMsgDOTALobbyRichPresence::new)
        }
    }

    // optional fixed64 lobby_id = 1;

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    fn get_lobby_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.lobby_id
    }

    fn mut_lobby_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.lobby_id
    }

    // optional .CSODOTALobby.State lobby_state = 2;

    pub fn clear_lobby_state(&mut self) {
        self.lobby_state = ::std::option::Option::None;
    }

    pub fn has_lobby_state(&self) -> bool {
        self.lobby_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_state(&mut self, v: super::dota_gcmessages_common_match_management::CSODOTALobby_State) {
        self.lobby_state = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_state(&self) -> super::dota_gcmessages_common_match_management::CSODOTALobby_State {
        self.lobby_state.unwrap_or(super::dota_gcmessages_common_match_management::CSODOTALobby_State::UI)
    }

    fn get_lobby_state_for_reflect(&self) -> &::std::option::Option<super::dota_gcmessages_common_match_management::CSODOTALobby_State> {
        &self.lobby_state
    }

    fn mut_lobby_state_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_gcmessages_common_match_management::CSODOTALobby_State> {
        &mut self.lobby_state
    }

    // optional bool password = 3;

    pub fn clear_password(&mut self) {
        self.password = ::std::option::Option::None;
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: bool) {
        self.password = ::std::option::Option::Some(v);
    }

    pub fn get_password(&self) -> bool {
        self.password.unwrap_or(false)
    }

    fn get_password_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.password
    }

    fn mut_password_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.password
    }

    // optional .DOTA_GameMode game_mode = 4;

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: super::dota_shared_enums::DOTA_GameMode) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    pub fn get_game_mode(&self) -> super::dota_shared_enums::DOTA_GameMode {
        self.game_mode.unwrap_or(super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE)
    }

    fn get_game_mode_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::DOTA_GameMode> {
        &self.game_mode
    }

    fn mut_game_mode_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::DOTA_GameMode> {
        &mut self.game_mode
    }

    // optional uint32 member_count = 5;

    pub fn clear_member_count(&mut self) {
        self.member_count = ::std::option::Option::None;
    }

    pub fn has_member_count(&self) -> bool {
        self.member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_count(&mut self, v: u32) {
        self.member_count = ::std::option::Option::Some(v);
    }

    pub fn get_member_count(&self) -> u32 {
        self.member_count.unwrap_or(0)
    }

    fn get_member_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.member_count
    }

    fn mut_member_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.member_count
    }

    // optional uint32 max_member_count = 6;

    pub fn clear_max_member_count(&mut self) {
        self.max_member_count = ::std::option::Option::None;
    }

    pub fn has_max_member_count(&self) -> bool {
        self.max_member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_member_count(&mut self, v: u32) {
        self.max_member_count = ::std::option::Option::Some(v);
    }

    pub fn get_max_member_count(&self) -> u32 {
        self.max_member_count.unwrap_or(0)
    }

    fn get_max_member_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.max_member_count
    }

    fn mut_max_member_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.max_member_count
    }

    // optional fixed64 custom_game_id = 7;

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    pub fn get_custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    fn get_custom_game_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.custom_game_id
    }

    fn mut_custom_game_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.custom_game_id
    }

    // optional string name = 8;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional uint32 lobby_type = 9;

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    fn get_lobby_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lobby_type
    }

    fn mut_lobby_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lobby_type
    }
}

impl ::protobuf::Message for CMsgDOTALobbyRichPresence {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.lobby_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.lobby_state = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.password = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.game_mode = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.member_count = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_member_count = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.custom_game_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lobby_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 9;
        }
        if let Some(v) = self.lobby_state {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.password {
            my_size += 2;
        }
        if let Some(v) = self.game_mode {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.member_count {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_member_count {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.custom_game_id {
            my_size += 9;
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.lobby_state {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.password {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_enum(4, v.value())?;
        }
        if let Some(v) = self.member_count {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.max_member_count {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_fixed64(7, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTALobbyRichPresence {
    fn new() -> CMsgDOTALobbyRichPresence {
        CMsgDOTALobbyRichPresence::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTALobbyRichPresence>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "lobby_id",
                    CMsgDOTALobbyRichPresence::get_lobby_id_for_reflect,
                    CMsgDOTALobbyRichPresence::mut_lobby_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_gcmessages_common_match_management::CSODOTALobby_State>>(
                    "lobby_state",
                    CMsgDOTALobbyRichPresence::get_lobby_state_for_reflect,
                    CMsgDOTALobbyRichPresence::mut_lobby_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "password",
                    CMsgDOTALobbyRichPresence::get_password_for_reflect,
                    CMsgDOTALobbyRichPresence::mut_password_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::DOTA_GameMode>>(
                    "game_mode",
                    CMsgDOTALobbyRichPresence::get_game_mode_for_reflect,
                    CMsgDOTALobbyRichPresence::mut_game_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "member_count",
                    CMsgDOTALobbyRichPresence::get_member_count_for_reflect,
                    CMsgDOTALobbyRichPresence::mut_member_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_member_count",
                    CMsgDOTALobbyRichPresence::get_max_member_count_for_reflect,
                    CMsgDOTALobbyRichPresence::mut_max_member_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "custom_game_id",
                    CMsgDOTALobbyRichPresence::get_custom_game_id_for_reflect,
                    CMsgDOTALobbyRichPresence::mut_custom_game_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgDOTALobbyRichPresence::get_name_for_reflect,
                    CMsgDOTALobbyRichPresence::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lobby_type",
                    CMsgDOTALobbyRichPresence::get_lobby_type_for_reflect,
                    CMsgDOTALobbyRichPresence::mut_lobby_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTALobbyRichPresence>(
                    "CMsgDOTALobbyRichPresence",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTALobbyRichPresence {
    fn clear(&mut self) {
        self.clear_lobby_id();
        self.clear_lobby_state();
        self.clear_password();
        self.clear_game_mode();
        self.clear_member_count();
        self.clear_max_member_count();
        self.clear_custom_game_id();
        self.clear_name();
        self.clear_lobby_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTALobbyRichPresence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTALobbyRichPresence {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTACustomGameListenServerStartedLoading {
    // message fields
    lobby_id: ::std::option::Option<u64>,
    custom_game_id: ::std::option::Option<u64>,
    lobby_members: ::std::vec::Vec<u32>,
    start_time: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTACustomGameListenServerStartedLoading {}

impl CMsgDOTACustomGameListenServerStartedLoading {
    pub fn new() -> CMsgDOTACustomGameListenServerStartedLoading {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTACustomGameListenServerStartedLoading {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTACustomGameListenServerStartedLoading> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTACustomGameListenServerStartedLoading,
        };
        unsafe {
            instance.get(CMsgDOTACustomGameListenServerStartedLoading::new)
        }
    }

    // optional fixed64 lobby_id = 1;

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    fn get_lobby_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.lobby_id
    }

    fn mut_lobby_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.lobby_id
    }

    // optional uint64 custom_game_id = 2;

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    pub fn get_custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    fn get_custom_game_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.custom_game_id
    }

    fn mut_custom_game_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.custom_game_id
    }

    // repeated uint32 lobby_members = 3;

    pub fn clear_lobby_members(&mut self) {
        self.lobby_members.clear();
    }

    // Param is passed by value, moved
    pub fn set_lobby_members(&mut self, v: ::std::vec::Vec<u32>) {
        self.lobby_members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lobby_members(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.lobby_members
    }

    // Take field
    pub fn take_lobby_members(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.lobby_members, ::std::vec::Vec::new())
    }

    pub fn get_lobby_members(&self) -> &[u32] {
        &self.lobby_members
    }

    fn get_lobby_members_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.lobby_members
    }

    fn mut_lobby_members_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.lobby_members
    }

    // optional uint32 start_time = 4;

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    pub fn get_start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    fn get_start_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.start_time
    }

    fn mut_start_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.start_time
    }
}

impl ::protobuf::Message for CMsgDOTACustomGameListenServerStartedLoading {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.lobby_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.custom_game_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.lobby_members)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 9;
        }
        if let Some(v) = self.custom_game_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.lobby_members {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.lobby_members {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.start_time {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTACustomGameListenServerStartedLoading {
    fn new() -> CMsgDOTACustomGameListenServerStartedLoading {
        CMsgDOTACustomGameListenServerStartedLoading::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTACustomGameListenServerStartedLoading>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "lobby_id",
                    CMsgDOTACustomGameListenServerStartedLoading::get_lobby_id_for_reflect,
                    CMsgDOTACustomGameListenServerStartedLoading::mut_lobby_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "custom_game_id",
                    CMsgDOTACustomGameListenServerStartedLoading::get_custom_game_id_for_reflect,
                    CMsgDOTACustomGameListenServerStartedLoading::mut_custom_game_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lobby_members",
                    CMsgDOTACustomGameListenServerStartedLoading::get_lobby_members_for_reflect,
                    CMsgDOTACustomGameListenServerStartedLoading::mut_lobby_members_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "start_time",
                    CMsgDOTACustomGameListenServerStartedLoading::get_start_time_for_reflect,
                    CMsgDOTACustomGameListenServerStartedLoading::mut_start_time_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTACustomGameListenServerStartedLoading>(
                    "CMsgDOTACustomGameListenServerStartedLoading",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTACustomGameListenServerStartedLoading {
    fn clear(&mut self) {
        self.clear_lobby_id();
        self.clear_custom_game_id();
        self.clear_lobby_members();
        self.clear_start_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTACustomGameListenServerStartedLoading {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTACustomGameListenServerStartedLoading {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTACustomGameClientFinishedLoading {
    // message fields
    lobby_id: ::std::option::Option<u64>,
    loading_duration: ::std::option::Option<u32>,
    result_code: ::std::option::Option<i32>,
    result_string: ::protobuf::SingularField<::std::string::String>,
    signon_states: ::std::option::Option<u32>,
    comment: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTACustomGameClientFinishedLoading {}

impl CMsgDOTACustomGameClientFinishedLoading {
    pub fn new() -> CMsgDOTACustomGameClientFinishedLoading {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTACustomGameClientFinishedLoading {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTACustomGameClientFinishedLoading> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTACustomGameClientFinishedLoading,
        };
        unsafe {
            instance.get(CMsgDOTACustomGameClientFinishedLoading::new)
        }
    }

    // optional fixed64 lobby_id = 1;

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    fn get_lobby_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.lobby_id
    }

    fn mut_lobby_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.lobby_id
    }

    // optional uint32 loading_duration = 2;

    pub fn clear_loading_duration(&mut self) {
        self.loading_duration = ::std::option::Option::None;
    }

    pub fn has_loading_duration(&self) -> bool {
        self.loading_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loading_duration(&mut self, v: u32) {
        self.loading_duration = ::std::option::Option::Some(v);
    }

    pub fn get_loading_duration(&self) -> u32 {
        self.loading_duration.unwrap_or(0)
    }

    fn get_loading_duration_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.loading_duration
    }

    fn mut_loading_duration_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.loading_duration
    }

    // optional sint32 result_code = 3;

    pub fn clear_result_code(&mut self) {
        self.result_code = ::std::option::Option::None;
    }

    pub fn has_result_code(&self) -> bool {
        self.result_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_code(&mut self, v: i32) {
        self.result_code = ::std::option::Option::Some(v);
    }

    pub fn get_result_code(&self) -> i32 {
        self.result_code.unwrap_or(0)
    }

    fn get_result_code_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.result_code
    }

    fn mut_result_code_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.result_code
    }

    // optional string result_string = 4;

    pub fn clear_result_string(&mut self) {
        self.result_string.clear();
    }

    pub fn has_result_string(&self) -> bool {
        self.result_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_string(&mut self, v: ::std::string::String) {
        self.result_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result_string(&mut self) -> &mut ::std::string::String {
        if self.result_string.is_none() {
            self.result_string.set_default();
        }
        self.result_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_result_string(&mut self) -> ::std::string::String {
        self.result_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_result_string(&self) -> &str {
        match self.result_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_result_string_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.result_string
    }

    fn mut_result_string_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.result_string
    }

    // optional uint32 signon_states = 5;

    pub fn clear_signon_states(&mut self) {
        self.signon_states = ::std::option::Option::None;
    }

    pub fn has_signon_states(&self) -> bool {
        self.signon_states.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signon_states(&mut self, v: u32) {
        self.signon_states = ::std::option::Option::Some(v);
    }

    pub fn get_signon_states(&self) -> u32 {
        self.signon_states.unwrap_or(0)
    }

    fn get_signon_states_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.signon_states
    }

    fn mut_signon_states_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.signon_states
    }

    // optional string comment = 6;

    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment.set_default();
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_comment_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.comment
    }

    fn mut_comment_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.comment
    }
}

impl ::protobuf::Message for CMsgDOTACustomGameClientFinishedLoading {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.lobby_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.loading_duration = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.result_code = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.result_string)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.signon_states = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.comment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 9;
        }
        if let Some(v) = self.loading_duration {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result_code {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        if let Some(ref v) = self.result_string.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.signon_states {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.loading_duration {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.result_code {
            os.write_sint32(3, v)?;
        }
        if let Some(ref v) = self.result_string.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.signon_states {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.comment.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTACustomGameClientFinishedLoading {
    fn new() -> CMsgDOTACustomGameClientFinishedLoading {
        CMsgDOTACustomGameClientFinishedLoading::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTACustomGameClientFinishedLoading>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "lobby_id",
                    CMsgDOTACustomGameClientFinishedLoading::get_lobby_id_for_reflect,
                    CMsgDOTACustomGameClientFinishedLoading::mut_lobby_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "loading_duration",
                    CMsgDOTACustomGameClientFinishedLoading::get_loading_duration_for_reflect,
                    CMsgDOTACustomGameClientFinishedLoading::mut_loading_duration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "result_code",
                    CMsgDOTACustomGameClientFinishedLoading::get_result_code_for_reflect,
                    CMsgDOTACustomGameClientFinishedLoading::mut_result_code_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "result_string",
                    CMsgDOTACustomGameClientFinishedLoading::get_result_string_for_reflect,
                    CMsgDOTACustomGameClientFinishedLoading::mut_result_string_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "signon_states",
                    CMsgDOTACustomGameClientFinishedLoading::get_signon_states_for_reflect,
                    CMsgDOTACustomGameClientFinishedLoading::mut_signon_states_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "comment",
                    CMsgDOTACustomGameClientFinishedLoading::get_comment_for_reflect,
                    CMsgDOTACustomGameClientFinishedLoading::mut_comment_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTACustomGameClientFinishedLoading>(
                    "CMsgDOTACustomGameClientFinishedLoading",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTACustomGameClientFinishedLoading {
    fn clear(&mut self) {
        self.clear_lobby_id();
        self.clear_loading_duration();
        self.clear_result_code();
        self.clear_result_string();
        self.clear_signon_states();
        self.clear_comment();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTACustomGameClientFinishedLoading {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTACustomGameClientFinishedLoading {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetLeagueSeries {
    // message fields
    league_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetLeagueSeries {}

impl CMsgClientToGCGetLeagueSeries {
    pub fn new() -> CMsgClientToGCGetLeagueSeries {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetLeagueSeries {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetLeagueSeries> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetLeagueSeries,
        };
        unsafe {
            instance.get(CMsgClientToGCGetLeagueSeries::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }
}

impl ::protobuf::Message for CMsgClientToGCGetLeagueSeries {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetLeagueSeries {
    fn new() -> CMsgClientToGCGetLeagueSeries {
        CMsgClientToGCGetLeagueSeries::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetLeagueSeries>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgClientToGCGetLeagueSeries::get_league_id_for_reflect,
                    CMsgClientToGCGetLeagueSeries::mut_league_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetLeagueSeries>(
                    "CMsgClientToGCGetLeagueSeries",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetLeagueSeries {
    fn clear(&mut self) {
        self.clear_league_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetLeagueSeries {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetLeagueSeries {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetLeagueSeriesResponse {
    // message fields
    series: ::protobuf::RepeatedField<CMsgClientToGCGetLeagueSeriesResponse_Series>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetLeagueSeriesResponse {}

impl CMsgClientToGCGetLeagueSeriesResponse {
    pub fn new() -> CMsgClientToGCGetLeagueSeriesResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetLeagueSeriesResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetLeagueSeriesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetLeagueSeriesResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCGetLeagueSeriesResponse::new)
        }
    }

    // repeated .CMsgClientToGCGetLeagueSeriesResponse.Series series = 1;

    pub fn clear_series(&mut self) {
        self.series.clear();
    }

    // Param is passed by value, moved
    pub fn set_series(&mut self, v: ::protobuf::RepeatedField<CMsgClientToGCGetLeagueSeriesResponse_Series>) {
        self.series = v;
    }

    // Mutable pointer to the field.
    pub fn mut_series(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCGetLeagueSeriesResponse_Series> {
        &mut self.series
    }

    // Take field
    pub fn take_series(&mut self) -> ::protobuf::RepeatedField<CMsgClientToGCGetLeagueSeriesResponse_Series> {
        ::std::mem::replace(&mut self.series, ::protobuf::RepeatedField::new())
    }

    pub fn get_series(&self) -> &[CMsgClientToGCGetLeagueSeriesResponse_Series] {
        &self.series
    }

    fn get_series_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientToGCGetLeagueSeriesResponse_Series> {
        &self.series
    }

    fn mut_series_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCGetLeagueSeriesResponse_Series> {
        &mut self.series
    }
}

impl ::protobuf::Message for CMsgClientToGCGetLeagueSeriesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.series {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.series)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.series {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.series {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetLeagueSeriesResponse {
    fn new() -> CMsgClientToGCGetLeagueSeriesResponse {
        CMsgClientToGCGetLeagueSeriesResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetLeagueSeriesResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCGetLeagueSeriesResponse_Series>>(
                    "series",
                    CMsgClientToGCGetLeagueSeriesResponse::get_series_for_reflect,
                    CMsgClientToGCGetLeagueSeriesResponse::mut_series_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetLeagueSeriesResponse>(
                    "CMsgClientToGCGetLeagueSeriesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetLeagueSeriesResponse {
    fn clear(&mut self) {
        self.clear_series();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetLeagueSeriesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetLeagueSeriesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetLeagueSeriesResponse_Series {
    // message fields
    series_id: ::std::option::Option<u32>,
    num_games: ::std::option::Option<u32>,
    teams: ::protobuf::RepeatedField<CMsgClientToGCGetLeagueSeriesResponse_Series_Team>,
    series_name: ::protobuf::SingularField<::std::string::String>,
    phase_name: ::protobuf::SingularField<::std::string::String>,
    start_time: ::std::option::Option<u32>,
    after_series_id: ::std::option::Option<u32>,
    num_completed_games: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetLeagueSeriesResponse_Series {}

impl CMsgClientToGCGetLeagueSeriesResponse_Series {
    pub fn new() -> CMsgClientToGCGetLeagueSeriesResponse_Series {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetLeagueSeriesResponse_Series {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetLeagueSeriesResponse_Series> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetLeagueSeriesResponse_Series,
        };
        unsafe {
            instance.get(CMsgClientToGCGetLeagueSeriesResponse_Series::new)
        }
    }

    // optional uint32 series_id = 1;

    pub fn clear_series_id(&mut self) {
        self.series_id = ::std::option::Option::None;
    }

    pub fn has_series_id(&self) -> bool {
        self.series_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_id(&mut self, v: u32) {
        self.series_id = ::std::option::Option::Some(v);
    }

    pub fn get_series_id(&self) -> u32 {
        self.series_id.unwrap_or(0)
    }

    fn get_series_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.series_id
    }

    fn mut_series_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.series_id
    }

    // optional uint32 num_games = 2;

    pub fn clear_num_games(&mut self) {
        self.num_games = ::std::option::Option::None;
    }

    pub fn has_num_games(&self) -> bool {
        self.num_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_games(&mut self, v: u32) {
        self.num_games = ::std::option::Option::Some(v);
    }

    pub fn get_num_games(&self) -> u32 {
        self.num_games.unwrap_or(0)
    }

    fn get_num_games_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.num_games
    }

    fn mut_num_games_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.num_games
    }

    // repeated .CMsgClientToGCGetLeagueSeriesResponse.Series.Team teams = 3;

    pub fn clear_teams(&mut self) {
        self.teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_teams(&mut self, v: ::protobuf::RepeatedField<CMsgClientToGCGetLeagueSeriesResponse_Series_Team>) {
        self.teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_teams(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCGetLeagueSeriesResponse_Series_Team> {
        &mut self.teams
    }

    // Take field
    pub fn take_teams(&mut self) -> ::protobuf::RepeatedField<CMsgClientToGCGetLeagueSeriesResponse_Series_Team> {
        ::std::mem::replace(&mut self.teams, ::protobuf::RepeatedField::new())
    }

    pub fn get_teams(&self) -> &[CMsgClientToGCGetLeagueSeriesResponse_Series_Team] {
        &self.teams
    }

    fn get_teams_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientToGCGetLeagueSeriesResponse_Series_Team> {
        &self.teams
    }

    fn mut_teams_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCGetLeagueSeriesResponse_Series_Team> {
        &mut self.teams
    }

    // optional string series_name = 4;

    pub fn clear_series_name(&mut self) {
        self.series_name.clear();
    }

    pub fn has_series_name(&self) -> bool {
        self.series_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_name(&mut self, v: ::std::string::String) {
        self.series_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_series_name(&mut self) -> &mut ::std::string::String {
        if self.series_name.is_none() {
            self.series_name.set_default();
        }
        self.series_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_series_name(&mut self) -> ::std::string::String {
        self.series_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_series_name(&self) -> &str {
        match self.series_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_series_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.series_name
    }

    fn mut_series_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.series_name
    }

    // optional string phase_name = 5;

    pub fn clear_phase_name(&mut self) {
        self.phase_name.clear();
    }

    pub fn has_phase_name(&self) -> bool {
        self.phase_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase_name(&mut self, v: ::std::string::String) {
        self.phase_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase_name(&mut self) -> &mut ::std::string::String {
        if self.phase_name.is_none() {
            self.phase_name.set_default();
        }
        self.phase_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase_name(&mut self) -> ::std::string::String {
        self.phase_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_phase_name(&self) -> &str {
        match self.phase_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_phase_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.phase_name
    }

    fn mut_phase_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.phase_name
    }

    // optional uint32 start_time = 6;

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    pub fn get_start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    fn get_start_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.start_time
    }

    fn mut_start_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.start_time
    }

    // optional uint32 after_series_id = 7;

    pub fn clear_after_series_id(&mut self) {
        self.after_series_id = ::std::option::Option::None;
    }

    pub fn has_after_series_id(&self) -> bool {
        self.after_series_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_after_series_id(&mut self, v: u32) {
        self.after_series_id = ::std::option::Option::Some(v);
    }

    pub fn get_after_series_id(&self) -> u32 {
        self.after_series_id.unwrap_or(0)
    }

    fn get_after_series_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.after_series_id
    }

    fn mut_after_series_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.after_series_id
    }

    // optional uint32 num_completed_games = 8;

    pub fn clear_num_completed_games(&mut self) {
        self.num_completed_games = ::std::option::Option::None;
    }

    pub fn has_num_completed_games(&self) -> bool {
        self.num_completed_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_completed_games(&mut self, v: u32) {
        self.num_completed_games = ::std::option::Option::Some(v);
    }

    pub fn get_num_completed_games(&self) -> u32 {
        self.num_completed_games.unwrap_or(0)
    }

    fn get_num_completed_games_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.num_completed_games
    }

    fn mut_num_completed_games_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.num_completed_games
    }
}

impl ::protobuf::Message for CMsgClientToGCGetLeagueSeriesResponse_Series {
    fn is_initialized(&self) -> bool {
        for v in &self.teams {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.series_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_games = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.teams)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.series_name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phase_name)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.after_series_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_completed_games = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.series_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_games {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.series_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.phase_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.after_series_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_completed_games {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.series_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_games {
            os.write_uint32(2, v)?;
        }
        for v in &self.teams {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.series_name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.phase_name.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.after_series_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.num_completed_games {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetLeagueSeriesResponse_Series {
    fn new() -> CMsgClientToGCGetLeagueSeriesResponse_Series {
        CMsgClientToGCGetLeagueSeriesResponse_Series::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetLeagueSeriesResponse_Series>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "series_id",
                    CMsgClientToGCGetLeagueSeriesResponse_Series::get_series_id_for_reflect,
                    CMsgClientToGCGetLeagueSeriesResponse_Series::mut_series_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_games",
                    CMsgClientToGCGetLeagueSeriesResponse_Series::get_num_games_for_reflect,
                    CMsgClientToGCGetLeagueSeriesResponse_Series::mut_num_games_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCGetLeagueSeriesResponse_Series_Team>>(
                    "teams",
                    CMsgClientToGCGetLeagueSeriesResponse_Series::get_teams_for_reflect,
                    CMsgClientToGCGetLeagueSeriesResponse_Series::mut_teams_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "series_name",
                    CMsgClientToGCGetLeagueSeriesResponse_Series::get_series_name_for_reflect,
                    CMsgClientToGCGetLeagueSeriesResponse_Series::mut_series_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "phase_name",
                    CMsgClientToGCGetLeagueSeriesResponse_Series::get_phase_name_for_reflect,
                    CMsgClientToGCGetLeagueSeriesResponse_Series::mut_phase_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "start_time",
                    CMsgClientToGCGetLeagueSeriesResponse_Series::get_start_time_for_reflect,
                    CMsgClientToGCGetLeagueSeriesResponse_Series::mut_start_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "after_series_id",
                    CMsgClientToGCGetLeagueSeriesResponse_Series::get_after_series_id_for_reflect,
                    CMsgClientToGCGetLeagueSeriesResponse_Series::mut_after_series_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_completed_games",
                    CMsgClientToGCGetLeagueSeriesResponse_Series::get_num_completed_games_for_reflect,
                    CMsgClientToGCGetLeagueSeriesResponse_Series::mut_num_completed_games_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetLeagueSeriesResponse_Series>(
                    "CMsgClientToGCGetLeagueSeriesResponse_Series",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetLeagueSeriesResponse_Series {
    fn clear(&mut self) {
        self.clear_series_id();
        self.clear_num_games();
        self.clear_teams();
        self.clear_series_name();
        self.clear_phase_name();
        self.clear_start_time();
        self.clear_after_series_id();
        self.clear_num_completed_games();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetLeagueSeriesResponse_Series {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetLeagueSeriesResponse_Series {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetLeagueSeriesResponse_Series_Team {
    // message fields
    team_id: ::std::option::Option<u32>,
    team_name: ::protobuf::SingularField<::std::string::String>,
    team_tag: ::protobuf::SingularField<::std::string::String>,
    team_score: ::std::option::Option<u32>,
    team_wins: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetLeagueSeriesResponse_Series_Team {}

impl CMsgClientToGCGetLeagueSeriesResponse_Series_Team {
    pub fn new() -> CMsgClientToGCGetLeagueSeriesResponse_Series_Team {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetLeagueSeriesResponse_Series_Team {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetLeagueSeriesResponse_Series_Team> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetLeagueSeriesResponse_Series_Team,
        };
        unsafe {
            instance.get(CMsgClientToGCGetLeagueSeriesResponse_Series_Team::new)
        }
    }

    // optional uint32 team_id = 1;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_id
    }

    // optional string team_name = 2;

    pub fn clear_team_name(&mut self) {
        self.team_name.clear();
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name.set_default();
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_name
    }

    fn mut_team_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_name
    }

    // optional string team_tag = 3;

    pub fn clear_team_tag(&mut self) {
        self.team_tag.clear();
    }

    pub fn has_team_tag(&self) -> bool {
        self.team_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_tag(&mut self, v: ::std::string::String) {
        self.team_tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_tag(&mut self) -> &mut ::std::string::String {
        if self.team_tag.is_none() {
            self.team_tag.set_default();
        }
        self.team_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_tag(&mut self) -> ::std::string::String {
        self.team_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_tag(&self) -> &str {
        match self.team_tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_tag_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_tag
    }

    fn mut_team_tag_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_tag
    }

    // optional uint32 team_score = 4;

    pub fn clear_team_score(&mut self) {
        self.team_score = ::std::option::Option::None;
    }

    pub fn has_team_score(&self) -> bool {
        self.team_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_score(&mut self, v: u32) {
        self.team_score = ::std::option::Option::Some(v);
    }

    pub fn get_team_score(&self) -> u32 {
        self.team_score.unwrap_or(0)
    }

    fn get_team_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_score
    }

    fn mut_team_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_score
    }

    // optional uint32 team_wins = 5;

    pub fn clear_team_wins(&mut self) {
        self.team_wins = ::std::option::Option::None;
    }

    pub fn has_team_wins(&self) -> bool {
        self.team_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_wins(&mut self, v: u32) {
        self.team_wins = ::std::option::Option::Some(v);
    }

    pub fn get_team_wins(&self) -> u32 {
        self.team_wins.unwrap_or(0)
    }

    fn get_team_wins_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_wins
    }

    fn mut_team_wins_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_wins
    }
}

impl ::protobuf::Message for CMsgClientToGCGetLeagueSeriesResponse_Series_Team {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_tag)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_score = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_wins = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.team_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.team_score {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_wins {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.team_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.team_tag.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.team_score {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.team_wins {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetLeagueSeriesResponse_Series_Team {
    fn new() -> CMsgClientToGCGetLeagueSeriesResponse_Series_Team {
        CMsgClientToGCGetLeagueSeriesResponse_Series_Team::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetLeagueSeriesResponse_Series_Team>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_id",
                    CMsgClientToGCGetLeagueSeriesResponse_Series_Team::get_team_id_for_reflect,
                    CMsgClientToGCGetLeagueSeriesResponse_Series_Team::mut_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_name",
                    CMsgClientToGCGetLeagueSeriesResponse_Series_Team::get_team_name_for_reflect,
                    CMsgClientToGCGetLeagueSeriesResponse_Series_Team::mut_team_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_tag",
                    CMsgClientToGCGetLeagueSeriesResponse_Series_Team::get_team_tag_for_reflect,
                    CMsgClientToGCGetLeagueSeriesResponse_Series_Team::mut_team_tag_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_score",
                    CMsgClientToGCGetLeagueSeriesResponse_Series_Team::get_team_score_for_reflect,
                    CMsgClientToGCGetLeagueSeriesResponse_Series_Team::mut_team_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_wins",
                    CMsgClientToGCGetLeagueSeriesResponse_Series_Team::get_team_wins_for_reflect,
                    CMsgClientToGCGetLeagueSeriesResponse_Series_Team::mut_team_wins_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetLeagueSeriesResponse_Series_Team>(
                    "CMsgClientToGCGetLeagueSeriesResponse_Series_Team",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetLeagueSeriesResponse_Series_Team {
    fn clear(&mut self) {
        self.clear_team_id();
        self.clear_team_name();
        self.clear_team_tag();
        self.clear_team_score();
        self.clear_team_wins();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetLeagueSeriesResponse_Series_Team {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetLeagueSeriesResponse_Series_Team {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCApplyGemCombiner {
    // message fields
    item_id_1: ::std::option::Option<u64>,
    item_id_2: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCApplyGemCombiner {}

impl CMsgClientToGCApplyGemCombiner {
    pub fn new() -> CMsgClientToGCApplyGemCombiner {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCApplyGemCombiner {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCApplyGemCombiner> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCApplyGemCombiner,
        };
        unsafe {
            instance.get(CMsgClientToGCApplyGemCombiner::new)
        }
    }

    // optional uint64 item_id_1 = 1;

    pub fn clear_item_id_1(&mut self) {
        self.item_id_1 = ::std::option::Option::None;
    }

    pub fn has_item_id_1(&self) -> bool {
        self.item_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id_1(&mut self, v: u64) {
        self.item_id_1 = ::std::option::Option::Some(v);
    }

    pub fn get_item_id_1(&self) -> u64 {
        self.item_id_1.unwrap_or(0)
    }

    fn get_item_id_1_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id_1
    }

    fn mut_item_id_1_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id_1
    }

    // optional uint64 item_id_2 = 2;

    pub fn clear_item_id_2(&mut self) {
        self.item_id_2 = ::std::option::Option::None;
    }

    pub fn has_item_id_2(&self) -> bool {
        self.item_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id_2(&mut self, v: u64) {
        self.item_id_2 = ::std::option::Option::Some(v);
    }

    pub fn get_item_id_2(&self) -> u64 {
        self.item_id_2.unwrap_or(0)
    }

    fn get_item_id_2_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id_2
    }

    fn mut_item_id_2_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id_2
    }
}

impl ::protobuf::Message for CMsgClientToGCApplyGemCombiner {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id_1 = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id_2 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id_1 {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id_2 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id_1 {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_id_2 {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCApplyGemCombiner {
    fn new() -> CMsgClientToGCApplyGemCombiner {
        CMsgClientToGCApplyGemCombiner::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCApplyGemCombiner>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id_1",
                    CMsgClientToGCApplyGemCombiner::get_item_id_1_for_reflect,
                    CMsgClientToGCApplyGemCombiner::mut_item_id_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id_2",
                    CMsgClientToGCApplyGemCombiner::get_item_id_2_for_reflect,
                    CMsgClientToGCApplyGemCombiner::mut_item_id_2_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCApplyGemCombiner>(
                    "CMsgClientToGCApplyGemCombiner",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCApplyGemCombiner {
    fn clear(&mut self) {
        self.clear_item_id_1();
        self.clear_item_id_2();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCApplyGemCombiner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCApplyGemCombiner {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCH264Unsupported {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCH264Unsupported {}

impl CMsgClientToGCH264Unsupported {
    pub fn new() -> CMsgClientToGCH264Unsupported {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCH264Unsupported {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCH264Unsupported> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCH264Unsupported,
        };
        unsafe {
            instance.get(CMsgClientToGCH264Unsupported::new)
        }
    }
}

impl ::protobuf::Message for CMsgClientToGCH264Unsupported {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCH264Unsupported {
    fn new() -> CMsgClientToGCH264Unsupported {
        CMsgClientToGCH264Unsupported::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCH264Unsupported>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCH264Unsupported>(
                    "CMsgClientToGCH264Unsupported",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCH264Unsupported {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCH264Unsupported {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCH264Unsupported {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestH264Support {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestH264Support {}

impl CMsgClientToGCRequestH264Support {
    pub fn new() -> CMsgClientToGCRequestH264Support {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestH264Support {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestH264Support> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestH264Support,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestH264Support::new)
        }
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestH264Support {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestH264Support {
    fn new() -> CMsgClientToGCRequestH264Support {
        CMsgClientToGCRequestH264Support::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestH264Support>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestH264Support>(
                    "CMsgClientToGCRequestH264Support",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestH264Support {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestH264Support {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestH264Support {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetQuestProgress {
    // message fields
    quest_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetQuestProgress {}

impl CMsgClientToGCGetQuestProgress {
    pub fn new() -> CMsgClientToGCGetQuestProgress {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetQuestProgress {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetQuestProgress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetQuestProgress,
        };
        unsafe {
            instance.get(CMsgClientToGCGetQuestProgress::new)
        }
    }

    // repeated uint32 quest_ids = 1;

    pub fn clear_quest_ids(&mut self) {
        self.quest_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_quest_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.quest_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quest_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.quest_ids
    }

    // Take field
    pub fn take_quest_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.quest_ids, ::std::vec::Vec::new())
    }

    pub fn get_quest_ids(&self) -> &[u32] {
        &self.quest_ids
    }

    fn get_quest_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.quest_ids
    }

    fn mut_quest_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.quest_ids
    }
}

impl ::protobuf::Message for CMsgClientToGCGetQuestProgress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.quest_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.quest_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.quest_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetQuestProgress {
    fn new() -> CMsgClientToGCGetQuestProgress {
        CMsgClientToGCGetQuestProgress::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetQuestProgress>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quest_ids",
                    CMsgClientToGCGetQuestProgress::get_quest_ids_for_reflect,
                    CMsgClientToGCGetQuestProgress::mut_quest_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetQuestProgress>(
                    "CMsgClientToGCGetQuestProgress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetQuestProgress {
    fn clear(&mut self) {
        self.clear_quest_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetQuestProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetQuestProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetQuestProgressResponse {
    // message fields
    success: ::std::option::Option<bool>,
    quests: ::protobuf::RepeatedField<CMsgClientToGCGetQuestProgressResponse_Quest>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetQuestProgressResponse {}

impl CMsgClientToGCGetQuestProgressResponse {
    pub fn new() -> CMsgClientToGCGetQuestProgressResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetQuestProgressResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetQuestProgressResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetQuestProgressResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCGetQuestProgressResponse::new)
        }
    }

    // optional bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    fn get_success_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.success
    }

    fn mut_success_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.success
    }

    // repeated .CMsgClientToGCGetQuestProgressResponse.Quest quests = 2;

    pub fn clear_quests(&mut self) {
        self.quests.clear();
    }

    // Param is passed by value, moved
    pub fn set_quests(&mut self, v: ::protobuf::RepeatedField<CMsgClientToGCGetQuestProgressResponse_Quest>) {
        self.quests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quests(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCGetQuestProgressResponse_Quest> {
        &mut self.quests
    }

    // Take field
    pub fn take_quests(&mut self) -> ::protobuf::RepeatedField<CMsgClientToGCGetQuestProgressResponse_Quest> {
        ::std::mem::replace(&mut self.quests, ::protobuf::RepeatedField::new())
    }

    pub fn get_quests(&self) -> &[CMsgClientToGCGetQuestProgressResponse_Quest] {
        &self.quests
    }

    fn get_quests_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientToGCGetQuestProgressResponse_Quest> {
        &self.quests
    }

    fn mut_quests_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCGetQuestProgressResponse_Quest> {
        &mut self.quests
    }
}

impl ::protobuf::Message for CMsgClientToGCGetQuestProgressResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.quests {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.quests)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        for value in &self.quests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        for v in &self.quests {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetQuestProgressResponse {
    fn new() -> CMsgClientToGCGetQuestProgressResponse {
        CMsgClientToGCGetQuestProgressResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetQuestProgressResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    CMsgClientToGCGetQuestProgressResponse::get_success_for_reflect,
                    CMsgClientToGCGetQuestProgressResponse::mut_success_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCGetQuestProgressResponse_Quest>>(
                    "quests",
                    CMsgClientToGCGetQuestProgressResponse::get_quests_for_reflect,
                    CMsgClientToGCGetQuestProgressResponse::mut_quests_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetQuestProgressResponse>(
                    "CMsgClientToGCGetQuestProgressResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetQuestProgressResponse {
    fn clear(&mut self) {
        self.clear_success();
        self.clear_quests();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetQuestProgressResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetQuestProgressResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetQuestProgressResponse_Challenge {
    // message fields
    challenge_id: ::std::option::Option<u32>,
    time_completed: ::std::option::Option<u32>,
    attempts: ::std::option::Option<u32>,
    hero_id: ::std::option::Option<u32>,
    challenge_type: ::std::option::Option<u32>,
    quest_rank: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetQuestProgressResponse_Challenge {}

impl CMsgClientToGCGetQuestProgressResponse_Challenge {
    pub fn new() -> CMsgClientToGCGetQuestProgressResponse_Challenge {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetQuestProgressResponse_Challenge {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetQuestProgressResponse_Challenge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetQuestProgressResponse_Challenge,
        };
        unsafe {
            instance.get(CMsgClientToGCGetQuestProgressResponse_Challenge::new)
        }
    }

    // optional uint32 challenge_id = 1;

    pub fn clear_challenge_id(&mut self) {
        self.challenge_id = ::std::option::Option::None;
    }

    pub fn has_challenge_id(&self) -> bool {
        self.challenge_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_id(&mut self, v: u32) {
        self.challenge_id = ::std::option::Option::Some(v);
    }

    pub fn get_challenge_id(&self) -> u32 {
        self.challenge_id.unwrap_or(0)
    }

    fn get_challenge_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.challenge_id
    }

    fn mut_challenge_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.challenge_id
    }

    // optional uint32 time_completed = 2;

    pub fn clear_time_completed(&mut self) {
        self.time_completed = ::std::option::Option::None;
    }

    pub fn has_time_completed(&self) -> bool {
        self.time_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_completed(&mut self, v: u32) {
        self.time_completed = ::std::option::Option::Some(v);
    }

    pub fn get_time_completed(&self) -> u32 {
        self.time_completed.unwrap_or(0)
    }

    fn get_time_completed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time_completed
    }

    fn mut_time_completed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time_completed
    }

    // optional uint32 attempts = 3;

    pub fn clear_attempts(&mut self) {
        self.attempts = ::std::option::Option::None;
    }

    pub fn has_attempts(&self) -> bool {
        self.attempts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attempts(&mut self, v: u32) {
        self.attempts = ::std::option::Option::Some(v);
    }

    pub fn get_attempts(&self) -> u32 {
        self.attempts.unwrap_or(0)
    }

    fn get_attempts_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.attempts
    }

    fn mut_attempts_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.attempts
    }

    // optional uint32 hero_id = 4;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 challenge_type = 5;

    pub fn clear_challenge_type(&mut self) {
        self.challenge_type = ::std::option::Option::None;
    }

    pub fn has_challenge_type(&self) -> bool {
        self.challenge_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_type(&mut self, v: u32) {
        self.challenge_type = ::std::option::Option::Some(v);
    }

    pub fn get_challenge_type(&self) -> u32 {
        self.challenge_type.unwrap_or(0)
    }

    fn get_challenge_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.challenge_type
    }

    fn mut_challenge_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.challenge_type
    }

    // optional uint32 quest_rank = 6;

    pub fn clear_quest_rank(&mut self) {
        self.quest_rank = ::std::option::Option::None;
    }

    pub fn has_quest_rank(&self) -> bool {
        self.quest_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_rank(&mut self, v: u32) {
        self.quest_rank = ::std::option::Option::Some(v);
    }

    pub fn get_quest_rank(&self) -> u32 {
        self.quest_rank.unwrap_or(0)
    }

    fn get_quest_rank_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.quest_rank
    }

    fn mut_quest_rank_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.quest_rank
    }
}

impl ::protobuf::Message for CMsgClientToGCGetQuestProgressResponse_Challenge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.challenge_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_completed = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.attempts = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.challenge_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quest_rank = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.challenge_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_completed {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.attempts {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.challenge_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quest_rank {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.challenge_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time_completed {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.attempts {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.challenge_type {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.quest_rank {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetQuestProgressResponse_Challenge {
    fn new() -> CMsgClientToGCGetQuestProgressResponse_Challenge {
        CMsgClientToGCGetQuestProgressResponse_Challenge::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetQuestProgressResponse_Challenge>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "challenge_id",
                    CMsgClientToGCGetQuestProgressResponse_Challenge::get_challenge_id_for_reflect,
                    CMsgClientToGCGetQuestProgressResponse_Challenge::mut_challenge_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_completed",
                    CMsgClientToGCGetQuestProgressResponse_Challenge::get_time_completed_for_reflect,
                    CMsgClientToGCGetQuestProgressResponse_Challenge::mut_time_completed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "attempts",
                    CMsgClientToGCGetQuestProgressResponse_Challenge::get_attempts_for_reflect,
                    CMsgClientToGCGetQuestProgressResponse_Challenge::mut_attempts_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgClientToGCGetQuestProgressResponse_Challenge::get_hero_id_for_reflect,
                    CMsgClientToGCGetQuestProgressResponse_Challenge::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "challenge_type",
                    CMsgClientToGCGetQuestProgressResponse_Challenge::get_challenge_type_for_reflect,
                    CMsgClientToGCGetQuestProgressResponse_Challenge::mut_challenge_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quest_rank",
                    CMsgClientToGCGetQuestProgressResponse_Challenge::get_quest_rank_for_reflect,
                    CMsgClientToGCGetQuestProgressResponse_Challenge::mut_quest_rank_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetQuestProgressResponse_Challenge>(
                    "CMsgClientToGCGetQuestProgressResponse_Challenge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetQuestProgressResponse_Challenge {
    fn clear(&mut self) {
        self.clear_challenge_id();
        self.clear_time_completed();
        self.clear_attempts();
        self.clear_hero_id();
        self.clear_challenge_type();
        self.clear_quest_rank();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetQuestProgressResponse_Challenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetQuestProgressResponse_Challenge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetQuestProgressResponse_Quest {
    // message fields
    quest_id: ::std::option::Option<u32>,
    completed_challenges: ::protobuf::RepeatedField<CMsgClientToGCGetQuestProgressResponse_Challenge>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetQuestProgressResponse_Quest {}

impl CMsgClientToGCGetQuestProgressResponse_Quest {
    pub fn new() -> CMsgClientToGCGetQuestProgressResponse_Quest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetQuestProgressResponse_Quest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetQuestProgressResponse_Quest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetQuestProgressResponse_Quest,
        };
        unsafe {
            instance.get(CMsgClientToGCGetQuestProgressResponse_Quest::new)
        }
    }

    // optional uint32 quest_id = 1;

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u32) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    pub fn get_quest_id(&self) -> u32 {
        self.quest_id.unwrap_or(0)
    }

    fn get_quest_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.quest_id
    }

    fn mut_quest_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.quest_id
    }

    // repeated .CMsgClientToGCGetQuestProgressResponse.Challenge completed_challenges = 2;

    pub fn clear_completed_challenges(&mut self) {
        self.completed_challenges.clear();
    }

    // Param is passed by value, moved
    pub fn set_completed_challenges(&mut self, v: ::protobuf::RepeatedField<CMsgClientToGCGetQuestProgressResponse_Challenge>) {
        self.completed_challenges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_completed_challenges(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCGetQuestProgressResponse_Challenge> {
        &mut self.completed_challenges
    }

    // Take field
    pub fn take_completed_challenges(&mut self) -> ::protobuf::RepeatedField<CMsgClientToGCGetQuestProgressResponse_Challenge> {
        ::std::mem::replace(&mut self.completed_challenges, ::protobuf::RepeatedField::new())
    }

    pub fn get_completed_challenges(&self) -> &[CMsgClientToGCGetQuestProgressResponse_Challenge] {
        &self.completed_challenges
    }

    fn get_completed_challenges_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientToGCGetQuestProgressResponse_Challenge> {
        &self.completed_challenges
    }

    fn mut_completed_challenges_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCGetQuestProgressResponse_Challenge> {
        &mut self.completed_challenges
    }
}

impl ::protobuf::Message for CMsgClientToGCGetQuestProgressResponse_Quest {
    fn is_initialized(&self) -> bool {
        for v in &self.completed_challenges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.completed_challenges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.completed_challenges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.completed_challenges {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetQuestProgressResponse_Quest {
    fn new() -> CMsgClientToGCGetQuestProgressResponse_Quest {
        CMsgClientToGCGetQuestProgressResponse_Quest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetQuestProgressResponse_Quest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quest_id",
                    CMsgClientToGCGetQuestProgressResponse_Quest::get_quest_id_for_reflect,
                    CMsgClientToGCGetQuestProgressResponse_Quest::mut_quest_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCGetQuestProgressResponse_Challenge>>(
                    "completed_challenges",
                    CMsgClientToGCGetQuestProgressResponse_Quest::get_completed_challenges_for_reflect,
                    CMsgClientToGCGetQuestProgressResponse_Quest::mut_completed_challenges_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetQuestProgressResponse_Quest>(
                    "CMsgClientToGCGetQuestProgressResponse_Quest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetQuestProgressResponse_Quest {
    fn clear(&mut self) {
        self.clear_quest_id();
        self.clear_completed_challenges();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetQuestProgressResponse_Quest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetQuestProgressResponse_Quest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientMatchSignedOut {
    // message fields
    match_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientMatchSignedOut {}

impl CMsgGCToClientMatchSignedOut {
    pub fn new() -> CMsgGCToClientMatchSignedOut {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientMatchSignedOut {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientMatchSignedOut> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientMatchSignedOut,
        };
        unsafe {
            instance.get(CMsgGCToClientMatchSignedOut::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }
}

impl ::protobuf::Message for CMsgGCToClientMatchSignedOut {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientMatchSignedOut {
    fn new() -> CMsgGCToClientMatchSignedOut {
        CMsgGCToClientMatchSignedOut::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientMatchSignedOut>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgGCToClientMatchSignedOut::get_match_id_for_reflect,
                    CMsgGCToClientMatchSignedOut::mut_match_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientMatchSignedOut>(
                    "CMsgGCToClientMatchSignedOut",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientMatchSignedOut {
    fn clear(&mut self) {
        self.clear_match_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientMatchSignedOut {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientMatchSignedOut {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCGetHeroStatsHistory {
    // message fields
    hero_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCGetHeroStatsHistory {}

impl CMsgGCGetHeroStatsHistory {
    pub fn new() -> CMsgGCGetHeroStatsHistory {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCGetHeroStatsHistory {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCGetHeroStatsHistory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCGetHeroStatsHistory,
        };
        unsafe {
            instance.get(CMsgGCGetHeroStatsHistory::new)
        }
    }

    // optional uint32 hero_id = 1;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }
}

impl ::protobuf::Message for CMsgGCGetHeroStatsHistory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCGetHeroStatsHistory {
    fn new() -> CMsgGCGetHeroStatsHistory {
        CMsgGCGetHeroStatsHistory::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCGetHeroStatsHistory>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgGCGetHeroStatsHistory::get_hero_id_for_reflect,
                    CMsgGCGetHeroStatsHistory::mut_hero_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCGetHeroStatsHistory>(
                    "CMsgGCGetHeroStatsHistory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCGetHeroStatsHistory {
    fn clear(&mut self) {
        self.clear_hero_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCGetHeroStatsHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCGetHeroStatsHistory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCGetHeroStatsHistoryResponse {
    // message fields
    hero_id: ::std::option::Option<u32>,
    records: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTASDOHeroStatsHistory>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCGetHeroStatsHistoryResponse {}

impl CMsgGCGetHeroStatsHistoryResponse {
    pub fn new() -> CMsgGCGetHeroStatsHistoryResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCGetHeroStatsHistoryResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCGetHeroStatsHistoryResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCGetHeroStatsHistoryResponse,
        };
        unsafe {
            instance.get(CMsgGCGetHeroStatsHistoryResponse::new)
        }
    }

    // optional uint32 hero_id = 1;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // repeated .CMsgDOTASDOHeroStatsHistory records = 2;

    pub fn clear_records(&mut self) {
        self.records.clear();
    }

    // Param is passed by value, moved
    pub fn set_records(&mut self, v: ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTASDOHeroStatsHistory>) {
        self.records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_records(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTASDOHeroStatsHistory> {
        &mut self.records
    }

    // Take field
    pub fn take_records(&mut self) -> ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTASDOHeroStatsHistory> {
        ::std::mem::replace(&mut self.records, ::protobuf::RepeatedField::new())
    }

    pub fn get_records(&self) -> &[super::dota_gcmessages_common::CMsgDOTASDOHeroStatsHistory] {
        &self.records
    }

    fn get_records_for_reflect(&self) -> &::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTASDOHeroStatsHistory> {
        &self.records
    }

    fn mut_records_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::dota_gcmessages_common::CMsgDOTASDOHeroStatsHistory> {
        &mut self.records
    }
}

impl ::protobuf::Message for CMsgGCGetHeroStatsHistoryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.records {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.records)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.records {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hero_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.records {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCGetHeroStatsHistoryResponse {
    fn new() -> CMsgGCGetHeroStatsHistoryResponse {
        CMsgGCGetHeroStatsHistoryResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCGetHeroStatsHistoryResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgGCGetHeroStatsHistoryResponse::get_hero_id_for_reflect,
                    CMsgGCGetHeroStatsHistoryResponse::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_gcmessages_common::CMsgDOTASDOHeroStatsHistory>>(
                    "records",
                    CMsgGCGetHeroStatsHistoryResponse::get_records_for_reflect,
                    CMsgGCGetHeroStatsHistoryResponse::mut_records_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCGetHeroStatsHistoryResponse>(
                    "CMsgGCGetHeroStatsHistoryResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCGetHeroStatsHistoryResponse {
    fn clear(&mut self) {
        self.clear_hero_id();
        self.clear_records();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCGetHeroStatsHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCGetHeroStatsHistoryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPlayerConductScorecardRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgPlayerConductScorecardRequest {}

impl CMsgPlayerConductScorecardRequest {
    pub fn new() -> CMsgPlayerConductScorecardRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgPlayerConductScorecardRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPlayerConductScorecardRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPlayerConductScorecardRequest,
        };
        unsafe {
            instance.get(CMsgPlayerConductScorecardRequest::new)
        }
    }
}

impl ::protobuf::Message for CMsgPlayerConductScorecardRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgPlayerConductScorecardRequest {
    fn new() -> CMsgPlayerConductScorecardRequest {
        CMsgPlayerConductScorecardRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgPlayerConductScorecardRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPlayerConductScorecardRequest>(
                    "CMsgPlayerConductScorecardRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgPlayerConductScorecardRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPlayerConductScorecardRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerConductScorecardRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPlayerConductScorecard {
    // message fields
    account_id: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    seq_num: ::std::option::Option<u32>,
    reasons: ::std::option::Option<u32>,
    matches_in_report: ::std::option::Option<u32>,
    matches_clean: ::std::option::Option<u32>,
    matches_reported: ::std::option::Option<u32>,
    matches_abandoned: ::std::option::Option<u32>,
    reports_count: ::std::option::Option<u32>,
    reports_parties: ::std::option::Option<u32>,
    commend_count: ::std::option::Option<u32>,
    end_score: ::std::option::Option<u32>,
    date: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgPlayerConductScorecard {}

impl CMsgPlayerConductScorecard {
    pub fn new() -> CMsgPlayerConductScorecard {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgPlayerConductScorecard {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPlayerConductScorecard> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPlayerConductScorecard,
        };
        unsafe {
            instance.get(CMsgPlayerConductScorecard::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint64 match_id = 2;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 seq_num = 3;

    pub fn clear_seq_num(&mut self) {
        self.seq_num = ::std::option::Option::None;
    }

    pub fn has_seq_num(&self) -> bool {
        self.seq_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num(&mut self, v: u32) {
        self.seq_num = ::std::option::Option::Some(v);
    }

    pub fn get_seq_num(&self) -> u32 {
        self.seq_num.unwrap_or(0)
    }

    fn get_seq_num_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.seq_num
    }

    fn mut_seq_num_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.seq_num
    }

    // optional uint32 reasons = 4;

    pub fn clear_reasons(&mut self) {
        self.reasons = ::std::option::Option::None;
    }

    pub fn has_reasons(&self) -> bool {
        self.reasons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reasons(&mut self, v: u32) {
        self.reasons = ::std::option::Option::Some(v);
    }

    pub fn get_reasons(&self) -> u32 {
        self.reasons.unwrap_or(0)
    }

    fn get_reasons_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reasons
    }

    fn mut_reasons_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reasons
    }

    // optional uint32 matches_in_report = 5;

    pub fn clear_matches_in_report(&mut self) {
        self.matches_in_report = ::std::option::Option::None;
    }

    pub fn has_matches_in_report(&self) -> bool {
        self.matches_in_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matches_in_report(&mut self, v: u32) {
        self.matches_in_report = ::std::option::Option::Some(v);
    }

    pub fn get_matches_in_report(&self) -> u32 {
        self.matches_in_report.unwrap_or(0)
    }

    fn get_matches_in_report_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.matches_in_report
    }

    fn mut_matches_in_report_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.matches_in_report
    }

    // optional uint32 matches_clean = 6;

    pub fn clear_matches_clean(&mut self) {
        self.matches_clean = ::std::option::Option::None;
    }

    pub fn has_matches_clean(&self) -> bool {
        self.matches_clean.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matches_clean(&mut self, v: u32) {
        self.matches_clean = ::std::option::Option::Some(v);
    }

    pub fn get_matches_clean(&self) -> u32 {
        self.matches_clean.unwrap_or(0)
    }

    fn get_matches_clean_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.matches_clean
    }

    fn mut_matches_clean_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.matches_clean
    }

    // optional uint32 matches_reported = 7;

    pub fn clear_matches_reported(&mut self) {
        self.matches_reported = ::std::option::Option::None;
    }

    pub fn has_matches_reported(&self) -> bool {
        self.matches_reported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matches_reported(&mut self, v: u32) {
        self.matches_reported = ::std::option::Option::Some(v);
    }

    pub fn get_matches_reported(&self) -> u32 {
        self.matches_reported.unwrap_or(0)
    }

    fn get_matches_reported_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.matches_reported
    }

    fn mut_matches_reported_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.matches_reported
    }

    // optional uint32 matches_abandoned = 8;

    pub fn clear_matches_abandoned(&mut self) {
        self.matches_abandoned = ::std::option::Option::None;
    }

    pub fn has_matches_abandoned(&self) -> bool {
        self.matches_abandoned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matches_abandoned(&mut self, v: u32) {
        self.matches_abandoned = ::std::option::Option::Some(v);
    }

    pub fn get_matches_abandoned(&self) -> u32 {
        self.matches_abandoned.unwrap_or(0)
    }

    fn get_matches_abandoned_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.matches_abandoned
    }

    fn mut_matches_abandoned_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.matches_abandoned
    }

    // optional uint32 reports_count = 9;

    pub fn clear_reports_count(&mut self) {
        self.reports_count = ::std::option::Option::None;
    }

    pub fn has_reports_count(&self) -> bool {
        self.reports_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reports_count(&mut self, v: u32) {
        self.reports_count = ::std::option::Option::Some(v);
    }

    pub fn get_reports_count(&self) -> u32 {
        self.reports_count.unwrap_or(0)
    }

    fn get_reports_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reports_count
    }

    fn mut_reports_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reports_count
    }

    // optional uint32 reports_parties = 10;

    pub fn clear_reports_parties(&mut self) {
        self.reports_parties = ::std::option::Option::None;
    }

    pub fn has_reports_parties(&self) -> bool {
        self.reports_parties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reports_parties(&mut self, v: u32) {
        self.reports_parties = ::std::option::Option::Some(v);
    }

    pub fn get_reports_parties(&self) -> u32 {
        self.reports_parties.unwrap_or(0)
    }

    fn get_reports_parties_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reports_parties
    }

    fn mut_reports_parties_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reports_parties
    }

    // optional uint32 commend_count = 11;

    pub fn clear_commend_count(&mut self) {
        self.commend_count = ::std::option::Option::None;
    }

    pub fn has_commend_count(&self) -> bool {
        self.commend_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commend_count(&mut self, v: u32) {
        self.commend_count = ::std::option::Option::Some(v);
    }

    pub fn get_commend_count(&self) -> u32 {
        self.commend_count.unwrap_or(0)
    }

    fn get_commend_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.commend_count
    }

    fn mut_commend_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.commend_count
    }

    // optional uint32 end_score = 13;

    pub fn clear_end_score(&mut self) {
        self.end_score = ::std::option::Option::None;
    }

    pub fn has_end_score(&self) -> bool {
        self.end_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_score(&mut self, v: u32) {
        self.end_score = ::std::option::Option::Some(v);
    }

    pub fn get_end_score(&self) -> u32 {
        self.end_score.unwrap_or(0)
    }

    fn get_end_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.end_score
    }

    fn mut_end_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.end_score
    }

    // optional uint32 date = 14;

    pub fn clear_date(&mut self) {
        self.date = ::std::option::Option::None;
    }

    pub fn has_date(&self) -> bool {
        self.date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: u32) {
        self.date = ::std::option::Option::Some(v);
    }

    pub fn get_date(&self) -> u32 {
        self.date.unwrap_or(0)
    }

    fn get_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.date
    }

    fn mut_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.date
    }
}

impl ::protobuf::Message for CMsgPlayerConductScorecard {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reasons = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matches_in_report = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matches_clean = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matches_reported = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matches_abandoned = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reports_count = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reports_parties = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.commend_count = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.end_score = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.date = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reasons {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matches_in_report {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matches_clean {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matches_reported {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matches_abandoned {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reports_count {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reports_parties {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.commend_count {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end_score {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.date {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.seq_num {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.reasons {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.matches_in_report {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.matches_clean {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.matches_reported {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.matches_abandoned {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.reports_count {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.reports_parties {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.commend_count {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.end_score {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.date {
            os.write_uint32(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgPlayerConductScorecard {
    fn new() -> CMsgPlayerConductScorecard {
        CMsgPlayerConductScorecard::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgPlayerConductScorecard>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgPlayerConductScorecard::get_account_id_for_reflect,
                    CMsgPlayerConductScorecard::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgPlayerConductScorecard::get_match_id_for_reflect,
                    CMsgPlayerConductScorecard::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "seq_num",
                    CMsgPlayerConductScorecard::get_seq_num_for_reflect,
                    CMsgPlayerConductScorecard::mut_seq_num_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reasons",
                    CMsgPlayerConductScorecard::get_reasons_for_reflect,
                    CMsgPlayerConductScorecard::mut_reasons_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "matches_in_report",
                    CMsgPlayerConductScorecard::get_matches_in_report_for_reflect,
                    CMsgPlayerConductScorecard::mut_matches_in_report_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "matches_clean",
                    CMsgPlayerConductScorecard::get_matches_clean_for_reflect,
                    CMsgPlayerConductScorecard::mut_matches_clean_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "matches_reported",
                    CMsgPlayerConductScorecard::get_matches_reported_for_reflect,
                    CMsgPlayerConductScorecard::mut_matches_reported_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "matches_abandoned",
                    CMsgPlayerConductScorecard::get_matches_abandoned_for_reflect,
                    CMsgPlayerConductScorecard::mut_matches_abandoned_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reports_count",
                    CMsgPlayerConductScorecard::get_reports_count_for_reflect,
                    CMsgPlayerConductScorecard::mut_reports_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reports_parties",
                    CMsgPlayerConductScorecard::get_reports_parties_for_reflect,
                    CMsgPlayerConductScorecard::mut_reports_parties_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "commend_count",
                    CMsgPlayerConductScorecard::get_commend_count_for_reflect,
                    CMsgPlayerConductScorecard::mut_commend_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "end_score",
                    CMsgPlayerConductScorecard::get_end_score_for_reflect,
                    CMsgPlayerConductScorecard::mut_end_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "date",
                    CMsgPlayerConductScorecard::get_date_for_reflect,
                    CMsgPlayerConductScorecard::mut_date_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPlayerConductScorecard>(
                    "CMsgPlayerConductScorecard",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgPlayerConductScorecard {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_match_id();
        self.clear_seq_num();
        self.clear_reasons();
        self.clear_matches_in_report();
        self.clear_matches_clean();
        self.clear_matches_reported();
        self.clear_matches_abandoned();
        self.clear_reports_count();
        self.clear_reports_parties();
        self.clear_commend_count();
        self.clear_end_score();
        self.clear_date();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPlayerConductScorecard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerConductScorecard {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCWageringRequest {
    // message fields
    event_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCWageringRequest {}

impl CMsgClientToGCWageringRequest {
    pub fn new() -> CMsgClientToGCWageringRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCWageringRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCWageringRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCWageringRequest,
        };
        unsafe {
            instance.get(CMsgClientToGCWageringRequest::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }
}

impl ::protobuf::Message for CMsgClientToGCWageringRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCWageringRequest {
    fn new() -> CMsgClientToGCWageringRequest {
        CMsgClientToGCWageringRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCWageringRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgClientToGCWageringRequest::get_event_id_for_reflect,
                    CMsgClientToGCWageringRequest::mut_event_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCWageringRequest>(
                    "CMsgClientToGCWageringRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCWageringRequest {
    fn clear(&mut self) {
        self.clear_event_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCWageringRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCWageringRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientWageringResponse {
    // message fields
    coins_remaining: ::std::option::Option<u32>,
    total_points_won: ::std::option::Option<u32>,
    total_points_wagered: ::std::option::Option<u32>,
    total_points_tipped: ::std::option::Option<u32>,
    success_rate: ::std::option::Option<u32>,
    total_games_wagered: ::std::option::Option<u32>,
    coins_max: ::std::option::Option<u32>,
    rank_wagers_remaining: ::std::option::Option<u32>,
    rank_wagers_max: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientWageringResponse {}

impl CMsgGCToClientWageringResponse {
    pub fn new() -> CMsgGCToClientWageringResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientWageringResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientWageringResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientWageringResponse,
        };
        unsafe {
            instance.get(CMsgGCToClientWageringResponse::new)
        }
    }

    // optional uint32 coins_remaining = 1;

    pub fn clear_coins_remaining(&mut self) {
        self.coins_remaining = ::std::option::Option::None;
    }

    pub fn has_coins_remaining(&self) -> bool {
        self.coins_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coins_remaining(&mut self, v: u32) {
        self.coins_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_coins_remaining(&self) -> u32 {
        self.coins_remaining.unwrap_or(0)
    }

    fn get_coins_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.coins_remaining
    }

    fn mut_coins_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.coins_remaining
    }

    // optional uint32 total_points_won = 2;

    pub fn clear_total_points_won(&mut self) {
        self.total_points_won = ::std::option::Option::None;
    }

    pub fn has_total_points_won(&self) -> bool {
        self.total_points_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_points_won(&mut self, v: u32) {
        self.total_points_won = ::std::option::Option::Some(v);
    }

    pub fn get_total_points_won(&self) -> u32 {
        self.total_points_won.unwrap_or(0)
    }

    fn get_total_points_won_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_points_won
    }

    fn mut_total_points_won_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_points_won
    }

    // optional uint32 total_points_wagered = 3;

    pub fn clear_total_points_wagered(&mut self) {
        self.total_points_wagered = ::std::option::Option::None;
    }

    pub fn has_total_points_wagered(&self) -> bool {
        self.total_points_wagered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_points_wagered(&mut self, v: u32) {
        self.total_points_wagered = ::std::option::Option::Some(v);
    }

    pub fn get_total_points_wagered(&self) -> u32 {
        self.total_points_wagered.unwrap_or(0)
    }

    fn get_total_points_wagered_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_points_wagered
    }

    fn mut_total_points_wagered_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_points_wagered
    }

    // optional uint32 total_points_tipped = 4;

    pub fn clear_total_points_tipped(&mut self) {
        self.total_points_tipped = ::std::option::Option::None;
    }

    pub fn has_total_points_tipped(&self) -> bool {
        self.total_points_tipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_points_tipped(&mut self, v: u32) {
        self.total_points_tipped = ::std::option::Option::Some(v);
    }

    pub fn get_total_points_tipped(&self) -> u32 {
        self.total_points_tipped.unwrap_or(0)
    }

    fn get_total_points_tipped_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_points_tipped
    }

    fn mut_total_points_tipped_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_points_tipped
    }

    // optional uint32 success_rate = 5;

    pub fn clear_success_rate(&mut self) {
        self.success_rate = ::std::option::Option::None;
    }

    pub fn has_success_rate(&self) -> bool {
        self.success_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success_rate(&mut self, v: u32) {
        self.success_rate = ::std::option::Option::Some(v);
    }

    pub fn get_success_rate(&self) -> u32 {
        self.success_rate.unwrap_or(0)
    }

    fn get_success_rate_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.success_rate
    }

    fn mut_success_rate_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.success_rate
    }

    // optional uint32 total_games_wagered = 6;

    pub fn clear_total_games_wagered(&mut self) {
        self.total_games_wagered = ::std::option::Option::None;
    }

    pub fn has_total_games_wagered(&self) -> bool {
        self.total_games_wagered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_games_wagered(&mut self, v: u32) {
        self.total_games_wagered = ::std::option::Option::Some(v);
    }

    pub fn get_total_games_wagered(&self) -> u32 {
        self.total_games_wagered.unwrap_or(0)
    }

    fn get_total_games_wagered_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_games_wagered
    }

    fn mut_total_games_wagered_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_games_wagered
    }

    // optional uint32 coins_max = 7;

    pub fn clear_coins_max(&mut self) {
        self.coins_max = ::std::option::Option::None;
    }

    pub fn has_coins_max(&self) -> bool {
        self.coins_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coins_max(&mut self, v: u32) {
        self.coins_max = ::std::option::Option::Some(v);
    }

    pub fn get_coins_max(&self) -> u32 {
        self.coins_max.unwrap_or(0)
    }

    fn get_coins_max_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.coins_max
    }

    fn mut_coins_max_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.coins_max
    }

    // optional uint32 rank_wagers_remaining = 8;

    pub fn clear_rank_wagers_remaining(&mut self) {
        self.rank_wagers_remaining = ::std::option::Option::None;
    }

    pub fn has_rank_wagers_remaining(&self) -> bool {
        self.rank_wagers_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_wagers_remaining(&mut self, v: u32) {
        self.rank_wagers_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_rank_wagers_remaining(&self) -> u32 {
        self.rank_wagers_remaining.unwrap_or(0)
    }

    fn get_rank_wagers_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rank_wagers_remaining
    }

    fn mut_rank_wagers_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rank_wagers_remaining
    }

    // optional uint32 rank_wagers_max = 9;

    pub fn clear_rank_wagers_max(&mut self) {
        self.rank_wagers_max = ::std::option::Option::None;
    }

    pub fn has_rank_wagers_max(&self) -> bool {
        self.rank_wagers_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_wagers_max(&mut self, v: u32) {
        self.rank_wagers_max = ::std::option::Option::Some(v);
    }

    pub fn get_rank_wagers_max(&self) -> u32 {
        self.rank_wagers_max.unwrap_or(0)
    }

    fn get_rank_wagers_max_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rank_wagers_max
    }

    fn mut_rank_wagers_max_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rank_wagers_max
    }
}

impl ::protobuf::Message for CMsgGCToClientWageringResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.coins_remaining = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_points_won = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_points_wagered = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_points_tipped = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.success_rate = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_games_wagered = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.coins_max = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rank_wagers_remaining = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rank_wagers_max = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.coins_remaining {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_points_won {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_points_wagered {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_points_tipped {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.success_rate {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_games_wagered {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.coins_max {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_wagers_remaining {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_wagers_max {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.coins_remaining {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.total_points_won {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.total_points_wagered {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.total_points_tipped {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.success_rate {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.total_games_wagered {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.coins_max {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.rank_wagers_remaining {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.rank_wagers_max {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientWageringResponse {
    fn new() -> CMsgGCToClientWageringResponse {
        CMsgGCToClientWageringResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientWageringResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "coins_remaining",
                    CMsgGCToClientWageringResponse::get_coins_remaining_for_reflect,
                    CMsgGCToClientWageringResponse::mut_coins_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_points_won",
                    CMsgGCToClientWageringResponse::get_total_points_won_for_reflect,
                    CMsgGCToClientWageringResponse::mut_total_points_won_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_points_wagered",
                    CMsgGCToClientWageringResponse::get_total_points_wagered_for_reflect,
                    CMsgGCToClientWageringResponse::mut_total_points_wagered_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_points_tipped",
                    CMsgGCToClientWageringResponse::get_total_points_tipped_for_reflect,
                    CMsgGCToClientWageringResponse::mut_total_points_tipped_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "success_rate",
                    CMsgGCToClientWageringResponse::get_success_rate_for_reflect,
                    CMsgGCToClientWageringResponse::mut_success_rate_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_games_wagered",
                    CMsgGCToClientWageringResponse::get_total_games_wagered_for_reflect,
                    CMsgGCToClientWageringResponse::mut_total_games_wagered_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "coins_max",
                    CMsgGCToClientWageringResponse::get_coins_max_for_reflect,
                    CMsgGCToClientWageringResponse::mut_coins_max_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rank_wagers_remaining",
                    CMsgGCToClientWageringResponse::get_rank_wagers_remaining_for_reflect,
                    CMsgGCToClientWageringResponse::mut_rank_wagers_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rank_wagers_max",
                    CMsgGCToClientWageringResponse::get_rank_wagers_max_for_reflect,
                    CMsgGCToClientWageringResponse::mut_rank_wagers_max_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientWageringResponse>(
                    "CMsgGCToClientWageringResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientWageringResponse {
    fn clear(&mut self) {
        self.clear_coins_remaining();
        self.clear_total_points_won();
        self.clear_total_points_wagered();
        self.clear_total_points_tipped();
        self.clear_success_rate();
        self.clear_total_games_wagered();
        self.clear_coins_max();
        self.clear_rank_wagers_remaining();
        self.clear_rank_wagers_max();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientWageringResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientWageringResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientWageringUpdate {
    // message fields
    event_id: ::std::option::Option<u32>,
    wagering_info: ::protobuf::SingularPtrField<CMsgGCToClientWageringResponse>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientWageringUpdate {}

impl CMsgGCToClientWageringUpdate {
    pub fn new() -> CMsgGCToClientWageringUpdate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientWageringUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientWageringUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientWageringUpdate,
        };
        unsafe {
            instance.get(CMsgGCToClientWageringUpdate::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // optional .CMsgGCToClientWageringResponse wagering_info = 2;

    pub fn clear_wagering_info(&mut self) {
        self.wagering_info.clear();
    }

    pub fn has_wagering_info(&self) -> bool {
        self.wagering_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wagering_info(&mut self, v: CMsgGCToClientWageringResponse) {
        self.wagering_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wagering_info(&mut self) -> &mut CMsgGCToClientWageringResponse {
        if self.wagering_info.is_none() {
            self.wagering_info.set_default();
        }
        self.wagering_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_wagering_info(&mut self) -> CMsgGCToClientWageringResponse {
        self.wagering_info.take().unwrap_or_else(|| CMsgGCToClientWageringResponse::new())
    }

    pub fn get_wagering_info(&self) -> &CMsgGCToClientWageringResponse {
        self.wagering_info.as_ref().unwrap_or_else(|| CMsgGCToClientWageringResponse::default_instance())
    }

    fn get_wagering_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientWageringResponse> {
        &self.wagering_info
    }

    fn mut_wagering_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientWageringResponse> {
        &mut self.wagering_info
    }
}

impl ::protobuf::Message for CMsgGCToClientWageringUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.wagering_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.wagering_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.wagering_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.wagering_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientWageringUpdate {
    fn new() -> CMsgGCToClientWageringUpdate {
        CMsgGCToClientWageringUpdate::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientWageringUpdate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgGCToClientWageringUpdate::get_event_id_for_reflect,
                    CMsgGCToClientWageringUpdate::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientWageringResponse>>(
                    "wagering_info",
                    CMsgGCToClientWageringUpdate::get_wagering_info_for_reflect,
                    CMsgGCToClientWageringUpdate::mut_wagering_info_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientWageringUpdate>(
                    "CMsgGCToClientWageringUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientWageringUpdate {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_wagering_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientWageringUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientWageringUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientArcanaVotesUpdate {
    // message fields
    event_id: ::std::option::Option<u32>,
    arcana_votes: ::protobuf::SingularPtrField<CMsgClientToGCRequestArcanaVotesRemainingResponse>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientArcanaVotesUpdate {}

impl CMsgGCToClientArcanaVotesUpdate {
    pub fn new() -> CMsgGCToClientArcanaVotesUpdate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientArcanaVotesUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientArcanaVotesUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientArcanaVotesUpdate,
        };
        unsafe {
            instance.get(CMsgGCToClientArcanaVotesUpdate::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // optional .CMsgClientToGCRequestArcanaVotesRemainingResponse arcana_votes = 2;

    pub fn clear_arcana_votes(&mut self) {
        self.arcana_votes.clear();
    }

    pub fn has_arcana_votes(&self) -> bool {
        self.arcana_votes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arcana_votes(&mut self, v: CMsgClientToGCRequestArcanaVotesRemainingResponse) {
        self.arcana_votes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arcana_votes(&mut self) -> &mut CMsgClientToGCRequestArcanaVotesRemainingResponse {
        if self.arcana_votes.is_none() {
            self.arcana_votes.set_default();
        }
        self.arcana_votes.as_mut().unwrap()
    }

    // Take field
    pub fn take_arcana_votes(&mut self) -> CMsgClientToGCRequestArcanaVotesRemainingResponse {
        self.arcana_votes.take().unwrap_or_else(|| CMsgClientToGCRequestArcanaVotesRemainingResponse::new())
    }

    pub fn get_arcana_votes(&self) -> &CMsgClientToGCRequestArcanaVotesRemainingResponse {
        self.arcana_votes.as_ref().unwrap_or_else(|| CMsgClientToGCRequestArcanaVotesRemainingResponse::default_instance())
    }

    fn get_arcana_votes_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgClientToGCRequestArcanaVotesRemainingResponse> {
        &self.arcana_votes
    }

    fn mut_arcana_votes_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgClientToGCRequestArcanaVotesRemainingResponse> {
        &mut self.arcana_votes
    }
}

impl ::protobuf::Message for CMsgGCToClientArcanaVotesUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.arcana_votes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.arcana_votes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.arcana_votes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.arcana_votes.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientArcanaVotesUpdate {
    fn new() -> CMsgGCToClientArcanaVotesUpdate {
        CMsgGCToClientArcanaVotesUpdate::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientArcanaVotesUpdate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgGCToClientArcanaVotesUpdate::get_event_id_for_reflect,
                    CMsgGCToClientArcanaVotesUpdate::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCRequestArcanaVotesRemainingResponse>>(
                    "arcana_votes",
                    CMsgGCToClientArcanaVotesUpdate::get_arcana_votes_for_reflect,
                    CMsgGCToClientArcanaVotesUpdate::mut_arcana_votes_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientArcanaVotesUpdate>(
                    "CMsgGCToClientArcanaVotesUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientArcanaVotesUpdate {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_arcana_votes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientArcanaVotesUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientArcanaVotesUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetEventGoals {
    // message fields
    event_ids: ::std::vec::Vec<super::dota_shared_enums::EEvent>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetEventGoals {}

impl CMsgClientToGCGetEventGoals {
    pub fn new() -> CMsgClientToGCGetEventGoals {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetEventGoals {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetEventGoals> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetEventGoals,
        };
        unsafe {
            instance.get(CMsgClientToGCGetEventGoals::new)
        }
    }

    // repeated .EEvent event_ids = 1;

    pub fn clear_event_ids(&mut self) {
        self.event_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_ids(&mut self, v: ::std::vec::Vec<super::dota_shared_enums::EEvent>) {
        self.event_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_event_ids(&mut self) -> &mut ::std::vec::Vec<super::dota_shared_enums::EEvent> {
        &mut self.event_ids
    }

    // Take field
    pub fn take_event_ids(&mut self) -> ::std::vec::Vec<super::dota_shared_enums::EEvent> {
        ::std::mem::replace(&mut self.event_ids, ::std::vec::Vec::new())
    }

    pub fn get_event_ids(&self) -> &[super::dota_shared_enums::EEvent] {
        &self.event_ids
    }

    fn get_event_ids_for_reflect(&self) -> &::std::vec::Vec<super::dota_shared_enums::EEvent> {
        &self.event_ids
    }

    fn mut_event_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<super::dota_shared_enums::EEvent> {
        &mut self.event_ids
    }
}

impl ::protobuf::Message for CMsgClientToGCGetEventGoals {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_into(wire_type, is, &mut self.event_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.event_ids {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.event_ids {
            os.write_enum(1, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetEventGoals {
    fn new() -> CMsgClientToGCGetEventGoals {
        CMsgClientToGCGetEventGoals::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetEventGoals>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::EEvent>>(
                    "event_ids",
                    CMsgClientToGCGetEventGoals::get_event_ids_for_reflect,
                    CMsgClientToGCGetEventGoals::mut_event_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetEventGoals>(
                    "CMsgClientToGCGetEventGoals",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetEventGoals {
    fn clear(&mut self) {
        self.clear_event_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetEventGoals {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetEventGoals {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgEventGoals {
    // message fields
    event_goals: ::protobuf::RepeatedField<CMsgEventGoals_EventGoal>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgEventGoals {}

impl CMsgEventGoals {
    pub fn new() -> CMsgEventGoals {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgEventGoals {
        static mut instance: ::protobuf::lazy::Lazy<CMsgEventGoals> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgEventGoals,
        };
        unsafe {
            instance.get(CMsgEventGoals::new)
        }
    }

    // repeated .CMsgEventGoals.EventGoal event_goals = 1;

    pub fn clear_event_goals(&mut self) {
        self.event_goals.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_goals(&mut self, v: ::protobuf::RepeatedField<CMsgEventGoals_EventGoal>) {
        self.event_goals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_event_goals(&mut self) -> &mut ::protobuf::RepeatedField<CMsgEventGoals_EventGoal> {
        &mut self.event_goals
    }

    // Take field
    pub fn take_event_goals(&mut self) -> ::protobuf::RepeatedField<CMsgEventGoals_EventGoal> {
        ::std::mem::replace(&mut self.event_goals, ::protobuf::RepeatedField::new())
    }

    pub fn get_event_goals(&self) -> &[CMsgEventGoals_EventGoal] {
        &self.event_goals
    }

    fn get_event_goals_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgEventGoals_EventGoal> {
        &self.event_goals
    }

    fn mut_event_goals_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgEventGoals_EventGoal> {
        &mut self.event_goals
    }
}

impl ::protobuf::Message for CMsgEventGoals {
    fn is_initialized(&self) -> bool {
        for v in &self.event_goals {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.event_goals)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.event_goals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.event_goals {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgEventGoals {
    fn new() -> CMsgEventGoals {
        CMsgEventGoals::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgEventGoals>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgEventGoals_EventGoal>>(
                    "event_goals",
                    CMsgEventGoals::get_event_goals_for_reflect,
                    CMsgEventGoals::mut_event_goals_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgEventGoals>(
                    "CMsgEventGoals",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgEventGoals {
    fn clear(&mut self) {
        self.clear_event_goals();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgEventGoals {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgEventGoals {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgEventGoals_EventGoal {
    // message fields
    event_id: ::std::option::Option<super::dota_shared_enums::EEvent>,
    goal_id: ::std::option::Option<u32>,
    value: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgEventGoals_EventGoal {}

impl CMsgEventGoals_EventGoal {
    pub fn new() -> CMsgEventGoals_EventGoal {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgEventGoals_EventGoal {
        static mut instance: ::protobuf::lazy::Lazy<CMsgEventGoals_EventGoal> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgEventGoals_EventGoal,
        };
        unsafe {
            instance.get(CMsgEventGoals_EventGoal::new)
        }
    }

    // optional .EEvent event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> super::dota_shared_enums::EEvent {
        self.event_id.unwrap_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::EEvent> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::EEvent> {
        &mut self.event_id
    }

    // optional uint32 goal_id = 2;

    pub fn clear_goal_id(&mut self) {
        self.goal_id = ::std::option::Option::None;
    }

    pub fn has_goal_id(&self) -> bool {
        self.goal_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_goal_id(&mut self, v: u32) {
        self.goal_id = ::std::option::Option::Some(v);
    }

    pub fn get_goal_id(&self) -> u32 {
        self.goal_id.unwrap_or(0)
    }

    fn get_goal_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.goal_id
    }

    fn mut_goal_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.goal_id
    }

    // optional uint64 value = 3;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> u64 {
        self.value.unwrap_or(0)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.value
    }
}

impl ::protobuf::Message for CMsgEventGoals_EventGoal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.goal_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.goal_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.goal_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgEventGoals_EventGoal {
    fn new() -> CMsgEventGoals_EventGoal {
        CMsgEventGoals_EventGoal::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgEventGoals_EventGoal>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::EEvent>>(
                    "event_id",
                    CMsgEventGoals_EventGoal::get_event_id_for_reflect,
                    CMsgEventGoals_EventGoal::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "goal_id",
                    CMsgEventGoals_EventGoal::get_goal_id_for_reflect,
                    CMsgEventGoals_EventGoal::mut_goal_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "value",
                    CMsgEventGoals_EventGoal::get_value_for_reflect,
                    CMsgEventGoals_EventGoal::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgEventGoals_EventGoal>(
                    "CMsgEventGoals_EventGoal",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgEventGoals_EventGoal {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_goal_id();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgEventGoals_EventGoal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgEventGoals_EventGoal {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCLeaguePredictions {
    // message fields
    league_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCLeaguePredictions {}

impl CMsgGCToGCLeaguePredictions {
    pub fn new() -> CMsgGCToGCLeaguePredictions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCLeaguePredictions {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCLeaguePredictions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCLeaguePredictions,
        };
        unsafe {
            instance.get(CMsgGCToGCLeaguePredictions::new)
        }
    }

    // optional uint32 league_id = 1;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }
}

impl ::protobuf::Message for CMsgGCToGCLeaguePredictions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCLeaguePredictions {
    fn new() -> CMsgGCToGCLeaguePredictions {
        CMsgGCToGCLeaguePredictions::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCLeaguePredictions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgGCToGCLeaguePredictions::get_league_id_for_reflect,
                    CMsgGCToGCLeaguePredictions::mut_league_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCLeaguePredictions>(
                    "CMsgGCToGCLeaguePredictions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCLeaguePredictions {
    fn clear(&mut self) {
        self.clear_league_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCLeaguePredictions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCLeaguePredictions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPredictionRankings {
    // message fields
    predictions: ::protobuf::RepeatedField<CMsgPredictionRankings_Prediction>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgPredictionRankings {}

impl CMsgPredictionRankings {
    pub fn new() -> CMsgPredictionRankings {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgPredictionRankings {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPredictionRankings> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPredictionRankings,
        };
        unsafe {
            instance.get(CMsgPredictionRankings::new)
        }
    }

    // repeated .CMsgPredictionRankings.Prediction predictions = 1;

    pub fn clear_predictions(&mut self) {
        self.predictions.clear();
    }

    // Param is passed by value, moved
    pub fn set_predictions(&mut self, v: ::protobuf::RepeatedField<CMsgPredictionRankings_Prediction>) {
        self.predictions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_predictions(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPredictionRankings_Prediction> {
        &mut self.predictions
    }

    // Take field
    pub fn take_predictions(&mut self) -> ::protobuf::RepeatedField<CMsgPredictionRankings_Prediction> {
        ::std::mem::replace(&mut self.predictions, ::protobuf::RepeatedField::new())
    }

    pub fn get_predictions(&self) -> &[CMsgPredictionRankings_Prediction] {
        &self.predictions
    }

    fn get_predictions_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgPredictionRankings_Prediction> {
        &self.predictions
    }

    fn mut_predictions_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPredictionRankings_Prediction> {
        &mut self.predictions
    }
}

impl ::protobuf::Message for CMsgPredictionRankings {
    fn is_initialized(&self) -> bool {
        for v in &self.predictions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.predictions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.predictions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.predictions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgPredictionRankings {
    fn new() -> CMsgPredictionRankings {
        CMsgPredictionRankings::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgPredictionRankings>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPredictionRankings_Prediction>>(
                    "predictions",
                    CMsgPredictionRankings::get_predictions_for_reflect,
                    CMsgPredictionRankings::mut_predictions_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPredictionRankings>(
                    "CMsgPredictionRankings",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgPredictionRankings {
    fn clear(&mut self) {
        self.clear_predictions();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPredictionRankings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPredictionRankings {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPredictionRankings_PredictionLine {
    // message fields
    answer_id: ::std::option::Option<u32>,
    answer_name: ::protobuf::SingularField<::std::string::String>,
    answer_logo: ::std::option::Option<u64>,
    answer_value: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgPredictionRankings_PredictionLine {}

impl CMsgPredictionRankings_PredictionLine {
    pub fn new() -> CMsgPredictionRankings_PredictionLine {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgPredictionRankings_PredictionLine {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPredictionRankings_PredictionLine> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPredictionRankings_PredictionLine,
        };
        unsafe {
            instance.get(CMsgPredictionRankings_PredictionLine::new)
        }
    }

    // optional uint32 answer_id = 1;

    pub fn clear_answer_id(&mut self) {
        self.answer_id = ::std::option::Option::None;
    }

    pub fn has_answer_id(&self) -> bool {
        self.answer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_id(&mut self, v: u32) {
        self.answer_id = ::std::option::Option::Some(v);
    }

    pub fn get_answer_id(&self) -> u32 {
        self.answer_id.unwrap_or(0)
    }

    fn get_answer_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.answer_id
    }

    fn mut_answer_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.answer_id
    }

    // optional string answer_name = 2;

    pub fn clear_answer_name(&mut self) {
        self.answer_name.clear();
    }

    pub fn has_answer_name(&self) -> bool {
        self.answer_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_name(&mut self, v: ::std::string::String) {
        self.answer_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_answer_name(&mut self) -> &mut ::std::string::String {
        if self.answer_name.is_none() {
            self.answer_name.set_default();
        }
        self.answer_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_answer_name(&mut self) -> ::std::string::String {
        self.answer_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_answer_name(&self) -> &str {
        match self.answer_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_answer_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.answer_name
    }

    fn mut_answer_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.answer_name
    }

    // optional uint64 answer_logo = 3;

    pub fn clear_answer_logo(&mut self) {
        self.answer_logo = ::std::option::Option::None;
    }

    pub fn has_answer_logo(&self) -> bool {
        self.answer_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_logo(&mut self, v: u64) {
        self.answer_logo = ::std::option::Option::Some(v);
    }

    pub fn get_answer_logo(&self) -> u64 {
        self.answer_logo.unwrap_or(0)
    }

    fn get_answer_logo_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.answer_logo
    }

    fn mut_answer_logo_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.answer_logo
    }

    // optional float answer_value = 4;

    pub fn clear_answer_value(&mut self) {
        self.answer_value = ::std::option::Option::None;
    }

    pub fn has_answer_value(&self) -> bool {
        self.answer_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_value(&mut self, v: f32) {
        self.answer_value = ::std::option::Option::Some(v);
    }

    pub fn get_answer_value(&self) -> f32 {
        self.answer_value.unwrap_or(0.)
    }

    fn get_answer_value_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.answer_value
    }

    fn mut_answer_value_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.answer_value
    }
}

impl ::protobuf::Message for CMsgPredictionRankings_PredictionLine {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.answer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.answer_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.answer_logo = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.answer_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.answer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.answer_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.answer_logo {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.answer_value {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.answer_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.answer_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.answer_logo {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.answer_value {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgPredictionRankings_PredictionLine {
    fn new() -> CMsgPredictionRankings_PredictionLine {
        CMsgPredictionRankings_PredictionLine::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgPredictionRankings_PredictionLine>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "answer_id",
                    CMsgPredictionRankings_PredictionLine::get_answer_id_for_reflect,
                    CMsgPredictionRankings_PredictionLine::mut_answer_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "answer_name",
                    CMsgPredictionRankings_PredictionLine::get_answer_name_for_reflect,
                    CMsgPredictionRankings_PredictionLine::mut_answer_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "answer_logo",
                    CMsgPredictionRankings_PredictionLine::get_answer_logo_for_reflect,
                    CMsgPredictionRankings_PredictionLine::mut_answer_logo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "answer_value",
                    CMsgPredictionRankings_PredictionLine::get_answer_value_for_reflect,
                    CMsgPredictionRankings_PredictionLine::mut_answer_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPredictionRankings_PredictionLine>(
                    "CMsgPredictionRankings_PredictionLine",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgPredictionRankings_PredictionLine {
    fn clear(&mut self) {
        self.clear_answer_id();
        self.clear_answer_name();
        self.clear_answer_logo();
        self.clear_answer_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPredictionRankings_PredictionLine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPredictionRankings_PredictionLine {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPredictionRankings_Prediction {
    // message fields
    selection_id: ::std::option::Option<u32>,
    prediction_lines: ::protobuf::RepeatedField<CMsgPredictionRankings_PredictionLine>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgPredictionRankings_Prediction {}

impl CMsgPredictionRankings_Prediction {
    pub fn new() -> CMsgPredictionRankings_Prediction {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgPredictionRankings_Prediction {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPredictionRankings_Prediction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPredictionRankings_Prediction,
        };
        unsafe {
            instance.get(CMsgPredictionRankings_Prediction::new)
        }
    }

    // optional uint32 selection_id = 1;

    pub fn clear_selection_id(&mut self) {
        self.selection_id = ::std::option::Option::None;
    }

    pub fn has_selection_id(&self) -> bool {
        self.selection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_id(&mut self, v: u32) {
        self.selection_id = ::std::option::Option::Some(v);
    }

    pub fn get_selection_id(&self) -> u32 {
        self.selection_id.unwrap_or(0)
    }

    fn get_selection_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.selection_id
    }

    fn mut_selection_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.selection_id
    }

    // repeated .CMsgPredictionRankings.PredictionLine prediction_lines = 2;

    pub fn clear_prediction_lines(&mut self) {
        self.prediction_lines.clear();
    }

    // Param is passed by value, moved
    pub fn set_prediction_lines(&mut self, v: ::protobuf::RepeatedField<CMsgPredictionRankings_PredictionLine>) {
        self.prediction_lines = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prediction_lines(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPredictionRankings_PredictionLine> {
        &mut self.prediction_lines
    }

    // Take field
    pub fn take_prediction_lines(&mut self) -> ::protobuf::RepeatedField<CMsgPredictionRankings_PredictionLine> {
        ::std::mem::replace(&mut self.prediction_lines, ::protobuf::RepeatedField::new())
    }

    pub fn get_prediction_lines(&self) -> &[CMsgPredictionRankings_PredictionLine] {
        &self.prediction_lines
    }

    fn get_prediction_lines_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgPredictionRankings_PredictionLine> {
        &self.prediction_lines
    }

    fn mut_prediction_lines_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPredictionRankings_PredictionLine> {
        &mut self.prediction_lines
    }
}

impl ::protobuf::Message for CMsgPredictionRankings_Prediction {
    fn is_initialized(&self) -> bool {
        for v in &self.prediction_lines {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.selection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.prediction_lines)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.selection_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.prediction_lines {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.selection_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.prediction_lines {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgPredictionRankings_Prediction {
    fn new() -> CMsgPredictionRankings_Prediction {
        CMsgPredictionRankings_Prediction::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgPredictionRankings_Prediction>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "selection_id",
                    CMsgPredictionRankings_Prediction::get_selection_id_for_reflect,
                    CMsgPredictionRankings_Prediction::mut_selection_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPredictionRankings_PredictionLine>>(
                    "prediction_lines",
                    CMsgPredictionRankings_Prediction::get_prediction_lines_for_reflect,
                    CMsgPredictionRankings_Prediction::mut_prediction_lines_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPredictionRankings_Prediction>(
                    "CMsgPredictionRankings_Prediction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgPredictionRankings_Prediction {
    fn clear(&mut self) {
        self.clear_selection_id();
        self.clear_prediction_lines();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPredictionRankings_Prediction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPredictionRankings_Prediction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPredictionResults {
    // message fields
    results: ::protobuf::RepeatedField<CMsgPredictionResults_Result>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgPredictionResults {}

impl CMsgPredictionResults {
    pub fn new() -> CMsgPredictionResults {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgPredictionResults {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPredictionResults> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPredictionResults,
        };
        unsafe {
            instance.get(CMsgPredictionResults::new)
        }
    }

    // repeated .CMsgPredictionResults.Result results = 1;

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<CMsgPredictionResults_Result>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPredictionResults_Result> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<CMsgPredictionResults_Result> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }

    pub fn get_results(&self) -> &[CMsgPredictionResults_Result] {
        &self.results
    }

    fn get_results_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgPredictionResults_Result> {
        &self.results
    }

    fn mut_results_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPredictionResults_Result> {
        &mut self.results
    }
}

impl ::protobuf::Message for CMsgPredictionResults {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.results {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgPredictionResults {
    fn new() -> CMsgPredictionResults {
        CMsgPredictionResults::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgPredictionResults>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPredictionResults_Result>>(
                    "results",
                    CMsgPredictionResults::get_results_for_reflect,
                    CMsgPredictionResults::mut_results_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPredictionResults>(
                    "CMsgPredictionResults",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgPredictionResults {
    fn clear(&mut self) {
        self.clear_results();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPredictionResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPredictionResults {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPredictionResults_ResultBreakdown {
    // message fields
    answer_selection: ::std::option::Option<u32>,
    answer_value: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgPredictionResults_ResultBreakdown {}

impl CMsgPredictionResults_ResultBreakdown {
    pub fn new() -> CMsgPredictionResults_ResultBreakdown {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgPredictionResults_ResultBreakdown {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPredictionResults_ResultBreakdown> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPredictionResults_ResultBreakdown,
        };
        unsafe {
            instance.get(CMsgPredictionResults_ResultBreakdown::new)
        }
    }

    // optional uint32 answer_selection = 2;

    pub fn clear_answer_selection(&mut self) {
        self.answer_selection = ::std::option::Option::None;
    }

    pub fn has_answer_selection(&self) -> bool {
        self.answer_selection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_selection(&mut self, v: u32) {
        self.answer_selection = ::std::option::Option::Some(v);
    }

    pub fn get_answer_selection(&self) -> u32 {
        self.answer_selection.unwrap_or(0)
    }

    fn get_answer_selection_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.answer_selection
    }

    fn mut_answer_selection_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.answer_selection
    }

    // optional float answer_value = 3;

    pub fn clear_answer_value(&mut self) {
        self.answer_value = ::std::option::Option::None;
    }

    pub fn has_answer_value(&self) -> bool {
        self.answer_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_value(&mut self, v: f32) {
        self.answer_value = ::std::option::Option::Some(v);
    }

    pub fn get_answer_value(&self) -> f32 {
        self.answer_value.unwrap_or(0.)
    }

    fn get_answer_value_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.answer_value
    }

    fn mut_answer_value_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.answer_value
    }
}

impl ::protobuf::Message for CMsgPredictionResults_ResultBreakdown {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.answer_selection = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.answer_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.answer_selection {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.answer_value {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.answer_selection {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.answer_value {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgPredictionResults_ResultBreakdown {
    fn new() -> CMsgPredictionResults_ResultBreakdown {
        CMsgPredictionResults_ResultBreakdown::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgPredictionResults_ResultBreakdown>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "answer_selection",
                    CMsgPredictionResults_ResultBreakdown::get_answer_selection_for_reflect,
                    CMsgPredictionResults_ResultBreakdown::mut_answer_selection_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "answer_value",
                    CMsgPredictionResults_ResultBreakdown::get_answer_value_for_reflect,
                    CMsgPredictionResults_ResultBreakdown::mut_answer_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPredictionResults_ResultBreakdown>(
                    "CMsgPredictionResults_ResultBreakdown",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgPredictionResults_ResultBreakdown {
    fn clear(&mut self) {
        self.clear_answer_selection();
        self.clear_answer_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPredictionResults_ResultBreakdown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPredictionResults_ResultBreakdown {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPredictionResults_Result {
    // message fields
    selection_id: ::std::option::Option<u32>,
    result_breakdown: ::protobuf::RepeatedField<CMsgPredictionResults_ResultBreakdown>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgPredictionResults_Result {}

impl CMsgPredictionResults_Result {
    pub fn new() -> CMsgPredictionResults_Result {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgPredictionResults_Result {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPredictionResults_Result> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPredictionResults_Result,
        };
        unsafe {
            instance.get(CMsgPredictionResults_Result::new)
        }
    }

    // optional uint32 selection_id = 1;

    pub fn clear_selection_id(&mut self) {
        self.selection_id = ::std::option::Option::None;
    }

    pub fn has_selection_id(&self) -> bool {
        self.selection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_id(&mut self, v: u32) {
        self.selection_id = ::std::option::Option::Some(v);
    }

    pub fn get_selection_id(&self) -> u32 {
        self.selection_id.unwrap_or(0)
    }

    fn get_selection_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.selection_id
    }

    fn mut_selection_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.selection_id
    }

    // repeated .CMsgPredictionResults.ResultBreakdown result_breakdown = 2;

    pub fn clear_result_breakdown(&mut self) {
        self.result_breakdown.clear();
    }

    // Param is passed by value, moved
    pub fn set_result_breakdown(&mut self, v: ::protobuf::RepeatedField<CMsgPredictionResults_ResultBreakdown>) {
        self.result_breakdown = v;
    }

    // Mutable pointer to the field.
    pub fn mut_result_breakdown(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPredictionResults_ResultBreakdown> {
        &mut self.result_breakdown
    }

    // Take field
    pub fn take_result_breakdown(&mut self) -> ::protobuf::RepeatedField<CMsgPredictionResults_ResultBreakdown> {
        ::std::mem::replace(&mut self.result_breakdown, ::protobuf::RepeatedField::new())
    }

    pub fn get_result_breakdown(&self) -> &[CMsgPredictionResults_ResultBreakdown] {
        &self.result_breakdown
    }

    fn get_result_breakdown_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgPredictionResults_ResultBreakdown> {
        &self.result_breakdown
    }

    fn mut_result_breakdown_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPredictionResults_ResultBreakdown> {
        &mut self.result_breakdown
    }
}

impl ::protobuf::Message for CMsgPredictionResults_Result {
    fn is_initialized(&self) -> bool {
        for v in &self.result_breakdown {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.selection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.result_breakdown)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.selection_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.result_breakdown {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.selection_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.result_breakdown {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgPredictionResults_Result {
    fn new() -> CMsgPredictionResults_Result {
        CMsgPredictionResults_Result::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgPredictionResults_Result>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "selection_id",
                    CMsgPredictionResults_Result::get_selection_id_for_reflect,
                    CMsgPredictionResults_Result::mut_selection_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPredictionResults_ResultBreakdown>>(
                    "result_breakdown",
                    CMsgPredictionResults_Result::get_result_breakdown_for_reflect,
                    CMsgPredictionResults_Result::mut_result_breakdown_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPredictionResults_Result>(
                    "CMsgPredictionResults_Result",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgPredictionResults_Result {
    fn clear(&mut self) {
        self.clear_selection_id();
        self.clear_result_breakdown();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPredictionResults_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPredictionResults_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCSuspiciousActivity {
    // message fields
    app_data: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCSuspiciousActivity {}

impl CMsgClientToGCSuspiciousActivity {
    pub fn new() -> CMsgClientToGCSuspiciousActivity {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCSuspiciousActivity {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCSuspiciousActivity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCSuspiciousActivity,
        };
        unsafe {
            instance.get(CMsgClientToGCSuspiciousActivity::new)
        }
    }

    // optional uint64 app_data = 1;

    pub fn clear_app_data(&mut self) {
        self.app_data = ::std::option::Option::None;
    }

    pub fn has_app_data(&self) -> bool {
        self.app_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_data(&mut self, v: u64) {
        self.app_data = ::std::option::Option::Some(v);
    }

    pub fn get_app_data(&self) -> u64 {
        self.app_data.unwrap_or(0)
    }

    fn get_app_data_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.app_data
    }

    fn mut_app_data_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.app_data
    }
}

impl ::protobuf::Message for CMsgClientToGCSuspiciousActivity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.app_data = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_data {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_data {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCSuspiciousActivity {
    fn new() -> CMsgClientToGCSuspiciousActivity {
        CMsgClientToGCSuspiciousActivity::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCSuspiciousActivity>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "app_data",
                    CMsgClientToGCSuspiciousActivity::get_app_data_for_reflect,
                    CMsgClientToGCSuspiciousActivity::mut_app_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCSuspiciousActivity>(
                    "CMsgClientToGCSuspiciousActivity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCSuspiciousActivity {
    fn clear(&mut self) {
        self.clear_app_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCSuspiciousActivity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSuspiciousActivity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCHasPlayerVotedForMVP {
    // message fields
    match_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCHasPlayerVotedForMVP {}

impl CMsgClientToGCHasPlayerVotedForMVP {
    pub fn new() -> CMsgClientToGCHasPlayerVotedForMVP {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCHasPlayerVotedForMVP {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCHasPlayerVotedForMVP> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCHasPlayerVotedForMVP,
        };
        unsafe {
            instance.get(CMsgClientToGCHasPlayerVotedForMVP::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }
}

impl ::protobuf::Message for CMsgClientToGCHasPlayerVotedForMVP {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCHasPlayerVotedForMVP {
    fn new() -> CMsgClientToGCHasPlayerVotedForMVP {
        CMsgClientToGCHasPlayerVotedForMVP::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCHasPlayerVotedForMVP>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgClientToGCHasPlayerVotedForMVP::get_match_id_for_reflect,
                    CMsgClientToGCHasPlayerVotedForMVP::mut_match_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCHasPlayerVotedForMVP>(
                    "CMsgClientToGCHasPlayerVotedForMVP",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCHasPlayerVotedForMVP {
    fn clear(&mut self) {
        self.clear_match_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCHasPlayerVotedForMVP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCHasPlayerVotedForMVP {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCHasPlayerVotedForMVPResponse {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCHasPlayerVotedForMVPResponse {}

impl CMsgClientToGCHasPlayerVotedForMVPResponse {
    pub fn new() -> CMsgClientToGCHasPlayerVotedForMVPResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCHasPlayerVotedForMVPResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCHasPlayerVotedForMVPResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCHasPlayerVotedForMVPResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCHasPlayerVotedForMVPResponse::new)
        }
    }

    // optional bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgClientToGCHasPlayerVotedForMVPResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCHasPlayerVotedForMVPResponse {
    fn new() -> CMsgClientToGCHasPlayerVotedForMVPResponse {
        CMsgClientToGCHasPlayerVotedForMVPResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCHasPlayerVotedForMVPResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    CMsgClientToGCHasPlayerVotedForMVPResponse::get_result_for_reflect,
                    CMsgClientToGCHasPlayerVotedForMVPResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCHasPlayerVotedForMVPResponse>(
                    "CMsgClientToGCHasPlayerVotedForMVPResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCHasPlayerVotedForMVPResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCHasPlayerVotedForMVPResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCHasPlayerVotedForMVPResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCVoteForMVP {
    // message fields
    match_id: ::std::option::Option<u64>,
    account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCVoteForMVP {}

impl CMsgClientToGCVoteForMVP {
    pub fn new() -> CMsgClientToGCVoteForMVP {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCVoteForMVP {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCVoteForMVP> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCVoteForMVP,
        };
        unsafe {
            instance.get(CMsgClientToGCVoteForMVP::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 account_id = 3;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgClientToGCVoteForMVP {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCVoteForMVP {
    fn new() -> CMsgClientToGCVoteForMVP {
        CMsgClientToGCVoteForMVP::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCVoteForMVP>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgClientToGCVoteForMVP::get_match_id_for_reflect,
                    CMsgClientToGCVoteForMVP::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgClientToGCVoteForMVP::get_account_id_for_reflect,
                    CMsgClientToGCVoteForMVP::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCVoteForMVP>(
                    "CMsgClientToGCVoteForMVP",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCVoteForMVP {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCVoteForMVP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCVoteForMVP {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCVoteForMVPResponse {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCVoteForMVPResponse {}

impl CMsgClientToGCVoteForMVPResponse {
    pub fn new() -> CMsgClientToGCVoteForMVPResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCVoteForMVPResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCVoteForMVPResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCVoteForMVPResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCVoteForMVPResponse::new)
        }
    }

    // optional bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgClientToGCVoteForMVPResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCVoteForMVPResponse {
    fn new() -> CMsgClientToGCVoteForMVPResponse {
        CMsgClientToGCVoteForMVPResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCVoteForMVPResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    CMsgClientToGCVoteForMVPResponse::get_result_for_reflect,
                    CMsgClientToGCVoteForMVPResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCVoteForMVPResponse>(
                    "CMsgClientToGCVoteForMVPResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCVoteForMVPResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCVoteForMVPResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCVoteForMVPResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgMVPVotesForMatch {
    // message fields
    players: ::protobuf::RepeatedField<CMsgMVPVotesForMatch_Player>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgMVPVotesForMatch {}

impl CMsgMVPVotesForMatch {
    pub fn new() -> CMsgMVPVotesForMatch {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgMVPVotesForMatch {
        static mut instance: ::protobuf::lazy::Lazy<CMsgMVPVotesForMatch> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgMVPVotesForMatch,
        };
        unsafe {
            instance.get(CMsgMVPVotesForMatch::new)
        }
    }

    // repeated .CMsgMVPVotesForMatch.Player players = 1;

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgMVPVotesForMatch_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgMVPVotesForMatch_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgMVPVotesForMatch_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    pub fn get_players(&self) -> &[CMsgMVPVotesForMatch_Player] {
        &self.players
    }

    fn get_players_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgMVPVotesForMatch_Player> {
        &self.players
    }

    fn mut_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgMVPVotesForMatch_Player> {
        &mut self.players
    }
}

impl ::protobuf::Message for CMsgMVPVotesForMatch {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.players {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgMVPVotesForMatch {
    fn new() -> CMsgMVPVotesForMatch {
        CMsgMVPVotesForMatch::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgMVPVotesForMatch>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgMVPVotesForMatch_Player>>(
                    "players",
                    CMsgMVPVotesForMatch::get_players_for_reflect,
                    CMsgMVPVotesForMatch::mut_players_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgMVPVotesForMatch>(
                    "CMsgMVPVotesForMatch",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgMVPVotesForMatch {
    fn clear(&mut self) {
        self.clear_players();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMVPVotesForMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMVPVotesForMatch {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgMVPVotesForMatch_Player {
    // message fields
    account_id: ::std::option::Option<u32>,
    vote_count: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgMVPVotesForMatch_Player {}

impl CMsgMVPVotesForMatch_Player {
    pub fn new() -> CMsgMVPVotesForMatch_Player {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgMVPVotesForMatch_Player {
        static mut instance: ::protobuf::lazy::Lazy<CMsgMVPVotesForMatch_Player> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgMVPVotesForMatch_Player,
        };
        unsafe {
            instance.get(CMsgMVPVotesForMatch_Player::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 vote_count = 2;

    pub fn clear_vote_count(&mut self) {
        self.vote_count = ::std::option::Option::None;
    }

    pub fn has_vote_count(&self) -> bool {
        self.vote_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_count(&mut self, v: u32) {
        self.vote_count = ::std::option::Option::Some(v);
    }

    pub fn get_vote_count(&self) -> u32 {
        self.vote_count.unwrap_or(0)
    }

    fn get_vote_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.vote_count
    }

    fn mut_vote_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.vote_count
    }
}

impl ::protobuf::Message for CMsgMVPVotesForMatch_Player {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.vote_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vote_count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.vote_count {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgMVPVotesForMatch_Player {
    fn new() -> CMsgMVPVotesForMatch_Player {
        CMsgMVPVotesForMatch_Player::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgMVPVotesForMatch_Player>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgMVPVotesForMatch_Player::get_account_id_for_reflect,
                    CMsgMVPVotesForMatch_Player::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "vote_count",
                    CMsgMVPVotesForMatch_Player::get_vote_count_for_reflect,
                    CMsgMVPVotesForMatch_Player::mut_vote_count_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgMVPVotesForMatch_Player>(
                    "CMsgMVPVotesForMatch_Player",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgMVPVotesForMatch_Player {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_vote_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMVPVotesForMatch_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMVPVotesForMatch_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLeaguePrizePool {
    // message fields
    prize_pool: ::std::option::Option<u32>,
    increment_per_second: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgLeaguePrizePool {}

impl CMsgLeaguePrizePool {
    pub fn new() -> CMsgLeaguePrizePool {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgLeaguePrizePool {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLeaguePrizePool> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLeaguePrizePool,
        };
        unsafe {
            instance.get(CMsgLeaguePrizePool::new)
        }
    }

    // optional uint32 prize_pool = 1;

    pub fn clear_prize_pool(&mut self) {
        self.prize_pool = ::std::option::Option::None;
    }

    pub fn has_prize_pool(&self) -> bool {
        self.prize_pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prize_pool(&mut self, v: u32) {
        self.prize_pool = ::std::option::Option::Some(v);
    }

    pub fn get_prize_pool(&self) -> u32 {
        self.prize_pool.unwrap_or(0)
    }

    fn get_prize_pool_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prize_pool
    }

    fn mut_prize_pool_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prize_pool
    }

    // optional float increment_per_second = 2;

    pub fn clear_increment_per_second(&mut self) {
        self.increment_per_second = ::std::option::Option::None;
    }

    pub fn has_increment_per_second(&self) -> bool {
        self.increment_per_second.is_some()
    }

    // Param is passed by value, moved
    pub fn set_increment_per_second(&mut self, v: f32) {
        self.increment_per_second = ::std::option::Option::Some(v);
    }

    pub fn get_increment_per_second(&self) -> f32 {
        self.increment_per_second.unwrap_or(0.)
    }

    fn get_increment_per_second_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.increment_per_second
    }

    fn mut_increment_per_second_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.increment_per_second
    }
}

impl ::protobuf::Message for CMsgLeaguePrizePool {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prize_pool = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.increment_per_second = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.prize_pool {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.increment_per_second {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prize_pool {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.increment_per_second {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgLeaguePrizePool {
    fn new() -> CMsgLeaguePrizePool {
        CMsgLeaguePrizePool::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgLeaguePrizePool>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prize_pool",
                    CMsgLeaguePrizePool::get_prize_pool_for_reflect,
                    CMsgLeaguePrizePool::mut_prize_pool_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "increment_per_second",
                    CMsgLeaguePrizePool::get_increment_per_second_for_reflect,
                    CMsgLeaguePrizePool::mut_increment_per_second_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLeaguePrizePool>(
                    "CMsgLeaguePrizePool",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgLeaguePrizePool {
    fn clear(&mut self) {
        self.clear_prize_pool();
        self.clear_increment_per_second();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLeaguePrizePool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLeaguePrizePool {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCTeammateStatsRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCTeammateStatsRequest {}

impl CMsgClientToGCTeammateStatsRequest {
    pub fn new() -> CMsgClientToGCTeammateStatsRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCTeammateStatsRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCTeammateStatsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCTeammateStatsRequest,
        };
        unsafe {
            instance.get(CMsgClientToGCTeammateStatsRequest::new)
        }
    }
}

impl ::protobuf::Message for CMsgClientToGCTeammateStatsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCTeammateStatsRequest {
    fn new() -> CMsgClientToGCTeammateStatsRequest {
        CMsgClientToGCTeammateStatsRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCTeammateStatsRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCTeammateStatsRequest>(
                    "CMsgClientToGCTeammateStatsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCTeammateStatsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCTeammateStatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCTeammateStatsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCTeammateStatsResponse {
    // message fields
    success: ::std::option::Option<bool>,
    teammate_stats: ::protobuf::RepeatedField<CMsgClientToGCTeammateStatsResponse_TeammateStat>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCTeammateStatsResponse {}

impl CMsgClientToGCTeammateStatsResponse {
    pub fn new() -> CMsgClientToGCTeammateStatsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCTeammateStatsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCTeammateStatsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCTeammateStatsResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCTeammateStatsResponse::new)
        }
    }

    // optional bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    fn get_success_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.success
    }

    fn mut_success_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.success
    }

    // repeated .CMsgClientToGCTeammateStatsResponse.TeammateStat teammate_stats = 2;

    pub fn clear_teammate_stats(&mut self) {
        self.teammate_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_teammate_stats(&mut self, v: ::protobuf::RepeatedField<CMsgClientToGCTeammateStatsResponse_TeammateStat>) {
        self.teammate_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_teammate_stats(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCTeammateStatsResponse_TeammateStat> {
        &mut self.teammate_stats
    }

    // Take field
    pub fn take_teammate_stats(&mut self) -> ::protobuf::RepeatedField<CMsgClientToGCTeammateStatsResponse_TeammateStat> {
        ::std::mem::replace(&mut self.teammate_stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_teammate_stats(&self) -> &[CMsgClientToGCTeammateStatsResponse_TeammateStat] {
        &self.teammate_stats
    }

    fn get_teammate_stats_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientToGCTeammateStatsResponse_TeammateStat> {
        &self.teammate_stats
    }

    fn mut_teammate_stats_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCTeammateStatsResponse_TeammateStat> {
        &mut self.teammate_stats
    }
}

impl ::protobuf::Message for CMsgClientToGCTeammateStatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.teammate_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.teammate_stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        for value in &self.teammate_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        for v in &self.teammate_stats {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCTeammateStatsResponse {
    fn new() -> CMsgClientToGCTeammateStatsResponse {
        CMsgClientToGCTeammateStatsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCTeammateStatsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    CMsgClientToGCTeammateStatsResponse::get_success_for_reflect,
                    CMsgClientToGCTeammateStatsResponse::mut_success_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCTeammateStatsResponse_TeammateStat>>(
                    "teammate_stats",
                    CMsgClientToGCTeammateStatsResponse::get_teammate_stats_for_reflect,
                    CMsgClientToGCTeammateStatsResponse::mut_teammate_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCTeammateStatsResponse>(
                    "CMsgClientToGCTeammateStatsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCTeammateStatsResponse {
    fn clear(&mut self) {
        self.clear_success();
        self.clear_teammate_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCTeammateStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCTeammateStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCTeammateStatsResponse_TeammateStat {
    // message fields
    account_id: ::std::option::Option<u32>,
    games: ::std::option::Option<u32>,
    wins: ::std::option::Option<u32>,
    most_recent_game_timestamp: ::std::option::Option<u32>,
    most_recent_game_match_id: ::std::option::Option<u64>,
    performance: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCTeammateStatsResponse_TeammateStat {}

impl CMsgClientToGCTeammateStatsResponse_TeammateStat {
    pub fn new() -> CMsgClientToGCTeammateStatsResponse_TeammateStat {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCTeammateStatsResponse_TeammateStat {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCTeammateStatsResponse_TeammateStat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCTeammateStatsResponse_TeammateStat,
        };
        unsafe {
            instance.get(CMsgClientToGCTeammateStatsResponse_TeammateStat::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 games = 2;

    pub fn clear_games(&mut self) {
        self.games = ::std::option::Option::None;
    }

    pub fn has_games(&self) -> bool {
        self.games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: u32) {
        self.games = ::std::option::Option::Some(v);
    }

    pub fn get_games(&self) -> u32 {
        self.games.unwrap_or(0)
    }

    fn get_games_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.games
    }

    fn mut_games_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.games
    }

    // optional uint32 wins = 3;

    pub fn clear_wins(&mut self) {
        self.wins = ::std::option::Option::None;
    }

    pub fn has_wins(&self) -> bool {
        self.wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: u32) {
        self.wins = ::std::option::Option::Some(v);
    }

    pub fn get_wins(&self) -> u32 {
        self.wins.unwrap_or(0)
    }

    fn get_wins_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.wins
    }

    fn mut_wins_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.wins
    }

    // optional uint32 most_recent_game_timestamp = 4;

    pub fn clear_most_recent_game_timestamp(&mut self) {
        self.most_recent_game_timestamp = ::std::option::Option::None;
    }

    pub fn has_most_recent_game_timestamp(&self) -> bool {
        self.most_recent_game_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_most_recent_game_timestamp(&mut self, v: u32) {
        self.most_recent_game_timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_most_recent_game_timestamp(&self) -> u32 {
        self.most_recent_game_timestamp.unwrap_or(0)
    }

    fn get_most_recent_game_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.most_recent_game_timestamp
    }

    fn mut_most_recent_game_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.most_recent_game_timestamp
    }

    // optional uint64 most_recent_game_match_id = 5;

    pub fn clear_most_recent_game_match_id(&mut self) {
        self.most_recent_game_match_id = ::std::option::Option::None;
    }

    pub fn has_most_recent_game_match_id(&self) -> bool {
        self.most_recent_game_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_most_recent_game_match_id(&mut self, v: u64) {
        self.most_recent_game_match_id = ::std::option::Option::Some(v);
    }

    pub fn get_most_recent_game_match_id(&self) -> u64 {
        self.most_recent_game_match_id.unwrap_or(0)
    }

    fn get_most_recent_game_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.most_recent_game_match_id
    }

    fn mut_most_recent_game_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.most_recent_game_match_id
    }

    // optional float performance = 100;

    pub fn clear_performance(&mut self) {
        self.performance = ::std::option::Option::None;
    }

    pub fn has_performance(&self) -> bool {
        self.performance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_performance(&mut self, v: f32) {
        self.performance = ::std::option::Option::Some(v);
    }

    pub fn get_performance(&self) -> f32 {
        self.performance.unwrap_or(0.)
    }

    fn get_performance_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.performance
    }

    fn mut_performance_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.performance
    }
}

impl ::protobuf::Message for CMsgClientToGCTeammateStatsResponse_TeammateStat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.games = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wins = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.most_recent_game_timestamp = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.most_recent_game_match_id = ::std::option::Option::Some(tmp);
                },
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.performance = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.games {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wins {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.most_recent_game_timestamp {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.most_recent_game_match_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.performance {
            my_size += 6;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.games {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.wins {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.most_recent_game_timestamp {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.most_recent_game_match_id {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.performance {
            os.write_float(100, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCTeammateStatsResponse_TeammateStat {
    fn new() -> CMsgClientToGCTeammateStatsResponse_TeammateStat {
        CMsgClientToGCTeammateStatsResponse_TeammateStat::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCTeammateStatsResponse_TeammateStat>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgClientToGCTeammateStatsResponse_TeammateStat::get_account_id_for_reflect,
                    CMsgClientToGCTeammateStatsResponse_TeammateStat::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "games",
                    CMsgClientToGCTeammateStatsResponse_TeammateStat::get_games_for_reflect,
                    CMsgClientToGCTeammateStatsResponse_TeammateStat::mut_games_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wins",
                    CMsgClientToGCTeammateStatsResponse_TeammateStat::get_wins_for_reflect,
                    CMsgClientToGCTeammateStatsResponse_TeammateStat::mut_wins_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "most_recent_game_timestamp",
                    CMsgClientToGCTeammateStatsResponse_TeammateStat::get_most_recent_game_timestamp_for_reflect,
                    CMsgClientToGCTeammateStatsResponse_TeammateStat::mut_most_recent_game_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "most_recent_game_match_id",
                    CMsgClientToGCTeammateStatsResponse_TeammateStat::get_most_recent_game_match_id_for_reflect,
                    CMsgClientToGCTeammateStatsResponse_TeammateStat::mut_most_recent_game_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "performance",
                    CMsgClientToGCTeammateStatsResponse_TeammateStat::get_performance_for_reflect,
                    CMsgClientToGCTeammateStatsResponse_TeammateStat::mut_performance_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCTeammateStatsResponse_TeammateStat>(
                    "CMsgClientToGCTeammateStatsResponse_TeammateStat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCTeammateStatsResponse_TeammateStat {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_games();
        self.clear_wins();
        self.clear_most_recent_game_timestamp();
        self.clear_most_recent_game_match_id();
        self.clear_performance();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCTeammateStatsResponse_TeammateStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCTeammateStatsResponse_TeammateStat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCVoteForArcana {
    // message fields
    matches: ::protobuf::RepeatedField<CMsgClientToGCVoteForArcana_MatchVote>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCVoteForArcana {}

impl CMsgClientToGCVoteForArcana {
    pub fn new() -> CMsgClientToGCVoteForArcana {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCVoteForArcana {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCVoteForArcana> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCVoteForArcana,
        };
        unsafe {
            instance.get(CMsgClientToGCVoteForArcana::new)
        }
    }

    // repeated .CMsgClientToGCVoteForArcana.MatchVote matches = 1;

    pub fn clear_matches(&mut self) {
        self.matches.clear();
    }

    // Param is passed by value, moved
    pub fn set_matches(&mut self, v: ::protobuf::RepeatedField<CMsgClientToGCVoteForArcana_MatchVote>) {
        self.matches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matches(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCVoteForArcana_MatchVote> {
        &mut self.matches
    }

    // Take field
    pub fn take_matches(&mut self) -> ::protobuf::RepeatedField<CMsgClientToGCVoteForArcana_MatchVote> {
        ::std::mem::replace(&mut self.matches, ::protobuf::RepeatedField::new())
    }

    pub fn get_matches(&self) -> &[CMsgClientToGCVoteForArcana_MatchVote] {
        &self.matches
    }

    fn get_matches_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientToGCVoteForArcana_MatchVote> {
        &self.matches
    }

    fn mut_matches_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCVoteForArcana_MatchVote> {
        &mut self.matches
    }
}

impl ::protobuf::Message for CMsgClientToGCVoteForArcana {
    fn is_initialized(&self) -> bool {
        for v in &self.matches {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matches)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.matches {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCVoteForArcana {
    fn new() -> CMsgClientToGCVoteForArcana {
        CMsgClientToGCVoteForArcana::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCVoteForArcana>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCVoteForArcana_MatchVote>>(
                    "matches",
                    CMsgClientToGCVoteForArcana::get_matches_for_reflect,
                    CMsgClientToGCVoteForArcana::mut_matches_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCVoteForArcana>(
                    "CMsgClientToGCVoteForArcana",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCVoteForArcana {
    fn clear(&mut self) {
        self.clear_matches();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCVoteForArcana {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCVoteForArcana {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCVoteForArcana_MatchVote {
    // message fields
    match_id: ::std::option::Option<u64>,
    hero_id: ::std::option::Option<u32>,
    vote_count: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCVoteForArcana_MatchVote {}

impl CMsgClientToGCVoteForArcana_MatchVote {
    pub fn new() -> CMsgClientToGCVoteForArcana_MatchVote {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCVoteForArcana_MatchVote {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCVoteForArcana_MatchVote> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCVoteForArcana_MatchVote,
        };
        unsafe {
            instance.get(CMsgClientToGCVoteForArcana_MatchVote::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 hero_id = 2;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 vote_count = 3;

    pub fn clear_vote_count(&mut self) {
        self.vote_count = ::std::option::Option::None;
    }

    pub fn has_vote_count(&self) -> bool {
        self.vote_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_count(&mut self, v: u32) {
        self.vote_count = ::std::option::Option::Some(v);
    }

    pub fn get_vote_count(&self) -> u32 {
        self.vote_count.unwrap_or(0)
    }

    fn get_vote_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.vote_count
    }

    fn mut_vote_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.vote_count
    }
}

impl ::protobuf::Message for CMsgClientToGCVoteForArcana_MatchVote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.vote_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vote_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.vote_count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCVoteForArcana_MatchVote {
    fn new() -> CMsgClientToGCVoteForArcana_MatchVote {
        CMsgClientToGCVoteForArcana_MatchVote::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCVoteForArcana_MatchVote>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgClientToGCVoteForArcana_MatchVote::get_match_id_for_reflect,
                    CMsgClientToGCVoteForArcana_MatchVote::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgClientToGCVoteForArcana_MatchVote::get_hero_id_for_reflect,
                    CMsgClientToGCVoteForArcana_MatchVote::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "vote_count",
                    CMsgClientToGCVoteForArcana_MatchVote::get_vote_count_for_reflect,
                    CMsgClientToGCVoteForArcana_MatchVote::mut_vote_count_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCVoteForArcana_MatchVote>(
                    "CMsgClientToGCVoteForArcana_MatchVote",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCVoteForArcana_MatchVote {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_hero_id();
        self.clear_vote_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCVoteForArcana_MatchVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCVoteForArcana_MatchVote {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCVoteForArcanaResponse {
    // message fields
    result: ::std::option::Option<CMsgClientToGCVoteForArcanaResponse_Result>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCVoteForArcanaResponse {}

impl CMsgClientToGCVoteForArcanaResponse {
    pub fn new() -> CMsgClientToGCVoteForArcanaResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCVoteForArcanaResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCVoteForArcanaResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCVoteForArcanaResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCVoteForArcanaResponse::new)
        }
    }

    // optional .CMsgClientToGCVoteForArcanaResponse.Result result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgClientToGCVoteForArcanaResponse_Result) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgClientToGCVoteForArcanaResponse_Result {
        self.result.unwrap_or(CMsgClientToGCVoteForArcanaResponse_Result::SUCCEEDED)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgClientToGCVoteForArcanaResponse_Result> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgClientToGCVoteForArcanaResponse_Result> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgClientToGCVoteForArcanaResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCVoteForArcanaResponse {
    fn new() -> CMsgClientToGCVoteForArcanaResponse {
        CMsgClientToGCVoteForArcanaResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCVoteForArcanaResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgClientToGCVoteForArcanaResponse_Result>>(
                    "result",
                    CMsgClientToGCVoteForArcanaResponse::get_result_for_reflect,
                    CMsgClientToGCVoteForArcanaResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCVoteForArcanaResponse>(
                    "CMsgClientToGCVoteForArcanaResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCVoteForArcanaResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCVoteForArcanaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCVoteForArcanaResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgClientToGCVoteForArcanaResponse_Result {
    SUCCEEDED = 0,
    VOTING_NOT_ENABLED_FOR_ROUND = 1,
    UNKNOWN_FAILURE = 2,
}

impl ::protobuf::ProtobufEnum for CMsgClientToGCVoteForArcanaResponse_Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgClientToGCVoteForArcanaResponse_Result> {
        match value {
            0 => ::std::option::Option::Some(CMsgClientToGCVoteForArcanaResponse_Result::SUCCEEDED),
            1 => ::std::option::Option::Some(CMsgClientToGCVoteForArcanaResponse_Result::VOTING_NOT_ENABLED_FOR_ROUND),
            2 => ::std::option::Option::Some(CMsgClientToGCVoteForArcanaResponse_Result::UNKNOWN_FAILURE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgClientToGCVoteForArcanaResponse_Result] = &[
            CMsgClientToGCVoteForArcanaResponse_Result::SUCCEEDED,
            CMsgClientToGCVoteForArcanaResponse_Result::VOTING_NOT_ENABLED_FOR_ROUND,
            CMsgClientToGCVoteForArcanaResponse_Result::UNKNOWN_FAILURE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgClientToGCVoteForArcanaResponse_Result>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgClientToGCVoteForArcanaResponse_Result", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgClientToGCVoteForArcanaResponse_Result {
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCVoteForArcanaResponse_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgArcanaVotes {
    // message fields
    matches: ::protobuf::RepeatedField<CMsgArcanaVotes_Match>,
    round_time_remaining: ::std::option::Option<u32>,
    round_number: ::std::option::Option<u32>,
    voting_state: ::std::option::Option<u32>,
    is_current_round_calibrating: ::std::option::Option<bool>,
    closest_active_match_id: ::std::option::Option<u32>,
    event_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgArcanaVotes {}

impl CMsgArcanaVotes {
    pub fn new() -> CMsgArcanaVotes {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgArcanaVotes {
        static mut instance: ::protobuf::lazy::Lazy<CMsgArcanaVotes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgArcanaVotes,
        };
        unsafe {
            instance.get(CMsgArcanaVotes::new)
        }
    }

    // repeated .CMsgArcanaVotes.Match matches = 1;

    pub fn clear_matches(&mut self) {
        self.matches.clear();
    }

    // Param is passed by value, moved
    pub fn set_matches(&mut self, v: ::protobuf::RepeatedField<CMsgArcanaVotes_Match>) {
        self.matches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matches(&mut self) -> &mut ::protobuf::RepeatedField<CMsgArcanaVotes_Match> {
        &mut self.matches
    }

    // Take field
    pub fn take_matches(&mut self) -> ::protobuf::RepeatedField<CMsgArcanaVotes_Match> {
        ::std::mem::replace(&mut self.matches, ::protobuf::RepeatedField::new())
    }

    pub fn get_matches(&self) -> &[CMsgArcanaVotes_Match] {
        &self.matches
    }

    fn get_matches_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgArcanaVotes_Match> {
        &self.matches
    }

    fn mut_matches_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgArcanaVotes_Match> {
        &mut self.matches
    }

    // optional uint32 round_time_remaining = 2;

    pub fn clear_round_time_remaining(&mut self) {
        self.round_time_remaining = ::std::option::Option::None;
    }

    pub fn has_round_time_remaining(&self) -> bool {
        self.round_time_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round_time_remaining(&mut self, v: u32) {
        self.round_time_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_round_time_remaining(&self) -> u32 {
        self.round_time_remaining.unwrap_or(0)
    }

    fn get_round_time_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.round_time_remaining
    }

    fn mut_round_time_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.round_time_remaining
    }

    // optional uint32 round_number = 3;

    pub fn clear_round_number(&mut self) {
        self.round_number = ::std::option::Option::None;
    }

    pub fn has_round_number(&self) -> bool {
        self.round_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round_number(&mut self, v: u32) {
        self.round_number = ::std::option::Option::Some(v);
    }

    pub fn get_round_number(&self) -> u32 {
        self.round_number.unwrap_or(0)
    }

    fn get_round_number_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.round_number
    }

    fn mut_round_number_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.round_number
    }

    // optional uint32 voting_state = 4;

    pub fn clear_voting_state(&mut self) {
        self.voting_state = ::std::option::Option::None;
    }

    pub fn has_voting_state(&self) -> bool {
        self.voting_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voting_state(&mut self, v: u32) {
        self.voting_state = ::std::option::Option::Some(v);
    }

    pub fn get_voting_state(&self) -> u32 {
        self.voting_state.unwrap_or(0)
    }

    fn get_voting_state_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.voting_state
    }

    fn mut_voting_state_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.voting_state
    }

    // optional bool is_current_round_calibrating = 5;

    pub fn clear_is_current_round_calibrating(&mut self) {
        self.is_current_round_calibrating = ::std::option::Option::None;
    }

    pub fn has_is_current_round_calibrating(&self) -> bool {
        self.is_current_round_calibrating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_current_round_calibrating(&mut self, v: bool) {
        self.is_current_round_calibrating = ::std::option::Option::Some(v);
    }

    pub fn get_is_current_round_calibrating(&self) -> bool {
        self.is_current_round_calibrating.unwrap_or(false)
    }

    fn get_is_current_round_calibrating_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_current_round_calibrating
    }

    fn mut_is_current_round_calibrating_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_current_round_calibrating
    }

    // optional uint32 closest_active_match_id = 6;

    pub fn clear_closest_active_match_id(&mut self) {
        self.closest_active_match_id = ::std::option::Option::None;
    }

    pub fn has_closest_active_match_id(&self) -> bool {
        self.closest_active_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_closest_active_match_id(&mut self, v: u32) {
        self.closest_active_match_id = ::std::option::Option::Some(v);
    }

    pub fn get_closest_active_match_id(&self) -> u32 {
        self.closest_active_match_id.unwrap_or(0)
    }

    fn get_closest_active_match_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.closest_active_match_id
    }

    fn mut_closest_active_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.closest_active_match_id
    }

    // optional uint32 event_id = 7;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }
}

impl ::protobuf::Message for CMsgArcanaVotes {
    fn is_initialized(&self) -> bool {
        for v in &self.matches {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matches)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.round_time_remaining = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.round_number = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.voting_state = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_current_round_calibrating = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.closest_active_match_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.round_time_remaining {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.round_number {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.voting_state {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_current_round_calibrating {
            my_size += 2;
        }
        if let Some(v) = self.closest_active_match_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.matches {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.round_time_remaining {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.round_number {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.voting_state {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.is_current_round_calibrating {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.closest_active_match_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgArcanaVotes {
    fn new() -> CMsgArcanaVotes {
        CMsgArcanaVotes::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgArcanaVotes>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgArcanaVotes_Match>>(
                    "matches",
                    CMsgArcanaVotes::get_matches_for_reflect,
                    CMsgArcanaVotes::mut_matches_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "round_time_remaining",
                    CMsgArcanaVotes::get_round_time_remaining_for_reflect,
                    CMsgArcanaVotes::mut_round_time_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "round_number",
                    CMsgArcanaVotes::get_round_number_for_reflect,
                    CMsgArcanaVotes::mut_round_number_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "voting_state",
                    CMsgArcanaVotes::get_voting_state_for_reflect,
                    CMsgArcanaVotes::mut_voting_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_current_round_calibrating",
                    CMsgArcanaVotes::get_is_current_round_calibrating_for_reflect,
                    CMsgArcanaVotes::mut_is_current_round_calibrating_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "closest_active_match_id",
                    CMsgArcanaVotes::get_closest_active_match_id_for_reflect,
                    CMsgArcanaVotes::mut_closest_active_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgArcanaVotes::get_event_id_for_reflect,
                    CMsgArcanaVotes::mut_event_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgArcanaVotes>(
                    "CMsgArcanaVotes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgArcanaVotes {
    fn clear(&mut self) {
        self.clear_matches();
        self.clear_round_time_remaining();
        self.clear_round_number();
        self.clear_voting_state();
        self.clear_is_current_round_calibrating();
        self.clear_closest_active_match_id();
        self.clear_event_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgArcanaVotes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgArcanaVotes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgArcanaVotes_Match {
    // message fields
    match_id: ::std::option::Option<u32>,
    hero_id_0: ::std::option::Option<u32>,
    hero_id_1: ::std::option::Option<u32>,
    hero_seeding_0: ::std::option::Option<u32>,
    hero_seeding_1: ::std::option::Option<u32>,
    vote_count_0: ::std::option::Option<u32>,
    vote_count_1: ::std::option::Option<u32>,
    voting_state: ::std::option::Option<u32>,
    round_number: ::std::option::Option<u32>,
    is_votes_hidden: ::std::option::Option<bool>,
    calibration_time_remaining: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgArcanaVotes_Match {}

impl CMsgArcanaVotes_Match {
    pub fn new() -> CMsgArcanaVotes_Match {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgArcanaVotes_Match {
        static mut instance: ::protobuf::lazy::Lazy<CMsgArcanaVotes_Match> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgArcanaVotes_Match,
        };
        unsafe {
            instance.get(CMsgArcanaVotes_Match::new)
        }
    }

    // optional uint32 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u32) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u32 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.match_id
    }

    // optional uint32 hero_id_0 = 2;

    pub fn clear_hero_id_0(&mut self) {
        self.hero_id_0 = ::std::option::Option::None;
    }

    pub fn has_hero_id_0(&self) -> bool {
        self.hero_id_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id_0(&mut self, v: u32) {
        self.hero_id_0 = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id_0(&self) -> u32 {
        self.hero_id_0.unwrap_or(0)
    }

    fn get_hero_id_0_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id_0
    }

    fn mut_hero_id_0_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id_0
    }

    // optional uint32 hero_id_1 = 3;

    pub fn clear_hero_id_1(&mut self) {
        self.hero_id_1 = ::std::option::Option::None;
    }

    pub fn has_hero_id_1(&self) -> bool {
        self.hero_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id_1(&mut self, v: u32) {
        self.hero_id_1 = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id_1(&self) -> u32 {
        self.hero_id_1.unwrap_or(0)
    }

    fn get_hero_id_1_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id_1
    }

    fn mut_hero_id_1_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id_1
    }

    // optional uint32 hero_seeding_0 = 4;

    pub fn clear_hero_seeding_0(&mut self) {
        self.hero_seeding_0 = ::std::option::Option::None;
    }

    pub fn has_hero_seeding_0(&self) -> bool {
        self.hero_seeding_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_seeding_0(&mut self, v: u32) {
        self.hero_seeding_0 = ::std::option::Option::Some(v);
    }

    pub fn get_hero_seeding_0(&self) -> u32 {
        self.hero_seeding_0.unwrap_or(0)
    }

    fn get_hero_seeding_0_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_seeding_0
    }

    fn mut_hero_seeding_0_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_seeding_0
    }

    // optional uint32 hero_seeding_1 = 5;

    pub fn clear_hero_seeding_1(&mut self) {
        self.hero_seeding_1 = ::std::option::Option::None;
    }

    pub fn has_hero_seeding_1(&self) -> bool {
        self.hero_seeding_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_seeding_1(&mut self, v: u32) {
        self.hero_seeding_1 = ::std::option::Option::Some(v);
    }

    pub fn get_hero_seeding_1(&self) -> u32 {
        self.hero_seeding_1.unwrap_or(0)
    }

    fn get_hero_seeding_1_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_seeding_1
    }

    fn mut_hero_seeding_1_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_seeding_1
    }

    // optional uint32 vote_count_0 = 6;

    pub fn clear_vote_count_0(&mut self) {
        self.vote_count_0 = ::std::option::Option::None;
    }

    pub fn has_vote_count_0(&self) -> bool {
        self.vote_count_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_count_0(&mut self, v: u32) {
        self.vote_count_0 = ::std::option::Option::Some(v);
    }

    pub fn get_vote_count_0(&self) -> u32 {
        self.vote_count_0.unwrap_or(0)
    }

    fn get_vote_count_0_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.vote_count_0
    }

    fn mut_vote_count_0_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.vote_count_0
    }

    // optional uint32 vote_count_1 = 7;

    pub fn clear_vote_count_1(&mut self) {
        self.vote_count_1 = ::std::option::Option::None;
    }

    pub fn has_vote_count_1(&self) -> bool {
        self.vote_count_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_count_1(&mut self, v: u32) {
        self.vote_count_1 = ::std::option::Option::Some(v);
    }

    pub fn get_vote_count_1(&self) -> u32 {
        self.vote_count_1.unwrap_or(0)
    }

    fn get_vote_count_1_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.vote_count_1
    }

    fn mut_vote_count_1_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.vote_count_1
    }

    // optional uint32 voting_state = 8;

    pub fn clear_voting_state(&mut self) {
        self.voting_state = ::std::option::Option::None;
    }

    pub fn has_voting_state(&self) -> bool {
        self.voting_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voting_state(&mut self, v: u32) {
        self.voting_state = ::std::option::Option::Some(v);
    }

    pub fn get_voting_state(&self) -> u32 {
        self.voting_state.unwrap_or(0)
    }

    fn get_voting_state_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.voting_state
    }

    fn mut_voting_state_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.voting_state
    }

    // optional uint32 round_number = 9;

    pub fn clear_round_number(&mut self) {
        self.round_number = ::std::option::Option::None;
    }

    pub fn has_round_number(&self) -> bool {
        self.round_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round_number(&mut self, v: u32) {
        self.round_number = ::std::option::Option::Some(v);
    }

    pub fn get_round_number(&self) -> u32 {
        self.round_number.unwrap_or(0)
    }

    fn get_round_number_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.round_number
    }

    fn mut_round_number_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.round_number
    }

    // optional bool is_votes_hidden = 10;

    pub fn clear_is_votes_hidden(&mut self) {
        self.is_votes_hidden = ::std::option::Option::None;
    }

    pub fn has_is_votes_hidden(&self) -> bool {
        self.is_votes_hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_votes_hidden(&mut self, v: bool) {
        self.is_votes_hidden = ::std::option::Option::Some(v);
    }

    pub fn get_is_votes_hidden(&self) -> bool {
        self.is_votes_hidden.unwrap_or(false)
    }

    fn get_is_votes_hidden_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_votes_hidden
    }

    fn mut_is_votes_hidden_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_votes_hidden
    }

    // optional uint32 calibration_time_remaining = 11;

    pub fn clear_calibration_time_remaining(&mut self) {
        self.calibration_time_remaining = ::std::option::Option::None;
    }

    pub fn has_calibration_time_remaining(&self) -> bool {
        self.calibration_time_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_calibration_time_remaining(&mut self, v: u32) {
        self.calibration_time_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_calibration_time_remaining(&self) -> u32 {
        self.calibration_time_remaining.unwrap_or(0)
    }

    fn get_calibration_time_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.calibration_time_remaining
    }

    fn mut_calibration_time_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.calibration_time_remaining
    }
}

impl ::protobuf::Message for CMsgArcanaVotes_Match {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id_0 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id_1 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_seeding_0 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_seeding_1 = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.vote_count_0 = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.vote_count_1 = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.voting_state = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.round_number = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_votes_hidden = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.calibration_time_remaining = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id_0 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id_1 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_seeding_0 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_seeding_1 {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vote_count_0 {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vote_count_1 {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.voting_state {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.round_number {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_votes_hidden {
            my_size += 2;
        }
        if let Some(v) = self.calibration_time_remaining {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_id_0 {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_id_1 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hero_seeding_0 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.hero_seeding_1 {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.vote_count_0 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.vote_count_1 {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.voting_state {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.round_number {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.is_votes_hidden {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.calibration_time_remaining {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgArcanaVotes_Match {
    fn new() -> CMsgArcanaVotes_Match {
        CMsgArcanaVotes_Match::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgArcanaVotes_Match>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "match_id",
                    CMsgArcanaVotes_Match::get_match_id_for_reflect,
                    CMsgArcanaVotes_Match::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id_0",
                    CMsgArcanaVotes_Match::get_hero_id_0_for_reflect,
                    CMsgArcanaVotes_Match::mut_hero_id_0_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id_1",
                    CMsgArcanaVotes_Match::get_hero_id_1_for_reflect,
                    CMsgArcanaVotes_Match::mut_hero_id_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_seeding_0",
                    CMsgArcanaVotes_Match::get_hero_seeding_0_for_reflect,
                    CMsgArcanaVotes_Match::mut_hero_seeding_0_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_seeding_1",
                    CMsgArcanaVotes_Match::get_hero_seeding_1_for_reflect,
                    CMsgArcanaVotes_Match::mut_hero_seeding_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "vote_count_0",
                    CMsgArcanaVotes_Match::get_vote_count_0_for_reflect,
                    CMsgArcanaVotes_Match::mut_vote_count_0_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "vote_count_1",
                    CMsgArcanaVotes_Match::get_vote_count_1_for_reflect,
                    CMsgArcanaVotes_Match::mut_vote_count_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "voting_state",
                    CMsgArcanaVotes_Match::get_voting_state_for_reflect,
                    CMsgArcanaVotes_Match::mut_voting_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "round_number",
                    CMsgArcanaVotes_Match::get_round_number_for_reflect,
                    CMsgArcanaVotes_Match::mut_round_number_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_votes_hidden",
                    CMsgArcanaVotes_Match::get_is_votes_hidden_for_reflect,
                    CMsgArcanaVotes_Match::mut_is_votes_hidden_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "calibration_time_remaining",
                    CMsgArcanaVotes_Match::get_calibration_time_remaining_for_reflect,
                    CMsgArcanaVotes_Match::mut_calibration_time_remaining_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgArcanaVotes_Match>(
                    "CMsgArcanaVotes_Match",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgArcanaVotes_Match {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_hero_id_0();
        self.clear_hero_id_1();
        self.clear_hero_seeding_0();
        self.clear_hero_seeding_1();
        self.clear_vote_count_0();
        self.clear_vote_count_1();
        self.clear_voting_state();
        self.clear_round_number();
        self.clear_is_votes_hidden();
        self.clear_calibration_time_remaining();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgArcanaVotes_Match {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgArcanaVotes_Match {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgArcanaVotes_VotingState {
    FINISHED = 0,
    IN_PROGRESS = 1,
    IN_FUTURE = 2,
}

impl ::protobuf::ProtobufEnum for CMsgArcanaVotes_VotingState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgArcanaVotes_VotingState> {
        match value {
            0 => ::std::option::Option::Some(CMsgArcanaVotes_VotingState::FINISHED),
            1 => ::std::option::Option::Some(CMsgArcanaVotes_VotingState::IN_PROGRESS),
            2 => ::std::option::Option::Some(CMsgArcanaVotes_VotingState::IN_FUTURE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgArcanaVotes_VotingState] = &[
            CMsgArcanaVotes_VotingState::FINISHED,
            CMsgArcanaVotes_VotingState::IN_PROGRESS,
            CMsgArcanaVotes_VotingState::IN_FUTURE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgArcanaVotes_VotingState>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgArcanaVotes_VotingState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgArcanaVotes_VotingState {
}

impl ::protobuf::reflect::ProtobufValue for CMsgArcanaVotes_VotingState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestArcanaVotesRemaining {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestArcanaVotesRemaining {}

impl CMsgClientToGCRequestArcanaVotesRemaining {
    pub fn new() -> CMsgClientToGCRequestArcanaVotesRemaining {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestArcanaVotesRemaining {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestArcanaVotesRemaining> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestArcanaVotesRemaining,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestArcanaVotesRemaining::new)
        }
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestArcanaVotesRemaining {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestArcanaVotesRemaining {
    fn new() -> CMsgClientToGCRequestArcanaVotesRemaining {
        CMsgClientToGCRequestArcanaVotesRemaining::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestArcanaVotesRemaining>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestArcanaVotesRemaining>(
                    "CMsgClientToGCRequestArcanaVotesRemaining",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestArcanaVotesRemaining {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestArcanaVotesRemaining {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestArcanaVotesRemaining {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestArcanaVotesRemainingResponse {
    // message fields
    result: ::std::option::Option<bool>,
    votes_remaining: ::std::option::Option<u32>,
    votes_total: ::std::option::Option<u32>,
    matches_previously_voted_for: ::protobuf::RepeatedField<CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestArcanaVotesRemainingResponse {}

impl CMsgClientToGCRequestArcanaVotesRemainingResponse {
    pub fn new() -> CMsgClientToGCRequestArcanaVotesRemainingResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestArcanaVotesRemainingResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestArcanaVotesRemainingResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestArcanaVotesRemainingResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestArcanaVotesRemainingResponse::new)
        }
    }

    // optional bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }

    // optional uint32 votes_remaining = 2;

    pub fn clear_votes_remaining(&mut self) {
        self.votes_remaining = ::std::option::Option::None;
    }

    pub fn has_votes_remaining(&self) -> bool {
        self.votes_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_votes_remaining(&mut self, v: u32) {
        self.votes_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_votes_remaining(&self) -> u32 {
        self.votes_remaining.unwrap_or(0)
    }

    fn get_votes_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.votes_remaining
    }

    fn mut_votes_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.votes_remaining
    }

    // optional uint32 votes_total = 3;

    pub fn clear_votes_total(&mut self) {
        self.votes_total = ::std::option::Option::None;
    }

    pub fn has_votes_total(&self) -> bool {
        self.votes_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_votes_total(&mut self, v: u32) {
        self.votes_total = ::std::option::Option::Some(v);
    }

    pub fn get_votes_total(&self) -> u32 {
        self.votes_total.unwrap_or(0)
    }

    fn get_votes_total_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.votes_total
    }

    fn mut_votes_total_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.votes_total
    }

    // repeated .CMsgClientToGCRequestArcanaVotesRemainingResponse.MatchVote matches_previously_voted_for = 4;

    pub fn clear_matches_previously_voted_for(&mut self) {
        self.matches_previously_voted_for.clear();
    }

    // Param is passed by value, moved
    pub fn set_matches_previously_voted_for(&mut self, v: ::protobuf::RepeatedField<CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote>) {
        self.matches_previously_voted_for = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matches_previously_voted_for(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote> {
        &mut self.matches_previously_voted_for
    }

    // Take field
    pub fn take_matches_previously_voted_for(&mut self) -> ::protobuf::RepeatedField<CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote> {
        ::std::mem::replace(&mut self.matches_previously_voted_for, ::protobuf::RepeatedField::new())
    }

    pub fn get_matches_previously_voted_for(&self) -> &[CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote] {
        &self.matches_previously_voted_for
    }

    fn get_matches_previously_voted_for_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote> {
        &self.matches_previously_voted_for
    }

    fn mut_matches_previously_voted_for_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote> {
        &mut self.matches_previously_voted_for
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestArcanaVotesRemainingResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.matches_previously_voted_for {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.votes_remaining = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.votes_total = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matches_previously_voted_for)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        if let Some(v) = self.votes_remaining {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.votes_total {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.matches_previously_voted_for {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.votes_remaining {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.votes_total {
            os.write_uint32(3, v)?;
        }
        for v in &self.matches_previously_voted_for {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestArcanaVotesRemainingResponse {
    fn new() -> CMsgClientToGCRequestArcanaVotesRemainingResponse {
        CMsgClientToGCRequestArcanaVotesRemainingResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestArcanaVotesRemainingResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    CMsgClientToGCRequestArcanaVotesRemainingResponse::get_result_for_reflect,
                    CMsgClientToGCRequestArcanaVotesRemainingResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "votes_remaining",
                    CMsgClientToGCRequestArcanaVotesRemainingResponse::get_votes_remaining_for_reflect,
                    CMsgClientToGCRequestArcanaVotesRemainingResponse::mut_votes_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "votes_total",
                    CMsgClientToGCRequestArcanaVotesRemainingResponse::get_votes_total_for_reflect,
                    CMsgClientToGCRequestArcanaVotesRemainingResponse::mut_votes_total_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote>>(
                    "matches_previously_voted_for",
                    CMsgClientToGCRequestArcanaVotesRemainingResponse::get_matches_previously_voted_for_for_reflect,
                    CMsgClientToGCRequestArcanaVotesRemainingResponse::mut_matches_previously_voted_for_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestArcanaVotesRemainingResponse>(
                    "CMsgClientToGCRequestArcanaVotesRemainingResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestArcanaVotesRemainingResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_votes_remaining();
        self.clear_votes_total();
        self.clear_matches_previously_voted_for();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestArcanaVotesRemainingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestArcanaVotesRemainingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote {
    // message fields
    match_id: ::std::option::Option<u64>,
    hero_id: ::std::option::Option<u32>,
    vote_count: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote {}

impl CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote {
    pub fn new() -> CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 hero_id = 2;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 vote_count = 3;

    pub fn clear_vote_count(&mut self) {
        self.vote_count = ::std::option::Option::None;
    }

    pub fn has_vote_count(&self) -> bool {
        self.vote_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_count(&mut self, v: u32) {
        self.vote_count = ::std::option::Option::Some(v);
    }

    pub fn get_vote_count(&self) -> u32 {
        self.vote_count.unwrap_or(0)
    }

    fn get_vote_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.vote_count
    }

    fn mut_vote_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.vote_count
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.vote_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vote_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.vote_count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote {
    fn new() -> CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote {
        CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote::get_match_id_for_reflect,
                    CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote::get_hero_id_for_reflect,
                    CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "vote_count",
                    CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote::get_vote_count_for_reflect,
                    CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote::mut_vote_count_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote>(
                    "CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_hero_id();
        self.clear_vote_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestArcanaVotesRemainingResponse_MatchVote {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestEventPointLog {
    // message fields
    event_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestEventPointLog {}

impl CMsgClientToGCRequestEventPointLog {
    pub fn new() -> CMsgClientToGCRequestEventPointLog {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestEventPointLog {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestEventPointLog> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestEventPointLog,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestEventPointLog::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestEventPointLog {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestEventPointLog {
    fn new() -> CMsgClientToGCRequestEventPointLog {
        CMsgClientToGCRequestEventPointLog::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestEventPointLog>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgClientToGCRequestEventPointLog::get_event_id_for_reflect,
                    CMsgClientToGCRequestEventPointLog::mut_event_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestEventPointLog>(
                    "CMsgClientToGCRequestEventPointLog",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestEventPointLog {
    fn clear(&mut self) {
        self.clear_event_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestEventPointLog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestEventPointLog {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestEventPointLogResponse {
    // message fields
    result: ::std::option::Option<bool>,
    transactions: ::protobuf::RepeatedField<CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction>,
    event_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestEventPointLogResponse {}

impl CMsgClientToGCRequestEventPointLogResponse {
    pub fn new() -> CMsgClientToGCRequestEventPointLogResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestEventPointLogResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestEventPointLogResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestEventPointLogResponse::new)
        }
    }

    // optional bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }

    // repeated .CMsgClientToGCRequestEventPointLogResponse.EventPointTransaction transactions = 2;

    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }

    pub fn get_transactions(&self) -> &[CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction] {
        &self.transactions
    }

    fn get_transactions_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction> {
        &self.transactions
    }

    fn mut_transactions_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction> {
        &mut self.transactions
    }

    // optional uint32 event_id = 3;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestEventPointLogResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        for v in &self.transactions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.event_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestEventPointLogResponse {
    fn new() -> CMsgClientToGCRequestEventPointLogResponse {
        CMsgClientToGCRequestEventPointLogResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestEventPointLogResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    CMsgClientToGCRequestEventPointLogResponse::get_result_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction>>(
                    "transactions",
                    CMsgClientToGCRequestEventPointLogResponse::get_transactions_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse::mut_transactions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgClientToGCRequestEventPointLogResponse::get_event_id_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse::mut_event_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestEventPointLogResponse>(
                    "CMsgClientToGCRequestEventPointLogResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestEventPointLogResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_transactions();
        self.clear_event_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestEventPointLogResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestEventPointLogResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent {
    // message fields
    quest_id: ::std::option::Option<u32>,
    challenge_id: ::std::option::Option<u32>,
    rank: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent {}

impl CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent {
    pub fn new() -> CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent::new)
        }
    }

    // optional uint32 quest_id = 1;

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u32) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    pub fn get_quest_id(&self) -> u32 {
        self.quest_id.unwrap_or(0)
    }

    fn get_quest_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.quest_id
    }

    fn mut_quest_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.quest_id
    }

    // optional uint32 challenge_id = 2;

    pub fn clear_challenge_id(&mut self) {
        self.challenge_id = ::std::option::Option::None;
    }

    pub fn has_challenge_id(&self) -> bool {
        self.challenge_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_id(&mut self, v: u32) {
        self.challenge_id = ::std::option::Option::Some(v);
    }

    pub fn get_challenge_id(&self) -> u32 {
        self.challenge_id.unwrap_or(0)
    }

    fn get_challenge_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.challenge_id
    }

    fn mut_challenge_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.challenge_id
    }

    // optional uint32 rank = 3;

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }

    pub fn get_rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }

    fn get_rank_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rank
    }

    fn mut_rank_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rank
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.challenge_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rank = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.challenge_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.challenge_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rank {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent {
    fn new() -> CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent {
        CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quest_id",
                    CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent::get_quest_id_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent::mut_quest_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "challenge_id",
                    CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent::get_challenge_id_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent::mut_challenge_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rank",
                    CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent::get_rank_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent::mut_rank_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent>(
                    "CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent {
    fn clear(&mut self) {
        self.clear_quest_id();
        self.clear_challenge_id();
        self.clear_rank();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent {
    // message fields
    match_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent {}

impl CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent {
    pub fn new() -> CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent {
    fn new() -> CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent {
        CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent::get_match_id_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent::mut_match_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent>(
                    "CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent {
    fn clear(&mut self) {
        self.clear_match_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent {
    // message fields
    recipient_account_id: ::std::option::Option<u32>,
    recipient_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent {}

impl CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent {
    pub fn new() -> CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent::new)
        }
    }

    // optional uint32 recipient_account_id = 1;

    pub fn clear_recipient_account_id(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
    }

    pub fn has_recipient_account_id(&self) -> bool {
        self.recipient_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_account_id(&mut self, v: u32) {
        self.recipient_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_recipient_account_id(&self) -> u32 {
        self.recipient_account_id.unwrap_or(0)
    }

    fn get_recipient_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.recipient_account_id
    }

    fn mut_recipient_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.recipient_account_id
    }

    // optional string recipient_name = 2;

    pub fn clear_recipient_name(&mut self) {
        self.recipient_name.clear();
    }

    pub fn has_recipient_name(&self) -> bool {
        self.recipient_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_name(&mut self, v: ::std::string::String) {
        self.recipient_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipient_name(&mut self) -> &mut ::std::string::String {
        if self.recipient_name.is_none() {
            self.recipient_name.set_default();
        }
        self.recipient_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_recipient_name(&mut self) -> ::std::string::String {
        self.recipient_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_recipient_name(&self) -> &str {
        match self.recipient_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_recipient_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.recipient_name
    }

    fn mut_recipient_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.recipient_name
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recipient_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recipient_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.recipient_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.recipient_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.recipient_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.recipient_name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent {
    fn new() -> CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent {
        CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "recipient_account_id",
                    CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent::get_recipient_account_id_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent::mut_recipient_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "recipient_name",
                    CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent::get_recipient_name_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent::mut_recipient_name_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent>(
                    "CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent {
    fn clear(&mut self) {
        self.clear_recipient_account_id();
        self.clear_recipient_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent {
    // message fields
    giver_account_id: ::std::option::Option<u32>,
    giver_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent {}

impl CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent {
    pub fn new() -> CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent::new)
        }
    }

    // optional uint32 giver_account_id = 1;

    pub fn clear_giver_account_id(&mut self) {
        self.giver_account_id = ::std::option::Option::None;
    }

    pub fn has_giver_account_id(&self) -> bool {
        self.giver_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_giver_account_id(&mut self, v: u32) {
        self.giver_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_giver_account_id(&self) -> u32 {
        self.giver_account_id.unwrap_or(0)
    }

    fn get_giver_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.giver_account_id
    }

    fn mut_giver_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.giver_account_id
    }

    // optional string giver_name = 2;

    pub fn clear_giver_name(&mut self) {
        self.giver_name.clear();
    }

    pub fn has_giver_name(&self) -> bool {
        self.giver_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_giver_name(&mut self, v: ::std::string::String) {
        self.giver_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_giver_name(&mut self) -> &mut ::std::string::String {
        if self.giver_name.is_none() {
            self.giver_name.set_default();
        }
        self.giver_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_giver_name(&mut self) -> ::std::string::String {
        self.giver_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_giver_name(&self) -> &str {
        match self.giver_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_giver_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.giver_name
    }

    fn mut_giver_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.giver_name
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.giver_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.giver_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.giver_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.giver_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.giver_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.giver_name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent {
    fn new() -> CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent {
        CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "giver_account_id",
                    CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent::get_giver_account_id_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent::mut_giver_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "giver_name",
                    CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent::get_giver_name_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent::mut_giver_name_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent>(
                    "CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent {
    fn clear(&mut self) {
        self.clear_giver_account_id();
        self.clear_giver_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent {
    // message fields
    recipe_item_def_index: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent {}

impl CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent {
    pub fn new() -> CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent::new)
        }
    }

    // optional uint32 recipe_item_def_index = 1;

    pub fn clear_recipe_item_def_index(&mut self) {
        self.recipe_item_def_index = ::std::option::Option::None;
    }

    pub fn has_recipe_item_def_index(&self) -> bool {
        self.recipe_item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipe_item_def_index(&mut self, v: u32) {
        self.recipe_item_def_index = ::std::option::Option::Some(v);
    }

    pub fn get_recipe_item_def_index(&self) -> u32 {
        self.recipe_item_def_index.unwrap_or(0)
    }

    fn get_recipe_item_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.recipe_item_def_index
    }

    fn mut_recipe_item_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.recipe_item_def_index
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recipe_item_def_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.recipe_item_def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.recipe_item_def_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent {
    fn new() -> CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent {
        CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "recipe_item_def_index",
                    CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent::get_recipe_item_def_index_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent::mut_recipe_item_def_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent>(
                    "CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent {
    fn clear(&mut self) {
        self.clear_recipe_item_def_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent {
    // message fields
    action_id: ::std::option::Option<u32>,
    action_score: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent {}

impl CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent {
    pub fn new() -> CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent::new)
        }
    }

    // optional uint32 action_id = 1;

    pub fn clear_action_id(&mut self) {
        self.action_id = ::std::option::Option::None;
    }

    pub fn has_action_id(&self) -> bool {
        self.action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = ::std::option::Option::Some(v);
    }

    pub fn get_action_id(&self) -> u32 {
        self.action_id.unwrap_or(0)
    }

    fn get_action_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.action_id
    }

    fn mut_action_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.action_id
    }

    // optional uint32 action_score = 2;

    pub fn clear_action_score(&mut self) {
        self.action_score = ::std::option::Option::None;
    }

    pub fn has_action_score(&self) -> bool {
        self.action_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_score(&mut self, v: u32) {
        self.action_score = ::std::option::Option::Some(v);
    }

    pub fn get_action_score(&self) -> u32 {
        self.action_score.unwrap_or(0)
    }

    fn get_action_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.action_score
    }

    fn mut_action_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.action_score
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.action_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.action_score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.action_score {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.action_score {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent {
    fn new() -> CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent {
        CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "action_id",
                    CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent::get_action_id_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent::mut_action_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "action_score",
                    CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent::get_action_score_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent::mut_action_score_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent>(
                    "CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent {
    fn clear(&mut self) {
        self.clear_action_id();
        self.clear_action_score();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent {
    // message fields
    community_goal_item: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent {}

impl CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent {
    pub fn new() -> CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent::new)
        }
    }

    // optional bool community_goal_item = 1;

    pub fn clear_community_goal_item(&mut self) {
        self.community_goal_item = ::std::option::Option::None;
    }

    pub fn has_community_goal_item(&self) -> bool {
        self.community_goal_item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_community_goal_item(&mut self, v: bool) {
        self.community_goal_item = ::std::option::Option::Some(v);
    }

    pub fn get_community_goal_item(&self) -> bool {
        self.community_goal_item.unwrap_or(false)
    }

    fn get_community_goal_item_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.community_goal_item
    }

    fn mut_community_goal_item_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.community_goal_item
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.community_goal_item = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.community_goal_item {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.community_goal_item {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent {
    fn new() -> CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent {
        CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "community_goal_item",
                    CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent::get_community_goal_item_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent::mut_community_goal_item_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent>(
                    "CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent {
    fn clear(&mut self) {
        self.clear_community_goal_item();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent {
    // message fields
    prediction_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent {}

impl CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent {
    pub fn new() -> CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent::new)
        }
    }

    // optional uint32 prediction_id = 1;

    pub fn clear_prediction_id(&mut self) {
        self.prediction_id = ::std::option::Option::None;
    }

    pub fn has_prediction_id(&self) -> bool {
        self.prediction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prediction_id(&mut self, v: u32) {
        self.prediction_id = ::std::option::Option::Some(v);
    }

    pub fn get_prediction_id(&self) -> u32 {
        self.prediction_id.unwrap_or(0)
    }

    fn get_prediction_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prediction_id
    }

    fn mut_prediction_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prediction_id
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prediction_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.prediction_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prediction_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent {
    fn new() -> CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent {
        CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prediction_id",
                    CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent::get_prediction_id_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent::mut_prediction_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent>(
                    "CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent {
    fn clear(&mut self) {
        self.clear_prediction_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent {
    // message fields
    match_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent {}

impl CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent {
    pub fn new() -> CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent {
    fn new() -> CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent {
        CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent::get_match_id_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent::mut_match_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent>(
                    "CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent {
    fn clear(&mut self) {
        self.clear_match_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent {
    // message fields
    team_gid: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent {}

impl CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent {
    pub fn new() -> CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent::new)
        }
    }

    // optional uint64 team_gid = 1;

    pub fn clear_team_gid(&mut self) {
        self.team_gid = ::std::option::Option::None;
    }

    pub fn has_team_gid(&self) -> bool {
        self.team_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_gid(&mut self, v: u64) {
        self.team_gid = ::std::option::Option::Some(v);
    }

    pub fn get_team_gid(&self) -> u64 {
        self.team_gid.unwrap_or(0)
    }

    fn get_team_gid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.team_gid
    }

    fn mut_team_gid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.team_gid
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.team_gid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team_gid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team_gid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent {
    fn new() -> CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent {
        CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "team_gid",
                    CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent::get_team_gid_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent::mut_team_gid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent>(
                    "CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent {
    fn clear(&mut self) {
        self.clear_team_gid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestEventPointLogResponse_WeekendTourneyPayoutEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent {
    // message fields
    percentile: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent {}

impl CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent {
    pub fn new() -> CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent::new)
        }
    }

    // optional uint32 percentile = 1;

    pub fn clear_percentile(&mut self) {
        self.percentile = ::std::option::Option::None;
    }

    pub fn has_percentile(&self) -> bool {
        self.percentile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_percentile(&mut self, v: u32) {
        self.percentile = ::std::option::Option::Some(v);
    }

    pub fn get_percentile(&self) -> u32 {
        self.percentile.unwrap_or(0)
    }

    fn get_percentile_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.percentile
    }

    fn mut_percentile_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.percentile
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.percentile = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.percentile {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.percentile {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent {
    fn new() -> CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent {
        CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "percentile",
                    CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent::get_percentile_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent::mut_percentile_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent>(
                    "CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent {
    fn clear(&mut self) {
        self.clear_percentile();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent {
    // message fields
    correct_answers: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent {}

impl CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent {
    pub fn new() -> CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent::new)
        }
    }

    // optional uint32 correct_answers = 1;

    pub fn clear_correct_answers(&mut self) {
        self.correct_answers = ::std::option::Option::None;
    }

    pub fn has_correct_answers(&self) -> bool {
        self.correct_answers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correct_answers(&mut self, v: u32) {
        self.correct_answers = ::std::option::Option::Some(v);
    }

    pub fn get_correct_answers(&self) -> u32 {
        self.correct_answers.unwrap_or(0)
    }

    fn get_correct_answers_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.correct_answers
    }

    fn mut_correct_answers_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.correct_answers
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.correct_answers = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.correct_answers {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.correct_answers {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent {
    fn new() -> CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent {
        CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "correct_answers",
                    CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent::get_correct_answers_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent::mut_correct_answers_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent>(
                    "CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent {
    fn clear(&mut self) {
        self.clear_correct_answers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent {
    // message fields
    points_won: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent {}

impl CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent {
    pub fn new() -> CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent::new)
        }
    }

    // optional uint32 points_won = 1;

    pub fn clear_points_won(&mut self) {
        self.points_won = ::std::option::Option::None;
    }

    pub fn has_points_won(&self) -> bool {
        self.points_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_won(&mut self, v: u32) {
        self.points_won = ::std::option::Option::Some(v);
    }

    pub fn get_points_won(&self) -> u32 {
        self.points_won.unwrap_or(0)
    }

    fn get_points_won_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points_won
    }

    fn mut_points_won_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points_won
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_won = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.points_won {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.points_won {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent {
    fn new() -> CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent {
        CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points_won",
                    CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent::get_points_won_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent::mut_points_won_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent>(
                    "CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent {
    fn clear(&mut self) {
        self.clear_points_won();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent {
    // message fields
    points_corrected: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent {}

impl CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent {
    pub fn new() -> CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent::new)
        }
    }

    // optional uint32 points_corrected = 1;

    pub fn clear_points_corrected(&mut self) {
        self.points_corrected = ::std::option::Option::None;
    }

    pub fn has_points_corrected(&self) -> bool {
        self.points_corrected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_corrected(&mut self, v: u32) {
        self.points_corrected = ::std::option::Option::Some(v);
    }

    pub fn get_points_corrected(&self) -> u32 {
        self.points_corrected.unwrap_or(0)
    }

    fn get_points_corrected_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points_corrected
    }

    fn mut_points_corrected_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points_corrected
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_corrected = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.points_corrected {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.points_corrected {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent {
    fn new() -> CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent {
        CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points_corrected",
                    CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent::get_points_corrected_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent::mut_points_corrected_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent>(
                    "CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent {
    fn clear(&mut self) {
        self.clear_points_corrected();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction {
    // message fields
    time: ::std::option::Option<u32>,
    event_points: ::std::option::Option<i32>,
    compendium_activated_event: ::std::option::Option<bool>,
    point_item_used_event: ::std::option::Option<bool>,
    wager_won_event: ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent>,
    mystery_item_received_event: ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent>,
    quest_challenge_event: ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent>,
    tip_given_event: ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent>,
    tip_received_event: ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent>,
    recycled_item_event: ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent>,
    action_reward_event: ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent>,
    in_game_prediction_event: ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent>,
    prediction_event: ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent>,
    fantasy_reward_event: ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent>,
    bracket_reward_event: ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent>,
    weekly_game_event: ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent>,
    exploit_correction_event: ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction {}

impl CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction {
    pub fn new() -> CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::new)
        }
    }

    // optional uint32 time = 1;

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: u32) {
        self.time = ::std::option::Option::Some(v);
    }

    pub fn get_time(&self) -> u32 {
        self.time.unwrap_or(0)
    }

    fn get_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time
    }

    fn mut_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time
    }

    // optional int32 event_points = 2;

    pub fn clear_event_points(&mut self) {
        self.event_points = ::std::option::Option::None;
    }

    pub fn has_event_points(&self) -> bool {
        self.event_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_points(&mut self, v: i32) {
        self.event_points = ::std::option::Option::Some(v);
    }

    pub fn get_event_points(&self) -> i32 {
        self.event_points.unwrap_or(0)
    }

    fn get_event_points_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.event_points
    }

    fn mut_event_points_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.event_points
    }

    // optional bool compendium_activated_event = 3;

    pub fn clear_compendium_activated_event(&mut self) {
        self.compendium_activated_event = ::std::option::Option::None;
    }

    pub fn has_compendium_activated_event(&self) -> bool {
        self.compendium_activated_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compendium_activated_event(&mut self, v: bool) {
        self.compendium_activated_event = ::std::option::Option::Some(v);
    }

    pub fn get_compendium_activated_event(&self) -> bool {
        self.compendium_activated_event.unwrap_or(false)
    }

    fn get_compendium_activated_event_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.compendium_activated_event
    }

    fn mut_compendium_activated_event_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.compendium_activated_event
    }

    // optional bool point_item_used_event = 4;

    pub fn clear_point_item_used_event(&mut self) {
        self.point_item_used_event = ::std::option::Option::None;
    }

    pub fn has_point_item_used_event(&self) -> bool {
        self.point_item_used_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_point_item_used_event(&mut self, v: bool) {
        self.point_item_used_event = ::std::option::Option::Some(v);
    }

    pub fn get_point_item_used_event(&self) -> bool {
        self.point_item_used_event.unwrap_or(false)
    }

    fn get_point_item_used_event_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.point_item_used_event
    }

    fn mut_point_item_used_event_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.point_item_used_event
    }

    // optional .CMsgClientToGCRequestEventPointLogResponse.WagerWonEvent wager_won_event = 5;

    pub fn clear_wager_won_event(&mut self) {
        self.wager_won_event.clear();
    }

    pub fn has_wager_won_event(&self) -> bool {
        self.wager_won_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wager_won_event(&mut self, v: CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent) {
        self.wager_won_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wager_won_event(&mut self) -> &mut CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent {
        if self.wager_won_event.is_none() {
            self.wager_won_event.set_default();
        }
        self.wager_won_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_wager_won_event(&mut self) -> CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent {
        self.wager_won_event.take().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent::new())
    }

    pub fn get_wager_won_event(&self) -> &CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent {
        self.wager_won_event.as_ref().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent::default_instance())
    }

    fn get_wager_won_event_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent> {
        &self.wager_won_event
    }

    fn mut_wager_won_event_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent> {
        &mut self.wager_won_event
    }

    // optional .CMsgClientToGCRequestEventPointLogResponse.MysteryItemReceivedEvent mystery_item_received_event = 6;

    pub fn clear_mystery_item_received_event(&mut self) {
        self.mystery_item_received_event.clear();
    }

    pub fn has_mystery_item_received_event(&self) -> bool {
        self.mystery_item_received_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mystery_item_received_event(&mut self, v: CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent) {
        self.mystery_item_received_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mystery_item_received_event(&mut self) -> &mut CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent {
        if self.mystery_item_received_event.is_none() {
            self.mystery_item_received_event.set_default();
        }
        self.mystery_item_received_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_mystery_item_received_event(&mut self) -> CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent {
        self.mystery_item_received_event.take().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent::new())
    }

    pub fn get_mystery_item_received_event(&self) -> &CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent {
        self.mystery_item_received_event.as_ref().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent::default_instance())
    }

    fn get_mystery_item_received_event_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent> {
        &self.mystery_item_received_event
    }

    fn mut_mystery_item_received_event_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent> {
        &mut self.mystery_item_received_event
    }

    // optional .CMsgClientToGCRequestEventPointLogResponse.QuestChallengeEvent quest_challenge_event = 7;

    pub fn clear_quest_challenge_event(&mut self) {
        self.quest_challenge_event.clear();
    }

    pub fn has_quest_challenge_event(&self) -> bool {
        self.quest_challenge_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_challenge_event(&mut self, v: CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent) {
        self.quest_challenge_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quest_challenge_event(&mut self) -> &mut CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent {
        if self.quest_challenge_event.is_none() {
            self.quest_challenge_event.set_default();
        }
        self.quest_challenge_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_quest_challenge_event(&mut self) -> CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent {
        self.quest_challenge_event.take().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent::new())
    }

    pub fn get_quest_challenge_event(&self) -> &CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent {
        self.quest_challenge_event.as_ref().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent::default_instance())
    }

    fn get_quest_challenge_event_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent> {
        &self.quest_challenge_event
    }

    fn mut_quest_challenge_event_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent> {
        &mut self.quest_challenge_event
    }

    // optional .CMsgClientToGCRequestEventPointLogResponse.TipGivenEvent tip_given_event = 8;

    pub fn clear_tip_given_event(&mut self) {
        self.tip_given_event.clear();
    }

    pub fn has_tip_given_event(&self) -> bool {
        self.tip_given_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_given_event(&mut self, v: CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent) {
        self.tip_given_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tip_given_event(&mut self) -> &mut CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent {
        if self.tip_given_event.is_none() {
            self.tip_given_event.set_default();
        }
        self.tip_given_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_tip_given_event(&mut self) -> CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent {
        self.tip_given_event.take().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent::new())
    }

    pub fn get_tip_given_event(&self) -> &CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent {
        self.tip_given_event.as_ref().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent::default_instance())
    }

    fn get_tip_given_event_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent> {
        &self.tip_given_event
    }

    fn mut_tip_given_event_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent> {
        &mut self.tip_given_event
    }

    // optional .CMsgClientToGCRequestEventPointLogResponse.TipReceivedEvent tip_received_event = 9;

    pub fn clear_tip_received_event(&mut self) {
        self.tip_received_event.clear();
    }

    pub fn has_tip_received_event(&self) -> bool {
        self.tip_received_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tip_received_event(&mut self, v: CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent) {
        self.tip_received_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tip_received_event(&mut self) -> &mut CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent {
        if self.tip_received_event.is_none() {
            self.tip_received_event.set_default();
        }
        self.tip_received_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_tip_received_event(&mut self) -> CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent {
        self.tip_received_event.take().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent::new())
    }

    pub fn get_tip_received_event(&self) -> &CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent {
        self.tip_received_event.as_ref().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent::default_instance())
    }

    fn get_tip_received_event_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent> {
        &self.tip_received_event
    }

    fn mut_tip_received_event_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent> {
        &mut self.tip_received_event
    }

    // optional .CMsgClientToGCRequestEventPointLogResponse.RecycledItemEvent recycled_item_event = 10;

    pub fn clear_recycled_item_event(&mut self) {
        self.recycled_item_event.clear();
    }

    pub fn has_recycled_item_event(&self) -> bool {
        self.recycled_item_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recycled_item_event(&mut self, v: CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent) {
        self.recycled_item_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recycled_item_event(&mut self) -> &mut CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent {
        if self.recycled_item_event.is_none() {
            self.recycled_item_event.set_default();
        }
        self.recycled_item_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_recycled_item_event(&mut self) -> CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent {
        self.recycled_item_event.take().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent::new())
    }

    pub fn get_recycled_item_event(&self) -> &CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent {
        self.recycled_item_event.as_ref().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent::default_instance())
    }

    fn get_recycled_item_event_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent> {
        &self.recycled_item_event
    }

    fn mut_recycled_item_event_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent> {
        &mut self.recycled_item_event
    }

    // optional .CMsgClientToGCRequestEventPointLogResponse.ActionRewardEvent action_reward_event = 11;

    pub fn clear_action_reward_event(&mut self) {
        self.action_reward_event.clear();
    }

    pub fn has_action_reward_event(&self) -> bool {
        self.action_reward_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_reward_event(&mut self, v: CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent) {
        self.action_reward_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action_reward_event(&mut self) -> &mut CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent {
        if self.action_reward_event.is_none() {
            self.action_reward_event.set_default();
        }
        self.action_reward_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_action_reward_event(&mut self) -> CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent {
        self.action_reward_event.take().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent::new())
    }

    pub fn get_action_reward_event(&self) -> &CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent {
        self.action_reward_event.as_ref().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent::default_instance())
    }

    fn get_action_reward_event_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent> {
        &self.action_reward_event
    }

    fn mut_action_reward_event_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent> {
        &mut self.action_reward_event
    }

    // optional .CMsgClientToGCRequestEventPointLogResponse.InGamePredictionCorrectEvent in_game_prediction_event = 12;

    pub fn clear_in_game_prediction_event(&mut self) {
        self.in_game_prediction_event.clear();
    }

    pub fn has_in_game_prediction_event(&self) -> bool {
        self.in_game_prediction_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_game_prediction_event(&mut self, v: CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent) {
        self.in_game_prediction_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_in_game_prediction_event(&mut self) -> &mut CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent {
        if self.in_game_prediction_event.is_none() {
            self.in_game_prediction_event.set_default();
        }
        self.in_game_prediction_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_in_game_prediction_event(&mut self) -> CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent {
        self.in_game_prediction_event.take().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent::new())
    }

    pub fn get_in_game_prediction_event(&self) -> &CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent {
        self.in_game_prediction_event.as_ref().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent::default_instance())
    }

    fn get_in_game_prediction_event_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent> {
        &self.in_game_prediction_event
    }

    fn mut_in_game_prediction_event_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent> {
        &mut self.in_game_prediction_event
    }

    // optional .CMsgClientToGCRequestEventPointLogResponse.CorrectPredictionEvent prediction_event = 13;

    pub fn clear_prediction_event(&mut self) {
        self.prediction_event.clear();
    }

    pub fn has_prediction_event(&self) -> bool {
        self.prediction_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prediction_event(&mut self, v: CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent) {
        self.prediction_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prediction_event(&mut self) -> &mut CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent {
        if self.prediction_event.is_none() {
            self.prediction_event.set_default();
        }
        self.prediction_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_prediction_event(&mut self) -> CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent {
        self.prediction_event.take().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent::new())
    }

    pub fn get_prediction_event(&self) -> &CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent {
        self.prediction_event.as_ref().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent::default_instance())
    }

    fn get_prediction_event_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent> {
        &self.prediction_event
    }

    fn mut_prediction_event_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent> {
        &mut self.prediction_event
    }

    // optional .CMsgClientToGCRequestEventPointLogResponse.FantasyRewardEvent fantasy_reward_event = 15;

    pub fn clear_fantasy_reward_event(&mut self) {
        self.fantasy_reward_event.clear();
    }

    pub fn has_fantasy_reward_event(&self) -> bool {
        self.fantasy_reward_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_reward_event(&mut self, v: CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent) {
        self.fantasy_reward_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fantasy_reward_event(&mut self) -> &mut CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent {
        if self.fantasy_reward_event.is_none() {
            self.fantasy_reward_event.set_default();
        }
        self.fantasy_reward_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_fantasy_reward_event(&mut self) -> CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent {
        self.fantasy_reward_event.take().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent::new())
    }

    pub fn get_fantasy_reward_event(&self) -> &CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent {
        self.fantasy_reward_event.as_ref().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent::default_instance())
    }

    fn get_fantasy_reward_event_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent> {
        &self.fantasy_reward_event
    }

    fn mut_fantasy_reward_event_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent> {
        &mut self.fantasy_reward_event
    }

    // optional .CMsgClientToGCRequestEventPointLogResponse.BracketRewardEvent bracket_reward_event = 16;

    pub fn clear_bracket_reward_event(&mut self) {
        self.bracket_reward_event.clear();
    }

    pub fn has_bracket_reward_event(&self) -> bool {
        self.bracket_reward_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bracket_reward_event(&mut self, v: CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent) {
        self.bracket_reward_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bracket_reward_event(&mut self) -> &mut CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent {
        if self.bracket_reward_event.is_none() {
            self.bracket_reward_event.set_default();
        }
        self.bracket_reward_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_bracket_reward_event(&mut self) -> CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent {
        self.bracket_reward_event.take().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent::new())
    }

    pub fn get_bracket_reward_event(&self) -> &CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent {
        self.bracket_reward_event.as_ref().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent::default_instance())
    }

    fn get_bracket_reward_event_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent> {
        &self.bracket_reward_event
    }

    fn mut_bracket_reward_event_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent> {
        &mut self.bracket_reward_event
    }

    // optional .CMsgClientToGCRequestEventPointLogResponse.WeeklyGameEvent weekly_game_event = 19;

    pub fn clear_weekly_game_event(&mut self) {
        self.weekly_game_event.clear();
    }

    pub fn has_weekly_game_event(&self) -> bool {
        self.weekly_game_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weekly_game_event(&mut self, v: CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent) {
        self.weekly_game_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_weekly_game_event(&mut self) -> &mut CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent {
        if self.weekly_game_event.is_none() {
            self.weekly_game_event.set_default();
        }
        self.weekly_game_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_weekly_game_event(&mut self) -> CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent {
        self.weekly_game_event.take().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent::new())
    }

    pub fn get_weekly_game_event(&self) -> &CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent {
        self.weekly_game_event.as_ref().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent::default_instance())
    }

    fn get_weekly_game_event_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent> {
        &self.weekly_game_event
    }

    fn mut_weekly_game_event_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent> {
        &mut self.weekly_game_event
    }

    // optional .CMsgClientToGCRequestEventPointLogResponse.ExploitCorrectionEvent exploit_correction_event = 20;

    pub fn clear_exploit_correction_event(&mut self) {
        self.exploit_correction_event.clear();
    }

    pub fn has_exploit_correction_event(&self) -> bool {
        self.exploit_correction_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exploit_correction_event(&mut self, v: CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent) {
        self.exploit_correction_event = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exploit_correction_event(&mut self) -> &mut CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent {
        if self.exploit_correction_event.is_none() {
            self.exploit_correction_event.set_default();
        }
        self.exploit_correction_event.as_mut().unwrap()
    }

    // Take field
    pub fn take_exploit_correction_event(&mut self) -> CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent {
        self.exploit_correction_event.take().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent::new())
    }

    pub fn get_exploit_correction_event(&self) -> &CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent {
        self.exploit_correction_event.as_ref().unwrap_or_else(|| CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent::default_instance())
    }

    fn get_exploit_correction_event_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent> {
        &self.exploit_correction_event
    }

    fn mut_exploit_correction_event_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent> {
        &mut self.exploit_correction_event
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction {
    fn is_initialized(&self) -> bool {
        for v in &self.wager_won_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mystery_item_received_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quest_challenge_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tip_given_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tip_received_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.recycled_item_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.action_reward_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.in_game_prediction_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prediction_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fantasy_reward_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bracket_reward_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.weekly_game_event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exploit_correction_event {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_points = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.compendium_activated_event = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.point_item_used_event = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.wager_won_event)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mystery_item_received_event)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quest_challenge_event)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tip_given_event)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tip_received_event)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.recycled_item_event)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action_reward_event)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.in_game_prediction_event)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prediction_event)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fantasy_reward_event)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bracket_reward_event)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.weekly_game_event)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exploit_correction_event)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_points {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.compendium_activated_event {
            my_size += 2;
        }
        if let Some(v) = self.point_item_used_event {
            my_size += 2;
        }
        if let Some(ref v) = self.wager_won_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mystery_item_received_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.quest_challenge_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tip_given_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tip_received_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.recycled_item_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.action_reward_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.in_game_prediction_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.prediction_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fantasy_reward_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bracket_reward_event.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.weekly_game_event.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.exploit_correction_event.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.time {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_points {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.compendium_activated_event {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.point_item_used_event {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.wager_won_event.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mystery_item_received_event.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.quest_challenge_event.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tip_given_event.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tip_received_event.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.recycled_item_event.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.action_reward_event.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.in_game_prediction_event.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.prediction_event.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fantasy_reward_event.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bracket_reward_event.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.weekly_game_event.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.exploit_correction_event.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction {
    fn new() -> CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction {
        CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time",
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::get_time_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::mut_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "event_points",
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::get_event_points_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::mut_event_points_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "compendium_activated_event",
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::get_compendium_activated_event_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::mut_compendium_activated_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "point_item_used_event",
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::get_point_item_used_event_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::mut_point_item_used_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCRequestEventPointLogResponse_WagerWonEvent>>(
                    "wager_won_event",
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::get_wager_won_event_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::mut_wager_won_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCRequestEventPointLogResponse_MysteryItemReceivedEvent>>(
                    "mystery_item_received_event",
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::get_mystery_item_received_event_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::mut_mystery_item_received_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCRequestEventPointLogResponse_QuestChallengeEvent>>(
                    "quest_challenge_event",
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::get_quest_challenge_event_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::mut_quest_challenge_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCRequestEventPointLogResponse_TipGivenEvent>>(
                    "tip_given_event",
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::get_tip_given_event_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::mut_tip_given_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCRequestEventPointLogResponse_TipReceivedEvent>>(
                    "tip_received_event",
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::get_tip_received_event_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::mut_tip_received_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCRequestEventPointLogResponse_RecycledItemEvent>>(
                    "recycled_item_event",
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::get_recycled_item_event_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::mut_recycled_item_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCRequestEventPointLogResponse_ActionRewardEvent>>(
                    "action_reward_event",
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::get_action_reward_event_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::mut_action_reward_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCRequestEventPointLogResponse_InGamePredictionCorrectEvent>>(
                    "in_game_prediction_event",
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::get_in_game_prediction_event_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::mut_in_game_prediction_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCRequestEventPointLogResponse_CorrectPredictionEvent>>(
                    "prediction_event",
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::get_prediction_event_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::mut_prediction_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCRequestEventPointLogResponse_FantasyRewardEvent>>(
                    "fantasy_reward_event",
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::get_fantasy_reward_event_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::mut_fantasy_reward_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCRequestEventPointLogResponse_BracketRewardEvent>>(
                    "bracket_reward_event",
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::get_bracket_reward_event_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::mut_bracket_reward_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCRequestEventPointLogResponse_WeeklyGameEvent>>(
                    "weekly_game_event",
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::get_weekly_game_event_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::mut_weekly_game_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCRequestEventPointLogResponse_ExploitCorrectionEvent>>(
                    "exploit_correction_event",
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::get_exploit_correction_event_for_reflect,
                    CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction::mut_exploit_correction_event_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction>(
                    "CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction {
    fn clear(&mut self) {
        self.clear_time();
        self.clear_event_points();
        self.clear_compendium_activated_event();
        self.clear_point_item_used_event();
        self.clear_wager_won_event();
        self.clear_mystery_item_received_event();
        self.clear_quest_challenge_event();
        self.clear_tip_given_event();
        self.clear_tip_received_event();
        self.clear_recycled_item_event();
        self.clear_action_reward_event();
        self.clear_in_game_prediction_event();
        self.clear_prediction_event();
        self.clear_fantasy_reward_event();
        self.clear_bracket_reward_event();
        self.clear_weekly_game_event();
        self.clear_exploit_correction_event();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestEventPointLogResponse_EventPointTransaction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCPublishUserStat {
    // message fields
    user_stats_event: ::std::option::Option<u32>,
    reference_data: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCPublishUserStat {}

impl CMsgClientToGCPublishUserStat {
    pub fn new() -> CMsgClientToGCPublishUserStat {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCPublishUserStat {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCPublishUserStat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCPublishUserStat,
        };
        unsafe {
            instance.get(CMsgClientToGCPublishUserStat::new)
        }
    }

    // optional uint32 user_stats_event = 1;

    pub fn clear_user_stats_event(&mut self) {
        self.user_stats_event = ::std::option::Option::None;
    }

    pub fn has_user_stats_event(&self) -> bool {
        self.user_stats_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_stats_event(&mut self, v: u32) {
        self.user_stats_event = ::std::option::Option::Some(v);
    }

    pub fn get_user_stats_event(&self) -> u32 {
        self.user_stats_event.unwrap_or(0)
    }

    fn get_user_stats_event_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.user_stats_event
    }

    fn mut_user_stats_event_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.user_stats_event
    }

    // optional uint64 reference_data = 2;

    pub fn clear_reference_data(&mut self) {
        self.reference_data = ::std::option::Option::None;
    }

    pub fn has_reference_data(&self) -> bool {
        self.reference_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reference_data(&mut self, v: u64) {
        self.reference_data = ::std::option::Option::Some(v);
    }

    pub fn get_reference_data(&self) -> u64 {
        self.reference_data.unwrap_or(0)
    }

    fn get_reference_data_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.reference_data
    }

    fn mut_reference_data_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.reference_data
    }
}

impl ::protobuf::Message for CMsgClientToGCPublishUserStat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_stats_event = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.reference_data = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_stats_event {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reference_data {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_stats_event {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reference_data {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCPublishUserStat {
    fn new() -> CMsgClientToGCPublishUserStat {
        CMsgClientToGCPublishUserStat::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCPublishUserStat>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "user_stats_event",
                    CMsgClientToGCPublishUserStat::get_user_stats_event_for_reflect,
                    CMsgClientToGCPublishUserStat::mut_user_stats_event_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "reference_data",
                    CMsgClientToGCPublishUserStat::get_reference_data_for_reflect,
                    CMsgClientToGCPublishUserStat::mut_reference_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCPublishUserStat>(
                    "CMsgClientToGCPublishUserStat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCPublishUserStat {
    fn clear(&mut self) {
        self.clear_user_stats_event();
        self.clear_reference_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCPublishUserStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCPublishUserStat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCAddTI6TreeProgress {
    // message fields
    trees: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCAddTI6TreeProgress {}

impl CMsgClientToGCAddTI6TreeProgress {
    pub fn new() -> CMsgClientToGCAddTI6TreeProgress {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCAddTI6TreeProgress {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCAddTI6TreeProgress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCAddTI6TreeProgress,
        };
        unsafe {
            instance.get(CMsgClientToGCAddTI6TreeProgress::new)
        }
    }

    // optional uint32 trees = 1;

    pub fn clear_trees(&mut self) {
        self.trees = ::std::option::Option::None;
    }

    pub fn has_trees(&self) -> bool {
        self.trees.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trees(&mut self, v: u32) {
        self.trees = ::std::option::Option::Some(v);
    }

    pub fn get_trees(&self) -> u32 {
        self.trees.unwrap_or(0)
    }

    fn get_trees_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.trees
    }

    fn mut_trees_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.trees
    }
}

impl ::protobuf::Message for CMsgClientToGCAddTI6TreeProgress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.trees = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.trees {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.trees {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCAddTI6TreeProgress {
    fn new() -> CMsgClientToGCAddTI6TreeProgress {
        CMsgClientToGCAddTI6TreeProgress::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCAddTI6TreeProgress>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "trees",
                    CMsgClientToGCAddTI6TreeProgress::get_trees_for_reflect,
                    CMsgClientToGCAddTI6TreeProgress::mut_trees_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCAddTI6TreeProgress>(
                    "CMsgClientToGCAddTI6TreeProgress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCAddTI6TreeProgress {
    fn clear(&mut self) {
        self.clear_trees();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCAddTI6TreeProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCAddTI6TreeProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestLinaPlaysRemaining {
    // message fields
    event_id: ::std::option::Option<super::dota_shared_enums::EEvent>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestLinaPlaysRemaining {}

impl CMsgClientToGCRequestLinaPlaysRemaining {
    pub fn new() -> CMsgClientToGCRequestLinaPlaysRemaining {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestLinaPlaysRemaining {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestLinaPlaysRemaining> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestLinaPlaysRemaining,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestLinaPlaysRemaining::new)
        }
    }

    // optional .EEvent event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> super::dota_shared_enums::EEvent {
        self.event_id.unwrap_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::EEvent> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::EEvent> {
        &mut self.event_id
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestLinaPlaysRemaining {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestLinaPlaysRemaining {
    fn new() -> CMsgClientToGCRequestLinaPlaysRemaining {
        CMsgClientToGCRequestLinaPlaysRemaining::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestLinaPlaysRemaining>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::EEvent>>(
                    "event_id",
                    CMsgClientToGCRequestLinaPlaysRemaining::get_event_id_for_reflect,
                    CMsgClientToGCRequestLinaPlaysRemaining::mut_event_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestLinaPlaysRemaining>(
                    "CMsgClientToGCRequestLinaPlaysRemaining",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestLinaPlaysRemaining {
    fn clear(&mut self) {
        self.clear_event_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestLinaPlaysRemaining {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestLinaPlaysRemaining {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestLinaPlaysRemainingResponse {
    // message fields
    plays_remaining: ::std::option::Option<u32>,
    plays_total: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestLinaPlaysRemainingResponse {}

impl CMsgClientToGCRequestLinaPlaysRemainingResponse {
    pub fn new() -> CMsgClientToGCRequestLinaPlaysRemainingResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestLinaPlaysRemainingResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestLinaPlaysRemainingResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestLinaPlaysRemainingResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestLinaPlaysRemainingResponse::new)
        }
    }

    // optional uint32 plays_remaining = 1;

    pub fn clear_plays_remaining(&mut self) {
        self.plays_remaining = ::std::option::Option::None;
    }

    pub fn has_plays_remaining(&self) -> bool {
        self.plays_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plays_remaining(&mut self, v: u32) {
        self.plays_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_plays_remaining(&self) -> u32 {
        self.plays_remaining.unwrap_or(0)
    }

    fn get_plays_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.plays_remaining
    }

    fn mut_plays_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.plays_remaining
    }

    // optional uint32 plays_total = 2;

    pub fn clear_plays_total(&mut self) {
        self.plays_total = ::std::option::Option::None;
    }

    pub fn has_plays_total(&self) -> bool {
        self.plays_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plays_total(&mut self, v: u32) {
        self.plays_total = ::std::option::Option::Some(v);
    }

    pub fn get_plays_total(&self) -> u32 {
        self.plays_total.unwrap_or(0)
    }

    fn get_plays_total_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.plays_total
    }

    fn mut_plays_total_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.plays_total
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestLinaPlaysRemainingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.plays_remaining = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.plays_total = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.plays_remaining {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.plays_total {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.plays_remaining {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.plays_total {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestLinaPlaysRemainingResponse {
    fn new() -> CMsgClientToGCRequestLinaPlaysRemainingResponse {
        CMsgClientToGCRequestLinaPlaysRemainingResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestLinaPlaysRemainingResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "plays_remaining",
                    CMsgClientToGCRequestLinaPlaysRemainingResponse::get_plays_remaining_for_reflect,
                    CMsgClientToGCRequestLinaPlaysRemainingResponse::mut_plays_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "plays_total",
                    CMsgClientToGCRequestLinaPlaysRemainingResponse::get_plays_total_for_reflect,
                    CMsgClientToGCRequestLinaPlaysRemainingResponse::mut_plays_total_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestLinaPlaysRemainingResponse>(
                    "CMsgClientToGCRequestLinaPlaysRemainingResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestLinaPlaysRemainingResponse {
    fn clear(&mut self) {
        self.clear_plays_remaining();
        self.clear_plays_total();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestLinaPlaysRemainingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestLinaPlaysRemainingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestLinaGameResult {
    // message fields
    event_id: ::std::option::Option<super::dota_shared_enums::EEvent>,
    slot_chosen: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestLinaGameResult {}

impl CMsgClientToGCRequestLinaGameResult {
    pub fn new() -> CMsgClientToGCRequestLinaGameResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestLinaGameResult {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestLinaGameResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestLinaGameResult,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestLinaGameResult::new)
        }
    }

    // optional .EEvent event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> super::dota_shared_enums::EEvent {
        self.event_id.unwrap_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::EEvent> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::EEvent> {
        &mut self.event_id
    }

    // optional uint32 slot_chosen = 2;

    pub fn clear_slot_chosen(&mut self) {
        self.slot_chosen = ::std::option::Option::None;
    }

    pub fn has_slot_chosen(&self) -> bool {
        self.slot_chosen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_chosen(&mut self, v: u32) {
        self.slot_chosen = ::std::option::Option::Some(v);
    }

    pub fn get_slot_chosen(&self) -> u32 {
        self.slot_chosen.unwrap_or(0)
    }

    fn get_slot_chosen_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_chosen
    }

    fn mut_slot_chosen_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_chosen
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestLinaGameResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_chosen = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.slot_chosen {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.slot_chosen {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestLinaGameResult {
    fn new() -> CMsgClientToGCRequestLinaGameResult {
        CMsgClientToGCRequestLinaGameResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestLinaGameResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::EEvent>>(
                    "event_id",
                    CMsgClientToGCRequestLinaGameResult::get_event_id_for_reflect,
                    CMsgClientToGCRequestLinaGameResult::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_chosen",
                    CMsgClientToGCRequestLinaGameResult::get_slot_chosen_for_reflect,
                    CMsgClientToGCRequestLinaGameResult::mut_slot_chosen_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestLinaGameResult>(
                    "CMsgClientToGCRequestLinaGameResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestLinaGameResult {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_slot_chosen();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestLinaGameResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestLinaGameResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestLinaGameResultResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestLinaGameResultResponse {}

impl CMsgClientToGCRequestLinaGameResultResponse {
    pub fn new() -> CMsgClientToGCRequestLinaGameResultResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestLinaGameResultResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestLinaGameResultResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestLinaGameResultResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestLinaGameResultResponse::new)
        }
    }

    // optional uint32 result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestLinaGameResultResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestLinaGameResultResponse {
    fn new() -> CMsgClientToGCRequestLinaGameResultResponse {
        CMsgClientToGCRequestLinaGameResultResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestLinaGameResultResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "result",
                    CMsgClientToGCRequestLinaGameResultResponse::get_result_for_reflect,
                    CMsgClientToGCRequestLinaGameResultResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestLinaGameResultResponse>(
                    "CMsgClientToGCRequestLinaGameResultResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestLinaGameResultResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestLinaGameResultResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestLinaGameResultResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestSlarkGameResult {
    // message fields
    event_id: ::std::option::Option<super::dota_shared_enums::EEvent>,
    slot_chosen: ::std::option::Option<u32>,
    week: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestSlarkGameResult {}

impl CMsgClientToGCRequestSlarkGameResult {
    pub fn new() -> CMsgClientToGCRequestSlarkGameResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestSlarkGameResult {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestSlarkGameResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestSlarkGameResult,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestSlarkGameResult::new)
        }
    }

    // optional .EEvent event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> super::dota_shared_enums::EEvent {
        self.event_id.unwrap_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::EEvent> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::EEvent> {
        &mut self.event_id
    }

    // optional uint32 slot_chosen = 2;

    pub fn clear_slot_chosen(&mut self) {
        self.slot_chosen = ::std::option::Option::None;
    }

    pub fn has_slot_chosen(&self) -> bool {
        self.slot_chosen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_chosen(&mut self, v: u32) {
        self.slot_chosen = ::std::option::Option::Some(v);
    }

    pub fn get_slot_chosen(&self) -> u32 {
        self.slot_chosen.unwrap_or(0)
    }

    fn get_slot_chosen_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_chosen
    }

    fn mut_slot_chosen_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_chosen
    }

    // optional uint32 week = 3;

    pub fn clear_week(&mut self) {
        self.week = ::std::option::Option::None;
    }

    pub fn has_week(&self) -> bool {
        self.week.is_some()
    }

    // Param is passed by value, moved
    pub fn set_week(&mut self, v: u32) {
        self.week = ::std::option::Option::Some(v);
    }

    pub fn get_week(&self) -> u32 {
        self.week.unwrap_or(0)
    }

    fn get_week_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.week
    }

    fn mut_week_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.week
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestSlarkGameResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_chosen = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.week = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.slot_chosen {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.week {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.slot_chosen {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.week {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestSlarkGameResult {
    fn new() -> CMsgClientToGCRequestSlarkGameResult {
        CMsgClientToGCRequestSlarkGameResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestSlarkGameResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::EEvent>>(
                    "event_id",
                    CMsgClientToGCRequestSlarkGameResult::get_event_id_for_reflect,
                    CMsgClientToGCRequestSlarkGameResult::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_chosen",
                    CMsgClientToGCRequestSlarkGameResult::get_slot_chosen_for_reflect,
                    CMsgClientToGCRequestSlarkGameResult::mut_slot_chosen_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "week",
                    CMsgClientToGCRequestSlarkGameResult::get_week_for_reflect,
                    CMsgClientToGCRequestSlarkGameResult::mut_week_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestSlarkGameResult>(
                    "CMsgClientToGCRequestSlarkGameResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestSlarkGameResult {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_slot_chosen();
        self.clear_week();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestSlarkGameResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestSlarkGameResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRequestSlarkGameResultResponse {
    // message fields
    points_won: ::std::option::Option<u32>,
    aura_won: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRequestSlarkGameResultResponse {}

impl CMsgClientToGCRequestSlarkGameResultResponse {
    pub fn new() -> CMsgClientToGCRequestSlarkGameResultResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRequestSlarkGameResultResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRequestSlarkGameResultResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRequestSlarkGameResultResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCRequestSlarkGameResultResponse::new)
        }
    }

    // optional uint32 points_won = 1;

    pub fn clear_points_won(&mut self) {
        self.points_won = ::std::option::Option::None;
    }

    pub fn has_points_won(&self) -> bool {
        self.points_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_won(&mut self, v: u32) {
        self.points_won = ::std::option::Option::Some(v);
    }

    pub fn get_points_won(&self) -> u32 {
        self.points_won.unwrap_or(0)
    }

    fn get_points_won_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points_won
    }

    fn mut_points_won_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points_won
    }

    // optional bool aura_won = 2;

    pub fn clear_aura_won(&mut self) {
        self.aura_won = ::std::option::Option::None;
    }

    pub fn has_aura_won(&self) -> bool {
        self.aura_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aura_won(&mut self, v: bool) {
        self.aura_won = ::std::option::Option::Some(v);
    }

    pub fn get_aura_won(&self) -> bool {
        self.aura_won.unwrap_or(false)
    }

    fn get_aura_won_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.aura_won
    }

    fn mut_aura_won_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.aura_won
    }
}

impl ::protobuf::Message for CMsgClientToGCRequestSlarkGameResultResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_won = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.aura_won = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.points_won {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.aura_won {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.points_won {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.aura_won {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRequestSlarkGameResultResponse {
    fn new() -> CMsgClientToGCRequestSlarkGameResultResponse {
        CMsgClientToGCRequestSlarkGameResultResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRequestSlarkGameResultResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points_won",
                    CMsgClientToGCRequestSlarkGameResultResponse::get_points_won_for_reflect,
                    CMsgClientToGCRequestSlarkGameResultResponse::mut_points_won_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "aura_won",
                    CMsgClientToGCRequestSlarkGameResultResponse::get_aura_won_for_reflect,
                    CMsgClientToGCRequestSlarkGameResultResponse::mut_aura_won_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRequestSlarkGameResultResponse>(
                    "CMsgClientToGCRequestSlarkGameResultResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRequestSlarkGameResultResponse {
    fn clear(&mut self) {
        self.clear_points_won();
        self.clear_aura_won();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRequestSlarkGameResultResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRequestSlarkGameResultResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientQuestProgressUpdated {
    // message fields
    quest_id: ::std::option::Option<u32>,
    completed_challenges: ::protobuf::RepeatedField<CMsgGCToClientQuestProgressUpdated_Challenge>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientQuestProgressUpdated {}

impl CMsgGCToClientQuestProgressUpdated {
    pub fn new() -> CMsgGCToClientQuestProgressUpdated {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientQuestProgressUpdated {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientQuestProgressUpdated> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientQuestProgressUpdated,
        };
        unsafe {
            instance.get(CMsgGCToClientQuestProgressUpdated::new)
        }
    }

    // optional uint32 quest_id = 1;

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u32) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    pub fn get_quest_id(&self) -> u32 {
        self.quest_id.unwrap_or(0)
    }

    fn get_quest_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.quest_id
    }

    fn mut_quest_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.quest_id
    }

    // repeated .CMsgGCToClientQuestProgressUpdated.Challenge completed_challenges = 2;

    pub fn clear_completed_challenges(&mut self) {
        self.completed_challenges.clear();
    }

    // Param is passed by value, moved
    pub fn set_completed_challenges(&mut self, v: ::protobuf::RepeatedField<CMsgGCToClientQuestProgressUpdated_Challenge>) {
        self.completed_challenges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_completed_challenges(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientQuestProgressUpdated_Challenge> {
        &mut self.completed_challenges
    }

    // Take field
    pub fn take_completed_challenges(&mut self) -> ::protobuf::RepeatedField<CMsgGCToClientQuestProgressUpdated_Challenge> {
        ::std::mem::replace(&mut self.completed_challenges, ::protobuf::RepeatedField::new())
    }

    pub fn get_completed_challenges(&self) -> &[CMsgGCToClientQuestProgressUpdated_Challenge] {
        &self.completed_challenges
    }

    fn get_completed_challenges_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCToClientQuestProgressUpdated_Challenge> {
        &self.completed_challenges
    }

    fn mut_completed_challenges_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientQuestProgressUpdated_Challenge> {
        &mut self.completed_challenges
    }
}

impl ::protobuf::Message for CMsgGCToClientQuestProgressUpdated {
    fn is_initialized(&self) -> bool {
        for v in &self.completed_challenges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.completed_challenges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.completed_challenges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.completed_challenges {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientQuestProgressUpdated {
    fn new() -> CMsgGCToClientQuestProgressUpdated {
        CMsgGCToClientQuestProgressUpdated::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientQuestProgressUpdated>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quest_id",
                    CMsgGCToClientQuestProgressUpdated::get_quest_id_for_reflect,
                    CMsgGCToClientQuestProgressUpdated::mut_quest_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientQuestProgressUpdated_Challenge>>(
                    "completed_challenges",
                    CMsgGCToClientQuestProgressUpdated::get_completed_challenges_for_reflect,
                    CMsgGCToClientQuestProgressUpdated::mut_completed_challenges_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientQuestProgressUpdated>(
                    "CMsgGCToClientQuestProgressUpdated",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientQuestProgressUpdated {
    fn clear(&mut self) {
        self.clear_quest_id();
        self.clear_completed_challenges();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientQuestProgressUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientQuestProgressUpdated {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientQuestProgressUpdated_Challenge {
    // message fields
    challenge_id: ::std::option::Option<u32>,
    time_completed: ::std::option::Option<u32>,
    attempts: ::std::option::Option<u32>,
    hero_id: ::std::option::Option<u32>,
    challenge_type: ::std::option::Option<u32>,
    quest_rank: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientQuestProgressUpdated_Challenge {}

impl CMsgGCToClientQuestProgressUpdated_Challenge {
    pub fn new() -> CMsgGCToClientQuestProgressUpdated_Challenge {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientQuestProgressUpdated_Challenge {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientQuestProgressUpdated_Challenge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientQuestProgressUpdated_Challenge,
        };
        unsafe {
            instance.get(CMsgGCToClientQuestProgressUpdated_Challenge::new)
        }
    }

    // optional uint32 challenge_id = 1;

    pub fn clear_challenge_id(&mut self) {
        self.challenge_id = ::std::option::Option::None;
    }

    pub fn has_challenge_id(&self) -> bool {
        self.challenge_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_id(&mut self, v: u32) {
        self.challenge_id = ::std::option::Option::Some(v);
    }

    pub fn get_challenge_id(&self) -> u32 {
        self.challenge_id.unwrap_or(0)
    }

    fn get_challenge_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.challenge_id
    }

    fn mut_challenge_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.challenge_id
    }

    // optional uint32 time_completed = 2;

    pub fn clear_time_completed(&mut self) {
        self.time_completed = ::std::option::Option::None;
    }

    pub fn has_time_completed(&self) -> bool {
        self.time_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_completed(&mut self, v: u32) {
        self.time_completed = ::std::option::Option::Some(v);
    }

    pub fn get_time_completed(&self) -> u32 {
        self.time_completed.unwrap_or(0)
    }

    fn get_time_completed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time_completed
    }

    fn mut_time_completed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time_completed
    }

    // optional uint32 attempts = 3;

    pub fn clear_attempts(&mut self) {
        self.attempts = ::std::option::Option::None;
    }

    pub fn has_attempts(&self) -> bool {
        self.attempts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attempts(&mut self, v: u32) {
        self.attempts = ::std::option::Option::Some(v);
    }

    pub fn get_attempts(&self) -> u32 {
        self.attempts.unwrap_or(0)
    }

    fn get_attempts_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.attempts
    }

    fn mut_attempts_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.attempts
    }

    // optional uint32 hero_id = 4;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 challenge_type = 5;

    pub fn clear_challenge_type(&mut self) {
        self.challenge_type = ::std::option::Option::None;
    }

    pub fn has_challenge_type(&self) -> bool {
        self.challenge_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_type(&mut self, v: u32) {
        self.challenge_type = ::std::option::Option::Some(v);
    }

    pub fn get_challenge_type(&self) -> u32 {
        self.challenge_type.unwrap_or(0)
    }

    fn get_challenge_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.challenge_type
    }

    fn mut_challenge_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.challenge_type
    }

    // optional uint32 quest_rank = 6;

    pub fn clear_quest_rank(&mut self) {
        self.quest_rank = ::std::option::Option::None;
    }

    pub fn has_quest_rank(&self) -> bool {
        self.quest_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_rank(&mut self, v: u32) {
        self.quest_rank = ::std::option::Option::Some(v);
    }

    pub fn get_quest_rank(&self) -> u32 {
        self.quest_rank.unwrap_or(0)
    }

    fn get_quest_rank_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.quest_rank
    }

    fn mut_quest_rank_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.quest_rank
    }
}

impl ::protobuf::Message for CMsgGCToClientQuestProgressUpdated_Challenge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.challenge_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_completed = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.attempts = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.challenge_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quest_rank = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.challenge_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_completed {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.attempts {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.challenge_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quest_rank {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.challenge_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time_completed {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.attempts {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.challenge_type {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.quest_rank {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientQuestProgressUpdated_Challenge {
    fn new() -> CMsgGCToClientQuestProgressUpdated_Challenge {
        CMsgGCToClientQuestProgressUpdated_Challenge::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientQuestProgressUpdated_Challenge>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "challenge_id",
                    CMsgGCToClientQuestProgressUpdated_Challenge::get_challenge_id_for_reflect,
                    CMsgGCToClientQuestProgressUpdated_Challenge::mut_challenge_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_completed",
                    CMsgGCToClientQuestProgressUpdated_Challenge::get_time_completed_for_reflect,
                    CMsgGCToClientQuestProgressUpdated_Challenge::mut_time_completed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "attempts",
                    CMsgGCToClientQuestProgressUpdated_Challenge::get_attempts_for_reflect,
                    CMsgGCToClientQuestProgressUpdated_Challenge::mut_attempts_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgGCToClientQuestProgressUpdated_Challenge::get_hero_id_for_reflect,
                    CMsgGCToClientQuestProgressUpdated_Challenge::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "challenge_type",
                    CMsgGCToClientQuestProgressUpdated_Challenge::get_challenge_type_for_reflect,
                    CMsgGCToClientQuestProgressUpdated_Challenge::mut_challenge_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quest_rank",
                    CMsgGCToClientQuestProgressUpdated_Challenge::get_quest_rank_for_reflect,
                    CMsgGCToClientQuestProgressUpdated_Challenge::mut_quest_rank_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientQuestProgressUpdated_Challenge>(
                    "CMsgGCToClientQuestProgressUpdated_Challenge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientQuestProgressUpdated_Challenge {
    fn clear(&mut self) {
        self.clear_challenge_id();
        self.clear_time_completed();
        self.clear_attempts();
        self.clear_hero_id();
        self.clear_challenge_type();
        self.clear_quest_rank();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientQuestProgressUpdated_Challenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientQuestProgressUpdated_Challenge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARedeemItem {
    // message fields
    currency_id: ::std::option::Option<u64>,
    purchase_def: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARedeemItem {}

impl CMsgDOTARedeemItem {
    pub fn new() -> CMsgDOTARedeemItem {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARedeemItem {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARedeemItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARedeemItem,
        };
        unsafe {
            instance.get(CMsgDOTARedeemItem::new)
        }
    }

    // optional uint64 currency_id = 1;

    pub fn clear_currency_id(&mut self) {
        self.currency_id = ::std::option::Option::None;
    }

    pub fn has_currency_id(&self) -> bool {
        self.currency_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency_id(&mut self, v: u64) {
        self.currency_id = ::std::option::Option::Some(v);
    }

    pub fn get_currency_id(&self) -> u64 {
        self.currency_id.unwrap_or(0)
    }

    fn get_currency_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.currency_id
    }

    fn mut_currency_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.currency_id
    }

    // optional uint32 purchase_def = 2;

    pub fn clear_purchase_def(&mut self) {
        self.purchase_def = ::std::option::Option::None;
    }

    pub fn has_purchase_def(&self) -> bool {
        self.purchase_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_def(&mut self, v: u32) {
        self.purchase_def = ::std::option::Option::Some(v);
    }

    pub fn get_purchase_def(&self) -> u32 {
        self.purchase_def.unwrap_or(0)
    }

    fn get_purchase_def_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.purchase_def
    }

    fn mut_purchase_def_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.purchase_def
    }
}

impl ::protobuf::Message for CMsgDOTARedeemItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.currency_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.purchase_def = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.currency_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.purchase_def {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.currency_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.purchase_def {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARedeemItem {
    fn new() -> CMsgDOTARedeemItem {
        CMsgDOTARedeemItem::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARedeemItem>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "currency_id",
                    CMsgDOTARedeemItem::get_currency_id_for_reflect,
                    CMsgDOTARedeemItem::mut_currency_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "purchase_def",
                    CMsgDOTARedeemItem::get_purchase_def_for_reflect,
                    CMsgDOTARedeemItem::mut_purchase_def_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARedeemItem>(
                    "CMsgDOTARedeemItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARedeemItem {
    fn clear(&mut self) {
        self.clear_currency_id();
        self.clear_purchase_def();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARedeemItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARedeemItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTARedeemItemResponse {
    // message fields
    response: ::std::option::Option<CMsgDOTARedeemItemResponse_EResultCode>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTARedeemItemResponse {}

impl CMsgDOTARedeemItemResponse {
    pub fn new() -> CMsgDOTARedeemItemResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTARedeemItemResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTARedeemItemResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTARedeemItemResponse,
        };
        unsafe {
            instance.get(CMsgDOTARedeemItemResponse::new)
        }
    }

    // optional .CMsgDOTARedeemItemResponse.EResultCode response = 1;

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: CMsgDOTARedeemItemResponse_EResultCode) {
        self.response = ::std::option::Option::Some(v);
    }

    pub fn get_response(&self) -> CMsgDOTARedeemItemResponse_EResultCode {
        self.response.unwrap_or(CMsgDOTARedeemItemResponse_EResultCode::k_Succeeded)
    }

    fn get_response_for_reflect(&self) -> &::std::option::Option<CMsgDOTARedeemItemResponse_EResultCode> {
        &self.response
    }

    fn mut_response_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTARedeemItemResponse_EResultCode> {
        &mut self.response
    }
}

impl ::protobuf::Message for CMsgDOTARedeemItemResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.response = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.response {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTARedeemItemResponse {
    fn new() -> CMsgDOTARedeemItemResponse {
        CMsgDOTARedeemItemResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTARedeemItemResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTARedeemItemResponse_EResultCode>>(
                    "response",
                    CMsgDOTARedeemItemResponse::get_response_for_reflect,
                    CMsgDOTARedeemItemResponse::mut_response_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTARedeemItemResponse>(
                    "CMsgDOTARedeemItemResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTARedeemItemResponse {
    fn clear(&mut self) {
        self.clear_response();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTARedeemItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARedeemItemResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTARedeemItemResponse_EResultCode {
    k_Succeeded = 0,
    k_Failed = 1,
}

impl ::protobuf::ProtobufEnum for CMsgDOTARedeemItemResponse_EResultCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTARedeemItemResponse_EResultCode> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTARedeemItemResponse_EResultCode::k_Succeeded),
            1 => ::std::option::Option::Some(CMsgDOTARedeemItemResponse_EResultCode::k_Failed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTARedeemItemResponse_EResultCode] = &[
            CMsgDOTARedeemItemResponse_EResultCode::k_Succeeded,
            CMsgDOTARedeemItemResponse_EResultCode::k_Failed,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTARedeemItemResponse_EResultCode>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTARedeemItemResponse_EResultCode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTARedeemItemResponse_EResultCode {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTARedeemItemResponse_EResultCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPerfectWorldUserLookupRequest {
    // message fields
    user_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgPerfectWorldUserLookupRequest {}

impl CMsgPerfectWorldUserLookupRequest {
    pub fn new() -> CMsgPerfectWorldUserLookupRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgPerfectWorldUserLookupRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPerfectWorldUserLookupRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPerfectWorldUserLookupRequest,
        };
        unsafe {
            instance.get(CMsgPerfectWorldUserLookupRequest::new)
        }
    }

    // optional string user_name = 1;

    pub fn clear_user_name(&mut self) {
        self.user_name.clear();
    }

    pub fn has_user_name(&self) -> bool {
        self.user_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_name(&mut self, v: ::std::string::String) {
        self.user_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_name(&mut self) -> &mut ::std::string::String {
        if self.user_name.is_none() {
            self.user_name.set_default();
        }
        self.user_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_name(&mut self) -> ::std::string::String {
        self.user_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_user_name(&self) -> &str {
        match self.user_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_user_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.user_name
    }

    fn mut_user_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.user_name
    }
}

impl ::protobuf::Message for CMsgPerfectWorldUserLookupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_name.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgPerfectWorldUserLookupRequest {
    fn new() -> CMsgPerfectWorldUserLookupRequest {
        CMsgPerfectWorldUserLookupRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgPerfectWorldUserLookupRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_name",
                    CMsgPerfectWorldUserLookupRequest::get_user_name_for_reflect,
                    CMsgPerfectWorldUserLookupRequest::mut_user_name_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPerfectWorldUserLookupRequest>(
                    "CMsgPerfectWorldUserLookupRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgPerfectWorldUserLookupRequest {
    fn clear(&mut self) {
        self.clear_user_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPerfectWorldUserLookupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPerfectWorldUserLookupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPerfectWorldUserLookupResponse {
    // message fields
    result_code: ::std::option::Option<CMsgPerfectWorldUserLookupResponse_EResultCode>,
    account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgPerfectWorldUserLookupResponse {}

impl CMsgPerfectWorldUserLookupResponse {
    pub fn new() -> CMsgPerfectWorldUserLookupResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgPerfectWorldUserLookupResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPerfectWorldUserLookupResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPerfectWorldUserLookupResponse,
        };
        unsafe {
            instance.get(CMsgPerfectWorldUserLookupResponse::new)
        }
    }

    // optional .CMsgPerfectWorldUserLookupResponse.EResultCode result_code = 1;

    pub fn clear_result_code(&mut self) {
        self.result_code = ::std::option::Option::None;
    }

    pub fn has_result_code(&self) -> bool {
        self.result_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_code(&mut self, v: CMsgPerfectWorldUserLookupResponse_EResultCode) {
        self.result_code = ::std::option::Option::Some(v);
    }

    pub fn get_result_code(&self) -> CMsgPerfectWorldUserLookupResponse_EResultCode {
        self.result_code.unwrap_or(CMsgPerfectWorldUserLookupResponse_EResultCode::SUCCESS_ACCOUNT_FOUND)
    }

    fn get_result_code_for_reflect(&self) -> &::std::option::Option<CMsgPerfectWorldUserLookupResponse_EResultCode> {
        &self.result_code
    }

    fn mut_result_code_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgPerfectWorldUserLookupResponse_EResultCode> {
        &mut self.result_code
    }

    // optional uint32 account_id = 2;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgPerfectWorldUserLookupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result_code = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result_code {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result_code {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgPerfectWorldUserLookupResponse {
    fn new() -> CMsgPerfectWorldUserLookupResponse {
        CMsgPerfectWorldUserLookupResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgPerfectWorldUserLookupResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgPerfectWorldUserLookupResponse_EResultCode>>(
                    "result_code",
                    CMsgPerfectWorldUserLookupResponse::get_result_code_for_reflect,
                    CMsgPerfectWorldUserLookupResponse::mut_result_code_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgPerfectWorldUserLookupResponse::get_account_id_for_reflect,
                    CMsgPerfectWorldUserLookupResponse::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPerfectWorldUserLookupResponse>(
                    "CMsgPerfectWorldUserLookupResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgPerfectWorldUserLookupResponse {
    fn clear(&mut self) {
        self.clear_result_code();
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPerfectWorldUserLookupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPerfectWorldUserLookupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgPerfectWorldUserLookupResponse_EResultCode {
    SUCCESS_ACCOUNT_FOUND = 0,
    ERROR_UNKNOWN = 1,
    ERROR_USER_NAME_WRONG_FORMAT = 2,
    ERROR_NO_PERFECT_WORLD_ACCOUNT_FOUND = 3,
    ERROR_NO_LINKED_STEAM_ACCOUNT_FOUND = 4,
}

impl ::protobuf::ProtobufEnum for CMsgPerfectWorldUserLookupResponse_EResultCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgPerfectWorldUserLookupResponse_EResultCode> {
        match value {
            0 => ::std::option::Option::Some(CMsgPerfectWorldUserLookupResponse_EResultCode::SUCCESS_ACCOUNT_FOUND),
            1 => ::std::option::Option::Some(CMsgPerfectWorldUserLookupResponse_EResultCode::ERROR_UNKNOWN),
            2 => ::std::option::Option::Some(CMsgPerfectWorldUserLookupResponse_EResultCode::ERROR_USER_NAME_WRONG_FORMAT),
            3 => ::std::option::Option::Some(CMsgPerfectWorldUserLookupResponse_EResultCode::ERROR_NO_PERFECT_WORLD_ACCOUNT_FOUND),
            4 => ::std::option::Option::Some(CMsgPerfectWorldUserLookupResponse_EResultCode::ERROR_NO_LINKED_STEAM_ACCOUNT_FOUND),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgPerfectWorldUserLookupResponse_EResultCode] = &[
            CMsgPerfectWorldUserLookupResponse_EResultCode::SUCCESS_ACCOUNT_FOUND,
            CMsgPerfectWorldUserLookupResponse_EResultCode::ERROR_UNKNOWN,
            CMsgPerfectWorldUserLookupResponse_EResultCode::ERROR_USER_NAME_WRONG_FORMAT,
            CMsgPerfectWorldUserLookupResponse_EResultCode::ERROR_NO_PERFECT_WORLD_ACCOUNT_FOUND,
            CMsgPerfectWorldUserLookupResponse_EResultCode::ERROR_NO_LINKED_STEAM_ACCOUNT_FOUND,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgPerfectWorldUserLookupResponse_EResultCode>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgPerfectWorldUserLookupResponse_EResultCode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgPerfectWorldUserLookupResponse_EResultCode {
}

impl ::protobuf::reflect::ProtobufValue for CMsgPerfectWorldUserLookupResponse_EResultCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgNexonPartnerUpdate {
    // message fields
    messagetype: ::std::option::Option<u32>,
    timeremaining: ::std::option::Option<u32>,
    terminate: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgNexonPartnerUpdate {}

impl CMsgNexonPartnerUpdate {
    pub fn new() -> CMsgNexonPartnerUpdate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgNexonPartnerUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgNexonPartnerUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgNexonPartnerUpdate,
        };
        unsafe {
            instance.get(CMsgNexonPartnerUpdate::new)
        }
    }

    // optional uint32 messagetype = 1;

    pub fn clear_messagetype(&mut self) {
        self.messagetype = ::std::option::Option::None;
    }

    pub fn has_messagetype(&self) -> bool {
        self.messagetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messagetype(&mut self, v: u32) {
        self.messagetype = ::std::option::Option::Some(v);
    }

    pub fn get_messagetype(&self) -> u32 {
        self.messagetype.unwrap_or(0)
    }

    fn get_messagetype_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.messagetype
    }

    fn mut_messagetype_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.messagetype
    }

    // optional uint32 timeremaining = 2;

    pub fn clear_timeremaining(&mut self) {
        self.timeremaining = ::std::option::Option::None;
    }

    pub fn has_timeremaining(&self) -> bool {
        self.timeremaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeremaining(&mut self, v: u32) {
        self.timeremaining = ::std::option::Option::Some(v);
    }

    pub fn get_timeremaining(&self) -> u32 {
        self.timeremaining.unwrap_or(0)
    }

    fn get_timeremaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timeremaining
    }

    fn mut_timeremaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timeremaining
    }

    // optional bool terminate = 3;

    pub fn clear_terminate(&mut self) {
        self.terminate = ::std::option::Option::None;
    }

    pub fn has_terminate(&self) -> bool {
        self.terminate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminate(&mut self, v: bool) {
        self.terminate = ::std::option::Option::Some(v);
    }

    pub fn get_terminate(&self) -> bool {
        self.terminate.unwrap_or(false)
    }

    fn get_terminate_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.terminate
    }

    fn mut_terminate_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.terminate
    }
}

impl ::protobuf::Message for CMsgNexonPartnerUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.messagetype = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeremaining = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.terminate = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.messagetype {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeremaining {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.terminate {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.messagetype {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timeremaining {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.terminate {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgNexonPartnerUpdate {
    fn new() -> CMsgNexonPartnerUpdate {
        CMsgNexonPartnerUpdate::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgNexonPartnerUpdate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "messagetype",
                    CMsgNexonPartnerUpdate::get_messagetype_for_reflect,
                    CMsgNexonPartnerUpdate::mut_messagetype_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timeremaining",
                    CMsgNexonPartnerUpdate::get_timeremaining_for_reflect,
                    CMsgNexonPartnerUpdate::mut_timeremaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "terminate",
                    CMsgNexonPartnerUpdate::get_terminate_for_reflect,
                    CMsgNexonPartnerUpdate::mut_terminate_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgNexonPartnerUpdate>(
                    "CMsgNexonPartnerUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgNexonPartnerUpdate {
    fn clear(&mut self) {
        self.clear_messagetype();
        self.clear_timeremaining();
        self.clear_terminate();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgNexonPartnerUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgNexonPartnerUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgMakeOffering {
    // message fields
    item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgMakeOffering {}

impl CMsgMakeOffering {
    pub fn new() -> CMsgMakeOffering {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgMakeOffering {
        static mut instance: ::protobuf::lazy::Lazy<CMsgMakeOffering> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgMakeOffering,
        };
        unsafe {
            instance.get(CMsgMakeOffering::new)
        }
    }

    // optional uint64 item_id = 1;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }
}

impl ::protobuf::Message for CMsgMakeOffering {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgMakeOffering {
    fn new() -> CMsgMakeOffering {
        CMsgMakeOffering::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgMakeOffering>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgMakeOffering::get_item_id_for_reflect,
                    CMsgMakeOffering::mut_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgMakeOffering>(
                    "CMsgMakeOffering",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgMakeOffering {
    fn clear(&mut self) {
        self.clear_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMakeOffering {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMakeOffering {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestOfferings {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgRequestOfferings {}

impl CMsgRequestOfferings {
    pub fn new() -> CMsgRequestOfferings {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgRequestOfferings {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRequestOfferings> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRequestOfferings,
        };
        unsafe {
            instance.get(CMsgRequestOfferings::new)
        }
    }
}

impl ::protobuf::Message for CMsgRequestOfferings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgRequestOfferings {
    fn new() -> CMsgRequestOfferings {
        CMsgRequestOfferings::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgRequestOfferings>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRequestOfferings>(
                    "CMsgRequestOfferings",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgRequestOfferings {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestOfferings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestOfferings {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestOfferingsResponse {
    // message fields
    offerings: ::protobuf::RepeatedField<CMsgRequestOfferingsResponse_NewYearsOffering>,
    completed: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgRequestOfferingsResponse {}

impl CMsgRequestOfferingsResponse {
    pub fn new() -> CMsgRequestOfferingsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgRequestOfferingsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRequestOfferingsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRequestOfferingsResponse,
        };
        unsafe {
            instance.get(CMsgRequestOfferingsResponse::new)
        }
    }

    // repeated .CMsgRequestOfferingsResponse.NewYearsOffering offerings = 1;

    pub fn clear_offerings(&mut self) {
        self.offerings.clear();
    }

    // Param is passed by value, moved
    pub fn set_offerings(&mut self, v: ::protobuf::RepeatedField<CMsgRequestOfferingsResponse_NewYearsOffering>) {
        self.offerings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_offerings(&mut self) -> &mut ::protobuf::RepeatedField<CMsgRequestOfferingsResponse_NewYearsOffering> {
        &mut self.offerings
    }

    // Take field
    pub fn take_offerings(&mut self) -> ::protobuf::RepeatedField<CMsgRequestOfferingsResponse_NewYearsOffering> {
        ::std::mem::replace(&mut self.offerings, ::protobuf::RepeatedField::new())
    }

    pub fn get_offerings(&self) -> &[CMsgRequestOfferingsResponse_NewYearsOffering] {
        &self.offerings
    }

    fn get_offerings_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgRequestOfferingsResponse_NewYearsOffering> {
        &self.offerings
    }

    fn mut_offerings_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgRequestOfferingsResponse_NewYearsOffering> {
        &mut self.offerings
    }

    // optional bool completed = 2;

    pub fn clear_completed(&mut self) {
        self.completed = ::std::option::Option::None;
    }

    pub fn has_completed(&self) -> bool {
        self.completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed(&mut self, v: bool) {
        self.completed = ::std::option::Option::Some(v);
    }

    pub fn get_completed(&self) -> bool {
        self.completed.unwrap_or(false)
    }

    fn get_completed_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.completed
    }

    fn mut_completed_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.completed
    }
}

impl ::protobuf::Message for CMsgRequestOfferingsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.offerings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.offerings)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.completed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.offerings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.completed {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.offerings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.completed {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgRequestOfferingsResponse {
    fn new() -> CMsgRequestOfferingsResponse {
        CMsgRequestOfferingsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgRequestOfferingsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgRequestOfferingsResponse_NewYearsOffering>>(
                    "offerings",
                    CMsgRequestOfferingsResponse::get_offerings_for_reflect,
                    CMsgRequestOfferingsResponse::mut_offerings_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "completed",
                    CMsgRequestOfferingsResponse::get_completed_for_reflect,
                    CMsgRequestOfferingsResponse::mut_completed_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRequestOfferingsResponse>(
                    "CMsgRequestOfferingsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgRequestOfferingsResponse {
    fn clear(&mut self) {
        self.clear_offerings();
        self.clear_completed();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestOfferingsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestOfferingsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestOfferingsResponse_NewYearsOffering {
    // message fields
    def_index: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgRequestOfferingsResponse_NewYearsOffering {}

impl CMsgRequestOfferingsResponse_NewYearsOffering {
    pub fn new() -> CMsgRequestOfferingsResponse_NewYearsOffering {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgRequestOfferingsResponse_NewYearsOffering {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRequestOfferingsResponse_NewYearsOffering> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRequestOfferingsResponse_NewYearsOffering,
        };
        unsafe {
            instance.get(CMsgRequestOfferingsResponse_NewYearsOffering::new)
        }
    }

    // optional uint32 def_index = 1;

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    fn get_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.def_index
    }

    fn mut_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.def_index
    }

    // optional uint64 item_id = 2;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }
}

impl ::protobuf::Message for CMsgRequestOfferingsResponse_NewYearsOffering {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgRequestOfferingsResponse_NewYearsOffering {
    fn new() -> CMsgRequestOfferingsResponse_NewYearsOffering {
        CMsgRequestOfferingsResponse_NewYearsOffering::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgRequestOfferingsResponse_NewYearsOffering>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "def_index",
                    CMsgRequestOfferingsResponse_NewYearsOffering::get_def_index_for_reflect,
                    CMsgRequestOfferingsResponse_NewYearsOffering::mut_def_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgRequestOfferingsResponse_NewYearsOffering::get_item_id_for_reflect,
                    CMsgRequestOfferingsResponse_NewYearsOffering::mut_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRequestOfferingsResponse_NewYearsOffering>(
                    "CMsgRequestOfferingsResponse_NewYearsOffering",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgRequestOfferingsResponse_NewYearsOffering {
    fn clear(&mut self) {
        self.clear_def_index();
        self.clear_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestOfferingsResponse_NewYearsOffering {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestOfferingsResponse_NewYearsOffering {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAPCBangTimedReward {
    // message fields
    persona: ::protobuf::SingularField<::std::string::String>,
    itemdef: ::std::option::Option<u32>,
    pcbangname: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAPCBangTimedReward {}

impl CMsgDOTAPCBangTimedReward {
    pub fn new() -> CMsgDOTAPCBangTimedReward {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAPCBangTimedReward {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAPCBangTimedReward> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAPCBangTimedReward,
        };
        unsafe {
            instance.get(CMsgDOTAPCBangTimedReward::new)
        }
    }

    // optional string persona = 1;

    pub fn clear_persona(&mut self) {
        self.persona.clear();
    }

    pub fn has_persona(&self) -> bool {
        self.persona.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona(&mut self, v: ::std::string::String) {
        self.persona = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona(&mut self) -> &mut ::std::string::String {
        if self.persona.is_none() {
            self.persona.set_default();
        }
        self.persona.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona(&mut self) -> ::std::string::String {
        self.persona.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_persona(&self) -> &str {
        match self.persona.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_persona_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.persona
    }

    fn mut_persona_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.persona
    }

    // optional uint32 itemdef = 2;

    pub fn clear_itemdef(&mut self) {
        self.itemdef = ::std::option::Option::None;
    }

    pub fn has_itemdef(&self) -> bool {
        self.itemdef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemdef(&mut self, v: u32) {
        self.itemdef = ::std::option::Option::Some(v);
    }

    pub fn get_itemdef(&self) -> u32 {
        self.itemdef.unwrap_or(0)
    }

    fn get_itemdef_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.itemdef
    }

    fn mut_itemdef_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.itemdef
    }

    // optional string pcbangname = 3;

    pub fn clear_pcbangname(&mut self) {
        self.pcbangname.clear();
    }

    pub fn has_pcbangname(&self) -> bool {
        self.pcbangname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pcbangname(&mut self, v: ::std::string::String) {
        self.pcbangname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pcbangname(&mut self) -> &mut ::std::string::String {
        if self.pcbangname.is_none() {
            self.pcbangname.set_default();
        }
        self.pcbangname.as_mut().unwrap()
    }

    // Take field
    pub fn take_pcbangname(&mut self) -> ::std::string::String {
        self.pcbangname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_pcbangname(&self) -> &str {
        match self.pcbangname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_pcbangname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.pcbangname
    }

    fn mut_pcbangname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.pcbangname
    }
}

impl ::protobuf::Message for CMsgDOTAPCBangTimedReward {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.itemdef = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pcbangname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.persona.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.itemdef {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pcbangname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.persona.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.itemdef {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.pcbangname.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAPCBangTimedReward {
    fn new() -> CMsgDOTAPCBangTimedReward {
        CMsgDOTAPCBangTimedReward::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAPCBangTimedReward>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "persona",
                    CMsgDOTAPCBangTimedReward::get_persona_for_reflect,
                    CMsgDOTAPCBangTimedReward::mut_persona_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "itemdef",
                    CMsgDOTAPCBangTimedReward::get_itemdef_for_reflect,
                    CMsgDOTAPCBangTimedReward::mut_itemdef_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pcbangname",
                    CMsgDOTAPCBangTimedReward::get_pcbangname_for_reflect,
                    CMsgDOTAPCBangTimedReward::mut_pcbangname_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAPCBangTimedReward>(
                    "CMsgDOTAPCBangTimedReward",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAPCBangTimedReward {
    fn clear(&mut self) {
        self.clear_persona();
        self.clear_itemdef();
        self.clear_pcbangname();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAPCBangTimedReward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAPCBangTimedReward {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTACompendiumInGamePredictionResults {
    // message fields
    results: ::protobuf::RepeatedField<CMsgDOTACompendiumInGamePredictionResults_PredictionResult>,
    league_id: ::std::option::Option<u32>,
    predictions_closed: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTACompendiumInGamePredictionResults {}

impl CMsgDOTACompendiumInGamePredictionResults {
    pub fn new() -> CMsgDOTACompendiumInGamePredictionResults {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTACompendiumInGamePredictionResults {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTACompendiumInGamePredictionResults> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTACompendiumInGamePredictionResults,
        };
        unsafe {
            instance.get(CMsgDOTACompendiumInGamePredictionResults::new)
        }
    }

    // repeated .CMsgDOTACompendiumInGamePredictionResults.PredictionResult results = 1;

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<CMsgDOTACompendiumInGamePredictionResults_PredictionResult>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTACompendiumInGamePredictionResults_PredictionResult> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<CMsgDOTACompendiumInGamePredictionResults_PredictionResult> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }

    pub fn get_results(&self) -> &[CMsgDOTACompendiumInGamePredictionResults_PredictionResult] {
        &self.results
    }

    fn get_results_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTACompendiumInGamePredictionResults_PredictionResult> {
        &self.results
    }

    fn mut_results_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTACompendiumInGamePredictionResults_PredictionResult> {
        &mut self.results
    }

    // optional uint32 league_id = 2;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional bool predictions_closed = 3;

    pub fn clear_predictions_closed(&mut self) {
        self.predictions_closed = ::std::option::Option::None;
    }

    pub fn has_predictions_closed(&self) -> bool {
        self.predictions_closed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_predictions_closed(&mut self, v: bool) {
        self.predictions_closed = ::std::option::Option::Some(v);
    }

    pub fn get_predictions_closed(&self) -> bool {
        self.predictions_closed.unwrap_or(false)
    }

    fn get_predictions_closed_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.predictions_closed
    }

    fn mut_predictions_closed_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.predictions_closed
    }
}

impl ::protobuf::Message for CMsgDOTACompendiumInGamePredictionResults {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.predictions_closed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.predictions_closed {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.results {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.league_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.predictions_closed {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTACompendiumInGamePredictionResults {
    fn new() -> CMsgDOTACompendiumInGamePredictionResults {
        CMsgDOTACompendiumInGamePredictionResults::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTACompendiumInGamePredictionResults>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTACompendiumInGamePredictionResults_PredictionResult>>(
                    "results",
                    CMsgDOTACompendiumInGamePredictionResults::get_results_for_reflect,
                    CMsgDOTACompendiumInGamePredictionResults::mut_results_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgDOTACompendiumInGamePredictionResults::get_league_id_for_reflect,
                    CMsgDOTACompendiumInGamePredictionResults::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "predictions_closed",
                    CMsgDOTACompendiumInGamePredictionResults::get_predictions_closed_for_reflect,
                    CMsgDOTACompendiumInGamePredictionResults::mut_predictions_closed_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTACompendiumInGamePredictionResults>(
                    "CMsgDOTACompendiumInGamePredictionResults",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTACompendiumInGamePredictionResults {
    fn clear(&mut self) {
        self.clear_results();
        self.clear_league_id();
        self.clear_predictions_closed();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTACompendiumInGamePredictionResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTACompendiumInGamePredictionResults {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTACompendiumInGamePredictionResults_PredictionResult {
    // message fields
    prediction_id: ::std::option::Option<u32>,
    prediction_value: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTACompendiumInGamePredictionResults_PredictionResult {}

impl CMsgDOTACompendiumInGamePredictionResults_PredictionResult {
    pub fn new() -> CMsgDOTACompendiumInGamePredictionResults_PredictionResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTACompendiumInGamePredictionResults_PredictionResult {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTACompendiumInGamePredictionResults_PredictionResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTACompendiumInGamePredictionResults_PredictionResult,
        };
        unsafe {
            instance.get(CMsgDOTACompendiumInGamePredictionResults_PredictionResult::new)
        }
    }

    // optional uint32 prediction_id = 1;

    pub fn clear_prediction_id(&mut self) {
        self.prediction_id = ::std::option::Option::None;
    }

    pub fn has_prediction_id(&self) -> bool {
        self.prediction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prediction_id(&mut self, v: u32) {
        self.prediction_id = ::std::option::Option::Some(v);
    }

    pub fn get_prediction_id(&self) -> u32 {
        self.prediction_id.unwrap_or(0)
    }

    fn get_prediction_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prediction_id
    }

    fn mut_prediction_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prediction_id
    }

    // optional uint32 prediction_value = 2;

    pub fn clear_prediction_value(&mut self) {
        self.prediction_value = ::std::option::Option::None;
    }

    pub fn has_prediction_value(&self) -> bool {
        self.prediction_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prediction_value(&mut self, v: u32) {
        self.prediction_value = ::std::option::Option::Some(v);
    }

    pub fn get_prediction_value(&self) -> u32 {
        self.prediction_value.unwrap_or(0)
    }

    fn get_prediction_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prediction_value
    }

    fn mut_prediction_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prediction_value
    }
}

impl ::protobuf::Message for CMsgDOTACompendiumInGamePredictionResults_PredictionResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prediction_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prediction_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.prediction_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prediction_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prediction_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.prediction_value {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTACompendiumInGamePredictionResults_PredictionResult {
    fn new() -> CMsgDOTACompendiumInGamePredictionResults_PredictionResult {
        CMsgDOTACompendiumInGamePredictionResults_PredictionResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTACompendiumInGamePredictionResults_PredictionResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prediction_id",
                    CMsgDOTACompendiumInGamePredictionResults_PredictionResult::get_prediction_id_for_reflect,
                    CMsgDOTACompendiumInGamePredictionResults_PredictionResult::mut_prediction_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prediction_value",
                    CMsgDOTACompendiumInGamePredictionResults_PredictionResult::get_prediction_value_for_reflect,
                    CMsgDOTACompendiumInGamePredictionResults_PredictionResult::mut_prediction_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTACompendiumInGamePredictionResults_PredictionResult>(
                    "CMsgDOTACompendiumInGamePredictionResults_PredictionResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTACompendiumInGamePredictionResults_PredictionResult {
    fn clear(&mut self) {
        self.clear_prediction_id();
        self.clear_prediction_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTACompendiumInGamePredictionResults_PredictionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTACompendiumInGamePredictionResults_PredictionResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCSelectCompendiumInGamePrediction {
    // message fields
    match_id: ::std::option::Option<u64>,
    predictions: ::protobuf::RepeatedField<CMsgClientToGCSelectCompendiumInGamePrediction_Prediction>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCSelectCompendiumInGamePrediction {}

impl CMsgClientToGCSelectCompendiumInGamePrediction {
    pub fn new() -> CMsgClientToGCSelectCompendiumInGamePrediction {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCSelectCompendiumInGamePrediction {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCSelectCompendiumInGamePrediction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCSelectCompendiumInGamePrediction,
        };
        unsafe {
            instance.get(CMsgClientToGCSelectCompendiumInGamePrediction::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // repeated .CMsgClientToGCSelectCompendiumInGamePrediction.Prediction predictions = 2;

    pub fn clear_predictions(&mut self) {
        self.predictions.clear();
    }

    // Param is passed by value, moved
    pub fn set_predictions(&mut self, v: ::protobuf::RepeatedField<CMsgClientToGCSelectCompendiumInGamePrediction_Prediction>) {
        self.predictions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_predictions(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCSelectCompendiumInGamePrediction_Prediction> {
        &mut self.predictions
    }

    // Take field
    pub fn take_predictions(&mut self) -> ::protobuf::RepeatedField<CMsgClientToGCSelectCompendiumInGamePrediction_Prediction> {
        ::std::mem::replace(&mut self.predictions, ::protobuf::RepeatedField::new())
    }

    pub fn get_predictions(&self) -> &[CMsgClientToGCSelectCompendiumInGamePrediction_Prediction] {
        &self.predictions
    }

    fn get_predictions_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientToGCSelectCompendiumInGamePrediction_Prediction> {
        &self.predictions
    }

    fn mut_predictions_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCSelectCompendiumInGamePrediction_Prediction> {
        &mut self.predictions
    }
}

impl ::protobuf::Message for CMsgClientToGCSelectCompendiumInGamePrediction {
    fn is_initialized(&self) -> bool {
        for v in &self.predictions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.predictions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.predictions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.predictions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCSelectCompendiumInGamePrediction {
    fn new() -> CMsgClientToGCSelectCompendiumInGamePrediction {
        CMsgClientToGCSelectCompendiumInGamePrediction::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCSelectCompendiumInGamePrediction>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgClientToGCSelectCompendiumInGamePrediction::get_match_id_for_reflect,
                    CMsgClientToGCSelectCompendiumInGamePrediction::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCSelectCompendiumInGamePrediction_Prediction>>(
                    "predictions",
                    CMsgClientToGCSelectCompendiumInGamePrediction::get_predictions_for_reflect,
                    CMsgClientToGCSelectCompendiumInGamePrediction::mut_predictions_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCSelectCompendiumInGamePrediction>(
                    "CMsgClientToGCSelectCompendiumInGamePrediction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCSelectCompendiumInGamePrediction {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_predictions();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCSelectCompendiumInGamePrediction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSelectCompendiumInGamePrediction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCSelectCompendiumInGamePrediction_Prediction {
    // message fields
    prediction_id: ::std::option::Option<u32>,
    prediction_value: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCSelectCompendiumInGamePrediction_Prediction {}

impl CMsgClientToGCSelectCompendiumInGamePrediction_Prediction {
    pub fn new() -> CMsgClientToGCSelectCompendiumInGamePrediction_Prediction {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCSelectCompendiumInGamePrediction_Prediction {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCSelectCompendiumInGamePrediction_Prediction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCSelectCompendiumInGamePrediction_Prediction,
        };
        unsafe {
            instance.get(CMsgClientToGCSelectCompendiumInGamePrediction_Prediction::new)
        }
    }

    // optional uint32 prediction_id = 1;

    pub fn clear_prediction_id(&mut self) {
        self.prediction_id = ::std::option::Option::None;
    }

    pub fn has_prediction_id(&self) -> bool {
        self.prediction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prediction_id(&mut self, v: u32) {
        self.prediction_id = ::std::option::Option::Some(v);
    }

    pub fn get_prediction_id(&self) -> u32 {
        self.prediction_id.unwrap_or(0)
    }

    fn get_prediction_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prediction_id
    }

    fn mut_prediction_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prediction_id
    }

    // optional uint32 prediction_value = 2;

    pub fn clear_prediction_value(&mut self) {
        self.prediction_value = ::std::option::Option::None;
    }

    pub fn has_prediction_value(&self) -> bool {
        self.prediction_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prediction_value(&mut self, v: u32) {
        self.prediction_value = ::std::option::Option::Some(v);
    }

    pub fn get_prediction_value(&self) -> u32 {
        self.prediction_value.unwrap_or(0)
    }

    fn get_prediction_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prediction_value
    }

    fn mut_prediction_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prediction_value
    }
}

impl ::protobuf::Message for CMsgClientToGCSelectCompendiumInGamePrediction_Prediction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prediction_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prediction_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.prediction_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prediction_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prediction_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.prediction_value {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCSelectCompendiumInGamePrediction_Prediction {
    fn new() -> CMsgClientToGCSelectCompendiumInGamePrediction_Prediction {
        CMsgClientToGCSelectCompendiumInGamePrediction_Prediction::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCSelectCompendiumInGamePrediction_Prediction>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prediction_id",
                    CMsgClientToGCSelectCompendiumInGamePrediction_Prediction::get_prediction_id_for_reflect,
                    CMsgClientToGCSelectCompendiumInGamePrediction_Prediction::mut_prediction_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prediction_value",
                    CMsgClientToGCSelectCompendiumInGamePrediction_Prediction::get_prediction_value_for_reflect,
                    CMsgClientToGCSelectCompendiumInGamePrediction_Prediction::mut_prediction_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCSelectCompendiumInGamePrediction_Prediction>(
                    "CMsgClientToGCSelectCompendiumInGamePrediction_Prediction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCSelectCompendiumInGamePrediction_Prediction {
    fn clear(&mut self) {
        self.clear_prediction_id();
        self.clear_prediction_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCSelectCompendiumInGamePrediction_Prediction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSelectCompendiumInGamePrediction_Prediction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCSelectCompendiumInGamePredictionResponse {
    // message fields
    result: ::std::option::Option<CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCSelectCompendiumInGamePredictionResponse {}

impl CMsgClientToGCSelectCompendiumInGamePredictionResponse {
    pub fn new() -> CMsgClientToGCSelectCompendiumInGamePredictionResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCSelectCompendiumInGamePredictionResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCSelectCompendiumInGamePredictionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCSelectCompendiumInGamePredictionResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCSelectCompendiumInGamePredictionResponse::new)
        }
    }

    // optional .CMsgClientToGCSelectCompendiumInGamePredictionResponse.EResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult {
        self.result.unwrap_or(CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgClientToGCSelectCompendiumInGamePredictionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCSelectCompendiumInGamePredictionResponse {
    fn new() -> CMsgClientToGCSelectCompendiumInGamePredictionResponse {
        CMsgClientToGCSelectCompendiumInGamePredictionResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCSelectCompendiumInGamePredictionResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult>>(
                    "result",
                    CMsgClientToGCSelectCompendiumInGamePredictionResponse::get_result_for_reflect,
                    CMsgClientToGCSelectCompendiumInGamePredictionResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCSelectCompendiumInGamePredictionResponse>(
                    "CMsgClientToGCSelectCompendiumInGamePredictionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCSelectCompendiumInGamePredictionResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCSelectCompendiumInGamePredictionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSelectCompendiumInGamePredictionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult {
    SUCCESS = 0,
    INVALID_MATCH = 1,
    PREDICTIONS_ARE_CLOSED = 2,
    OTHER_ERROR = 3,
}

impl ::protobuf::ProtobufEnum for CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult::SUCCESS),
            1 => ::std::option::Option::Some(CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult::INVALID_MATCH),
            2 => ::std::option::Option::Some(CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult::PREDICTIONS_ARE_CLOSED),
            3 => ::std::option::Option::Some(CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult::OTHER_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult] = &[
            CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult::SUCCESS,
            CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult::INVALID_MATCH,
            CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult::PREDICTIONS_ARE_CLOSED,
            CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult::OTHER_ERROR,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSelectCompendiumInGamePredictionResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCOpenPlayerCardPack {
    // message fields
    player_card_pack_item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCOpenPlayerCardPack {}

impl CMsgClientToGCOpenPlayerCardPack {
    pub fn new() -> CMsgClientToGCOpenPlayerCardPack {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCOpenPlayerCardPack {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCOpenPlayerCardPack> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCOpenPlayerCardPack,
        };
        unsafe {
            instance.get(CMsgClientToGCOpenPlayerCardPack::new)
        }
    }

    // optional uint64 player_card_pack_item_id = 1;

    pub fn clear_player_card_pack_item_id(&mut self) {
        self.player_card_pack_item_id = ::std::option::Option::None;
    }

    pub fn has_player_card_pack_item_id(&self) -> bool {
        self.player_card_pack_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_card_pack_item_id(&mut self, v: u64) {
        self.player_card_pack_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_card_pack_item_id(&self) -> u64 {
        self.player_card_pack_item_id.unwrap_or(0)
    }

    fn get_player_card_pack_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.player_card_pack_item_id
    }

    fn mut_player_card_pack_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.player_card_pack_item_id
    }
}

impl ::protobuf::Message for CMsgClientToGCOpenPlayerCardPack {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.player_card_pack_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_card_pack_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_card_pack_item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCOpenPlayerCardPack {
    fn new() -> CMsgClientToGCOpenPlayerCardPack {
        CMsgClientToGCOpenPlayerCardPack::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCOpenPlayerCardPack>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "player_card_pack_item_id",
                    CMsgClientToGCOpenPlayerCardPack::get_player_card_pack_item_id_for_reflect,
                    CMsgClientToGCOpenPlayerCardPack::mut_player_card_pack_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCOpenPlayerCardPack>(
                    "CMsgClientToGCOpenPlayerCardPack",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCOpenPlayerCardPack {
    fn clear(&mut self) {
        self.clear_player_card_pack_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCOpenPlayerCardPack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCOpenPlayerCardPack {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCOpenPlayerCardPackResponse {
    // message fields
    result: ::std::option::Option<CMsgClientToGCOpenPlayerCardPackResponse_Result>,
    player_card_item_ids: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCOpenPlayerCardPackResponse {}

impl CMsgClientToGCOpenPlayerCardPackResponse {
    pub fn new() -> CMsgClientToGCOpenPlayerCardPackResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCOpenPlayerCardPackResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCOpenPlayerCardPackResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCOpenPlayerCardPackResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCOpenPlayerCardPackResponse::new)
        }
    }

    // optional .CMsgClientToGCOpenPlayerCardPackResponse.Result result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgClientToGCOpenPlayerCardPackResponse_Result) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgClientToGCOpenPlayerCardPackResponse_Result {
        self.result.unwrap_or(CMsgClientToGCOpenPlayerCardPackResponse_Result::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgClientToGCOpenPlayerCardPackResponse_Result> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgClientToGCOpenPlayerCardPackResponse_Result> {
        &mut self.result
    }

    // repeated uint64 player_card_item_ids = 2;

    pub fn clear_player_card_item_ids(&mut self) {
        self.player_card_item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_card_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.player_card_item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_card_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.player_card_item_ids
    }

    // Take field
    pub fn take_player_card_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.player_card_item_ids, ::std::vec::Vec::new())
    }

    pub fn get_player_card_item_ids(&self) -> &[u64] {
        &self.player_card_item_ids
    }

    fn get_player_card_item_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.player_card_item_ids
    }

    fn mut_player_card_item_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.player_card_item_ids
    }
}

impl ::protobuf::Message for CMsgClientToGCOpenPlayerCardPackResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.player_card_item_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.player_card_item_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        for v in &self.player_card_item_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCOpenPlayerCardPackResponse {
    fn new() -> CMsgClientToGCOpenPlayerCardPackResponse {
        CMsgClientToGCOpenPlayerCardPackResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCOpenPlayerCardPackResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgClientToGCOpenPlayerCardPackResponse_Result>>(
                    "result",
                    CMsgClientToGCOpenPlayerCardPackResponse::get_result_for_reflect,
                    CMsgClientToGCOpenPlayerCardPackResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "player_card_item_ids",
                    CMsgClientToGCOpenPlayerCardPackResponse::get_player_card_item_ids_for_reflect,
                    CMsgClientToGCOpenPlayerCardPackResponse::mut_player_card_item_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCOpenPlayerCardPackResponse>(
                    "CMsgClientToGCOpenPlayerCardPackResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCOpenPlayerCardPackResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_player_card_item_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCOpenPlayerCardPackResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCOpenPlayerCardPackResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgClientToGCOpenPlayerCardPackResponse_Result {
    SUCCESS = 1,
    ERROR_INTERNAL = 2,
    ERROR_FAILED_TO_FIND_PACK = 3,
    ERROR_ITEM_NOT_CARD_PACK = 4,
    ERROR_FAILED_CARD_CREATE = 5,
}

impl ::protobuf::ProtobufEnum for CMsgClientToGCOpenPlayerCardPackResponse_Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgClientToGCOpenPlayerCardPackResponse_Result> {
        match value {
            1 => ::std::option::Option::Some(CMsgClientToGCOpenPlayerCardPackResponse_Result::SUCCESS),
            2 => ::std::option::Option::Some(CMsgClientToGCOpenPlayerCardPackResponse_Result::ERROR_INTERNAL),
            3 => ::std::option::Option::Some(CMsgClientToGCOpenPlayerCardPackResponse_Result::ERROR_FAILED_TO_FIND_PACK),
            4 => ::std::option::Option::Some(CMsgClientToGCOpenPlayerCardPackResponse_Result::ERROR_ITEM_NOT_CARD_PACK),
            5 => ::std::option::Option::Some(CMsgClientToGCOpenPlayerCardPackResponse_Result::ERROR_FAILED_CARD_CREATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgClientToGCOpenPlayerCardPackResponse_Result] = &[
            CMsgClientToGCOpenPlayerCardPackResponse_Result::SUCCESS,
            CMsgClientToGCOpenPlayerCardPackResponse_Result::ERROR_INTERNAL,
            CMsgClientToGCOpenPlayerCardPackResponse_Result::ERROR_FAILED_TO_FIND_PACK,
            CMsgClientToGCOpenPlayerCardPackResponse_Result::ERROR_ITEM_NOT_CARD_PACK,
            CMsgClientToGCOpenPlayerCardPackResponse_Result::ERROR_FAILED_CARD_CREATE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgClientToGCOpenPlayerCardPackResponse_Result>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgClientToGCOpenPlayerCardPackResponse_Result", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgClientToGCOpenPlayerCardPackResponse_Result {
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCOpenPlayerCardPackResponse_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRecyclePlayerCard {
    // message fields
    player_card_item_ids: ::std::vec::Vec<u64>,
    event_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRecyclePlayerCard {}

impl CMsgClientToGCRecyclePlayerCard {
    pub fn new() -> CMsgClientToGCRecyclePlayerCard {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRecyclePlayerCard {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRecyclePlayerCard> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRecyclePlayerCard,
        };
        unsafe {
            instance.get(CMsgClientToGCRecyclePlayerCard::new)
        }
    }

    // repeated uint64 player_card_item_ids = 3;

    pub fn clear_player_card_item_ids(&mut self) {
        self.player_card_item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_card_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.player_card_item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_card_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.player_card_item_ids
    }

    // Take field
    pub fn take_player_card_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.player_card_item_ids, ::std::vec::Vec::new())
    }

    pub fn get_player_card_item_ids(&self) -> &[u64] {
        &self.player_card_item_ids
    }

    fn get_player_card_item_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.player_card_item_ids
    }

    fn mut_player_card_item_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.player_card_item_ids
    }

    // optional uint32 event_id = 2;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }
}

impl ::protobuf::Message for CMsgClientToGCRecyclePlayerCard {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.player_card_item_ids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.player_card_item_ids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.player_card_item_ids {
            os.write_uint64(3, *v)?;
        };
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRecyclePlayerCard {
    fn new() -> CMsgClientToGCRecyclePlayerCard {
        CMsgClientToGCRecyclePlayerCard::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRecyclePlayerCard>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "player_card_item_ids",
                    CMsgClientToGCRecyclePlayerCard::get_player_card_item_ids_for_reflect,
                    CMsgClientToGCRecyclePlayerCard::mut_player_card_item_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgClientToGCRecyclePlayerCard::get_event_id_for_reflect,
                    CMsgClientToGCRecyclePlayerCard::mut_event_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRecyclePlayerCard>(
                    "CMsgClientToGCRecyclePlayerCard",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRecyclePlayerCard {
    fn clear(&mut self) {
        self.clear_player_card_item_ids();
        self.clear_event_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRecyclePlayerCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRecyclePlayerCard {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRecyclePlayerCardResponse {
    // message fields
    result: ::std::option::Option<CMsgClientToGCRecyclePlayerCardResponse_Result>,
    dust_amount: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRecyclePlayerCardResponse {}

impl CMsgClientToGCRecyclePlayerCardResponse {
    pub fn new() -> CMsgClientToGCRecyclePlayerCardResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRecyclePlayerCardResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRecyclePlayerCardResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRecyclePlayerCardResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCRecyclePlayerCardResponse::new)
        }
    }

    // optional .CMsgClientToGCRecyclePlayerCardResponse.Result result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgClientToGCRecyclePlayerCardResponse_Result) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgClientToGCRecyclePlayerCardResponse_Result {
        self.result.unwrap_or(CMsgClientToGCRecyclePlayerCardResponse_Result::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgClientToGCRecyclePlayerCardResponse_Result> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgClientToGCRecyclePlayerCardResponse_Result> {
        &mut self.result
    }

    // optional uint32 dust_amount = 2;

    pub fn clear_dust_amount(&mut self) {
        self.dust_amount = ::std::option::Option::None;
    }

    pub fn has_dust_amount(&self) -> bool {
        self.dust_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dust_amount(&mut self, v: u32) {
        self.dust_amount = ::std::option::Option::Some(v);
    }

    pub fn get_dust_amount(&self) -> u32 {
        self.dust_amount.unwrap_or(0)
    }

    fn get_dust_amount_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.dust_amount
    }

    fn mut_dust_amount_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.dust_amount
    }
}

impl ::protobuf::Message for CMsgClientToGCRecyclePlayerCardResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dust_amount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.dust_amount {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.dust_amount {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRecyclePlayerCardResponse {
    fn new() -> CMsgClientToGCRecyclePlayerCardResponse {
        CMsgClientToGCRecyclePlayerCardResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRecyclePlayerCardResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgClientToGCRecyclePlayerCardResponse_Result>>(
                    "result",
                    CMsgClientToGCRecyclePlayerCardResponse::get_result_for_reflect,
                    CMsgClientToGCRecyclePlayerCardResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dust_amount",
                    CMsgClientToGCRecyclePlayerCardResponse::get_dust_amount_for_reflect,
                    CMsgClientToGCRecyclePlayerCardResponse::mut_dust_amount_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRecyclePlayerCardResponse>(
                    "CMsgClientToGCRecyclePlayerCardResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRecyclePlayerCardResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_dust_amount();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRecyclePlayerCardResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRecyclePlayerCardResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgClientToGCRecyclePlayerCardResponse_Result {
    SUCCESS = 1,
    ERROR_INTERNAL = 2,
    ERROR_FAILED_TO_FIND_PLAYER_CARD = 3,
    ERROR_ITEM_NOT_PLAYER_CARD = 4,
    ERROR_FAILED_DUST_CARD_CREATE = 5,
    ERROR_CARD_LOCKED = 6,
}

impl ::protobuf::ProtobufEnum for CMsgClientToGCRecyclePlayerCardResponse_Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgClientToGCRecyclePlayerCardResponse_Result> {
        match value {
            1 => ::std::option::Option::Some(CMsgClientToGCRecyclePlayerCardResponse_Result::SUCCESS),
            2 => ::std::option::Option::Some(CMsgClientToGCRecyclePlayerCardResponse_Result::ERROR_INTERNAL),
            3 => ::std::option::Option::Some(CMsgClientToGCRecyclePlayerCardResponse_Result::ERROR_FAILED_TO_FIND_PLAYER_CARD),
            4 => ::std::option::Option::Some(CMsgClientToGCRecyclePlayerCardResponse_Result::ERROR_ITEM_NOT_PLAYER_CARD),
            5 => ::std::option::Option::Some(CMsgClientToGCRecyclePlayerCardResponse_Result::ERROR_FAILED_DUST_CARD_CREATE),
            6 => ::std::option::Option::Some(CMsgClientToGCRecyclePlayerCardResponse_Result::ERROR_CARD_LOCKED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgClientToGCRecyclePlayerCardResponse_Result] = &[
            CMsgClientToGCRecyclePlayerCardResponse_Result::SUCCESS,
            CMsgClientToGCRecyclePlayerCardResponse_Result::ERROR_INTERNAL,
            CMsgClientToGCRecyclePlayerCardResponse_Result::ERROR_FAILED_TO_FIND_PLAYER_CARD,
            CMsgClientToGCRecyclePlayerCardResponse_Result::ERROR_ITEM_NOT_PLAYER_CARD,
            CMsgClientToGCRecyclePlayerCardResponse_Result::ERROR_FAILED_DUST_CARD_CREATE,
            CMsgClientToGCRecyclePlayerCardResponse_Result::ERROR_CARD_LOCKED,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgClientToGCRecyclePlayerCardResponse_Result>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgClientToGCRecyclePlayerCardResponse_Result", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgClientToGCRecyclePlayerCardResponse_Result {
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRecyclePlayerCardResponse_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCCreatePlayerCardPack {
    // message fields
    card_dust_item_id: ::std::option::Option<u64>,
    event_id: ::std::option::Option<u32>,
    premium_pack: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCCreatePlayerCardPack {}

impl CMsgClientToGCCreatePlayerCardPack {
    pub fn new() -> CMsgClientToGCCreatePlayerCardPack {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCCreatePlayerCardPack {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCCreatePlayerCardPack> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCCreatePlayerCardPack,
        };
        unsafe {
            instance.get(CMsgClientToGCCreatePlayerCardPack::new)
        }
    }

    // optional uint64 card_dust_item_id = 1;

    pub fn clear_card_dust_item_id(&mut self) {
        self.card_dust_item_id = ::std::option::Option::None;
    }

    pub fn has_card_dust_item_id(&self) -> bool {
        self.card_dust_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_card_dust_item_id(&mut self, v: u64) {
        self.card_dust_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_card_dust_item_id(&self) -> u64 {
        self.card_dust_item_id.unwrap_or(0)
    }

    fn get_card_dust_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.card_dust_item_id
    }

    fn mut_card_dust_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.card_dust_item_id
    }

    // optional uint32 event_id = 2;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // optional bool premium_pack = 3;

    pub fn clear_premium_pack(&mut self) {
        self.premium_pack = ::std::option::Option::None;
    }

    pub fn has_premium_pack(&self) -> bool {
        self.premium_pack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_premium_pack(&mut self, v: bool) {
        self.premium_pack = ::std::option::Option::Some(v);
    }

    pub fn get_premium_pack(&self) -> bool {
        self.premium_pack.unwrap_or(false)
    }

    fn get_premium_pack_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.premium_pack
    }

    fn mut_premium_pack_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.premium_pack
    }
}

impl ::protobuf::Message for CMsgClientToGCCreatePlayerCardPack {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.card_dust_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.premium_pack = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.card_dust_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.premium_pack {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.card_dust_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.premium_pack {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCCreatePlayerCardPack {
    fn new() -> CMsgClientToGCCreatePlayerCardPack {
        CMsgClientToGCCreatePlayerCardPack::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCCreatePlayerCardPack>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "card_dust_item_id",
                    CMsgClientToGCCreatePlayerCardPack::get_card_dust_item_id_for_reflect,
                    CMsgClientToGCCreatePlayerCardPack::mut_card_dust_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgClientToGCCreatePlayerCardPack::get_event_id_for_reflect,
                    CMsgClientToGCCreatePlayerCardPack::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "premium_pack",
                    CMsgClientToGCCreatePlayerCardPack::get_premium_pack_for_reflect,
                    CMsgClientToGCCreatePlayerCardPack::mut_premium_pack_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCCreatePlayerCardPack>(
                    "CMsgClientToGCCreatePlayerCardPack",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCCreatePlayerCardPack {
    fn clear(&mut self) {
        self.clear_card_dust_item_id();
        self.clear_event_id();
        self.clear_premium_pack();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCCreatePlayerCardPack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCreatePlayerCardPack {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCCreatePlayerCardPackResponse {
    // message fields
    result: ::std::option::Option<CMsgClientToGCCreatePlayerCardPackResponse_Result>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCCreatePlayerCardPackResponse {}

impl CMsgClientToGCCreatePlayerCardPackResponse {
    pub fn new() -> CMsgClientToGCCreatePlayerCardPackResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCCreatePlayerCardPackResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCCreatePlayerCardPackResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCCreatePlayerCardPackResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCCreatePlayerCardPackResponse::new)
        }
    }

    // optional .CMsgClientToGCCreatePlayerCardPackResponse.Result result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgClientToGCCreatePlayerCardPackResponse_Result) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgClientToGCCreatePlayerCardPackResponse_Result {
        self.result.unwrap_or(CMsgClientToGCCreatePlayerCardPackResponse_Result::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgClientToGCCreatePlayerCardPackResponse_Result> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgClientToGCCreatePlayerCardPackResponse_Result> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgClientToGCCreatePlayerCardPackResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCCreatePlayerCardPackResponse {
    fn new() -> CMsgClientToGCCreatePlayerCardPackResponse {
        CMsgClientToGCCreatePlayerCardPackResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCCreatePlayerCardPackResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgClientToGCCreatePlayerCardPackResponse_Result>>(
                    "result",
                    CMsgClientToGCCreatePlayerCardPackResponse::get_result_for_reflect,
                    CMsgClientToGCCreatePlayerCardPackResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCCreatePlayerCardPackResponse>(
                    "CMsgClientToGCCreatePlayerCardPackResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCCreatePlayerCardPackResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCCreatePlayerCardPackResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCreatePlayerCardPackResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgClientToGCCreatePlayerCardPackResponse_Result {
    SUCCESS = 1,
    ERROR_INTERNAL = 2,
    ERROR_INSUFFICIENT_DUST = 3,
    ERROR_ITEM_NOT_DUST_ITEM = 4,
    ERROR_FAILED_CARD_PACK_CREATE = 5,
}

impl ::protobuf::ProtobufEnum for CMsgClientToGCCreatePlayerCardPackResponse_Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgClientToGCCreatePlayerCardPackResponse_Result> {
        match value {
            1 => ::std::option::Option::Some(CMsgClientToGCCreatePlayerCardPackResponse_Result::SUCCESS),
            2 => ::std::option::Option::Some(CMsgClientToGCCreatePlayerCardPackResponse_Result::ERROR_INTERNAL),
            3 => ::std::option::Option::Some(CMsgClientToGCCreatePlayerCardPackResponse_Result::ERROR_INSUFFICIENT_DUST),
            4 => ::std::option::Option::Some(CMsgClientToGCCreatePlayerCardPackResponse_Result::ERROR_ITEM_NOT_DUST_ITEM),
            5 => ::std::option::Option::Some(CMsgClientToGCCreatePlayerCardPackResponse_Result::ERROR_FAILED_CARD_PACK_CREATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgClientToGCCreatePlayerCardPackResponse_Result] = &[
            CMsgClientToGCCreatePlayerCardPackResponse_Result::SUCCESS,
            CMsgClientToGCCreatePlayerCardPackResponse_Result::ERROR_INTERNAL,
            CMsgClientToGCCreatePlayerCardPackResponse_Result::ERROR_INSUFFICIENT_DUST,
            CMsgClientToGCCreatePlayerCardPackResponse_Result::ERROR_ITEM_NOT_DUST_ITEM,
            CMsgClientToGCCreatePlayerCardPackResponse_Result::ERROR_FAILED_CARD_PACK_CREATE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgClientToGCCreatePlayerCardPackResponse_Result>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgClientToGCCreatePlayerCardPackResponse_Result", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgClientToGCCreatePlayerCardPackResponse_Result {
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCreatePlayerCardPackResponse_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_International2016 {
    // message fields
    battle_pass_level: ::std::option::Option<u32>,
    questlines: ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_International2016_Questlines>,
    wagering: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_Wagering>,
    achievements: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_Achievements>,
    battle_cup: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_BattleCup>,
    predictions: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_Predictions>,
    bracket: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_Bracket>,
    player_cards: ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_International2016_PlayerCard>,
    fantasy_challenge: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_International2016 {}

impl CMsgGCToClientBattlePassRollup_International2016 {
    pub fn new() -> CMsgGCToClientBattlePassRollup_International2016 {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_International2016 {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_International2016> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_International2016,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_International2016::new)
        }
    }

    // optional uint32 battle_pass_level = 1;

    pub fn clear_battle_pass_level(&mut self) {
        self.battle_pass_level = ::std::option::Option::None;
    }

    pub fn has_battle_pass_level(&self) -> bool {
        self.battle_pass_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battle_pass_level(&mut self, v: u32) {
        self.battle_pass_level = ::std::option::Option::Some(v);
    }

    pub fn get_battle_pass_level(&self) -> u32 {
        self.battle_pass_level.unwrap_or(0)
    }

    fn get_battle_pass_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.battle_pass_level
    }

    fn mut_battle_pass_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.battle_pass_level
    }

    // repeated .CMsgGCToClientBattlePassRollup_International2016.Questlines questlines = 2;

    pub fn clear_questlines(&mut self) {
        self.questlines.clear();
    }

    // Param is passed by value, moved
    pub fn set_questlines(&mut self, v: ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_International2016_Questlines>) {
        self.questlines = v;
    }

    // Mutable pointer to the field.
    pub fn mut_questlines(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_International2016_Questlines> {
        &mut self.questlines
    }

    // Take field
    pub fn take_questlines(&mut self) -> ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_International2016_Questlines> {
        ::std::mem::replace(&mut self.questlines, ::protobuf::RepeatedField::new())
    }

    pub fn get_questlines(&self) -> &[CMsgGCToClientBattlePassRollup_International2016_Questlines] {
        &self.questlines
    }

    fn get_questlines_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_International2016_Questlines> {
        &self.questlines
    }

    fn mut_questlines_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_International2016_Questlines> {
        &mut self.questlines
    }

    // optional .CMsgGCToClientBattlePassRollup_International2016.Wagering wagering = 3;

    pub fn clear_wagering(&mut self) {
        self.wagering.clear();
    }

    pub fn has_wagering(&self) -> bool {
        self.wagering.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wagering(&mut self, v: CMsgGCToClientBattlePassRollup_International2016_Wagering) {
        self.wagering = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wagering(&mut self) -> &mut CMsgGCToClientBattlePassRollup_International2016_Wagering {
        if self.wagering.is_none() {
            self.wagering.set_default();
        }
        self.wagering.as_mut().unwrap()
    }

    // Take field
    pub fn take_wagering(&mut self) -> CMsgGCToClientBattlePassRollup_International2016_Wagering {
        self.wagering.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_International2016_Wagering::new())
    }

    pub fn get_wagering(&self) -> &CMsgGCToClientBattlePassRollup_International2016_Wagering {
        self.wagering.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_International2016_Wagering::default_instance())
    }

    fn get_wagering_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_Wagering> {
        &self.wagering
    }

    fn mut_wagering_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_Wagering> {
        &mut self.wagering
    }

    // optional .CMsgGCToClientBattlePassRollup_International2016.Achievements achievements = 4;

    pub fn clear_achievements(&mut self) {
        self.achievements.clear();
    }

    pub fn has_achievements(&self) -> bool {
        self.achievements.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievements(&mut self, v: CMsgGCToClientBattlePassRollup_International2016_Achievements) {
        self.achievements = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_achievements(&mut self) -> &mut CMsgGCToClientBattlePassRollup_International2016_Achievements {
        if self.achievements.is_none() {
            self.achievements.set_default();
        }
        self.achievements.as_mut().unwrap()
    }

    // Take field
    pub fn take_achievements(&mut self) -> CMsgGCToClientBattlePassRollup_International2016_Achievements {
        self.achievements.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_International2016_Achievements::new())
    }

    pub fn get_achievements(&self) -> &CMsgGCToClientBattlePassRollup_International2016_Achievements {
        self.achievements.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_International2016_Achievements::default_instance())
    }

    fn get_achievements_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_Achievements> {
        &self.achievements
    }

    fn mut_achievements_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_Achievements> {
        &mut self.achievements
    }

    // optional .CMsgGCToClientBattlePassRollup_International2016.BattleCup battle_cup = 5;

    pub fn clear_battle_cup(&mut self) {
        self.battle_cup.clear();
    }

    pub fn has_battle_cup(&self) -> bool {
        self.battle_cup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battle_cup(&mut self, v: CMsgGCToClientBattlePassRollup_International2016_BattleCup) {
        self.battle_cup = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_battle_cup(&mut self) -> &mut CMsgGCToClientBattlePassRollup_International2016_BattleCup {
        if self.battle_cup.is_none() {
            self.battle_cup.set_default();
        }
        self.battle_cup.as_mut().unwrap()
    }

    // Take field
    pub fn take_battle_cup(&mut self) -> CMsgGCToClientBattlePassRollup_International2016_BattleCup {
        self.battle_cup.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_International2016_BattleCup::new())
    }

    pub fn get_battle_cup(&self) -> &CMsgGCToClientBattlePassRollup_International2016_BattleCup {
        self.battle_cup.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_International2016_BattleCup::default_instance())
    }

    fn get_battle_cup_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_BattleCup> {
        &self.battle_cup
    }

    fn mut_battle_cup_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_BattleCup> {
        &mut self.battle_cup
    }

    // optional .CMsgGCToClientBattlePassRollup_International2016.Predictions predictions = 6;

    pub fn clear_predictions(&mut self) {
        self.predictions.clear();
    }

    pub fn has_predictions(&self) -> bool {
        self.predictions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_predictions(&mut self, v: CMsgGCToClientBattlePassRollup_International2016_Predictions) {
        self.predictions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_predictions(&mut self) -> &mut CMsgGCToClientBattlePassRollup_International2016_Predictions {
        if self.predictions.is_none() {
            self.predictions.set_default();
        }
        self.predictions.as_mut().unwrap()
    }

    // Take field
    pub fn take_predictions(&mut self) -> CMsgGCToClientBattlePassRollup_International2016_Predictions {
        self.predictions.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_International2016_Predictions::new())
    }

    pub fn get_predictions(&self) -> &CMsgGCToClientBattlePassRollup_International2016_Predictions {
        self.predictions.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_International2016_Predictions::default_instance())
    }

    fn get_predictions_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_Predictions> {
        &self.predictions
    }

    fn mut_predictions_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_Predictions> {
        &mut self.predictions
    }

    // optional .CMsgGCToClientBattlePassRollup_International2016.Bracket bracket = 7;

    pub fn clear_bracket(&mut self) {
        self.bracket.clear();
    }

    pub fn has_bracket(&self) -> bool {
        self.bracket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bracket(&mut self, v: CMsgGCToClientBattlePassRollup_International2016_Bracket) {
        self.bracket = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bracket(&mut self) -> &mut CMsgGCToClientBattlePassRollup_International2016_Bracket {
        if self.bracket.is_none() {
            self.bracket.set_default();
        }
        self.bracket.as_mut().unwrap()
    }

    // Take field
    pub fn take_bracket(&mut self) -> CMsgGCToClientBattlePassRollup_International2016_Bracket {
        self.bracket.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_International2016_Bracket::new())
    }

    pub fn get_bracket(&self) -> &CMsgGCToClientBattlePassRollup_International2016_Bracket {
        self.bracket.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_International2016_Bracket::default_instance())
    }

    fn get_bracket_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_Bracket> {
        &self.bracket
    }

    fn mut_bracket_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_Bracket> {
        &mut self.bracket
    }

    // repeated .CMsgGCToClientBattlePassRollup_International2016.PlayerCard player_cards = 8;

    pub fn clear_player_cards(&mut self) {
        self.player_cards.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_cards(&mut self, v: ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_International2016_PlayerCard>) {
        self.player_cards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_cards(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_International2016_PlayerCard> {
        &mut self.player_cards
    }

    // Take field
    pub fn take_player_cards(&mut self) -> ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_International2016_PlayerCard> {
        ::std::mem::replace(&mut self.player_cards, ::protobuf::RepeatedField::new())
    }

    pub fn get_player_cards(&self) -> &[CMsgGCToClientBattlePassRollup_International2016_PlayerCard] {
        &self.player_cards
    }

    fn get_player_cards_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_International2016_PlayerCard> {
        &self.player_cards
    }

    fn mut_player_cards_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_International2016_PlayerCard> {
        &mut self.player_cards
    }

    // optional .CMsgGCToClientBattlePassRollup_International2016.FantasyChallenge fantasy_challenge = 9;

    pub fn clear_fantasy_challenge(&mut self) {
        self.fantasy_challenge.clear();
    }

    pub fn has_fantasy_challenge(&self) -> bool {
        self.fantasy_challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_challenge(&mut self, v: CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge) {
        self.fantasy_challenge = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fantasy_challenge(&mut self) -> &mut CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge {
        if self.fantasy_challenge.is_none() {
            self.fantasy_challenge.set_default();
        }
        self.fantasy_challenge.as_mut().unwrap()
    }

    // Take field
    pub fn take_fantasy_challenge(&mut self) -> CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge {
        self.fantasy_challenge.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge::new())
    }

    pub fn get_fantasy_challenge(&self) -> &CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge {
        self.fantasy_challenge.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge::default_instance())
    }

    fn get_fantasy_challenge_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge> {
        &self.fantasy_challenge
    }

    fn mut_fantasy_challenge_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge> {
        &mut self.fantasy_challenge
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_International2016 {
    fn is_initialized(&self) -> bool {
        for v in &self.questlines {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.wagering {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.achievements {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.battle_cup {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.predictions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bracket {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.player_cards {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fantasy_challenge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.battle_pass_level = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.questlines)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.wagering)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.achievements)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.battle_cup)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.predictions)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bracket)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_cards)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fantasy_challenge)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.battle_pass_level {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.questlines {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.wagering.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.achievements.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.battle_cup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.predictions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bracket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.player_cards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.fantasy_challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.battle_pass_level {
            os.write_uint32(1, v)?;
        }
        for v in &self.questlines {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.wagering.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.achievements.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.battle_cup.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.predictions.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bracket.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.player_cards {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.fantasy_challenge.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_International2016 {
    fn new() -> CMsgGCToClientBattlePassRollup_International2016 {
        CMsgGCToClientBattlePassRollup_International2016::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_International2016>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "battle_pass_level",
                    CMsgGCToClientBattlePassRollup_International2016::get_battle_pass_level_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016::mut_battle_pass_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_International2016_Questlines>>(
                    "questlines",
                    CMsgGCToClientBattlePassRollup_International2016::get_questlines_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016::mut_questlines_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_International2016_Wagering>>(
                    "wagering",
                    CMsgGCToClientBattlePassRollup_International2016::get_wagering_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016::mut_wagering_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_International2016_Achievements>>(
                    "achievements",
                    CMsgGCToClientBattlePassRollup_International2016::get_achievements_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016::mut_achievements_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_International2016_BattleCup>>(
                    "battle_cup",
                    CMsgGCToClientBattlePassRollup_International2016::get_battle_cup_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016::mut_battle_cup_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_International2016_Predictions>>(
                    "predictions",
                    CMsgGCToClientBattlePassRollup_International2016::get_predictions_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016::mut_predictions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_International2016_Bracket>>(
                    "bracket",
                    CMsgGCToClientBattlePassRollup_International2016::get_bracket_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016::mut_bracket_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_International2016_PlayerCard>>(
                    "player_cards",
                    CMsgGCToClientBattlePassRollup_International2016::get_player_cards_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016::mut_player_cards_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge>>(
                    "fantasy_challenge",
                    CMsgGCToClientBattlePassRollup_International2016::get_fantasy_challenge_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016::mut_fantasy_challenge_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_International2016>(
                    "CMsgGCToClientBattlePassRollup_International2016",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_International2016 {
    fn clear(&mut self) {
        self.clear_battle_pass_level();
        self.clear_questlines();
        self.clear_wagering();
        self.clear_achievements();
        self.clear_battle_cup();
        self.clear_predictions();
        self.clear_bracket();
        self.clear_player_cards();
        self.clear_fantasy_challenge();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_International2016 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_International2016 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_International2016_Questlines {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    onestar: ::std::option::Option<u32>,
    twostar: ::std::option::Option<u32>,
    threestar: ::std::option::Option<u32>,
    total: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_International2016_Questlines {}

impl CMsgGCToClientBattlePassRollup_International2016_Questlines {
    pub fn new() -> CMsgGCToClientBattlePassRollup_International2016_Questlines {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_International2016_Questlines {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_International2016_Questlines> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_International2016_Questlines,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_International2016_Questlines::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional uint32 onestar = 2;

    pub fn clear_onestar(&mut self) {
        self.onestar = ::std::option::Option::None;
    }

    pub fn has_onestar(&self) -> bool {
        self.onestar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_onestar(&mut self, v: u32) {
        self.onestar = ::std::option::Option::Some(v);
    }

    pub fn get_onestar(&self) -> u32 {
        self.onestar.unwrap_or(0)
    }

    fn get_onestar_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.onestar
    }

    fn mut_onestar_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.onestar
    }

    // optional uint32 twostar = 3;

    pub fn clear_twostar(&mut self) {
        self.twostar = ::std::option::Option::None;
    }

    pub fn has_twostar(&self) -> bool {
        self.twostar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_twostar(&mut self, v: u32) {
        self.twostar = ::std::option::Option::Some(v);
    }

    pub fn get_twostar(&self) -> u32 {
        self.twostar.unwrap_or(0)
    }

    fn get_twostar_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.twostar
    }

    fn mut_twostar_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.twostar
    }

    // optional uint32 threestar = 4;

    pub fn clear_threestar(&mut self) {
        self.threestar = ::std::option::Option::None;
    }

    pub fn has_threestar(&self) -> bool {
        self.threestar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threestar(&mut self, v: u32) {
        self.threestar = ::std::option::Option::Some(v);
    }

    pub fn get_threestar(&self) -> u32 {
        self.threestar.unwrap_or(0)
    }

    fn get_threestar_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.threestar
    }

    fn mut_threestar_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.threestar
    }

    // optional uint32 total = 5;

    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u32) {
        self.total = ::std::option::Option::Some(v);
    }

    pub fn get_total(&self) -> u32 {
        self.total.unwrap_or(0)
    }

    fn get_total_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total
    }

    fn mut_total_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_International2016_Questlines {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.onestar = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.twostar = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.threestar = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.onestar {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.twostar {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.threestar {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.onestar {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.twostar {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.threestar {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.total {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_International2016_Questlines {
    fn new() -> CMsgGCToClientBattlePassRollup_International2016_Questlines {
        CMsgGCToClientBattlePassRollup_International2016_Questlines::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_International2016_Questlines>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgGCToClientBattlePassRollup_International2016_Questlines::get_name_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Questlines::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "onestar",
                    CMsgGCToClientBattlePassRollup_International2016_Questlines::get_onestar_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Questlines::mut_onestar_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "twostar",
                    CMsgGCToClientBattlePassRollup_International2016_Questlines::get_twostar_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Questlines::mut_twostar_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "threestar",
                    CMsgGCToClientBattlePassRollup_International2016_Questlines::get_threestar_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Questlines::mut_threestar_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total",
                    CMsgGCToClientBattlePassRollup_International2016_Questlines::get_total_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Questlines::mut_total_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_International2016_Questlines>(
                    "CMsgGCToClientBattlePassRollup_International2016_Questlines",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_International2016_Questlines {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_onestar();
        self.clear_twostar();
        self.clear_threestar();
        self.clear_total();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_International2016_Questlines {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_International2016_Questlines {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_International2016_Wagering {
    // message fields
    total_wagered: ::std::option::Option<u32>,
    total_won: ::std::option::Option<u32>,
    average_won: ::std::option::Option<u32>,
    success_rate: ::std::option::Option<u32>,
    total_tips: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_International2016_Wagering {}

impl CMsgGCToClientBattlePassRollup_International2016_Wagering {
    pub fn new() -> CMsgGCToClientBattlePassRollup_International2016_Wagering {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_International2016_Wagering {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_International2016_Wagering> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_International2016_Wagering,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_International2016_Wagering::new)
        }
    }

    // optional uint32 total_wagered = 1;

    pub fn clear_total_wagered(&mut self) {
        self.total_wagered = ::std::option::Option::None;
    }

    pub fn has_total_wagered(&self) -> bool {
        self.total_wagered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_wagered(&mut self, v: u32) {
        self.total_wagered = ::std::option::Option::Some(v);
    }

    pub fn get_total_wagered(&self) -> u32 {
        self.total_wagered.unwrap_or(0)
    }

    fn get_total_wagered_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_wagered
    }

    fn mut_total_wagered_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_wagered
    }

    // optional uint32 total_won = 2;

    pub fn clear_total_won(&mut self) {
        self.total_won = ::std::option::Option::None;
    }

    pub fn has_total_won(&self) -> bool {
        self.total_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_won(&mut self, v: u32) {
        self.total_won = ::std::option::Option::Some(v);
    }

    pub fn get_total_won(&self) -> u32 {
        self.total_won.unwrap_or(0)
    }

    fn get_total_won_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_won
    }

    fn mut_total_won_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_won
    }

    // optional uint32 average_won = 3;

    pub fn clear_average_won(&mut self) {
        self.average_won = ::std::option::Option::None;
    }

    pub fn has_average_won(&self) -> bool {
        self.average_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_won(&mut self, v: u32) {
        self.average_won = ::std::option::Option::Some(v);
    }

    pub fn get_average_won(&self) -> u32 {
        self.average_won.unwrap_or(0)
    }

    fn get_average_won_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.average_won
    }

    fn mut_average_won_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.average_won
    }

    // optional uint32 success_rate = 4;

    pub fn clear_success_rate(&mut self) {
        self.success_rate = ::std::option::Option::None;
    }

    pub fn has_success_rate(&self) -> bool {
        self.success_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success_rate(&mut self, v: u32) {
        self.success_rate = ::std::option::Option::Some(v);
    }

    pub fn get_success_rate(&self) -> u32 {
        self.success_rate.unwrap_or(0)
    }

    fn get_success_rate_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.success_rate
    }

    fn mut_success_rate_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.success_rate
    }

    // optional uint32 total_tips = 5;

    pub fn clear_total_tips(&mut self) {
        self.total_tips = ::std::option::Option::None;
    }

    pub fn has_total_tips(&self) -> bool {
        self.total_tips.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_tips(&mut self, v: u32) {
        self.total_tips = ::std::option::Option::Some(v);
    }

    pub fn get_total_tips(&self) -> u32 {
        self.total_tips.unwrap_or(0)
    }

    fn get_total_tips_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_tips
    }

    fn mut_total_tips_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_tips
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_International2016_Wagering {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_wagered = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_won = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.average_won = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.success_rate = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_tips = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.total_wagered {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_won {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.average_won {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.success_rate {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_tips {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.total_wagered {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.total_won {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.average_won {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.success_rate {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.total_tips {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_International2016_Wagering {
    fn new() -> CMsgGCToClientBattlePassRollup_International2016_Wagering {
        CMsgGCToClientBattlePassRollup_International2016_Wagering::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_International2016_Wagering>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_wagered",
                    CMsgGCToClientBattlePassRollup_International2016_Wagering::get_total_wagered_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Wagering::mut_total_wagered_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_won",
                    CMsgGCToClientBattlePassRollup_International2016_Wagering::get_total_won_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Wagering::mut_total_won_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "average_won",
                    CMsgGCToClientBattlePassRollup_International2016_Wagering::get_average_won_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Wagering::mut_average_won_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "success_rate",
                    CMsgGCToClientBattlePassRollup_International2016_Wagering::get_success_rate_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Wagering::mut_success_rate_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_tips",
                    CMsgGCToClientBattlePassRollup_International2016_Wagering::get_total_tips_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Wagering::mut_total_tips_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_International2016_Wagering>(
                    "CMsgGCToClientBattlePassRollup_International2016_Wagering",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_International2016_Wagering {
    fn clear(&mut self) {
        self.clear_total_wagered();
        self.clear_total_won();
        self.clear_average_won();
        self.clear_success_rate();
        self.clear_total_tips();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_International2016_Wagering {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_International2016_Wagering {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_International2016_Achievements {
    // message fields
    completed: ::std::option::Option<u32>,
    total: ::std::option::Option<u32>,
    points: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_International2016_Achievements {}

impl CMsgGCToClientBattlePassRollup_International2016_Achievements {
    pub fn new() -> CMsgGCToClientBattlePassRollup_International2016_Achievements {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_International2016_Achievements {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_International2016_Achievements> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_International2016_Achievements,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_International2016_Achievements::new)
        }
    }

    // optional uint32 completed = 1;

    pub fn clear_completed(&mut self) {
        self.completed = ::std::option::Option::None;
    }

    pub fn has_completed(&self) -> bool {
        self.completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed(&mut self, v: u32) {
        self.completed = ::std::option::Option::Some(v);
    }

    pub fn get_completed(&self) -> u32 {
        self.completed.unwrap_or(0)
    }

    fn get_completed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.completed
    }

    fn mut_completed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.completed
    }

    // optional uint32 total = 2;

    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u32) {
        self.total = ::std::option::Option::Some(v);
    }

    pub fn get_total(&self) -> u32 {
        self.total.unwrap_or(0)
    }

    fn get_total_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total
    }

    fn mut_total_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total
    }

    // optional uint32 points = 3;

    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: u32) {
        self.points = ::std::option::Option::Some(v);
    }

    pub fn get_points(&self) -> u32 {
        self.points.unwrap_or(0)
    }

    fn get_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points
    }

    fn mut_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_International2016_Achievements {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.completed = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.completed {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.completed {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.total {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.points {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_International2016_Achievements {
    fn new() -> CMsgGCToClientBattlePassRollup_International2016_Achievements {
        CMsgGCToClientBattlePassRollup_International2016_Achievements::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_International2016_Achievements>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "completed",
                    CMsgGCToClientBattlePassRollup_International2016_Achievements::get_completed_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Achievements::mut_completed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total",
                    CMsgGCToClientBattlePassRollup_International2016_Achievements::get_total_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Achievements::mut_total_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points",
                    CMsgGCToClientBattlePassRollup_International2016_Achievements::get_points_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Achievements::mut_points_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_International2016_Achievements>(
                    "CMsgGCToClientBattlePassRollup_International2016_Achievements",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_International2016_Achievements {
    fn clear(&mut self) {
        self.clear_completed();
        self.clear_total();
        self.clear_points();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_International2016_Achievements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_International2016_Achievements {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_International2016_BattleCup {
    // message fields
    wins: ::std::option::Option<u32>,
    score: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_International2016_BattleCup {}

impl CMsgGCToClientBattlePassRollup_International2016_BattleCup {
    pub fn new() -> CMsgGCToClientBattlePassRollup_International2016_BattleCup {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_International2016_BattleCup {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_International2016_BattleCup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_International2016_BattleCup,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_International2016_BattleCup::new)
        }
    }

    // optional uint32 wins = 1;

    pub fn clear_wins(&mut self) {
        self.wins = ::std::option::Option::None;
    }

    pub fn has_wins(&self) -> bool {
        self.wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: u32) {
        self.wins = ::std::option::Option::Some(v);
    }

    pub fn get_wins(&self) -> u32 {
        self.wins.unwrap_or(0)
    }

    fn get_wins_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.wins
    }

    fn mut_wins_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.wins
    }

    // optional uint32 score = 2;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    fn get_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.score
    }

    fn mut_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.score
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_International2016_BattleCup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wins = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.wins {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.wins {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_International2016_BattleCup {
    fn new() -> CMsgGCToClientBattlePassRollup_International2016_BattleCup {
        CMsgGCToClientBattlePassRollup_International2016_BattleCup::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_International2016_BattleCup>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wins",
                    CMsgGCToClientBattlePassRollup_International2016_BattleCup::get_wins_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_BattleCup::mut_wins_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "score",
                    CMsgGCToClientBattlePassRollup_International2016_BattleCup::get_score_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_BattleCup::mut_score_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_International2016_BattleCup>(
                    "CMsgGCToClientBattlePassRollup_International2016_BattleCup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_International2016_BattleCup {
    fn clear(&mut self) {
        self.clear_wins();
        self.clear_score();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_International2016_BattleCup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_International2016_BattleCup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_International2016_Predictions {
    // message fields
    correct: ::std::option::Option<u32>,
    total: ::std::option::Option<u32>,
    points: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_International2016_Predictions {}

impl CMsgGCToClientBattlePassRollup_International2016_Predictions {
    pub fn new() -> CMsgGCToClientBattlePassRollup_International2016_Predictions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_International2016_Predictions {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_International2016_Predictions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_International2016_Predictions,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_International2016_Predictions::new)
        }
    }

    // optional uint32 correct = 1;

    pub fn clear_correct(&mut self) {
        self.correct = ::std::option::Option::None;
    }

    pub fn has_correct(&self) -> bool {
        self.correct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correct(&mut self, v: u32) {
        self.correct = ::std::option::Option::Some(v);
    }

    pub fn get_correct(&self) -> u32 {
        self.correct.unwrap_or(0)
    }

    fn get_correct_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.correct
    }

    fn mut_correct_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.correct
    }

    // optional uint32 total = 2;

    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u32) {
        self.total = ::std::option::Option::Some(v);
    }

    pub fn get_total(&self) -> u32 {
        self.total.unwrap_or(0)
    }

    fn get_total_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total
    }

    fn mut_total_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total
    }

    // optional uint32 points = 3;

    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: u32) {
        self.points = ::std::option::Option::Some(v);
    }

    pub fn get_points(&self) -> u32 {
        self.points.unwrap_or(0)
    }

    fn get_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points
    }

    fn mut_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_International2016_Predictions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.correct = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.correct {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.correct {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.total {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.points {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_International2016_Predictions {
    fn new() -> CMsgGCToClientBattlePassRollup_International2016_Predictions {
        CMsgGCToClientBattlePassRollup_International2016_Predictions::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_International2016_Predictions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "correct",
                    CMsgGCToClientBattlePassRollup_International2016_Predictions::get_correct_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Predictions::mut_correct_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total",
                    CMsgGCToClientBattlePassRollup_International2016_Predictions::get_total_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Predictions::mut_total_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points",
                    CMsgGCToClientBattlePassRollup_International2016_Predictions::get_points_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Predictions::mut_points_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_International2016_Predictions>(
                    "CMsgGCToClientBattlePassRollup_International2016_Predictions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_International2016_Predictions {
    fn clear(&mut self) {
        self.clear_correct();
        self.clear_total();
        self.clear_points();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_International2016_Predictions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_International2016_Predictions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_International2016_Bracket {
    // message fields
    correct: ::std::option::Option<u32>,
    points: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_International2016_Bracket {}

impl CMsgGCToClientBattlePassRollup_International2016_Bracket {
    pub fn new() -> CMsgGCToClientBattlePassRollup_International2016_Bracket {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_International2016_Bracket {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_International2016_Bracket> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_International2016_Bracket,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_International2016_Bracket::new)
        }
    }

    // optional uint32 correct = 1;

    pub fn clear_correct(&mut self) {
        self.correct = ::std::option::Option::None;
    }

    pub fn has_correct(&self) -> bool {
        self.correct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correct(&mut self, v: u32) {
        self.correct = ::std::option::Option::Some(v);
    }

    pub fn get_correct(&self) -> u32 {
        self.correct.unwrap_or(0)
    }

    fn get_correct_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.correct
    }

    fn mut_correct_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.correct
    }

    // optional uint32 points = 2;

    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: u32) {
        self.points = ::std::option::Option::Some(v);
    }

    pub fn get_points(&self) -> u32 {
        self.points.unwrap_or(0)
    }

    fn get_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points
    }

    fn mut_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_International2016_Bracket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.correct = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.correct {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.correct {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.points {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_International2016_Bracket {
    fn new() -> CMsgGCToClientBattlePassRollup_International2016_Bracket {
        CMsgGCToClientBattlePassRollup_International2016_Bracket::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_International2016_Bracket>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "correct",
                    CMsgGCToClientBattlePassRollup_International2016_Bracket::get_correct_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Bracket::mut_correct_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points",
                    CMsgGCToClientBattlePassRollup_International2016_Bracket::get_points_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_Bracket::mut_points_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_International2016_Bracket>(
                    "CMsgGCToClientBattlePassRollup_International2016_Bracket",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_International2016_Bracket {
    fn clear(&mut self) {
        self.clear_correct();
        self.clear_points();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_International2016_Bracket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_International2016_Bracket {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_International2016_PlayerCard {
    // message fields
    account_id: ::std::option::Option<u32>,
    quality: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_International2016_PlayerCard {}

impl CMsgGCToClientBattlePassRollup_International2016_PlayerCard {
    pub fn new() -> CMsgGCToClientBattlePassRollup_International2016_PlayerCard {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_International2016_PlayerCard {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_International2016_PlayerCard> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_International2016_PlayerCard,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_International2016_PlayerCard::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 quality = 2;

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    pub fn get_quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    fn get_quality_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.quality
    }

    fn mut_quality_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.quality
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_International2016_PlayerCard {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_International2016_PlayerCard {
    fn new() -> CMsgGCToClientBattlePassRollup_International2016_PlayerCard {
        CMsgGCToClientBattlePassRollup_International2016_PlayerCard::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_International2016_PlayerCard>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCToClientBattlePassRollup_International2016_PlayerCard::get_account_id_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_PlayerCard::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quality",
                    CMsgGCToClientBattlePassRollup_International2016_PlayerCard::get_quality_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_PlayerCard::mut_quality_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_International2016_PlayerCard>(
                    "CMsgGCToClientBattlePassRollup_International2016_PlayerCard",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_International2016_PlayerCard {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_quality();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_International2016_PlayerCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_International2016_PlayerCard {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge {
    // message fields
    total_score: ::std::option::Option<f32>,
    percentile: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge {}

impl CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge {
    pub fn new() -> CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge::new)
        }
    }

    // optional float total_score = 1;

    pub fn clear_total_score(&mut self) {
        self.total_score = ::std::option::Option::None;
    }

    pub fn has_total_score(&self) -> bool {
        self.total_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_score(&mut self, v: f32) {
        self.total_score = ::std::option::Option::Some(v);
    }

    pub fn get_total_score(&self) -> f32 {
        self.total_score.unwrap_or(0.)
    }

    fn get_total_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.total_score
    }

    fn mut_total_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.total_score
    }

    // optional float percentile = 2;

    pub fn clear_percentile(&mut self) {
        self.percentile = ::std::option::Option::None;
    }

    pub fn has_percentile(&self) -> bool {
        self.percentile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_percentile(&mut self, v: f32) {
        self.percentile = ::std::option::Option::Some(v);
    }

    pub fn get_percentile(&self) -> f32 {
        self.percentile.unwrap_or(0.)
    }

    fn get_percentile_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.percentile
    }

    fn mut_percentile_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.percentile
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.total_score = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.percentile = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.total_score {
            my_size += 5;
        }
        if let Some(v) = self.percentile {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.total_score {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.percentile {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge {
    fn new() -> CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge {
        CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "total_score",
                    CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge::get_total_score_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge::mut_total_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "percentile",
                    CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge::get_percentile_for_reflect,
                    CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge::mut_percentile_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge>(
                    "CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge {
    fn clear(&mut self) {
        self.clear_total_score();
        self.clear_percentile();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_International2016_FantasyChallenge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Fall2016 {
    // message fields
    battle_pass_level: ::std::option::Option<u32>,
    questlines: ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Fall2016_Questlines>,
    wagering: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_Wagering>,
    achievements: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_Achievements>,
    battle_cup: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_BattleCup>,
    predictions: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_Predictions>,
    bracket: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_Bracket>,
    player_cards: ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard>,
    fantasy_challenge: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Fall2016 {}

impl CMsgGCToClientBattlePassRollup_Fall2016 {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Fall2016 {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Fall2016 {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Fall2016> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Fall2016,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Fall2016::new)
        }
    }

    // optional uint32 battle_pass_level = 1;

    pub fn clear_battle_pass_level(&mut self) {
        self.battle_pass_level = ::std::option::Option::None;
    }

    pub fn has_battle_pass_level(&self) -> bool {
        self.battle_pass_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battle_pass_level(&mut self, v: u32) {
        self.battle_pass_level = ::std::option::Option::Some(v);
    }

    pub fn get_battle_pass_level(&self) -> u32 {
        self.battle_pass_level.unwrap_or(0)
    }

    fn get_battle_pass_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.battle_pass_level
    }

    fn mut_battle_pass_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.battle_pass_level
    }

    // repeated .CMsgGCToClientBattlePassRollup_Fall2016.Questlines questlines = 2;

    pub fn clear_questlines(&mut self) {
        self.questlines.clear();
    }

    // Param is passed by value, moved
    pub fn set_questlines(&mut self, v: ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Fall2016_Questlines>) {
        self.questlines = v;
    }

    // Mutable pointer to the field.
    pub fn mut_questlines(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Fall2016_Questlines> {
        &mut self.questlines
    }

    // Take field
    pub fn take_questlines(&mut self) -> ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Fall2016_Questlines> {
        ::std::mem::replace(&mut self.questlines, ::protobuf::RepeatedField::new())
    }

    pub fn get_questlines(&self) -> &[CMsgGCToClientBattlePassRollup_Fall2016_Questlines] {
        &self.questlines
    }

    fn get_questlines_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Fall2016_Questlines> {
        &self.questlines
    }

    fn mut_questlines_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Fall2016_Questlines> {
        &mut self.questlines
    }

    // optional .CMsgGCToClientBattlePassRollup_Fall2016.Wagering wagering = 3;

    pub fn clear_wagering(&mut self) {
        self.wagering.clear();
    }

    pub fn has_wagering(&self) -> bool {
        self.wagering.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wagering(&mut self, v: CMsgGCToClientBattlePassRollup_Fall2016_Wagering) {
        self.wagering = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wagering(&mut self) -> &mut CMsgGCToClientBattlePassRollup_Fall2016_Wagering {
        if self.wagering.is_none() {
            self.wagering.set_default();
        }
        self.wagering.as_mut().unwrap()
    }

    // Take field
    pub fn take_wagering(&mut self) -> CMsgGCToClientBattlePassRollup_Fall2016_Wagering {
        self.wagering.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Fall2016_Wagering::new())
    }

    pub fn get_wagering(&self) -> &CMsgGCToClientBattlePassRollup_Fall2016_Wagering {
        self.wagering.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Fall2016_Wagering::default_instance())
    }

    fn get_wagering_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_Wagering> {
        &self.wagering
    }

    fn mut_wagering_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_Wagering> {
        &mut self.wagering
    }

    // optional .CMsgGCToClientBattlePassRollup_Fall2016.Achievements achievements = 4;

    pub fn clear_achievements(&mut self) {
        self.achievements.clear();
    }

    pub fn has_achievements(&self) -> bool {
        self.achievements.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievements(&mut self, v: CMsgGCToClientBattlePassRollup_Fall2016_Achievements) {
        self.achievements = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_achievements(&mut self) -> &mut CMsgGCToClientBattlePassRollup_Fall2016_Achievements {
        if self.achievements.is_none() {
            self.achievements.set_default();
        }
        self.achievements.as_mut().unwrap()
    }

    // Take field
    pub fn take_achievements(&mut self) -> CMsgGCToClientBattlePassRollup_Fall2016_Achievements {
        self.achievements.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Fall2016_Achievements::new())
    }

    pub fn get_achievements(&self) -> &CMsgGCToClientBattlePassRollup_Fall2016_Achievements {
        self.achievements.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Fall2016_Achievements::default_instance())
    }

    fn get_achievements_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_Achievements> {
        &self.achievements
    }

    fn mut_achievements_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_Achievements> {
        &mut self.achievements
    }

    // optional .CMsgGCToClientBattlePassRollup_Fall2016.BattleCup battle_cup = 5;

    pub fn clear_battle_cup(&mut self) {
        self.battle_cup.clear();
    }

    pub fn has_battle_cup(&self) -> bool {
        self.battle_cup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battle_cup(&mut self, v: CMsgGCToClientBattlePassRollup_Fall2016_BattleCup) {
        self.battle_cup = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_battle_cup(&mut self) -> &mut CMsgGCToClientBattlePassRollup_Fall2016_BattleCup {
        if self.battle_cup.is_none() {
            self.battle_cup.set_default();
        }
        self.battle_cup.as_mut().unwrap()
    }

    // Take field
    pub fn take_battle_cup(&mut self) -> CMsgGCToClientBattlePassRollup_Fall2016_BattleCup {
        self.battle_cup.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Fall2016_BattleCup::new())
    }

    pub fn get_battle_cup(&self) -> &CMsgGCToClientBattlePassRollup_Fall2016_BattleCup {
        self.battle_cup.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Fall2016_BattleCup::default_instance())
    }

    fn get_battle_cup_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_BattleCup> {
        &self.battle_cup
    }

    fn mut_battle_cup_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_BattleCup> {
        &mut self.battle_cup
    }

    // optional .CMsgGCToClientBattlePassRollup_Fall2016.Predictions predictions = 6;

    pub fn clear_predictions(&mut self) {
        self.predictions.clear();
    }

    pub fn has_predictions(&self) -> bool {
        self.predictions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_predictions(&mut self, v: CMsgGCToClientBattlePassRollup_Fall2016_Predictions) {
        self.predictions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_predictions(&mut self) -> &mut CMsgGCToClientBattlePassRollup_Fall2016_Predictions {
        if self.predictions.is_none() {
            self.predictions.set_default();
        }
        self.predictions.as_mut().unwrap()
    }

    // Take field
    pub fn take_predictions(&mut self) -> CMsgGCToClientBattlePassRollup_Fall2016_Predictions {
        self.predictions.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Fall2016_Predictions::new())
    }

    pub fn get_predictions(&self) -> &CMsgGCToClientBattlePassRollup_Fall2016_Predictions {
        self.predictions.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Fall2016_Predictions::default_instance())
    }

    fn get_predictions_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_Predictions> {
        &self.predictions
    }

    fn mut_predictions_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_Predictions> {
        &mut self.predictions
    }

    // optional .CMsgGCToClientBattlePassRollup_Fall2016.Bracket bracket = 7;

    pub fn clear_bracket(&mut self) {
        self.bracket.clear();
    }

    pub fn has_bracket(&self) -> bool {
        self.bracket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bracket(&mut self, v: CMsgGCToClientBattlePassRollup_Fall2016_Bracket) {
        self.bracket = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bracket(&mut self) -> &mut CMsgGCToClientBattlePassRollup_Fall2016_Bracket {
        if self.bracket.is_none() {
            self.bracket.set_default();
        }
        self.bracket.as_mut().unwrap()
    }

    // Take field
    pub fn take_bracket(&mut self) -> CMsgGCToClientBattlePassRollup_Fall2016_Bracket {
        self.bracket.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Fall2016_Bracket::new())
    }

    pub fn get_bracket(&self) -> &CMsgGCToClientBattlePassRollup_Fall2016_Bracket {
        self.bracket.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Fall2016_Bracket::default_instance())
    }

    fn get_bracket_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_Bracket> {
        &self.bracket
    }

    fn mut_bracket_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_Bracket> {
        &mut self.bracket
    }

    // repeated .CMsgGCToClientBattlePassRollup_Fall2016.PlayerCard player_cards = 8;

    pub fn clear_player_cards(&mut self) {
        self.player_cards.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_cards(&mut self, v: ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard>) {
        self.player_cards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_cards(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard> {
        &mut self.player_cards
    }

    // Take field
    pub fn take_player_cards(&mut self) -> ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard> {
        ::std::mem::replace(&mut self.player_cards, ::protobuf::RepeatedField::new())
    }

    pub fn get_player_cards(&self) -> &[CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard] {
        &self.player_cards
    }

    fn get_player_cards_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard> {
        &self.player_cards
    }

    fn mut_player_cards_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard> {
        &mut self.player_cards
    }

    // optional .CMsgGCToClientBattlePassRollup_Fall2016.FantasyChallenge fantasy_challenge = 9;

    pub fn clear_fantasy_challenge(&mut self) {
        self.fantasy_challenge.clear();
    }

    pub fn has_fantasy_challenge(&self) -> bool {
        self.fantasy_challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_challenge(&mut self, v: CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge) {
        self.fantasy_challenge = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fantasy_challenge(&mut self) -> &mut CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge {
        if self.fantasy_challenge.is_none() {
            self.fantasy_challenge.set_default();
        }
        self.fantasy_challenge.as_mut().unwrap()
    }

    // Take field
    pub fn take_fantasy_challenge(&mut self) -> CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge {
        self.fantasy_challenge.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge::new())
    }

    pub fn get_fantasy_challenge(&self) -> &CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge {
        self.fantasy_challenge.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge::default_instance())
    }

    fn get_fantasy_challenge_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge> {
        &self.fantasy_challenge
    }

    fn mut_fantasy_challenge_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge> {
        &mut self.fantasy_challenge
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Fall2016 {
    fn is_initialized(&self) -> bool {
        for v in &self.questlines {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.wagering {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.achievements {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.battle_cup {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.predictions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bracket {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.player_cards {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fantasy_challenge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.battle_pass_level = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.questlines)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.wagering)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.achievements)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.battle_cup)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.predictions)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bracket)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_cards)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fantasy_challenge)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.battle_pass_level {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.questlines {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.wagering.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.achievements.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.battle_cup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.predictions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bracket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.player_cards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.fantasy_challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.battle_pass_level {
            os.write_uint32(1, v)?;
        }
        for v in &self.questlines {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.wagering.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.achievements.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.battle_cup.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.predictions.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bracket.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.player_cards {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.fantasy_challenge.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Fall2016 {
    fn new() -> CMsgGCToClientBattlePassRollup_Fall2016 {
        CMsgGCToClientBattlePassRollup_Fall2016::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Fall2016>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "battle_pass_level",
                    CMsgGCToClientBattlePassRollup_Fall2016::get_battle_pass_level_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016::mut_battle_pass_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Fall2016_Questlines>>(
                    "questlines",
                    CMsgGCToClientBattlePassRollup_Fall2016::get_questlines_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016::mut_questlines_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Fall2016_Wagering>>(
                    "wagering",
                    CMsgGCToClientBattlePassRollup_Fall2016::get_wagering_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016::mut_wagering_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Fall2016_Achievements>>(
                    "achievements",
                    CMsgGCToClientBattlePassRollup_Fall2016::get_achievements_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016::mut_achievements_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Fall2016_BattleCup>>(
                    "battle_cup",
                    CMsgGCToClientBattlePassRollup_Fall2016::get_battle_cup_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016::mut_battle_cup_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Fall2016_Predictions>>(
                    "predictions",
                    CMsgGCToClientBattlePassRollup_Fall2016::get_predictions_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016::mut_predictions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Fall2016_Bracket>>(
                    "bracket",
                    CMsgGCToClientBattlePassRollup_Fall2016::get_bracket_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016::mut_bracket_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard>>(
                    "player_cards",
                    CMsgGCToClientBattlePassRollup_Fall2016::get_player_cards_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016::mut_player_cards_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge>>(
                    "fantasy_challenge",
                    CMsgGCToClientBattlePassRollup_Fall2016::get_fantasy_challenge_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016::mut_fantasy_challenge_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Fall2016>(
                    "CMsgGCToClientBattlePassRollup_Fall2016",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Fall2016 {
    fn clear(&mut self) {
        self.clear_battle_pass_level();
        self.clear_questlines();
        self.clear_wagering();
        self.clear_achievements();
        self.clear_battle_cup();
        self.clear_predictions();
        self.clear_bracket();
        self.clear_player_cards();
        self.clear_fantasy_challenge();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Fall2016 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Fall2016 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Fall2016_Questlines {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    onestar: ::std::option::Option<u32>,
    twostar: ::std::option::Option<u32>,
    threestar: ::std::option::Option<u32>,
    total: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Fall2016_Questlines {}

impl CMsgGCToClientBattlePassRollup_Fall2016_Questlines {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Fall2016_Questlines {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Fall2016_Questlines {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Fall2016_Questlines> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Fall2016_Questlines,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Fall2016_Questlines::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional uint32 onestar = 2;

    pub fn clear_onestar(&mut self) {
        self.onestar = ::std::option::Option::None;
    }

    pub fn has_onestar(&self) -> bool {
        self.onestar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_onestar(&mut self, v: u32) {
        self.onestar = ::std::option::Option::Some(v);
    }

    pub fn get_onestar(&self) -> u32 {
        self.onestar.unwrap_or(0)
    }

    fn get_onestar_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.onestar
    }

    fn mut_onestar_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.onestar
    }

    // optional uint32 twostar = 3;

    pub fn clear_twostar(&mut self) {
        self.twostar = ::std::option::Option::None;
    }

    pub fn has_twostar(&self) -> bool {
        self.twostar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_twostar(&mut self, v: u32) {
        self.twostar = ::std::option::Option::Some(v);
    }

    pub fn get_twostar(&self) -> u32 {
        self.twostar.unwrap_or(0)
    }

    fn get_twostar_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.twostar
    }

    fn mut_twostar_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.twostar
    }

    // optional uint32 threestar = 4;

    pub fn clear_threestar(&mut self) {
        self.threestar = ::std::option::Option::None;
    }

    pub fn has_threestar(&self) -> bool {
        self.threestar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threestar(&mut self, v: u32) {
        self.threestar = ::std::option::Option::Some(v);
    }

    pub fn get_threestar(&self) -> u32 {
        self.threestar.unwrap_or(0)
    }

    fn get_threestar_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.threestar
    }

    fn mut_threestar_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.threestar
    }

    // optional uint32 total = 5;

    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u32) {
        self.total = ::std::option::Option::Some(v);
    }

    pub fn get_total(&self) -> u32 {
        self.total.unwrap_or(0)
    }

    fn get_total_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total
    }

    fn mut_total_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Fall2016_Questlines {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.onestar = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.twostar = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.threestar = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.onestar {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.twostar {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.threestar {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.onestar {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.twostar {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.threestar {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.total {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Fall2016_Questlines {
    fn new() -> CMsgGCToClientBattlePassRollup_Fall2016_Questlines {
        CMsgGCToClientBattlePassRollup_Fall2016_Questlines::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Fall2016_Questlines>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgGCToClientBattlePassRollup_Fall2016_Questlines::get_name_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Questlines::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "onestar",
                    CMsgGCToClientBattlePassRollup_Fall2016_Questlines::get_onestar_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Questlines::mut_onestar_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "twostar",
                    CMsgGCToClientBattlePassRollup_Fall2016_Questlines::get_twostar_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Questlines::mut_twostar_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "threestar",
                    CMsgGCToClientBattlePassRollup_Fall2016_Questlines::get_threestar_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Questlines::mut_threestar_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total",
                    CMsgGCToClientBattlePassRollup_Fall2016_Questlines::get_total_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Questlines::mut_total_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Fall2016_Questlines>(
                    "CMsgGCToClientBattlePassRollup_Fall2016_Questlines",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Fall2016_Questlines {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_onestar();
        self.clear_twostar();
        self.clear_threestar();
        self.clear_total();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Fall2016_Questlines {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Fall2016_Questlines {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Fall2016_Wagering {
    // message fields
    total_wagered: ::std::option::Option<u32>,
    total_won: ::std::option::Option<u32>,
    average_won: ::std::option::Option<u32>,
    success_rate: ::std::option::Option<u32>,
    total_tips: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Fall2016_Wagering {}

impl CMsgGCToClientBattlePassRollup_Fall2016_Wagering {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Fall2016_Wagering {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Fall2016_Wagering {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Fall2016_Wagering> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Fall2016_Wagering,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Fall2016_Wagering::new)
        }
    }

    // optional uint32 total_wagered = 1;

    pub fn clear_total_wagered(&mut self) {
        self.total_wagered = ::std::option::Option::None;
    }

    pub fn has_total_wagered(&self) -> bool {
        self.total_wagered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_wagered(&mut self, v: u32) {
        self.total_wagered = ::std::option::Option::Some(v);
    }

    pub fn get_total_wagered(&self) -> u32 {
        self.total_wagered.unwrap_or(0)
    }

    fn get_total_wagered_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_wagered
    }

    fn mut_total_wagered_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_wagered
    }

    // optional uint32 total_won = 2;

    pub fn clear_total_won(&mut self) {
        self.total_won = ::std::option::Option::None;
    }

    pub fn has_total_won(&self) -> bool {
        self.total_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_won(&mut self, v: u32) {
        self.total_won = ::std::option::Option::Some(v);
    }

    pub fn get_total_won(&self) -> u32 {
        self.total_won.unwrap_or(0)
    }

    fn get_total_won_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_won
    }

    fn mut_total_won_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_won
    }

    // optional uint32 average_won = 3;

    pub fn clear_average_won(&mut self) {
        self.average_won = ::std::option::Option::None;
    }

    pub fn has_average_won(&self) -> bool {
        self.average_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_won(&mut self, v: u32) {
        self.average_won = ::std::option::Option::Some(v);
    }

    pub fn get_average_won(&self) -> u32 {
        self.average_won.unwrap_or(0)
    }

    fn get_average_won_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.average_won
    }

    fn mut_average_won_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.average_won
    }

    // optional uint32 success_rate = 4;

    pub fn clear_success_rate(&mut self) {
        self.success_rate = ::std::option::Option::None;
    }

    pub fn has_success_rate(&self) -> bool {
        self.success_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success_rate(&mut self, v: u32) {
        self.success_rate = ::std::option::Option::Some(v);
    }

    pub fn get_success_rate(&self) -> u32 {
        self.success_rate.unwrap_or(0)
    }

    fn get_success_rate_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.success_rate
    }

    fn mut_success_rate_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.success_rate
    }

    // optional uint32 total_tips = 5;

    pub fn clear_total_tips(&mut self) {
        self.total_tips = ::std::option::Option::None;
    }

    pub fn has_total_tips(&self) -> bool {
        self.total_tips.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_tips(&mut self, v: u32) {
        self.total_tips = ::std::option::Option::Some(v);
    }

    pub fn get_total_tips(&self) -> u32 {
        self.total_tips.unwrap_or(0)
    }

    fn get_total_tips_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_tips
    }

    fn mut_total_tips_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_tips
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Fall2016_Wagering {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_wagered = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_won = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.average_won = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.success_rate = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_tips = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.total_wagered {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_won {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.average_won {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.success_rate {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_tips {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.total_wagered {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.total_won {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.average_won {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.success_rate {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.total_tips {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Fall2016_Wagering {
    fn new() -> CMsgGCToClientBattlePassRollup_Fall2016_Wagering {
        CMsgGCToClientBattlePassRollup_Fall2016_Wagering::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Fall2016_Wagering>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_wagered",
                    CMsgGCToClientBattlePassRollup_Fall2016_Wagering::get_total_wagered_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Wagering::mut_total_wagered_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_won",
                    CMsgGCToClientBattlePassRollup_Fall2016_Wagering::get_total_won_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Wagering::mut_total_won_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "average_won",
                    CMsgGCToClientBattlePassRollup_Fall2016_Wagering::get_average_won_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Wagering::mut_average_won_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "success_rate",
                    CMsgGCToClientBattlePassRollup_Fall2016_Wagering::get_success_rate_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Wagering::mut_success_rate_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_tips",
                    CMsgGCToClientBattlePassRollup_Fall2016_Wagering::get_total_tips_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Wagering::mut_total_tips_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Fall2016_Wagering>(
                    "CMsgGCToClientBattlePassRollup_Fall2016_Wagering",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Fall2016_Wagering {
    fn clear(&mut self) {
        self.clear_total_wagered();
        self.clear_total_won();
        self.clear_average_won();
        self.clear_success_rate();
        self.clear_total_tips();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Fall2016_Wagering {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Fall2016_Wagering {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Fall2016_Achievements {
    // message fields
    completed: ::std::option::Option<u32>,
    total: ::std::option::Option<u32>,
    points: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Fall2016_Achievements {}

impl CMsgGCToClientBattlePassRollup_Fall2016_Achievements {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Fall2016_Achievements {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Fall2016_Achievements {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Fall2016_Achievements> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Fall2016_Achievements,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Fall2016_Achievements::new)
        }
    }

    // optional uint32 completed = 1;

    pub fn clear_completed(&mut self) {
        self.completed = ::std::option::Option::None;
    }

    pub fn has_completed(&self) -> bool {
        self.completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed(&mut self, v: u32) {
        self.completed = ::std::option::Option::Some(v);
    }

    pub fn get_completed(&self) -> u32 {
        self.completed.unwrap_or(0)
    }

    fn get_completed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.completed
    }

    fn mut_completed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.completed
    }

    // optional uint32 total = 2;

    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u32) {
        self.total = ::std::option::Option::Some(v);
    }

    pub fn get_total(&self) -> u32 {
        self.total.unwrap_or(0)
    }

    fn get_total_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total
    }

    fn mut_total_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total
    }

    // optional uint32 points = 3;

    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: u32) {
        self.points = ::std::option::Option::Some(v);
    }

    pub fn get_points(&self) -> u32 {
        self.points.unwrap_or(0)
    }

    fn get_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points
    }

    fn mut_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Fall2016_Achievements {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.completed = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.completed {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.completed {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.total {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.points {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Fall2016_Achievements {
    fn new() -> CMsgGCToClientBattlePassRollup_Fall2016_Achievements {
        CMsgGCToClientBattlePassRollup_Fall2016_Achievements::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Fall2016_Achievements>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "completed",
                    CMsgGCToClientBattlePassRollup_Fall2016_Achievements::get_completed_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Achievements::mut_completed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total",
                    CMsgGCToClientBattlePassRollup_Fall2016_Achievements::get_total_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Achievements::mut_total_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points",
                    CMsgGCToClientBattlePassRollup_Fall2016_Achievements::get_points_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Achievements::mut_points_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Fall2016_Achievements>(
                    "CMsgGCToClientBattlePassRollup_Fall2016_Achievements",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Fall2016_Achievements {
    fn clear(&mut self) {
        self.clear_completed();
        self.clear_total();
        self.clear_points();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Fall2016_Achievements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Fall2016_Achievements {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Fall2016_BattleCup {
    // message fields
    wins: ::std::option::Option<u32>,
    score: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Fall2016_BattleCup {}

impl CMsgGCToClientBattlePassRollup_Fall2016_BattleCup {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Fall2016_BattleCup {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Fall2016_BattleCup {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Fall2016_BattleCup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Fall2016_BattleCup,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Fall2016_BattleCup::new)
        }
    }

    // optional uint32 wins = 1;

    pub fn clear_wins(&mut self) {
        self.wins = ::std::option::Option::None;
    }

    pub fn has_wins(&self) -> bool {
        self.wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: u32) {
        self.wins = ::std::option::Option::Some(v);
    }

    pub fn get_wins(&self) -> u32 {
        self.wins.unwrap_or(0)
    }

    fn get_wins_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.wins
    }

    fn mut_wins_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.wins
    }

    // optional uint32 score = 2;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    fn get_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.score
    }

    fn mut_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.score
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Fall2016_BattleCup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wins = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.wins {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.wins {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Fall2016_BattleCup {
    fn new() -> CMsgGCToClientBattlePassRollup_Fall2016_BattleCup {
        CMsgGCToClientBattlePassRollup_Fall2016_BattleCup::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Fall2016_BattleCup>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wins",
                    CMsgGCToClientBattlePassRollup_Fall2016_BattleCup::get_wins_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_BattleCup::mut_wins_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "score",
                    CMsgGCToClientBattlePassRollup_Fall2016_BattleCup::get_score_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_BattleCup::mut_score_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Fall2016_BattleCup>(
                    "CMsgGCToClientBattlePassRollup_Fall2016_BattleCup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Fall2016_BattleCup {
    fn clear(&mut self) {
        self.clear_wins();
        self.clear_score();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Fall2016_BattleCup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Fall2016_BattleCup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Fall2016_Predictions {
    // message fields
    correct: ::std::option::Option<u32>,
    total: ::std::option::Option<u32>,
    points: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Fall2016_Predictions {}

impl CMsgGCToClientBattlePassRollup_Fall2016_Predictions {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Fall2016_Predictions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Fall2016_Predictions {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Fall2016_Predictions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Fall2016_Predictions,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Fall2016_Predictions::new)
        }
    }

    // optional uint32 correct = 1;

    pub fn clear_correct(&mut self) {
        self.correct = ::std::option::Option::None;
    }

    pub fn has_correct(&self) -> bool {
        self.correct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correct(&mut self, v: u32) {
        self.correct = ::std::option::Option::Some(v);
    }

    pub fn get_correct(&self) -> u32 {
        self.correct.unwrap_or(0)
    }

    fn get_correct_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.correct
    }

    fn mut_correct_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.correct
    }

    // optional uint32 total = 2;

    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u32) {
        self.total = ::std::option::Option::Some(v);
    }

    pub fn get_total(&self) -> u32 {
        self.total.unwrap_or(0)
    }

    fn get_total_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total
    }

    fn mut_total_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total
    }

    // optional uint32 points = 3;

    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: u32) {
        self.points = ::std::option::Option::Some(v);
    }

    pub fn get_points(&self) -> u32 {
        self.points.unwrap_or(0)
    }

    fn get_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points
    }

    fn mut_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Fall2016_Predictions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.correct = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.correct {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.correct {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.total {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.points {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Fall2016_Predictions {
    fn new() -> CMsgGCToClientBattlePassRollup_Fall2016_Predictions {
        CMsgGCToClientBattlePassRollup_Fall2016_Predictions::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Fall2016_Predictions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "correct",
                    CMsgGCToClientBattlePassRollup_Fall2016_Predictions::get_correct_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Predictions::mut_correct_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total",
                    CMsgGCToClientBattlePassRollup_Fall2016_Predictions::get_total_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Predictions::mut_total_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points",
                    CMsgGCToClientBattlePassRollup_Fall2016_Predictions::get_points_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Predictions::mut_points_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Fall2016_Predictions>(
                    "CMsgGCToClientBattlePassRollup_Fall2016_Predictions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Fall2016_Predictions {
    fn clear(&mut self) {
        self.clear_correct();
        self.clear_total();
        self.clear_points();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Fall2016_Predictions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Fall2016_Predictions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Fall2016_Bracket {
    // message fields
    correct: ::std::option::Option<u32>,
    points: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Fall2016_Bracket {}

impl CMsgGCToClientBattlePassRollup_Fall2016_Bracket {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Fall2016_Bracket {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Fall2016_Bracket {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Fall2016_Bracket> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Fall2016_Bracket,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Fall2016_Bracket::new)
        }
    }

    // optional uint32 correct = 1;

    pub fn clear_correct(&mut self) {
        self.correct = ::std::option::Option::None;
    }

    pub fn has_correct(&self) -> bool {
        self.correct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correct(&mut self, v: u32) {
        self.correct = ::std::option::Option::Some(v);
    }

    pub fn get_correct(&self) -> u32 {
        self.correct.unwrap_or(0)
    }

    fn get_correct_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.correct
    }

    fn mut_correct_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.correct
    }

    // optional uint32 points = 2;

    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: u32) {
        self.points = ::std::option::Option::Some(v);
    }

    pub fn get_points(&self) -> u32 {
        self.points.unwrap_or(0)
    }

    fn get_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points
    }

    fn mut_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Fall2016_Bracket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.correct = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.correct {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.correct {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.points {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Fall2016_Bracket {
    fn new() -> CMsgGCToClientBattlePassRollup_Fall2016_Bracket {
        CMsgGCToClientBattlePassRollup_Fall2016_Bracket::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Fall2016_Bracket>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "correct",
                    CMsgGCToClientBattlePassRollup_Fall2016_Bracket::get_correct_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Bracket::mut_correct_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points",
                    CMsgGCToClientBattlePassRollup_Fall2016_Bracket::get_points_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_Bracket::mut_points_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Fall2016_Bracket>(
                    "CMsgGCToClientBattlePassRollup_Fall2016_Bracket",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Fall2016_Bracket {
    fn clear(&mut self) {
        self.clear_correct();
        self.clear_points();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Fall2016_Bracket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Fall2016_Bracket {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard {
    // message fields
    account_id: ::std::option::Option<u32>,
    quality: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard {}

impl CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 quality = 2;

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    pub fn get_quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    fn get_quality_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.quality
    }

    fn mut_quality_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.quality
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard {
    fn new() -> CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard {
        CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard::get_account_id_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quality",
                    CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard::get_quality_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard::mut_quality_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard>(
                    "CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_quality();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Fall2016_PlayerCard {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge {
    // message fields
    total_score: ::std::option::Option<f32>,
    percentile: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge {}

impl CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge::new)
        }
    }

    // optional float total_score = 1;

    pub fn clear_total_score(&mut self) {
        self.total_score = ::std::option::Option::None;
    }

    pub fn has_total_score(&self) -> bool {
        self.total_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_score(&mut self, v: f32) {
        self.total_score = ::std::option::Option::Some(v);
    }

    pub fn get_total_score(&self) -> f32 {
        self.total_score.unwrap_or(0.)
    }

    fn get_total_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.total_score
    }

    fn mut_total_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.total_score
    }

    // optional float percentile = 2;

    pub fn clear_percentile(&mut self) {
        self.percentile = ::std::option::Option::None;
    }

    pub fn has_percentile(&self) -> bool {
        self.percentile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_percentile(&mut self, v: f32) {
        self.percentile = ::std::option::Option::Some(v);
    }

    pub fn get_percentile(&self) -> f32 {
        self.percentile.unwrap_or(0.)
    }

    fn get_percentile_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.percentile
    }

    fn mut_percentile_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.percentile
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.total_score = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.percentile = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.total_score {
            my_size += 5;
        }
        if let Some(v) = self.percentile {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.total_score {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.percentile {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge {
    fn new() -> CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge {
        CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "total_score",
                    CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge::get_total_score_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge::mut_total_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "percentile",
                    CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge::get_percentile_for_reflect,
                    CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge::mut_percentile_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge>(
                    "CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge {
    fn clear(&mut self) {
        self.clear_total_score();
        self.clear_percentile();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Fall2016_FantasyChallenge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Winter2017 {
    // message fields
    battle_pass_level: ::std::option::Option<u32>,
    questlines: ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Winter2017_Questlines>,
    wagering: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_Wagering>,
    achievements: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_Achievements>,
    battle_cup: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_BattleCup>,
    predictions: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_Predictions>,
    bracket: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_Bracket>,
    player_cards: ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard>,
    fantasy_challenge: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Winter2017 {}

impl CMsgGCToClientBattlePassRollup_Winter2017 {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Winter2017 {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Winter2017 {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Winter2017> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Winter2017,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Winter2017::new)
        }
    }

    // optional uint32 battle_pass_level = 1;

    pub fn clear_battle_pass_level(&mut self) {
        self.battle_pass_level = ::std::option::Option::None;
    }

    pub fn has_battle_pass_level(&self) -> bool {
        self.battle_pass_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battle_pass_level(&mut self, v: u32) {
        self.battle_pass_level = ::std::option::Option::Some(v);
    }

    pub fn get_battle_pass_level(&self) -> u32 {
        self.battle_pass_level.unwrap_or(0)
    }

    fn get_battle_pass_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.battle_pass_level
    }

    fn mut_battle_pass_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.battle_pass_level
    }

    // repeated .CMsgGCToClientBattlePassRollup_Winter2017.Questlines questlines = 2;

    pub fn clear_questlines(&mut self) {
        self.questlines.clear();
    }

    // Param is passed by value, moved
    pub fn set_questlines(&mut self, v: ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Winter2017_Questlines>) {
        self.questlines = v;
    }

    // Mutable pointer to the field.
    pub fn mut_questlines(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Winter2017_Questlines> {
        &mut self.questlines
    }

    // Take field
    pub fn take_questlines(&mut self) -> ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Winter2017_Questlines> {
        ::std::mem::replace(&mut self.questlines, ::protobuf::RepeatedField::new())
    }

    pub fn get_questlines(&self) -> &[CMsgGCToClientBattlePassRollup_Winter2017_Questlines] {
        &self.questlines
    }

    fn get_questlines_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Winter2017_Questlines> {
        &self.questlines
    }

    fn mut_questlines_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Winter2017_Questlines> {
        &mut self.questlines
    }

    // optional .CMsgGCToClientBattlePassRollup_Winter2017.Wagering wagering = 3;

    pub fn clear_wagering(&mut self) {
        self.wagering.clear();
    }

    pub fn has_wagering(&self) -> bool {
        self.wagering.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wagering(&mut self, v: CMsgGCToClientBattlePassRollup_Winter2017_Wagering) {
        self.wagering = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wagering(&mut self) -> &mut CMsgGCToClientBattlePassRollup_Winter2017_Wagering {
        if self.wagering.is_none() {
            self.wagering.set_default();
        }
        self.wagering.as_mut().unwrap()
    }

    // Take field
    pub fn take_wagering(&mut self) -> CMsgGCToClientBattlePassRollup_Winter2017_Wagering {
        self.wagering.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Winter2017_Wagering::new())
    }

    pub fn get_wagering(&self) -> &CMsgGCToClientBattlePassRollup_Winter2017_Wagering {
        self.wagering.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Winter2017_Wagering::default_instance())
    }

    fn get_wagering_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_Wagering> {
        &self.wagering
    }

    fn mut_wagering_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_Wagering> {
        &mut self.wagering
    }

    // optional .CMsgGCToClientBattlePassRollup_Winter2017.Achievements achievements = 4;

    pub fn clear_achievements(&mut self) {
        self.achievements.clear();
    }

    pub fn has_achievements(&self) -> bool {
        self.achievements.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievements(&mut self, v: CMsgGCToClientBattlePassRollup_Winter2017_Achievements) {
        self.achievements = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_achievements(&mut self) -> &mut CMsgGCToClientBattlePassRollup_Winter2017_Achievements {
        if self.achievements.is_none() {
            self.achievements.set_default();
        }
        self.achievements.as_mut().unwrap()
    }

    // Take field
    pub fn take_achievements(&mut self) -> CMsgGCToClientBattlePassRollup_Winter2017_Achievements {
        self.achievements.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Winter2017_Achievements::new())
    }

    pub fn get_achievements(&self) -> &CMsgGCToClientBattlePassRollup_Winter2017_Achievements {
        self.achievements.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Winter2017_Achievements::default_instance())
    }

    fn get_achievements_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_Achievements> {
        &self.achievements
    }

    fn mut_achievements_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_Achievements> {
        &mut self.achievements
    }

    // optional .CMsgGCToClientBattlePassRollup_Winter2017.BattleCup battle_cup = 5;

    pub fn clear_battle_cup(&mut self) {
        self.battle_cup.clear();
    }

    pub fn has_battle_cup(&self) -> bool {
        self.battle_cup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battle_cup(&mut self, v: CMsgGCToClientBattlePassRollup_Winter2017_BattleCup) {
        self.battle_cup = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_battle_cup(&mut self) -> &mut CMsgGCToClientBattlePassRollup_Winter2017_BattleCup {
        if self.battle_cup.is_none() {
            self.battle_cup.set_default();
        }
        self.battle_cup.as_mut().unwrap()
    }

    // Take field
    pub fn take_battle_cup(&mut self) -> CMsgGCToClientBattlePassRollup_Winter2017_BattleCup {
        self.battle_cup.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Winter2017_BattleCup::new())
    }

    pub fn get_battle_cup(&self) -> &CMsgGCToClientBattlePassRollup_Winter2017_BattleCup {
        self.battle_cup.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Winter2017_BattleCup::default_instance())
    }

    fn get_battle_cup_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_BattleCup> {
        &self.battle_cup
    }

    fn mut_battle_cup_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_BattleCup> {
        &mut self.battle_cup
    }

    // optional .CMsgGCToClientBattlePassRollup_Winter2017.Predictions predictions = 6;

    pub fn clear_predictions(&mut self) {
        self.predictions.clear();
    }

    pub fn has_predictions(&self) -> bool {
        self.predictions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_predictions(&mut self, v: CMsgGCToClientBattlePassRollup_Winter2017_Predictions) {
        self.predictions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_predictions(&mut self) -> &mut CMsgGCToClientBattlePassRollup_Winter2017_Predictions {
        if self.predictions.is_none() {
            self.predictions.set_default();
        }
        self.predictions.as_mut().unwrap()
    }

    // Take field
    pub fn take_predictions(&mut self) -> CMsgGCToClientBattlePassRollup_Winter2017_Predictions {
        self.predictions.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Winter2017_Predictions::new())
    }

    pub fn get_predictions(&self) -> &CMsgGCToClientBattlePassRollup_Winter2017_Predictions {
        self.predictions.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Winter2017_Predictions::default_instance())
    }

    fn get_predictions_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_Predictions> {
        &self.predictions
    }

    fn mut_predictions_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_Predictions> {
        &mut self.predictions
    }

    // optional .CMsgGCToClientBattlePassRollup_Winter2017.Bracket bracket = 7;

    pub fn clear_bracket(&mut self) {
        self.bracket.clear();
    }

    pub fn has_bracket(&self) -> bool {
        self.bracket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bracket(&mut self, v: CMsgGCToClientBattlePassRollup_Winter2017_Bracket) {
        self.bracket = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bracket(&mut self) -> &mut CMsgGCToClientBattlePassRollup_Winter2017_Bracket {
        if self.bracket.is_none() {
            self.bracket.set_default();
        }
        self.bracket.as_mut().unwrap()
    }

    // Take field
    pub fn take_bracket(&mut self) -> CMsgGCToClientBattlePassRollup_Winter2017_Bracket {
        self.bracket.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Winter2017_Bracket::new())
    }

    pub fn get_bracket(&self) -> &CMsgGCToClientBattlePassRollup_Winter2017_Bracket {
        self.bracket.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Winter2017_Bracket::default_instance())
    }

    fn get_bracket_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_Bracket> {
        &self.bracket
    }

    fn mut_bracket_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_Bracket> {
        &mut self.bracket
    }

    // repeated .CMsgGCToClientBattlePassRollup_Winter2017.PlayerCard player_cards = 8;

    pub fn clear_player_cards(&mut self) {
        self.player_cards.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_cards(&mut self, v: ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard>) {
        self.player_cards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_cards(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard> {
        &mut self.player_cards
    }

    // Take field
    pub fn take_player_cards(&mut self) -> ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard> {
        ::std::mem::replace(&mut self.player_cards, ::protobuf::RepeatedField::new())
    }

    pub fn get_player_cards(&self) -> &[CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard] {
        &self.player_cards
    }

    fn get_player_cards_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard> {
        &self.player_cards
    }

    fn mut_player_cards_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard> {
        &mut self.player_cards
    }

    // optional .CMsgGCToClientBattlePassRollup_Winter2017.FantasyChallenge fantasy_challenge = 9;

    pub fn clear_fantasy_challenge(&mut self) {
        self.fantasy_challenge.clear();
    }

    pub fn has_fantasy_challenge(&self) -> bool {
        self.fantasy_challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_challenge(&mut self, v: CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge) {
        self.fantasy_challenge = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fantasy_challenge(&mut self) -> &mut CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge {
        if self.fantasy_challenge.is_none() {
            self.fantasy_challenge.set_default();
        }
        self.fantasy_challenge.as_mut().unwrap()
    }

    // Take field
    pub fn take_fantasy_challenge(&mut self) -> CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge {
        self.fantasy_challenge.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge::new())
    }

    pub fn get_fantasy_challenge(&self) -> &CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge {
        self.fantasy_challenge.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge::default_instance())
    }

    fn get_fantasy_challenge_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge> {
        &self.fantasy_challenge
    }

    fn mut_fantasy_challenge_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge> {
        &mut self.fantasy_challenge
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Winter2017 {
    fn is_initialized(&self) -> bool {
        for v in &self.questlines {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.wagering {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.achievements {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.battle_cup {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.predictions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bracket {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.player_cards {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fantasy_challenge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.battle_pass_level = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.questlines)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.wagering)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.achievements)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.battle_cup)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.predictions)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bracket)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_cards)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fantasy_challenge)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.battle_pass_level {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.questlines {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.wagering.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.achievements.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.battle_cup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.predictions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bracket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.player_cards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.fantasy_challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.battle_pass_level {
            os.write_uint32(1, v)?;
        }
        for v in &self.questlines {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.wagering.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.achievements.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.battle_cup.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.predictions.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bracket.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.player_cards {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.fantasy_challenge.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Winter2017 {
    fn new() -> CMsgGCToClientBattlePassRollup_Winter2017 {
        CMsgGCToClientBattlePassRollup_Winter2017::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Winter2017>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "battle_pass_level",
                    CMsgGCToClientBattlePassRollup_Winter2017::get_battle_pass_level_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017::mut_battle_pass_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Winter2017_Questlines>>(
                    "questlines",
                    CMsgGCToClientBattlePassRollup_Winter2017::get_questlines_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017::mut_questlines_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Winter2017_Wagering>>(
                    "wagering",
                    CMsgGCToClientBattlePassRollup_Winter2017::get_wagering_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017::mut_wagering_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Winter2017_Achievements>>(
                    "achievements",
                    CMsgGCToClientBattlePassRollup_Winter2017::get_achievements_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017::mut_achievements_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Winter2017_BattleCup>>(
                    "battle_cup",
                    CMsgGCToClientBattlePassRollup_Winter2017::get_battle_cup_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017::mut_battle_cup_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Winter2017_Predictions>>(
                    "predictions",
                    CMsgGCToClientBattlePassRollup_Winter2017::get_predictions_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017::mut_predictions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Winter2017_Bracket>>(
                    "bracket",
                    CMsgGCToClientBattlePassRollup_Winter2017::get_bracket_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017::mut_bracket_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard>>(
                    "player_cards",
                    CMsgGCToClientBattlePassRollup_Winter2017::get_player_cards_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017::mut_player_cards_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge>>(
                    "fantasy_challenge",
                    CMsgGCToClientBattlePassRollup_Winter2017::get_fantasy_challenge_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017::mut_fantasy_challenge_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Winter2017>(
                    "CMsgGCToClientBattlePassRollup_Winter2017",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Winter2017 {
    fn clear(&mut self) {
        self.clear_battle_pass_level();
        self.clear_questlines();
        self.clear_wagering();
        self.clear_achievements();
        self.clear_battle_cup();
        self.clear_predictions();
        self.clear_bracket();
        self.clear_player_cards();
        self.clear_fantasy_challenge();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Winter2017 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Winter2017 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Winter2017_Questlines {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    onestar: ::std::option::Option<u32>,
    twostar: ::std::option::Option<u32>,
    threestar: ::std::option::Option<u32>,
    total: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Winter2017_Questlines {}

impl CMsgGCToClientBattlePassRollup_Winter2017_Questlines {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Winter2017_Questlines {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Winter2017_Questlines {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Winter2017_Questlines> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Winter2017_Questlines,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Winter2017_Questlines::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional uint32 onestar = 2;

    pub fn clear_onestar(&mut self) {
        self.onestar = ::std::option::Option::None;
    }

    pub fn has_onestar(&self) -> bool {
        self.onestar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_onestar(&mut self, v: u32) {
        self.onestar = ::std::option::Option::Some(v);
    }

    pub fn get_onestar(&self) -> u32 {
        self.onestar.unwrap_or(0)
    }

    fn get_onestar_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.onestar
    }

    fn mut_onestar_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.onestar
    }

    // optional uint32 twostar = 3;

    pub fn clear_twostar(&mut self) {
        self.twostar = ::std::option::Option::None;
    }

    pub fn has_twostar(&self) -> bool {
        self.twostar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_twostar(&mut self, v: u32) {
        self.twostar = ::std::option::Option::Some(v);
    }

    pub fn get_twostar(&self) -> u32 {
        self.twostar.unwrap_or(0)
    }

    fn get_twostar_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.twostar
    }

    fn mut_twostar_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.twostar
    }

    // optional uint32 threestar = 4;

    pub fn clear_threestar(&mut self) {
        self.threestar = ::std::option::Option::None;
    }

    pub fn has_threestar(&self) -> bool {
        self.threestar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threestar(&mut self, v: u32) {
        self.threestar = ::std::option::Option::Some(v);
    }

    pub fn get_threestar(&self) -> u32 {
        self.threestar.unwrap_or(0)
    }

    fn get_threestar_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.threestar
    }

    fn mut_threestar_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.threestar
    }

    // optional uint32 total = 5;

    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u32) {
        self.total = ::std::option::Option::Some(v);
    }

    pub fn get_total(&self) -> u32 {
        self.total.unwrap_or(0)
    }

    fn get_total_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total
    }

    fn mut_total_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Winter2017_Questlines {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.onestar = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.twostar = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.threestar = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.onestar {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.twostar {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.threestar {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.onestar {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.twostar {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.threestar {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.total {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Winter2017_Questlines {
    fn new() -> CMsgGCToClientBattlePassRollup_Winter2017_Questlines {
        CMsgGCToClientBattlePassRollup_Winter2017_Questlines::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Winter2017_Questlines>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgGCToClientBattlePassRollup_Winter2017_Questlines::get_name_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Questlines::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "onestar",
                    CMsgGCToClientBattlePassRollup_Winter2017_Questlines::get_onestar_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Questlines::mut_onestar_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "twostar",
                    CMsgGCToClientBattlePassRollup_Winter2017_Questlines::get_twostar_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Questlines::mut_twostar_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "threestar",
                    CMsgGCToClientBattlePassRollup_Winter2017_Questlines::get_threestar_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Questlines::mut_threestar_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total",
                    CMsgGCToClientBattlePassRollup_Winter2017_Questlines::get_total_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Questlines::mut_total_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Winter2017_Questlines>(
                    "CMsgGCToClientBattlePassRollup_Winter2017_Questlines",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Winter2017_Questlines {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_onestar();
        self.clear_twostar();
        self.clear_threestar();
        self.clear_total();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Winter2017_Questlines {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Winter2017_Questlines {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Winter2017_Wagering {
    // message fields
    total_wagered: ::std::option::Option<u32>,
    total_won: ::std::option::Option<u32>,
    average_won: ::std::option::Option<u32>,
    success_rate: ::std::option::Option<u32>,
    total_tips: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Winter2017_Wagering {}

impl CMsgGCToClientBattlePassRollup_Winter2017_Wagering {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Winter2017_Wagering {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Winter2017_Wagering {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Winter2017_Wagering> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Winter2017_Wagering,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Winter2017_Wagering::new)
        }
    }

    // optional uint32 total_wagered = 1;

    pub fn clear_total_wagered(&mut self) {
        self.total_wagered = ::std::option::Option::None;
    }

    pub fn has_total_wagered(&self) -> bool {
        self.total_wagered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_wagered(&mut self, v: u32) {
        self.total_wagered = ::std::option::Option::Some(v);
    }

    pub fn get_total_wagered(&self) -> u32 {
        self.total_wagered.unwrap_or(0)
    }

    fn get_total_wagered_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_wagered
    }

    fn mut_total_wagered_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_wagered
    }

    // optional uint32 total_won = 2;

    pub fn clear_total_won(&mut self) {
        self.total_won = ::std::option::Option::None;
    }

    pub fn has_total_won(&self) -> bool {
        self.total_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_won(&mut self, v: u32) {
        self.total_won = ::std::option::Option::Some(v);
    }

    pub fn get_total_won(&self) -> u32 {
        self.total_won.unwrap_or(0)
    }

    fn get_total_won_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_won
    }

    fn mut_total_won_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_won
    }

    // optional uint32 average_won = 3;

    pub fn clear_average_won(&mut self) {
        self.average_won = ::std::option::Option::None;
    }

    pub fn has_average_won(&self) -> bool {
        self.average_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_won(&mut self, v: u32) {
        self.average_won = ::std::option::Option::Some(v);
    }

    pub fn get_average_won(&self) -> u32 {
        self.average_won.unwrap_or(0)
    }

    fn get_average_won_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.average_won
    }

    fn mut_average_won_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.average_won
    }

    // optional uint32 success_rate = 4;

    pub fn clear_success_rate(&mut self) {
        self.success_rate = ::std::option::Option::None;
    }

    pub fn has_success_rate(&self) -> bool {
        self.success_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success_rate(&mut self, v: u32) {
        self.success_rate = ::std::option::Option::Some(v);
    }

    pub fn get_success_rate(&self) -> u32 {
        self.success_rate.unwrap_or(0)
    }

    fn get_success_rate_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.success_rate
    }

    fn mut_success_rate_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.success_rate
    }

    // optional uint32 total_tips = 5;

    pub fn clear_total_tips(&mut self) {
        self.total_tips = ::std::option::Option::None;
    }

    pub fn has_total_tips(&self) -> bool {
        self.total_tips.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_tips(&mut self, v: u32) {
        self.total_tips = ::std::option::Option::Some(v);
    }

    pub fn get_total_tips(&self) -> u32 {
        self.total_tips.unwrap_or(0)
    }

    fn get_total_tips_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_tips
    }

    fn mut_total_tips_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_tips
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Winter2017_Wagering {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_wagered = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_won = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.average_won = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.success_rate = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_tips = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.total_wagered {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_won {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.average_won {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.success_rate {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_tips {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.total_wagered {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.total_won {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.average_won {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.success_rate {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.total_tips {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Winter2017_Wagering {
    fn new() -> CMsgGCToClientBattlePassRollup_Winter2017_Wagering {
        CMsgGCToClientBattlePassRollup_Winter2017_Wagering::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Winter2017_Wagering>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_wagered",
                    CMsgGCToClientBattlePassRollup_Winter2017_Wagering::get_total_wagered_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Wagering::mut_total_wagered_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_won",
                    CMsgGCToClientBattlePassRollup_Winter2017_Wagering::get_total_won_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Wagering::mut_total_won_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "average_won",
                    CMsgGCToClientBattlePassRollup_Winter2017_Wagering::get_average_won_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Wagering::mut_average_won_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "success_rate",
                    CMsgGCToClientBattlePassRollup_Winter2017_Wagering::get_success_rate_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Wagering::mut_success_rate_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_tips",
                    CMsgGCToClientBattlePassRollup_Winter2017_Wagering::get_total_tips_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Wagering::mut_total_tips_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Winter2017_Wagering>(
                    "CMsgGCToClientBattlePassRollup_Winter2017_Wagering",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Winter2017_Wagering {
    fn clear(&mut self) {
        self.clear_total_wagered();
        self.clear_total_won();
        self.clear_average_won();
        self.clear_success_rate();
        self.clear_total_tips();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Winter2017_Wagering {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Winter2017_Wagering {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Winter2017_Achievements {
    // message fields
    completed: ::std::option::Option<u32>,
    total: ::std::option::Option<u32>,
    points: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Winter2017_Achievements {}

impl CMsgGCToClientBattlePassRollup_Winter2017_Achievements {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Winter2017_Achievements {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Winter2017_Achievements {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Winter2017_Achievements> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Winter2017_Achievements,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Winter2017_Achievements::new)
        }
    }

    // optional uint32 completed = 1;

    pub fn clear_completed(&mut self) {
        self.completed = ::std::option::Option::None;
    }

    pub fn has_completed(&self) -> bool {
        self.completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed(&mut self, v: u32) {
        self.completed = ::std::option::Option::Some(v);
    }

    pub fn get_completed(&self) -> u32 {
        self.completed.unwrap_or(0)
    }

    fn get_completed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.completed
    }

    fn mut_completed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.completed
    }

    // optional uint32 total = 2;

    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u32) {
        self.total = ::std::option::Option::Some(v);
    }

    pub fn get_total(&self) -> u32 {
        self.total.unwrap_or(0)
    }

    fn get_total_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total
    }

    fn mut_total_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total
    }

    // optional uint32 points = 3;

    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: u32) {
        self.points = ::std::option::Option::Some(v);
    }

    pub fn get_points(&self) -> u32 {
        self.points.unwrap_or(0)
    }

    fn get_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points
    }

    fn mut_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Winter2017_Achievements {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.completed = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.completed {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.completed {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.total {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.points {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Winter2017_Achievements {
    fn new() -> CMsgGCToClientBattlePassRollup_Winter2017_Achievements {
        CMsgGCToClientBattlePassRollup_Winter2017_Achievements::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Winter2017_Achievements>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "completed",
                    CMsgGCToClientBattlePassRollup_Winter2017_Achievements::get_completed_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Achievements::mut_completed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total",
                    CMsgGCToClientBattlePassRollup_Winter2017_Achievements::get_total_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Achievements::mut_total_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points",
                    CMsgGCToClientBattlePassRollup_Winter2017_Achievements::get_points_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Achievements::mut_points_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Winter2017_Achievements>(
                    "CMsgGCToClientBattlePassRollup_Winter2017_Achievements",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Winter2017_Achievements {
    fn clear(&mut self) {
        self.clear_completed();
        self.clear_total();
        self.clear_points();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Winter2017_Achievements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Winter2017_Achievements {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Winter2017_BattleCup {
    // message fields
    wins: ::std::option::Option<u32>,
    score: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Winter2017_BattleCup {}

impl CMsgGCToClientBattlePassRollup_Winter2017_BattleCup {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Winter2017_BattleCup {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Winter2017_BattleCup {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Winter2017_BattleCup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Winter2017_BattleCup,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Winter2017_BattleCup::new)
        }
    }

    // optional uint32 wins = 1;

    pub fn clear_wins(&mut self) {
        self.wins = ::std::option::Option::None;
    }

    pub fn has_wins(&self) -> bool {
        self.wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: u32) {
        self.wins = ::std::option::Option::Some(v);
    }

    pub fn get_wins(&self) -> u32 {
        self.wins.unwrap_or(0)
    }

    fn get_wins_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.wins
    }

    fn mut_wins_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.wins
    }

    // optional uint32 score = 2;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    fn get_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.score
    }

    fn mut_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.score
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Winter2017_BattleCup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wins = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.wins {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.wins {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Winter2017_BattleCup {
    fn new() -> CMsgGCToClientBattlePassRollup_Winter2017_BattleCup {
        CMsgGCToClientBattlePassRollup_Winter2017_BattleCup::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Winter2017_BattleCup>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wins",
                    CMsgGCToClientBattlePassRollup_Winter2017_BattleCup::get_wins_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_BattleCup::mut_wins_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "score",
                    CMsgGCToClientBattlePassRollup_Winter2017_BattleCup::get_score_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_BattleCup::mut_score_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Winter2017_BattleCup>(
                    "CMsgGCToClientBattlePassRollup_Winter2017_BattleCup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Winter2017_BattleCup {
    fn clear(&mut self) {
        self.clear_wins();
        self.clear_score();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Winter2017_BattleCup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Winter2017_BattleCup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Winter2017_Predictions {
    // message fields
    correct: ::std::option::Option<u32>,
    total: ::std::option::Option<u32>,
    points: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Winter2017_Predictions {}

impl CMsgGCToClientBattlePassRollup_Winter2017_Predictions {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Winter2017_Predictions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Winter2017_Predictions {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Winter2017_Predictions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Winter2017_Predictions,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Winter2017_Predictions::new)
        }
    }

    // optional uint32 correct = 1;

    pub fn clear_correct(&mut self) {
        self.correct = ::std::option::Option::None;
    }

    pub fn has_correct(&self) -> bool {
        self.correct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correct(&mut self, v: u32) {
        self.correct = ::std::option::Option::Some(v);
    }

    pub fn get_correct(&self) -> u32 {
        self.correct.unwrap_or(0)
    }

    fn get_correct_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.correct
    }

    fn mut_correct_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.correct
    }

    // optional uint32 total = 2;

    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u32) {
        self.total = ::std::option::Option::Some(v);
    }

    pub fn get_total(&self) -> u32 {
        self.total.unwrap_or(0)
    }

    fn get_total_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total
    }

    fn mut_total_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total
    }

    // optional uint32 points = 3;

    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: u32) {
        self.points = ::std::option::Option::Some(v);
    }

    pub fn get_points(&self) -> u32 {
        self.points.unwrap_or(0)
    }

    fn get_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points
    }

    fn mut_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Winter2017_Predictions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.correct = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.correct {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.correct {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.total {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.points {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Winter2017_Predictions {
    fn new() -> CMsgGCToClientBattlePassRollup_Winter2017_Predictions {
        CMsgGCToClientBattlePassRollup_Winter2017_Predictions::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Winter2017_Predictions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "correct",
                    CMsgGCToClientBattlePassRollup_Winter2017_Predictions::get_correct_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Predictions::mut_correct_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total",
                    CMsgGCToClientBattlePassRollup_Winter2017_Predictions::get_total_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Predictions::mut_total_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points",
                    CMsgGCToClientBattlePassRollup_Winter2017_Predictions::get_points_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Predictions::mut_points_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Winter2017_Predictions>(
                    "CMsgGCToClientBattlePassRollup_Winter2017_Predictions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Winter2017_Predictions {
    fn clear(&mut self) {
        self.clear_correct();
        self.clear_total();
        self.clear_points();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Winter2017_Predictions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Winter2017_Predictions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Winter2017_Bracket {
    // message fields
    correct: ::std::option::Option<u32>,
    points: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Winter2017_Bracket {}

impl CMsgGCToClientBattlePassRollup_Winter2017_Bracket {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Winter2017_Bracket {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Winter2017_Bracket {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Winter2017_Bracket> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Winter2017_Bracket,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Winter2017_Bracket::new)
        }
    }

    // optional uint32 correct = 1;

    pub fn clear_correct(&mut self) {
        self.correct = ::std::option::Option::None;
    }

    pub fn has_correct(&self) -> bool {
        self.correct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correct(&mut self, v: u32) {
        self.correct = ::std::option::Option::Some(v);
    }

    pub fn get_correct(&self) -> u32 {
        self.correct.unwrap_or(0)
    }

    fn get_correct_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.correct
    }

    fn mut_correct_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.correct
    }

    // optional uint32 points = 2;

    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: u32) {
        self.points = ::std::option::Option::Some(v);
    }

    pub fn get_points(&self) -> u32 {
        self.points.unwrap_or(0)
    }

    fn get_points_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.points
    }

    fn mut_points_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.points
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Winter2017_Bracket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.correct = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.correct {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.correct {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.points {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Winter2017_Bracket {
    fn new() -> CMsgGCToClientBattlePassRollup_Winter2017_Bracket {
        CMsgGCToClientBattlePassRollup_Winter2017_Bracket::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Winter2017_Bracket>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "correct",
                    CMsgGCToClientBattlePassRollup_Winter2017_Bracket::get_correct_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Bracket::mut_correct_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "points",
                    CMsgGCToClientBattlePassRollup_Winter2017_Bracket::get_points_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_Bracket::mut_points_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Winter2017_Bracket>(
                    "CMsgGCToClientBattlePassRollup_Winter2017_Bracket",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Winter2017_Bracket {
    fn clear(&mut self) {
        self.clear_correct();
        self.clear_points();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Winter2017_Bracket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Winter2017_Bracket {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard {
    // message fields
    account_id: ::std::option::Option<u32>,
    quality: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard {}

impl CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 quality = 2;

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    pub fn get_quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    fn get_quality_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.quality
    }

    fn mut_quality_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.quality
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard {
    fn new() -> CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard {
        CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard::get_account_id_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quality",
                    CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard::get_quality_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard::mut_quality_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard>(
                    "CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_quality();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Winter2017_PlayerCard {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge {
    // message fields
    total_score: ::std::option::Option<f32>,
    percentile: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge {}

impl CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge::new)
        }
    }

    // optional float total_score = 1;

    pub fn clear_total_score(&mut self) {
        self.total_score = ::std::option::Option::None;
    }

    pub fn has_total_score(&self) -> bool {
        self.total_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_score(&mut self, v: f32) {
        self.total_score = ::std::option::Option::Some(v);
    }

    pub fn get_total_score(&self) -> f32 {
        self.total_score.unwrap_or(0.)
    }

    fn get_total_score_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.total_score
    }

    fn mut_total_score_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.total_score
    }

    // optional float percentile = 2;

    pub fn clear_percentile(&mut self) {
        self.percentile = ::std::option::Option::None;
    }

    pub fn has_percentile(&self) -> bool {
        self.percentile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_percentile(&mut self, v: f32) {
        self.percentile = ::std::option::Option::Some(v);
    }

    pub fn get_percentile(&self) -> f32 {
        self.percentile.unwrap_or(0.)
    }

    fn get_percentile_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.percentile
    }

    fn mut_percentile_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.percentile
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.total_score = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.percentile = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.total_score {
            my_size += 5;
        }
        if let Some(v) = self.percentile {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.total_score {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.percentile {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge {
    fn new() -> CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge {
        CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "total_score",
                    CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge::get_total_score_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge::mut_total_score_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "percentile",
                    CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge::get_percentile_for_reflect,
                    CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge::mut_percentile_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge>(
                    "CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge {
    fn clear(&mut self) {
        self.clear_total_score();
        self.clear_percentile();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollup_Winter2017_FantasyChallenge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollupRequest {
    // message fields
    event_id: ::std::option::Option<u32>,
    account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollupRequest {}

impl CMsgGCToClientBattlePassRollupRequest {
    pub fn new() -> CMsgGCToClientBattlePassRollupRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollupRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollupRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollupRequest,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollupRequest::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // optional uint32 account_id = 2;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollupRequest {
    fn new() -> CMsgGCToClientBattlePassRollupRequest {
        CMsgGCToClientBattlePassRollupRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollupRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgGCToClientBattlePassRollupRequest::get_event_id_for_reflect,
                    CMsgGCToClientBattlePassRollupRequest::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCToClientBattlePassRollupRequest::get_account_id_for_reflect,
                    CMsgGCToClientBattlePassRollupRequest::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollupRequest>(
                    "CMsgGCToClientBattlePassRollupRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollupRequest {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollupResponse {
    // message fields
    event_ti6: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016>,
    event_fall2016: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016>,
    event_winter2017: ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollupResponse {}

impl CMsgGCToClientBattlePassRollupResponse {
    pub fn new() -> CMsgGCToClientBattlePassRollupResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollupResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollupResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollupResponse,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollupResponse::new)
        }
    }

    // optional .CMsgGCToClientBattlePassRollup_International2016 event_ti6 = 1;

    pub fn clear_event_ti6(&mut self) {
        self.event_ti6.clear();
    }

    pub fn has_event_ti6(&self) -> bool {
        self.event_ti6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_ti6(&mut self, v: CMsgGCToClientBattlePassRollup_International2016) {
        self.event_ti6 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_ti6(&mut self) -> &mut CMsgGCToClientBattlePassRollup_International2016 {
        if self.event_ti6.is_none() {
            self.event_ti6.set_default();
        }
        self.event_ti6.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_ti6(&mut self) -> CMsgGCToClientBattlePassRollup_International2016 {
        self.event_ti6.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_International2016::new())
    }

    pub fn get_event_ti6(&self) -> &CMsgGCToClientBattlePassRollup_International2016 {
        self.event_ti6.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_International2016::default_instance())
    }

    fn get_event_ti6_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016> {
        &self.event_ti6
    }

    fn mut_event_ti6_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_International2016> {
        &mut self.event_ti6
    }

    // optional .CMsgGCToClientBattlePassRollup_Fall2016 event_fall2016 = 2;

    pub fn clear_event_fall2016(&mut self) {
        self.event_fall2016.clear();
    }

    pub fn has_event_fall2016(&self) -> bool {
        self.event_fall2016.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_fall2016(&mut self, v: CMsgGCToClientBattlePassRollup_Fall2016) {
        self.event_fall2016 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_fall2016(&mut self) -> &mut CMsgGCToClientBattlePassRollup_Fall2016 {
        if self.event_fall2016.is_none() {
            self.event_fall2016.set_default();
        }
        self.event_fall2016.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_fall2016(&mut self) -> CMsgGCToClientBattlePassRollup_Fall2016 {
        self.event_fall2016.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Fall2016::new())
    }

    pub fn get_event_fall2016(&self) -> &CMsgGCToClientBattlePassRollup_Fall2016 {
        self.event_fall2016.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Fall2016::default_instance())
    }

    fn get_event_fall2016_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016> {
        &self.event_fall2016
    }

    fn mut_event_fall2016_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Fall2016> {
        &mut self.event_fall2016
    }

    // optional .CMsgGCToClientBattlePassRollup_Winter2017 event_winter2017 = 3;

    pub fn clear_event_winter2017(&mut self) {
        self.event_winter2017.clear();
    }

    pub fn has_event_winter2017(&self) -> bool {
        self.event_winter2017.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_winter2017(&mut self, v: CMsgGCToClientBattlePassRollup_Winter2017) {
        self.event_winter2017 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_winter2017(&mut self) -> &mut CMsgGCToClientBattlePassRollup_Winter2017 {
        if self.event_winter2017.is_none() {
            self.event_winter2017.set_default();
        }
        self.event_winter2017.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_winter2017(&mut self) -> CMsgGCToClientBattlePassRollup_Winter2017 {
        self.event_winter2017.take().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Winter2017::new())
    }

    pub fn get_event_winter2017(&self) -> &CMsgGCToClientBattlePassRollup_Winter2017 {
        self.event_winter2017.as_ref().unwrap_or_else(|| CMsgGCToClientBattlePassRollup_Winter2017::default_instance())
    }

    fn get_event_winter2017_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017> {
        &self.event_winter2017
    }

    fn mut_event_winter2017_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgGCToClientBattlePassRollup_Winter2017> {
        &mut self.event_winter2017
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollupResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.event_ti6 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.event_fall2016 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.event_winter2017 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.event_ti6)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.event_fall2016)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.event_winter2017)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.event_ti6.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.event_fall2016.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.event_winter2017.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.event_ti6.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.event_fall2016.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.event_winter2017.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollupResponse {
    fn new() -> CMsgGCToClientBattlePassRollupResponse {
        CMsgGCToClientBattlePassRollupResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollupResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_International2016>>(
                    "event_ti6",
                    CMsgGCToClientBattlePassRollupResponse::get_event_ti6_for_reflect,
                    CMsgGCToClientBattlePassRollupResponse::mut_event_ti6_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Fall2016>>(
                    "event_fall2016",
                    CMsgGCToClientBattlePassRollupResponse::get_event_fall2016_for_reflect,
                    CMsgGCToClientBattlePassRollupResponse::mut_event_fall2016_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToClientBattlePassRollup_Winter2017>>(
                    "event_winter2017",
                    CMsgGCToClientBattlePassRollupResponse::get_event_winter2017_for_reflect,
                    CMsgGCToClientBattlePassRollupResponse::mut_event_winter2017_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollupResponse>(
                    "CMsgGCToClientBattlePassRollupResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollupResponse {
    fn clear(&mut self) {
        self.clear_event_ti6();
        self.clear_event_fall2016();
        self.clear_event_winter2017();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollupListRequest {
    // message fields
    account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollupListRequest {}

impl CMsgGCToClientBattlePassRollupListRequest {
    pub fn new() -> CMsgGCToClientBattlePassRollupListRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollupListRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollupListRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollupListRequest,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollupListRequest::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollupListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollupListRequest {
    fn new() -> CMsgGCToClientBattlePassRollupListRequest {
        CMsgGCToClientBattlePassRollupListRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollupListRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCToClientBattlePassRollupListRequest::get_account_id_for_reflect,
                    CMsgGCToClientBattlePassRollupListRequest::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollupListRequest>(
                    "CMsgGCToClientBattlePassRollupListRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollupListRequest {
    fn clear(&mut self) {
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollupListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollupListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientBattlePassRollupListResponse {
    // message fields
    event_id: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientBattlePassRollupListResponse {}

impl CMsgGCToClientBattlePassRollupListResponse {
    pub fn new() -> CMsgGCToClientBattlePassRollupListResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientBattlePassRollupListResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientBattlePassRollupListResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientBattlePassRollupListResponse,
        };
        unsafe {
            instance.get(CMsgGCToClientBattlePassRollupListResponse::new)
        }
    }

    // repeated uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: ::std::vec::Vec<u32>) {
        self.event_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_event_id(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.event_id
    }

    // Take field
    pub fn take_event_id(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.event_id, ::std::vec::Vec::new())
    }

    pub fn get_event_id(&self) -> &[u32] {
        &self.event_id
    }

    fn get_event_id_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.event_id
    }
}

impl ::protobuf::Message for CMsgGCToClientBattlePassRollupListResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.event_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.event_id {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.event_id {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientBattlePassRollupListResponse {
    fn new() -> CMsgGCToClientBattlePassRollupListResponse {
        CMsgGCToClientBattlePassRollupListResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientBattlePassRollupListResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgGCToClientBattlePassRollupListResponse::get_event_id_for_reflect,
                    CMsgGCToClientBattlePassRollupListResponse::mut_event_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientBattlePassRollupListResponse>(
                    "CMsgGCToClientBattlePassRollupListResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientBattlePassRollupListResponse {
    fn clear(&mut self) {
        self.clear_event_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientBattlePassRollupListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientBattlePassRollupListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCTransferSeasonalMMRRequest {
    // message fields
    is_party: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCTransferSeasonalMMRRequest {}

impl CMsgClientToGCTransferSeasonalMMRRequest {
    pub fn new() -> CMsgClientToGCTransferSeasonalMMRRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCTransferSeasonalMMRRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCTransferSeasonalMMRRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCTransferSeasonalMMRRequest,
        };
        unsafe {
            instance.get(CMsgClientToGCTransferSeasonalMMRRequest::new)
        }
    }

    // optional bool is_party = 1;

    pub fn clear_is_party(&mut self) {
        self.is_party = ::std::option::Option::None;
    }

    pub fn has_is_party(&self) -> bool {
        self.is_party.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_party(&mut self, v: bool) {
        self.is_party = ::std::option::Option::Some(v);
    }

    pub fn get_is_party(&self) -> bool {
        self.is_party.unwrap_or(false)
    }

    fn get_is_party_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_party
    }

    fn mut_is_party_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_party
    }
}

impl ::protobuf::Message for CMsgClientToGCTransferSeasonalMMRRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_party = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.is_party {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.is_party {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCTransferSeasonalMMRRequest {
    fn new() -> CMsgClientToGCTransferSeasonalMMRRequest {
        CMsgClientToGCTransferSeasonalMMRRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCTransferSeasonalMMRRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_party",
                    CMsgClientToGCTransferSeasonalMMRRequest::get_is_party_for_reflect,
                    CMsgClientToGCTransferSeasonalMMRRequest::mut_is_party_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCTransferSeasonalMMRRequest>(
                    "CMsgClientToGCTransferSeasonalMMRRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCTransferSeasonalMMRRequest {
    fn clear(&mut self) {
        self.clear_is_party();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCTransferSeasonalMMRRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCTransferSeasonalMMRRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCTransferSeasonalMMRResponse {
    // message fields
    success: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCTransferSeasonalMMRResponse {}

impl CMsgClientToGCTransferSeasonalMMRResponse {
    pub fn new() -> CMsgClientToGCTransferSeasonalMMRResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCTransferSeasonalMMRResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCTransferSeasonalMMRResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCTransferSeasonalMMRResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCTransferSeasonalMMRResponse::new)
        }
    }

    // optional bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    fn get_success_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.success
    }

    fn mut_success_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.success
    }
}

impl ::protobuf::Message for CMsgClientToGCTransferSeasonalMMRResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCTransferSeasonalMMRResponse {
    fn new() -> CMsgClientToGCTransferSeasonalMMRResponse {
        CMsgClientToGCTransferSeasonalMMRResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCTransferSeasonalMMRResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    CMsgClientToGCTransferSeasonalMMRResponse::get_success_for_reflect,
                    CMsgClientToGCTransferSeasonalMMRResponse::mut_success_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCTransferSeasonalMMRResponse>(
                    "CMsgClientToGCTransferSeasonalMMRResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCTransferSeasonalMMRResponse {
    fn clear(&mut self) {
        self.clear_success();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCTransferSeasonalMMRResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCTransferSeasonalMMRResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientPlaytestStatus {
    // message fields
    active: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientPlaytestStatus {}

impl CMsgGCToClientPlaytestStatus {
    pub fn new() -> CMsgGCToClientPlaytestStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientPlaytestStatus {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientPlaytestStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientPlaytestStatus,
        };
        unsafe {
            instance.get(CMsgGCToClientPlaytestStatus::new)
        }
    }

    // optional bool active = 1;

    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = ::std::option::Option::Some(v);
    }

    pub fn get_active(&self) -> bool {
        self.active.unwrap_or(false)
    }

    fn get_active_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.active
    }

    fn mut_active_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.active
    }
}

impl ::protobuf::Message for CMsgGCToClientPlaytestStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.active {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.active {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientPlaytestStatus {
    fn new() -> CMsgGCToClientPlaytestStatus {
        CMsgGCToClientPlaytestStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientPlaytestStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "active",
                    CMsgGCToClientPlaytestStatus::get_active_for_reflect,
                    CMsgGCToClientPlaytestStatus::mut_active_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientPlaytestStatus>(
                    "CMsgGCToClientPlaytestStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientPlaytestStatus {
    fn clear(&mut self) {
        self.clear_active();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientPlaytestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientPlaytestStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCJoinPlaytest {
    // message fields
    client_version: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCJoinPlaytest {}

impl CMsgClientToGCJoinPlaytest {
    pub fn new() -> CMsgClientToGCJoinPlaytest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCJoinPlaytest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCJoinPlaytest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCJoinPlaytest,
        };
        unsafe {
            instance.get(CMsgClientToGCJoinPlaytest::new)
        }
    }

    // optional uint32 client_version = 1;

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    pub fn get_client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    fn get_client_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.client_version
    }

    fn mut_client_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.client_version
    }
}

impl ::protobuf::Message for CMsgClientToGCJoinPlaytest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.client_version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCJoinPlaytest {
    fn new() -> CMsgClientToGCJoinPlaytest {
        CMsgClientToGCJoinPlaytest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCJoinPlaytest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "client_version",
                    CMsgClientToGCJoinPlaytest::get_client_version_for_reflect,
                    CMsgClientToGCJoinPlaytest::mut_client_version_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCJoinPlaytest>(
                    "CMsgClientToGCJoinPlaytest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCJoinPlaytest {
    fn clear(&mut self) {
        self.clear_client_version();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCJoinPlaytest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCJoinPlaytest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCJoinPlaytestResponse {
    // message fields
    error: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCJoinPlaytestResponse {}

impl CMsgClientToGCJoinPlaytestResponse {
    pub fn new() -> CMsgClientToGCJoinPlaytestResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCJoinPlaytestResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCJoinPlaytestResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCJoinPlaytestResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCJoinPlaytestResponse::new)
        }
    }

    // optional string error = 1;

    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_error_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.error
    }

    fn mut_error_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.error
    }
}

impl ::protobuf::Message for CMsgClientToGCJoinPlaytestResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCJoinPlaytestResponse {
    fn new() -> CMsgClientToGCJoinPlaytestResponse {
        CMsgClientToGCJoinPlaytestResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCJoinPlaytestResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    CMsgClientToGCJoinPlaytestResponse::get_error_for_reflect,
                    CMsgClientToGCJoinPlaytestResponse::mut_error_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCJoinPlaytestResponse>(
                    "CMsgClientToGCJoinPlaytestResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCJoinPlaytestResponse {
    fn clear(&mut self) {
        self.clear_error();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCJoinPlaytestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCJoinPlaytestResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAEventInvite {
    // message fields
    teams: ::protobuf::RepeatedField<CMsgDOTAEventInvite_Team>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAEventInvite {}

impl CMsgDOTAEventInvite {
    pub fn new() -> CMsgDOTAEventInvite {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAEventInvite {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAEventInvite> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAEventInvite,
        };
        unsafe {
            instance.get(CMsgDOTAEventInvite::new)
        }
    }

    // repeated .CMsgDOTAEventInvite.Team teams = 1;

    pub fn clear_teams(&mut self) {
        self.teams.clear();
    }

    // Param is passed by value, moved
    pub fn set_teams(&mut self, v: ::protobuf::RepeatedField<CMsgDOTAEventInvite_Team>) {
        self.teams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_teams(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAEventInvite_Team> {
        &mut self.teams
    }

    // Take field
    pub fn take_teams(&mut self) -> ::protobuf::RepeatedField<CMsgDOTAEventInvite_Team> {
        ::std::mem::replace(&mut self.teams, ::protobuf::RepeatedField::new())
    }

    pub fn get_teams(&self) -> &[CMsgDOTAEventInvite_Team] {
        &self.teams
    }

    fn get_teams_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTAEventInvite_Team> {
        &self.teams
    }

    fn mut_teams_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTAEventInvite_Team> {
        &mut self.teams
    }
}

impl ::protobuf::Message for CMsgDOTAEventInvite {
    fn is_initialized(&self) -> bool {
        for v in &self.teams {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.teams)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.teams {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAEventInvite {
    fn new() -> CMsgDOTAEventInvite {
        CMsgDOTAEventInvite::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAEventInvite>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAEventInvite_Team>>(
                    "teams",
                    CMsgDOTAEventInvite::get_teams_for_reflect,
                    CMsgDOTAEventInvite::mut_teams_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAEventInvite>(
                    "CMsgDOTAEventInvite",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAEventInvite {
    fn clear(&mut self) {
        self.clear_teams();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAEventInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAEventInvite {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAEventInvite_Team {
    // message fields
    team_id: ::std::option::Option<u32>,
    announcement_date: ::std::option::Option<u32>,
    team_name: ::protobuf::SingularField<::std::string::String>,
    invite_type: ::std::option::Option<EDOTAEventInviteType>,
    region: ::std::option::Option<u32>,
    qualifier_winner: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAEventInvite_Team {}

impl CMsgDOTAEventInvite_Team {
    pub fn new() -> CMsgDOTAEventInvite_Team {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAEventInvite_Team {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAEventInvite_Team> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAEventInvite_Team,
        };
        unsafe {
            instance.get(CMsgDOTAEventInvite_Team::new)
        }
    }

    // optional uint32 team_id = 1;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_id
    }

    // optional uint32 announcement_date = 2;

    pub fn clear_announcement_date(&mut self) {
        self.announcement_date = ::std::option::Option::None;
    }

    pub fn has_announcement_date(&self) -> bool {
        self.announcement_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_date(&mut self, v: u32) {
        self.announcement_date = ::std::option::Option::Some(v);
    }

    pub fn get_announcement_date(&self) -> u32 {
        self.announcement_date.unwrap_or(0)
    }

    fn get_announcement_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.announcement_date
    }

    fn mut_announcement_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.announcement_date
    }

    // optional string team_name = 3;

    pub fn clear_team_name(&mut self) {
        self.team_name.clear();
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name.set_default();
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_team_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.team_name
    }

    fn mut_team_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.team_name
    }

    // optional .EDOTAEventInviteType invite_type = 4;

    pub fn clear_invite_type(&mut self) {
        self.invite_type = ::std::option::Option::None;
    }

    pub fn has_invite_type(&self) -> bool {
        self.invite_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_type(&mut self, v: EDOTAEventInviteType) {
        self.invite_type = ::std::option::Option::Some(v);
    }

    pub fn get_invite_type(&self) -> EDOTAEventInviteType {
        self.invite_type.unwrap_or(EDOTAEventInviteType::k_EDOTAEventInviteType_Direct)
    }

    fn get_invite_type_for_reflect(&self) -> &::std::option::Option<EDOTAEventInviteType> {
        &self.invite_type
    }

    fn mut_invite_type_for_reflect(&mut self) -> &mut ::std::option::Option<EDOTAEventInviteType> {
        &mut self.invite_type
    }

    // optional uint32 region = 5;

    pub fn clear_region(&mut self) {
        self.region = ::std::option::Option::None;
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: u32) {
        self.region = ::std::option::Option::Some(v);
    }

    pub fn get_region(&self) -> u32 {
        self.region.unwrap_or(0)
    }

    fn get_region_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.region
    }

    fn mut_region_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.region
    }

    // optional bool qualifier_winner = 6;

    pub fn clear_qualifier_winner(&mut self) {
        self.qualifier_winner = ::std::option::Option::None;
    }

    pub fn has_qualifier_winner(&self) -> bool {
        self.qualifier_winner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qualifier_winner(&mut self, v: bool) {
        self.qualifier_winner = ::std::option::Option::Some(v);
    }

    pub fn get_qualifier_winner(&self) -> bool {
        self.qualifier_winner.unwrap_or(false)
    }

    fn get_qualifier_winner_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.qualifier_winner
    }

    fn mut_qualifier_winner_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.qualifier_winner
    }
}

impl ::protobuf::Message for CMsgDOTAEventInvite_Team {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.announcement_date = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.team_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.invite_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.region = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.qualifier_winner = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.announcement_date {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.invite_type {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.region {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.qualifier_winner {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.announcement_date {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.team_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.invite_type {
            os.write_enum(4, v.value())?;
        }
        if let Some(v) = self.region {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.qualifier_winner {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAEventInvite_Team {
    fn new() -> CMsgDOTAEventInvite_Team {
        CMsgDOTAEventInvite_Team::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAEventInvite_Team>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_id",
                    CMsgDOTAEventInvite_Team::get_team_id_for_reflect,
                    CMsgDOTAEventInvite_Team::mut_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "announcement_date",
                    CMsgDOTAEventInvite_Team::get_announcement_date_for_reflect,
                    CMsgDOTAEventInvite_Team::mut_announcement_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "team_name",
                    CMsgDOTAEventInvite_Team::get_team_name_for_reflect,
                    CMsgDOTAEventInvite_Team::mut_team_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EDOTAEventInviteType>>(
                    "invite_type",
                    CMsgDOTAEventInvite_Team::get_invite_type_for_reflect,
                    CMsgDOTAEventInvite_Team::mut_invite_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "region",
                    CMsgDOTAEventInvite_Team::get_region_for_reflect,
                    CMsgDOTAEventInvite_Team::mut_region_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "qualifier_winner",
                    CMsgDOTAEventInvite_Team::get_qualifier_winner_for_reflect,
                    CMsgDOTAEventInvite_Team::mut_qualifier_winner_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAEventInvite_Team>(
                    "CMsgDOTAEventInvite_Team",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAEventInvite_Team {
    fn clear(&mut self) {
        self.clear_team_id();
        self.clear_announcement_date();
        self.clear_team_name();
        self.clear_invite_type();
        self.clear_region();
        self.clear_qualifier_winner();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAEventInvite_Team {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAEventInvite_Team {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASetFavoriteTeam {
    // message fields
    team_id: ::std::option::Option<u32>,
    event_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASetFavoriteTeam {}

impl CMsgDOTASetFavoriteTeam {
    pub fn new() -> CMsgDOTASetFavoriteTeam {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASetFavoriteTeam {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASetFavoriteTeam> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASetFavoriteTeam,
        };
        unsafe {
            instance.get(CMsgDOTASetFavoriteTeam::new)
        }
    }

    // optional uint32 team_id = 1;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_id
    }

    // optional uint32 event_id = 2;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }
}

impl ::protobuf::Message for CMsgDOTASetFavoriteTeam {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASetFavoriteTeam {
    fn new() -> CMsgDOTASetFavoriteTeam {
        CMsgDOTASetFavoriteTeam::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASetFavoriteTeam>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_id",
                    CMsgDOTASetFavoriteTeam::get_team_id_for_reflect,
                    CMsgDOTASetFavoriteTeam::mut_team_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgDOTASetFavoriteTeam::get_event_id_for_reflect,
                    CMsgDOTASetFavoriteTeam::mut_event_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASetFavoriteTeam>(
                    "CMsgDOTASetFavoriteTeam",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASetFavoriteTeam {
    fn clear(&mut self) {
        self.clear_team_id();
        self.clear_event_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASetFavoriteTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASetFavoriteTeam {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTATriviaQuestion {
    // message fields
    question_id: ::std::option::Option<u32>,
    category: ::std::option::Option<EDOTATriviaQuestionCategory>,
    timestamp: ::std::option::Option<u32>,
    question_value: ::protobuf::SingularField<::std::string::String>,
    answer_values: ::protobuf::RepeatedField<::std::string::String>,
    correct_answer_index: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTATriviaQuestion {}

impl CMsgDOTATriviaQuestion {
    pub fn new() -> CMsgDOTATriviaQuestion {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTATriviaQuestion {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTATriviaQuestion> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTATriviaQuestion,
        };
        unsafe {
            instance.get(CMsgDOTATriviaQuestion::new)
        }
    }

    // optional uint32 question_id = 1;

    pub fn clear_question_id(&mut self) {
        self.question_id = ::std::option::Option::None;
    }

    pub fn has_question_id(&self) -> bool {
        self.question_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question_id(&mut self, v: u32) {
        self.question_id = ::std::option::Option::Some(v);
    }

    pub fn get_question_id(&self) -> u32 {
        self.question_id.unwrap_or(0)
    }

    fn get_question_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.question_id
    }

    fn mut_question_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.question_id
    }

    // optional .EDOTATriviaQuestionCategory category = 2;

    pub fn clear_category(&mut self) {
        self.category = ::std::option::Option::None;
    }

    pub fn has_category(&self) -> bool {
        self.category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: EDOTATriviaQuestionCategory) {
        self.category = ::std::option::Option::Some(v);
    }

    pub fn get_category(&self) -> EDOTATriviaQuestionCategory {
        self.category.unwrap_or(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityIcon)
    }

    fn get_category_for_reflect(&self) -> &::std::option::Option<EDOTATriviaQuestionCategory> {
        &self.category
    }

    fn mut_category_for_reflect(&mut self) -> &mut ::std::option::Option<EDOTATriviaQuestionCategory> {
        &mut self.category
    }

    // optional uint32 timestamp = 3;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional string question_value = 4;

    pub fn clear_question_value(&mut self) {
        self.question_value.clear();
    }

    pub fn has_question_value(&self) -> bool {
        self.question_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question_value(&mut self, v: ::std::string::String) {
        self.question_value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_question_value(&mut self) -> &mut ::std::string::String {
        if self.question_value.is_none() {
            self.question_value.set_default();
        }
        self.question_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_question_value(&mut self) -> ::std::string::String {
        self.question_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_question_value(&self) -> &str {
        match self.question_value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_question_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.question_value
    }

    fn mut_question_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.question_value
    }

    // repeated string answer_values = 5;

    pub fn clear_answer_values(&mut self) {
        self.answer_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_answer_values(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.answer_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_answer_values(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.answer_values
    }

    // Take field
    pub fn take_answer_values(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.answer_values, ::protobuf::RepeatedField::new())
    }

    pub fn get_answer_values(&self) -> &[::std::string::String] {
        &self.answer_values
    }

    fn get_answer_values_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.answer_values
    }

    fn mut_answer_values_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.answer_values
    }

    // optional uint32 correct_answer_index = 6;

    pub fn clear_correct_answer_index(&mut self) {
        self.correct_answer_index = ::std::option::Option::None;
    }

    pub fn has_correct_answer_index(&self) -> bool {
        self.correct_answer_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correct_answer_index(&mut self, v: u32) {
        self.correct_answer_index = ::std::option::Option::Some(v);
    }

    pub fn get_correct_answer_index(&self) -> u32 {
        self.correct_answer_index.unwrap_or(0)
    }

    fn get_correct_answer_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.correct_answer_index
    }

    fn mut_correct_answer_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.correct_answer_index
    }
}

impl ::protobuf::Message for CMsgDOTATriviaQuestion {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.question_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.category = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.question_value)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.answer_values)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.correct_answer_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.question_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.category {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.question_value.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.answer_values {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.correct_answer_index {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.question_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.category {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.question_value.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.answer_values {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.correct_answer_index {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTATriviaQuestion {
    fn new() -> CMsgDOTATriviaQuestion {
        CMsgDOTATriviaQuestion::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTATriviaQuestion>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "question_id",
                    CMsgDOTATriviaQuestion::get_question_id_for_reflect,
                    CMsgDOTATriviaQuestion::mut_question_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EDOTATriviaQuestionCategory>>(
                    "category",
                    CMsgDOTATriviaQuestion::get_category_for_reflect,
                    CMsgDOTATriviaQuestion::mut_category_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgDOTATriviaQuestion::get_timestamp_for_reflect,
                    CMsgDOTATriviaQuestion::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "question_value",
                    CMsgDOTATriviaQuestion::get_question_value_for_reflect,
                    CMsgDOTATriviaQuestion::mut_question_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "answer_values",
                    CMsgDOTATriviaQuestion::get_answer_values_for_reflect,
                    CMsgDOTATriviaQuestion::mut_answer_values_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "correct_answer_index",
                    CMsgDOTATriviaQuestion::get_correct_answer_index_for_reflect,
                    CMsgDOTATriviaQuestion::mut_correct_answer_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTATriviaQuestion>(
                    "CMsgDOTATriviaQuestion",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTATriviaQuestion {
    fn clear(&mut self) {
        self.clear_question_id();
        self.clear_category();
        self.clear_timestamp();
        self.clear_question_value();
        self.clear_answer_values();
        self.clear_correct_answer_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTATriviaQuestion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTATriviaQuestion {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTATriviaCurrentQuestions {
    // message fields
    questions: ::protobuf::RepeatedField<CMsgDOTATriviaQuestion>,
    trivia_enabled: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTATriviaCurrentQuestions {}

impl CMsgDOTATriviaCurrentQuestions {
    pub fn new() -> CMsgDOTATriviaCurrentQuestions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTATriviaCurrentQuestions {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTATriviaCurrentQuestions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTATriviaCurrentQuestions,
        };
        unsafe {
            instance.get(CMsgDOTATriviaCurrentQuestions::new)
        }
    }

    // repeated .CMsgDOTATriviaQuestion questions = 1;

    pub fn clear_questions(&mut self) {
        self.questions.clear();
    }

    // Param is passed by value, moved
    pub fn set_questions(&mut self, v: ::protobuf::RepeatedField<CMsgDOTATriviaQuestion>) {
        self.questions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_questions(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTATriviaQuestion> {
        &mut self.questions
    }

    // Take field
    pub fn take_questions(&mut self) -> ::protobuf::RepeatedField<CMsgDOTATriviaQuestion> {
        ::std::mem::replace(&mut self.questions, ::protobuf::RepeatedField::new())
    }

    pub fn get_questions(&self) -> &[CMsgDOTATriviaQuestion] {
        &self.questions
    }

    fn get_questions_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgDOTATriviaQuestion> {
        &self.questions
    }

    fn mut_questions_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDOTATriviaQuestion> {
        &mut self.questions
    }

    // optional bool trivia_enabled = 2;

    pub fn clear_trivia_enabled(&mut self) {
        self.trivia_enabled = ::std::option::Option::None;
    }

    pub fn has_trivia_enabled(&self) -> bool {
        self.trivia_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trivia_enabled(&mut self, v: bool) {
        self.trivia_enabled = ::std::option::Option::Some(v);
    }

    pub fn get_trivia_enabled(&self) -> bool {
        self.trivia_enabled.unwrap_or(false)
    }

    fn get_trivia_enabled_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.trivia_enabled
    }

    fn mut_trivia_enabled_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.trivia_enabled
    }
}

impl ::protobuf::Message for CMsgDOTATriviaCurrentQuestions {
    fn is_initialized(&self) -> bool {
        for v in &self.questions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.questions)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trivia_enabled = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.questions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.trivia_enabled {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.questions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.trivia_enabled {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTATriviaCurrentQuestions {
    fn new() -> CMsgDOTATriviaCurrentQuestions {
        CMsgDOTATriviaCurrentQuestions::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTATriviaCurrentQuestions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTATriviaQuestion>>(
                    "questions",
                    CMsgDOTATriviaCurrentQuestions::get_questions_for_reflect,
                    CMsgDOTATriviaCurrentQuestions::mut_questions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "trivia_enabled",
                    CMsgDOTATriviaCurrentQuestions::get_trivia_enabled_for_reflect,
                    CMsgDOTATriviaCurrentQuestions::mut_trivia_enabled_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTATriviaCurrentQuestions>(
                    "CMsgDOTATriviaCurrentQuestions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTATriviaCurrentQuestions {
    fn clear(&mut self) {
        self.clear_questions();
        self.clear_trivia_enabled();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTATriviaCurrentQuestions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTATriviaCurrentQuestions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTATriviaQuestionAnswersSummary {
    // message fields
    summary_available: ::std::option::Option<bool>,
    picked_count: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTATriviaQuestionAnswersSummary {}

impl CMsgDOTATriviaQuestionAnswersSummary {
    pub fn new() -> CMsgDOTATriviaQuestionAnswersSummary {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTATriviaQuestionAnswersSummary {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTATriviaQuestionAnswersSummary> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTATriviaQuestionAnswersSummary,
        };
        unsafe {
            instance.get(CMsgDOTATriviaQuestionAnswersSummary::new)
        }
    }

    // optional bool summary_available = 1;

    pub fn clear_summary_available(&mut self) {
        self.summary_available = ::std::option::Option::None;
    }

    pub fn has_summary_available(&self) -> bool {
        self.summary_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary_available(&mut self, v: bool) {
        self.summary_available = ::std::option::Option::Some(v);
    }

    pub fn get_summary_available(&self) -> bool {
        self.summary_available.unwrap_or(false)
    }

    fn get_summary_available_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.summary_available
    }

    fn mut_summary_available_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.summary_available
    }

    // repeated uint32 picked_count = 2;

    pub fn clear_picked_count(&mut self) {
        self.picked_count.clear();
    }

    // Param is passed by value, moved
    pub fn set_picked_count(&mut self, v: ::std::vec::Vec<u32>) {
        self.picked_count = v;
    }

    // Mutable pointer to the field.
    pub fn mut_picked_count(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.picked_count
    }

    // Take field
    pub fn take_picked_count(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.picked_count, ::std::vec::Vec::new())
    }

    pub fn get_picked_count(&self) -> &[u32] {
        &self.picked_count
    }

    fn get_picked_count_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.picked_count
    }

    fn mut_picked_count_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.picked_count
    }
}

impl ::protobuf::Message for CMsgDOTATriviaQuestionAnswersSummary {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.summary_available = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.picked_count)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.summary_available {
            my_size += 2;
        }
        for value in &self.picked_count {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.summary_available {
            os.write_bool(1, v)?;
        }
        for v in &self.picked_count {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTATriviaQuestionAnswersSummary {
    fn new() -> CMsgDOTATriviaQuestionAnswersSummary {
        CMsgDOTATriviaQuestionAnswersSummary::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTATriviaQuestionAnswersSummary>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "summary_available",
                    CMsgDOTATriviaQuestionAnswersSummary::get_summary_available_for_reflect,
                    CMsgDOTATriviaQuestionAnswersSummary::mut_summary_available_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "picked_count",
                    CMsgDOTATriviaQuestionAnswersSummary::get_picked_count_for_reflect,
                    CMsgDOTATriviaQuestionAnswersSummary::mut_picked_count_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTATriviaQuestionAnswersSummary>(
                    "CMsgDOTATriviaQuestionAnswersSummary",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTATriviaQuestionAnswersSummary {
    fn clear(&mut self) {
        self.clear_summary_available();
        self.clear_picked_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTATriviaQuestionAnswersSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTATriviaQuestionAnswersSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASubmitTriviaQuestionAnswer {
    // message fields
    question_id: ::std::option::Option<u32>,
    answer_index: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASubmitTriviaQuestionAnswer {}

impl CMsgDOTASubmitTriviaQuestionAnswer {
    pub fn new() -> CMsgDOTASubmitTriviaQuestionAnswer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASubmitTriviaQuestionAnswer {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASubmitTriviaQuestionAnswer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASubmitTriviaQuestionAnswer,
        };
        unsafe {
            instance.get(CMsgDOTASubmitTriviaQuestionAnswer::new)
        }
    }

    // optional uint32 question_id = 1;

    pub fn clear_question_id(&mut self) {
        self.question_id = ::std::option::Option::None;
    }

    pub fn has_question_id(&self) -> bool {
        self.question_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question_id(&mut self, v: u32) {
        self.question_id = ::std::option::Option::Some(v);
    }

    pub fn get_question_id(&self) -> u32 {
        self.question_id.unwrap_or(0)
    }

    fn get_question_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.question_id
    }

    fn mut_question_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.question_id
    }

    // optional uint32 answer_index = 2;

    pub fn clear_answer_index(&mut self) {
        self.answer_index = ::std::option::Option::None;
    }

    pub fn has_answer_index(&self) -> bool {
        self.answer_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_index(&mut self, v: u32) {
        self.answer_index = ::std::option::Option::Some(v);
    }

    pub fn get_answer_index(&self) -> u32 {
        self.answer_index.unwrap_or(0)
    }

    fn get_answer_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.answer_index
    }

    fn mut_answer_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.answer_index
    }
}

impl ::protobuf::Message for CMsgDOTASubmitTriviaQuestionAnswer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.question_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.answer_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.question_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.answer_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.question_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.answer_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASubmitTriviaQuestionAnswer {
    fn new() -> CMsgDOTASubmitTriviaQuestionAnswer {
        CMsgDOTASubmitTriviaQuestionAnswer::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASubmitTriviaQuestionAnswer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "question_id",
                    CMsgDOTASubmitTriviaQuestionAnswer::get_question_id_for_reflect,
                    CMsgDOTASubmitTriviaQuestionAnswer::mut_question_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "answer_index",
                    CMsgDOTASubmitTriviaQuestionAnswer::get_answer_index_for_reflect,
                    CMsgDOTASubmitTriviaQuestionAnswer::mut_answer_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASubmitTriviaQuestionAnswer>(
                    "CMsgDOTASubmitTriviaQuestionAnswer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASubmitTriviaQuestionAnswer {
    fn clear(&mut self) {
        self.clear_question_id();
        self.clear_answer_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASubmitTriviaQuestionAnswer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASubmitTriviaQuestionAnswer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASubmitTriviaQuestionAnswerResponse {
    // message fields
    result: ::std::option::Option<EDOTATriviaAnswerResult>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASubmitTriviaQuestionAnswerResponse {}

impl CMsgDOTASubmitTriviaQuestionAnswerResponse {
    pub fn new() -> CMsgDOTASubmitTriviaQuestionAnswerResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASubmitTriviaQuestionAnswerResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASubmitTriviaQuestionAnswerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASubmitTriviaQuestionAnswerResponse,
        };
        unsafe {
            instance.get(CMsgDOTASubmitTriviaQuestionAnswerResponse::new)
        }
    }

    // optional .EDOTATriviaAnswerResult result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EDOTATriviaAnswerResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> EDOTATriviaAnswerResult {
        self.result.unwrap_or(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_Success)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<EDOTATriviaAnswerResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<EDOTATriviaAnswerResult> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgDOTASubmitTriviaQuestionAnswerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASubmitTriviaQuestionAnswerResponse {
    fn new() -> CMsgDOTASubmitTriviaQuestionAnswerResponse {
        CMsgDOTASubmitTriviaQuestionAnswerResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASubmitTriviaQuestionAnswerResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EDOTATriviaAnswerResult>>(
                    "result",
                    CMsgDOTASubmitTriviaQuestionAnswerResponse::get_result_for_reflect,
                    CMsgDOTASubmitTriviaQuestionAnswerResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASubmitTriviaQuestionAnswerResponse>(
                    "CMsgDOTASubmitTriviaQuestionAnswerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASubmitTriviaQuestionAnswerResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASubmitTriviaQuestionAnswerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASubmitTriviaQuestionAnswerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAStartTriviaSession {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAStartTriviaSession {}

impl CMsgDOTAStartTriviaSession {
    pub fn new() -> CMsgDOTAStartTriviaSession {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAStartTriviaSession {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAStartTriviaSession> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAStartTriviaSession,
        };
        unsafe {
            instance.get(CMsgDOTAStartTriviaSession::new)
        }
    }
}

impl ::protobuf::Message for CMsgDOTAStartTriviaSession {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAStartTriviaSession {
    fn new() -> CMsgDOTAStartTriviaSession {
        CMsgDOTAStartTriviaSession::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAStartTriviaSession>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAStartTriviaSession>(
                    "CMsgDOTAStartTriviaSession",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAStartTriviaSession {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAStartTriviaSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAStartTriviaSession {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAStartTriviaSessionResponse {
    // message fields
    trivia_enabled: ::std::option::Option<bool>,
    current_timestamp: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAStartTriviaSessionResponse {}

impl CMsgDOTAStartTriviaSessionResponse {
    pub fn new() -> CMsgDOTAStartTriviaSessionResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAStartTriviaSessionResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAStartTriviaSessionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAStartTriviaSessionResponse,
        };
        unsafe {
            instance.get(CMsgDOTAStartTriviaSessionResponse::new)
        }
    }

    // optional bool trivia_enabled = 1;

    pub fn clear_trivia_enabled(&mut self) {
        self.trivia_enabled = ::std::option::Option::None;
    }

    pub fn has_trivia_enabled(&self) -> bool {
        self.trivia_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trivia_enabled(&mut self, v: bool) {
        self.trivia_enabled = ::std::option::Option::Some(v);
    }

    pub fn get_trivia_enabled(&self) -> bool {
        self.trivia_enabled.unwrap_or(false)
    }

    fn get_trivia_enabled_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.trivia_enabled
    }

    fn mut_trivia_enabled_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.trivia_enabled
    }

    // optional uint32 current_timestamp = 2;

    pub fn clear_current_timestamp(&mut self) {
        self.current_timestamp = ::std::option::Option::None;
    }

    pub fn has_current_timestamp(&self) -> bool {
        self.current_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_timestamp(&mut self, v: u32) {
        self.current_timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_current_timestamp(&self) -> u32 {
        self.current_timestamp.unwrap_or(0)
    }

    fn get_current_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.current_timestamp
    }

    fn mut_current_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.current_timestamp
    }
}

impl ::protobuf::Message for CMsgDOTAStartTriviaSessionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trivia_enabled = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.current_timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.trivia_enabled {
            my_size += 2;
        }
        if let Some(v) = self.current_timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.trivia_enabled {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.current_timestamp {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAStartTriviaSessionResponse {
    fn new() -> CMsgDOTAStartTriviaSessionResponse {
        CMsgDOTAStartTriviaSessionResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAStartTriviaSessionResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "trivia_enabled",
                    CMsgDOTAStartTriviaSessionResponse::get_trivia_enabled_for_reflect,
                    CMsgDOTAStartTriviaSessionResponse::mut_trivia_enabled_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "current_timestamp",
                    CMsgDOTAStartTriviaSessionResponse::get_current_timestamp_for_reflect,
                    CMsgDOTAStartTriviaSessionResponse::mut_current_timestamp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAStartTriviaSessionResponse>(
                    "CMsgDOTAStartTriviaSessionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAStartTriviaSessionResponse {
    fn clear(&mut self) {
        self.clear_trivia_enabled();
        self.clear_current_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAStartTriviaSessionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAStartTriviaSessionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGiveTip {
    // message fields
    recipient_account_id: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    event_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGiveTip {}

impl CMsgClientToGCGiveTip {
    pub fn new() -> CMsgClientToGCGiveTip {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGiveTip {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGiveTip> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGiveTip,
        };
        unsafe {
            instance.get(CMsgClientToGCGiveTip::new)
        }
    }

    // optional uint32 recipient_account_id = 1;

    pub fn clear_recipient_account_id(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
    }

    pub fn has_recipient_account_id(&self) -> bool {
        self.recipient_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_account_id(&mut self, v: u32) {
        self.recipient_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_recipient_account_id(&self) -> u32 {
        self.recipient_account_id.unwrap_or(0)
    }

    fn get_recipient_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.recipient_account_id
    }

    fn mut_recipient_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.recipient_account_id
    }

    // optional uint64 match_id = 2;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional uint32 event_id = 3;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }
}

impl ::protobuf::Message for CMsgClientToGCGiveTip {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recipient_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.recipient_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.recipient_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGiveTip {
    fn new() -> CMsgClientToGCGiveTip {
        CMsgClientToGCGiveTip::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGiveTip>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "recipient_account_id",
                    CMsgClientToGCGiveTip::get_recipient_account_id_for_reflect,
                    CMsgClientToGCGiveTip::mut_recipient_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgClientToGCGiveTip::get_match_id_for_reflect,
                    CMsgClientToGCGiveTip::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgClientToGCGiveTip::get_event_id_for_reflect,
                    CMsgClientToGCGiveTip::mut_event_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGiveTip>(
                    "CMsgClientToGCGiveTip",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGiveTip {
    fn clear(&mut self) {
        self.clear_recipient_account_id();
        self.clear_match_id();
        self.clear_event_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGiveTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGiveTip {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGiveTipResponse {
    // message fields
    result: ::std::option::Option<CMsgClientToGCGiveTipResponse_Result>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGiveTipResponse {}

impl CMsgClientToGCGiveTipResponse {
    pub fn new() -> CMsgClientToGCGiveTipResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGiveTipResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGiveTipResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGiveTipResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCGiveTipResponse::new)
        }
    }

    // optional .CMsgClientToGCGiveTipResponse.Result result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgClientToGCGiveTipResponse_Result) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgClientToGCGiveTipResponse_Result {
        self.result.unwrap_or(CMsgClientToGCGiveTipResponse_Result::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgClientToGCGiveTipResponse_Result> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgClientToGCGiveTipResponse_Result> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgClientToGCGiveTipResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGiveTipResponse {
    fn new() -> CMsgClientToGCGiveTipResponse {
        CMsgClientToGCGiveTipResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGiveTipResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgClientToGCGiveTipResponse_Result>>(
                    "result",
                    CMsgClientToGCGiveTipResponse::get_result_for_reflect,
                    CMsgClientToGCGiveTipResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGiveTipResponse>(
                    "CMsgClientToGCGiveTipResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGiveTipResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGiveTipResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGiveTipResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgClientToGCGiveTipResponse_Result {
    SUCCESS = 0,
    ERROR_ALREADY_TIPPED = 1,
    ERROR_INVALID_MATCH_ID = 2,
    ERROR_INVALID_EVENT_ID = 3,
    ERROR_INVALID_MATCH_TIME = 4,
    ERROR_NOT_WINNER = 5,
    ERROR_UNOWNED_EVENT = 6,
    ERROR_INVALID_LOBBY_TYPE = 7,
    ERROR_UNKNOWN = 8,
}

impl ::protobuf::ProtobufEnum for CMsgClientToGCGiveTipResponse_Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgClientToGCGiveTipResponse_Result> {
        match value {
            0 => ::std::option::Option::Some(CMsgClientToGCGiveTipResponse_Result::SUCCESS),
            1 => ::std::option::Option::Some(CMsgClientToGCGiveTipResponse_Result::ERROR_ALREADY_TIPPED),
            2 => ::std::option::Option::Some(CMsgClientToGCGiveTipResponse_Result::ERROR_INVALID_MATCH_ID),
            3 => ::std::option::Option::Some(CMsgClientToGCGiveTipResponse_Result::ERROR_INVALID_EVENT_ID),
            4 => ::std::option::Option::Some(CMsgClientToGCGiveTipResponse_Result::ERROR_INVALID_MATCH_TIME),
            5 => ::std::option::Option::Some(CMsgClientToGCGiveTipResponse_Result::ERROR_NOT_WINNER),
            6 => ::std::option::Option::Some(CMsgClientToGCGiveTipResponse_Result::ERROR_UNOWNED_EVENT),
            7 => ::std::option::Option::Some(CMsgClientToGCGiveTipResponse_Result::ERROR_INVALID_LOBBY_TYPE),
            8 => ::std::option::Option::Some(CMsgClientToGCGiveTipResponse_Result::ERROR_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgClientToGCGiveTipResponse_Result] = &[
            CMsgClientToGCGiveTipResponse_Result::SUCCESS,
            CMsgClientToGCGiveTipResponse_Result::ERROR_ALREADY_TIPPED,
            CMsgClientToGCGiveTipResponse_Result::ERROR_INVALID_MATCH_ID,
            CMsgClientToGCGiveTipResponse_Result::ERROR_INVALID_EVENT_ID,
            CMsgClientToGCGiveTipResponse_Result::ERROR_INVALID_MATCH_TIME,
            CMsgClientToGCGiveTipResponse_Result::ERROR_NOT_WINNER,
            CMsgClientToGCGiveTipResponse_Result::ERROR_UNOWNED_EVENT,
            CMsgClientToGCGiveTipResponse_Result::ERROR_INVALID_LOBBY_TYPE,
            CMsgClientToGCGiveTipResponse_Result::ERROR_UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgClientToGCGiveTipResponse_Result>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgClientToGCGiveTipResponse_Result", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgClientToGCGiveTipResponse_Result {
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGiveTipResponse_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAAnchorPhoneNumberRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAAnchorPhoneNumberRequest {}

impl CMsgDOTAAnchorPhoneNumberRequest {
    pub fn new() -> CMsgDOTAAnchorPhoneNumberRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAAnchorPhoneNumberRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAAnchorPhoneNumberRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAAnchorPhoneNumberRequest,
        };
        unsafe {
            instance.get(CMsgDOTAAnchorPhoneNumberRequest::new)
        }
    }
}

impl ::protobuf::Message for CMsgDOTAAnchorPhoneNumberRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAAnchorPhoneNumberRequest {
    fn new() -> CMsgDOTAAnchorPhoneNumberRequest {
        CMsgDOTAAnchorPhoneNumberRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAAnchorPhoneNumberRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAAnchorPhoneNumberRequest>(
                    "CMsgDOTAAnchorPhoneNumberRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAAnchorPhoneNumberRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAAnchorPhoneNumberRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAAnchorPhoneNumberRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAAnchorPhoneNumberResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAAnchorPhoneNumberResponse_Result>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAAnchorPhoneNumberResponse {}

impl CMsgDOTAAnchorPhoneNumberResponse {
    pub fn new() -> CMsgDOTAAnchorPhoneNumberResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAAnchorPhoneNumberResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAAnchorPhoneNumberResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAAnchorPhoneNumberResponse,
        };
        unsafe {
            instance.get(CMsgDOTAAnchorPhoneNumberResponse::new)
        }
    }

    // optional .CMsgDOTAAnchorPhoneNumberResponse.Result result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAAnchorPhoneNumberResponse_Result) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAAnchorPhoneNumberResponse_Result {
        self.result.unwrap_or(CMsgDOTAAnchorPhoneNumberResponse_Result::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAAnchorPhoneNumberResponse_Result> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAAnchorPhoneNumberResponse_Result> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgDOTAAnchorPhoneNumberResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAAnchorPhoneNumberResponse {
    fn new() -> CMsgDOTAAnchorPhoneNumberResponse {
        CMsgDOTAAnchorPhoneNumberResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAAnchorPhoneNumberResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAAnchorPhoneNumberResponse_Result>>(
                    "result",
                    CMsgDOTAAnchorPhoneNumberResponse::get_result_for_reflect,
                    CMsgDOTAAnchorPhoneNumberResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAAnchorPhoneNumberResponse>(
                    "CMsgDOTAAnchorPhoneNumberResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAAnchorPhoneNumberResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAAnchorPhoneNumberResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAAnchorPhoneNumberResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAAnchorPhoneNumberResponse_Result {
    SUCCESS = 0,
    ERROR_UNKNOWN = 1,
    ERROR_NO_STEAM_PHONE = 2,
    ERROR_ALREADY_IN_USE = 3,
    ERROR_COOLDOWN_ACTIVE = 4,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAAnchorPhoneNumberResponse_Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAAnchorPhoneNumberResponse_Result> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAAnchorPhoneNumberResponse_Result::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAAnchorPhoneNumberResponse_Result::ERROR_UNKNOWN),
            2 => ::std::option::Option::Some(CMsgDOTAAnchorPhoneNumberResponse_Result::ERROR_NO_STEAM_PHONE),
            3 => ::std::option::Option::Some(CMsgDOTAAnchorPhoneNumberResponse_Result::ERROR_ALREADY_IN_USE),
            4 => ::std::option::Option::Some(CMsgDOTAAnchorPhoneNumberResponse_Result::ERROR_COOLDOWN_ACTIVE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAAnchorPhoneNumberResponse_Result] = &[
            CMsgDOTAAnchorPhoneNumberResponse_Result::SUCCESS,
            CMsgDOTAAnchorPhoneNumberResponse_Result::ERROR_UNKNOWN,
            CMsgDOTAAnchorPhoneNumberResponse_Result::ERROR_NO_STEAM_PHONE,
            CMsgDOTAAnchorPhoneNumberResponse_Result::ERROR_ALREADY_IN_USE,
            CMsgDOTAAnchorPhoneNumberResponse_Result::ERROR_COOLDOWN_ACTIVE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAAnchorPhoneNumberResponse_Result>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAAnchorPhoneNumberResponse_Result", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAAnchorPhoneNumberResponse_Result {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAAnchorPhoneNumberResponse_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAUnanchorPhoneNumberRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAUnanchorPhoneNumberRequest {}

impl CMsgDOTAUnanchorPhoneNumberRequest {
    pub fn new() -> CMsgDOTAUnanchorPhoneNumberRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAUnanchorPhoneNumberRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAUnanchorPhoneNumberRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAUnanchorPhoneNumberRequest,
        };
        unsafe {
            instance.get(CMsgDOTAUnanchorPhoneNumberRequest::new)
        }
    }
}

impl ::protobuf::Message for CMsgDOTAUnanchorPhoneNumberRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAUnanchorPhoneNumberRequest {
    fn new() -> CMsgDOTAUnanchorPhoneNumberRequest {
        CMsgDOTAUnanchorPhoneNumberRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAUnanchorPhoneNumberRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAUnanchorPhoneNumberRequest>(
                    "CMsgDOTAUnanchorPhoneNumberRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAUnanchorPhoneNumberRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAUnanchorPhoneNumberRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAUnanchorPhoneNumberRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAUnanchorPhoneNumberResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAUnanchorPhoneNumberResponse_Result>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAUnanchorPhoneNumberResponse {}

impl CMsgDOTAUnanchorPhoneNumberResponse {
    pub fn new() -> CMsgDOTAUnanchorPhoneNumberResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAUnanchorPhoneNumberResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAUnanchorPhoneNumberResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAUnanchorPhoneNumberResponse,
        };
        unsafe {
            instance.get(CMsgDOTAUnanchorPhoneNumberResponse::new)
        }
    }

    // optional .CMsgDOTAUnanchorPhoneNumberResponse.Result result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAUnanchorPhoneNumberResponse_Result) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAUnanchorPhoneNumberResponse_Result {
        self.result.unwrap_or(CMsgDOTAUnanchorPhoneNumberResponse_Result::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAUnanchorPhoneNumberResponse_Result> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAUnanchorPhoneNumberResponse_Result> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgDOTAUnanchorPhoneNumberResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAUnanchorPhoneNumberResponse {
    fn new() -> CMsgDOTAUnanchorPhoneNumberResponse {
        CMsgDOTAUnanchorPhoneNumberResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAUnanchorPhoneNumberResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAUnanchorPhoneNumberResponse_Result>>(
                    "result",
                    CMsgDOTAUnanchorPhoneNumberResponse::get_result_for_reflect,
                    CMsgDOTAUnanchorPhoneNumberResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAUnanchorPhoneNumberResponse>(
                    "CMsgDOTAUnanchorPhoneNumberResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAUnanchorPhoneNumberResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAUnanchorPhoneNumberResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAUnanchorPhoneNumberResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAUnanchorPhoneNumberResponse_Result {
    SUCCESS = 0,
    ERROR_UNKNOWN = 1,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAUnanchorPhoneNumberResponse_Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAUnanchorPhoneNumberResponse_Result> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAUnanchorPhoneNumberResponse_Result::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAUnanchorPhoneNumberResponse_Result::ERROR_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAUnanchorPhoneNumberResponse_Result] = &[
            CMsgDOTAUnanchorPhoneNumberResponse_Result::SUCCESS,
            CMsgDOTAUnanchorPhoneNumberResponse_Result::ERROR_UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAUnanchorPhoneNumberResponse_Result>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAUnanchorPhoneNumberResponse_Result", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAUnanchorPhoneNumberResponse_Result {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAUnanchorPhoneNumberResponse_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientTipNotification {
    // message fields
    tipper_account_id: ::std::option::Option<u32>,
    tipper_name: ::protobuf::SingularField<::std::string::String>,
    recipient_account_id: ::std::option::Option<u32>,
    recipient_name: ::protobuf::SingularField<::std::string::String>,
    event_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientTipNotification {}

impl CMsgGCToClientTipNotification {
    pub fn new() -> CMsgGCToClientTipNotification {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientTipNotification {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientTipNotification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientTipNotification,
        };
        unsafe {
            instance.get(CMsgGCToClientTipNotification::new)
        }
    }

    // optional uint32 tipper_account_id = 1;

    pub fn clear_tipper_account_id(&mut self) {
        self.tipper_account_id = ::std::option::Option::None;
    }

    pub fn has_tipper_account_id(&self) -> bool {
        self.tipper_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tipper_account_id(&mut self, v: u32) {
        self.tipper_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_tipper_account_id(&self) -> u32 {
        self.tipper_account_id.unwrap_or(0)
    }

    fn get_tipper_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tipper_account_id
    }

    fn mut_tipper_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tipper_account_id
    }

    // optional string tipper_name = 2;

    pub fn clear_tipper_name(&mut self) {
        self.tipper_name.clear();
    }

    pub fn has_tipper_name(&self) -> bool {
        self.tipper_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tipper_name(&mut self, v: ::std::string::String) {
        self.tipper_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tipper_name(&mut self) -> &mut ::std::string::String {
        if self.tipper_name.is_none() {
            self.tipper_name.set_default();
        }
        self.tipper_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_tipper_name(&mut self) -> ::std::string::String {
        self.tipper_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_tipper_name(&self) -> &str {
        match self.tipper_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_tipper_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.tipper_name
    }

    fn mut_tipper_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.tipper_name
    }

    // optional uint32 recipient_account_id = 3;

    pub fn clear_recipient_account_id(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
    }

    pub fn has_recipient_account_id(&self) -> bool {
        self.recipient_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_account_id(&mut self, v: u32) {
        self.recipient_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_recipient_account_id(&self) -> u32 {
        self.recipient_account_id.unwrap_or(0)
    }

    fn get_recipient_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.recipient_account_id
    }

    fn mut_recipient_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.recipient_account_id
    }

    // optional string recipient_name = 4;

    pub fn clear_recipient_name(&mut self) {
        self.recipient_name.clear();
    }

    pub fn has_recipient_name(&self) -> bool {
        self.recipient_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_name(&mut self, v: ::std::string::String) {
        self.recipient_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipient_name(&mut self) -> &mut ::std::string::String {
        if self.recipient_name.is_none() {
            self.recipient_name.set_default();
        }
        self.recipient_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_recipient_name(&mut self) -> ::std::string::String {
        self.recipient_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_recipient_name(&self) -> &str {
        match self.recipient_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_recipient_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.recipient_name
    }

    fn mut_recipient_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.recipient_name
    }

    // optional uint32 event_id = 5;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }
}

impl ::protobuf::Message for CMsgGCToClientTipNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tipper_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tipper_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recipient_account_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recipient_name)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tipper_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tipper_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.recipient_account_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.recipient_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tipper_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.tipper_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.recipient_account_id {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.recipient_name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientTipNotification {
    fn new() -> CMsgGCToClientTipNotification {
        CMsgGCToClientTipNotification::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientTipNotification>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tipper_account_id",
                    CMsgGCToClientTipNotification::get_tipper_account_id_for_reflect,
                    CMsgGCToClientTipNotification::mut_tipper_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tipper_name",
                    CMsgGCToClientTipNotification::get_tipper_name_for_reflect,
                    CMsgGCToClientTipNotification::mut_tipper_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "recipient_account_id",
                    CMsgGCToClientTipNotification::get_recipient_account_id_for_reflect,
                    CMsgGCToClientTipNotification::mut_recipient_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "recipient_name",
                    CMsgGCToClientTipNotification::get_recipient_name_for_reflect,
                    CMsgGCToClientTipNotification::mut_recipient_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgGCToClientTipNotification::get_event_id_for_reflect,
                    CMsgGCToClientTipNotification::mut_event_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientTipNotification>(
                    "CMsgGCToClientTipNotification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientTipNotification {
    fn clear(&mut self) {
        self.clear_tipper_account_id();
        self.clear_tipper_name();
        self.clear_recipient_account_id();
        self.clear_recipient_name();
        self.clear_event_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientTipNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientTipNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientAllStarVotesRequest {
    // message fields
    event_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientAllStarVotesRequest {}

impl CMsgGCToClientAllStarVotesRequest {
    pub fn new() -> CMsgGCToClientAllStarVotesRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientAllStarVotesRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientAllStarVotesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientAllStarVotesRequest,
        };
        unsafe {
            instance.get(CMsgGCToClientAllStarVotesRequest::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }
}

impl ::protobuf::Message for CMsgGCToClientAllStarVotesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientAllStarVotesRequest {
    fn new() -> CMsgGCToClientAllStarVotesRequest {
        CMsgGCToClientAllStarVotesRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientAllStarVotesRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgGCToClientAllStarVotesRequest::get_event_id_for_reflect,
                    CMsgGCToClientAllStarVotesRequest::mut_event_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientAllStarVotesRequest>(
                    "CMsgGCToClientAllStarVotesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientAllStarVotesRequest {
    fn clear(&mut self) {
        self.clear_event_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientAllStarVotesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientAllStarVotesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientAllStarVotesReply {
    // message fields
    player_account_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientAllStarVotesReply {}

impl CMsgGCToClientAllStarVotesReply {
    pub fn new() -> CMsgGCToClientAllStarVotesReply {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientAllStarVotesReply {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientAllStarVotesReply> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientAllStarVotesReply,
        };
        unsafe {
            instance.get(CMsgGCToClientAllStarVotesReply::new)
        }
    }

    // repeated uint32 player_account_ids = 1;

    pub fn clear_player_account_ids(&mut self) {
        self.player_account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.player_account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.player_account_ids
    }

    // Take field
    pub fn take_player_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.player_account_ids, ::std::vec::Vec::new())
    }

    pub fn get_player_account_ids(&self) -> &[u32] {
        &self.player_account_ids
    }

    fn get_player_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.player_account_ids
    }

    fn mut_player_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.player_account_ids
    }
}

impl ::protobuf::Message for CMsgGCToClientAllStarVotesReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.player_account_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.player_account_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.player_account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientAllStarVotesReply {
    fn new() -> CMsgGCToClientAllStarVotesReply {
        CMsgGCToClientAllStarVotesReply::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientAllStarVotesReply>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_account_ids",
                    CMsgGCToClientAllStarVotesReply::get_player_account_ids_for_reflect,
                    CMsgGCToClientAllStarVotesReply::mut_player_account_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientAllStarVotesReply>(
                    "CMsgGCToClientAllStarVotesReply",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientAllStarVotesReply {
    fn clear(&mut self) {
        self.clear_player_account_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientAllStarVotesReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientAllStarVotesReply {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientAllStarVotesSubmit {
    // message fields
    event_id: ::std::option::Option<u32>,
    player_account_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientAllStarVotesSubmit {}

impl CMsgGCToClientAllStarVotesSubmit {
    pub fn new() -> CMsgGCToClientAllStarVotesSubmit {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientAllStarVotesSubmit {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientAllStarVotesSubmit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientAllStarVotesSubmit,
        };
        unsafe {
            instance.get(CMsgGCToClientAllStarVotesSubmit::new)
        }
    }

    // optional uint32 event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_id
    }

    // repeated uint32 player_account_ids = 2;

    pub fn clear_player_account_ids(&mut self) {
        self.player_account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.player_account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.player_account_ids
    }

    // Take field
    pub fn take_player_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.player_account_ids, ::std::vec::Vec::new())
    }

    pub fn get_player_account_ids(&self) -> &[u32] {
        &self.player_account_ids
    }

    fn get_player_account_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.player_account_ids
    }

    fn mut_player_account_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.player_account_ids
    }
}

impl ::protobuf::Message for CMsgGCToClientAllStarVotesSubmit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.player_account_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.player_account_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.player_account_ids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientAllStarVotesSubmit {
    fn new() -> CMsgGCToClientAllStarVotesSubmit {
        CMsgGCToClientAllStarVotesSubmit::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientAllStarVotesSubmit>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_id",
                    CMsgGCToClientAllStarVotesSubmit::get_event_id_for_reflect,
                    CMsgGCToClientAllStarVotesSubmit::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_account_ids",
                    CMsgGCToClientAllStarVotesSubmit::get_player_account_ids_for_reflect,
                    CMsgGCToClientAllStarVotesSubmit::mut_player_account_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientAllStarVotesSubmit>(
                    "CMsgGCToClientAllStarVotesSubmit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientAllStarVotesSubmit {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_player_account_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientAllStarVotesSubmit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientAllStarVotesSubmit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientAllStarVotesSubmitReply {
    // message fields
    result: ::std::option::Option<CMsgGCToClientAllStarVotesSubmitReply_Result>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientAllStarVotesSubmitReply {}

impl CMsgGCToClientAllStarVotesSubmitReply {
    pub fn new() -> CMsgGCToClientAllStarVotesSubmitReply {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientAllStarVotesSubmitReply {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientAllStarVotesSubmitReply> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientAllStarVotesSubmitReply,
        };
        unsafe {
            instance.get(CMsgGCToClientAllStarVotesSubmitReply::new)
        }
    }

    // optional .CMsgGCToClientAllStarVotesSubmitReply.Result result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgGCToClientAllStarVotesSubmitReply_Result) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgGCToClientAllStarVotesSubmitReply_Result {
        self.result.unwrap_or(CMsgGCToClientAllStarVotesSubmitReply_Result::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgGCToClientAllStarVotesSubmitReply_Result> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgGCToClientAllStarVotesSubmitReply_Result> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgGCToClientAllStarVotesSubmitReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientAllStarVotesSubmitReply {
    fn new() -> CMsgGCToClientAllStarVotesSubmitReply {
        CMsgGCToClientAllStarVotesSubmitReply::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientAllStarVotesSubmitReply>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGCToClientAllStarVotesSubmitReply_Result>>(
                    "result",
                    CMsgGCToClientAllStarVotesSubmitReply::get_result_for_reflect,
                    CMsgGCToClientAllStarVotesSubmitReply::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientAllStarVotesSubmitReply>(
                    "CMsgGCToClientAllStarVotesSubmitReply",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientAllStarVotesSubmitReply {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientAllStarVotesSubmitReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientAllStarVotesSubmitReply {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGCToClientAllStarVotesSubmitReply_Result {
    SUCCESS = 1,
    ERROR_INTERNAL = 2,
    ERROR_INVALID_EVENT_ID = 3,
    ERROR_INVALID_ACCOUNT_ID = 4,
    ERROR_SELECTIONS_LOCKED = 5,
}

impl ::protobuf::ProtobufEnum for CMsgGCToClientAllStarVotesSubmitReply_Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGCToClientAllStarVotesSubmitReply_Result> {
        match value {
            1 => ::std::option::Option::Some(CMsgGCToClientAllStarVotesSubmitReply_Result::SUCCESS),
            2 => ::std::option::Option::Some(CMsgGCToClientAllStarVotesSubmitReply_Result::ERROR_INTERNAL),
            3 => ::std::option::Option::Some(CMsgGCToClientAllStarVotesSubmitReply_Result::ERROR_INVALID_EVENT_ID),
            4 => ::std::option::Option::Some(CMsgGCToClientAllStarVotesSubmitReply_Result::ERROR_INVALID_ACCOUNT_ID),
            5 => ::std::option::Option::Some(CMsgGCToClientAllStarVotesSubmitReply_Result::ERROR_SELECTIONS_LOCKED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGCToClientAllStarVotesSubmitReply_Result] = &[
            CMsgGCToClientAllStarVotesSubmitReply_Result::SUCCESS,
            CMsgGCToClientAllStarVotesSubmitReply_Result::ERROR_INTERNAL,
            CMsgGCToClientAllStarVotesSubmitReply_Result::ERROR_INVALID_EVENT_ID,
            CMsgGCToClientAllStarVotesSubmitReply_Result::ERROR_INVALID_ACCOUNT_ID,
            CMsgGCToClientAllStarVotesSubmitReply_Result::ERROR_SELECTIONS_LOCKED,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgGCToClientAllStarVotesSubmitReply_Result>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgGCToClientAllStarVotesSubmitReply_Result", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgGCToClientAllStarVotesSubmitReply_Result {
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientAllStarVotesSubmitReply_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAClientToGCQuickStatsRequest {
    // message fields
    player_account_id: ::std::option::Option<u32>,
    hero_id: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u32>,
    league_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAClientToGCQuickStatsRequest {}

impl CMsgDOTAClientToGCQuickStatsRequest {
    pub fn new() -> CMsgDOTAClientToGCQuickStatsRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAClientToGCQuickStatsRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAClientToGCQuickStatsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAClientToGCQuickStatsRequest,
        };
        unsafe {
            instance.get(CMsgDOTAClientToGCQuickStatsRequest::new)
        }
    }

    // optional uint32 player_account_id = 1;

    pub fn clear_player_account_id(&mut self) {
        self.player_account_id = ::std::option::Option::None;
    }

    pub fn has_player_account_id(&self) -> bool {
        self.player_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_account_id(&mut self, v: u32) {
        self.player_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_account_id(&self) -> u32 {
        self.player_account_id.unwrap_or(0)
    }

    fn get_player_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_account_id
    }

    fn mut_player_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_account_id
    }

    // optional uint32 hero_id = 2;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional uint32 item_id = 3;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u32) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u32 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_id
    }

    // optional uint32 league_id = 4;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }
}

impl ::protobuf::Message for CMsgDOTAClientToGCQuickStatsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAClientToGCQuickStatsRequest {
    fn new() -> CMsgDOTAClientToGCQuickStatsRequest {
        CMsgDOTAClientToGCQuickStatsRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAClientToGCQuickStatsRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_account_id",
                    CMsgDOTAClientToGCQuickStatsRequest::get_player_account_id_for_reflect,
                    CMsgDOTAClientToGCQuickStatsRequest::mut_player_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CMsgDOTAClientToGCQuickStatsRequest::get_hero_id_for_reflect,
                    CMsgDOTAClientToGCQuickStatsRequest::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_id",
                    CMsgDOTAClientToGCQuickStatsRequest::get_item_id_for_reflect,
                    CMsgDOTAClientToGCQuickStatsRequest::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CMsgDOTAClientToGCQuickStatsRequest::get_league_id_for_reflect,
                    CMsgDOTAClientToGCQuickStatsRequest::mut_league_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAClientToGCQuickStatsRequest>(
                    "CMsgDOTAClientToGCQuickStatsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAClientToGCQuickStatsRequest {
    fn clear(&mut self) {
        self.clear_player_account_id();
        self.clear_hero_id();
        self.clear_item_id();
        self.clear_league_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAClientToGCQuickStatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAClientToGCQuickStatsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAClientToGCQuickStatsResponse {
    // message fields
    original_request: ::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsRequest>,
    hero_stats: ::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats>,
    item_stats: ::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats>,
    item_hero_stats: ::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats>,
    item_player_stats: ::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats>,
    hero_player_stats: ::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats>,
    full_set_stats: ::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAClientToGCQuickStatsResponse {}

impl CMsgDOTAClientToGCQuickStatsResponse {
    pub fn new() -> CMsgDOTAClientToGCQuickStatsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAClientToGCQuickStatsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAClientToGCQuickStatsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAClientToGCQuickStatsResponse,
        };
        unsafe {
            instance.get(CMsgDOTAClientToGCQuickStatsResponse::new)
        }
    }

    // optional .CMsgDOTAClientToGCQuickStatsRequest original_request = 1;

    pub fn clear_original_request(&mut self) {
        self.original_request.clear();
    }

    pub fn has_original_request(&self) -> bool {
        self.original_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_request(&mut self, v: CMsgDOTAClientToGCQuickStatsRequest) {
        self.original_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_request(&mut self) -> &mut CMsgDOTAClientToGCQuickStatsRequest {
        if self.original_request.is_none() {
            self.original_request.set_default();
        }
        self.original_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_request(&mut self) -> CMsgDOTAClientToGCQuickStatsRequest {
        self.original_request.take().unwrap_or_else(|| CMsgDOTAClientToGCQuickStatsRequest::new())
    }

    pub fn get_original_request(&self) -> &CMsgDOTAClientToGCQuickStatsRequest {
        self.original_request.as_ref().unwrap_or_else(|| CMsgDOTAClientToGCQuickStatsRequest::default_instance())
    }

    fn get_original_request_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsRequest> {
        &self.original_request
    }

    fn mut_original_request_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsRequest> {
        &mut self.original_request
    }

    // optional .CMsgDOTAClientToGCQuickStatsResponse.SimpleStats hero_stats = 2;

    pub fn clear_hero_stats(&mut self) {
        self.hero_stats.clear();
    }

    pub fn has_hero_stats(&self) -> bool {
        self.hero_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_stats(&mut self, v: CMsgDOTAClientToGCQuickStatsResponse_SimpleStats) {
        self.hero_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hero_stats(&mut self) -> &mut CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        if self.hero_stats.is_none() {
            self.hero_stats.set_default();
        }
        self.hero_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_hero_stats(&mut self) -> CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        self.hero_stats.take().unwrap_or_else(|| CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::new())
    }

    pub fn get_hero_stats(&self) -> &CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        self.hero_stats.as_ref().unwrap_or_else(|| CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::default_instance())
    }

    fn get_hero_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats> {
        &self.hero_stats
    }

    fn mut_hero_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats> {
        &mut self.hero_stats
    }

    // optional .CMsgDOTAClientToGCQuickStatsResponse.SimpleStats item_stats = 3;

    pub fn clear_item_stats(&mut self) {
        self.item_stats.clear();
    }

    pub fn has_item_stats(&self) -> bool {
        self.item_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_stats(&mut self, v: CMsgDOTAClientToGCQuickStatsResponse_SimpleStats) {
        self.item_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_stats(&mut self) -> &mut CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        if self.item_stats.is_none() {
            self.item_stats.set_default();
        }
        self.item_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_stats(&mut self) -> CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        self.item_stats.take().unwrap_or_else(|| CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::new())
    }

    pub fn get_item_stats(&self) -> &CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        self.item_stats.as_ref().unwrap_or_else(|| CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::default_instance())
    }

    fn get_item_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats> {
        &self.item_stats
    }

    fn mut_item_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats> {
        &mut self.item_stats
    }

    // optional .CMsgDOTAClientToGCQuickStatsResponse.SimpleStats item_hero_stats = 4;

    pub fn clear_item_hero_stats(&mut self) {
        self.item_hero_stats.clear();
    }

    pub fn has_item_hero_stats(&self) -> bool {
        self.item_hero_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_hero_stats(&mut self, v: CMsgDOTAClientToGCQuickStatsResponse_SimpleStats) {
        self.item_hero_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_hero_stats(&mut self) -> &mut CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        if self.item_hero_stats.is_none() {
            self.item_hero_stats.set_default();
        }
        self.item_hero_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_hero_stats(&mut self) -> CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        self.item_hero_stats.take().unwrap_or_else(|| CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::new())
    }

    pub fn get_item_hero_stats(&self) -> &CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        self.item_hero_stats.as_ref().unwrap_or_else(|| CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::default_instance())
    }

    fn get_item_hero_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats> {
        &self.item_hero_stats
    }

    fn mut_item_hero_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats> {
        &mut self.item_hero_stats
    }

    // optional .CMsgDOTAClientToGCQuickStatsResponse.SimpleStats item_player_stats = 5;

    pub fn clear_item_player_stats(&mut self) {
        self.item_player_stats.clear();
    }

    pub fn has_item_player_stats(&self) -> bool {
        self.item_player_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_player_stats(&mut self, v: CMsgDOTAClientToGCQuickStatsResponse_SimpleStats) {
        self.item_player_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_player_stats(&mut self) -> &mut CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        if self.item_player_stats.is_none() {
            self.item_player_stats.set_default();
        }
        self.item_player_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_player_stats(&mut self) -> CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        self.item_player_stats.take().unwrap_or_else(|| CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::new())
    }

    pub fn get_item_player_stats(&self) -> &CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        self.item_player_stats.as_ref().unwrap_or_else(|| CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::default_instance())
    }

    fn get_item_player_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats> {
        &self.item_player_stats
    }

    fn mut_item_player_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats> {
        &mut self.item_player_stats
    }

    // optional .CMsgDOTAClientToGCQuickStatsResponse.SimpleStats hero_player_stats = 6;

    pub fn clear_hero_player_stats(&mut self) {
        self.hero_player_stats.clear();
    }

    pub fn has_hero_player_stats(&self) -> bool {
        self.hero_player_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_player_stats(&mut self, v: CMsgDOTAClientToGCQuickStatsResponse_SimpleStats) {
        self.hero_player_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hero_player_stats(&mut self) -> &mut CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        if self.hero_player_stats.is_none() {
            self.hero_player_stats.set_default();
        }
        self.hero_player_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_hero_player_stats(&mut self) -> CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        self.hero_player_stats.take().unwrap_or_else(|| CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::new())
    }

    pub fn get_hero_player_stats(&self) -> &CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        self.hero_player_stats.as_ref().unwrap_or_else(|| CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::default_instance())
    }

    fn get_hero_player_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats> {
        &self.hero_player_stats
    }

    fn mut_hero_player_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats> {
        &mut self.hero_player_stats
    }

    // optional .CMsgDOTAClientToGCQuickStatsResponse.SimpleStats full_set_stats = 7;

    pub fn clear_full_set_stats(&mut self) {
        self.full_set_stats.clear();
    }

    pub fn has_full_set_stats(&self) -> bool {
        self.full_set_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_set_stats(&mut self, v: CMsgDOTAClientToGCQuickStatsResponse_SimpleStats) {
        self.full_set_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_set_stats(&mut self) -> &mut CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        if self.full_set_stats.is_none() {
            self.full_set_stats.set_default();
        }
        self.full_set_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_full_set_stats(&mut self) -> CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        self.full_set_stats.take().unwrap_or_else(|| CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::new())
    }

    pub fn get_full_set_stats(&self) -> &CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        self.full_set_stats.as_ref().unwrap_or_else(|| CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::default_instance())
    }

    fn get_full_set_stats_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats> {
        &self.full_set_stats
    }

    fn mut_full_set_stats_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats> {
        &mut self.full_set_stats
    }
}

impl ::protobuf::Message for CMsgDOTAClientToGCQuickStatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.original_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hero_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.item_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.item_hero_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.item_player_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hero_player_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.full_set_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.original_request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hero_stats)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.item_stats)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.item_hero_stats)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.item_player_stats)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hero_player_stats)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.full_set_stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.original_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hero_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.item_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.item_hero_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.item_player_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hero_player_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.full_set_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.original_request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hero_stats.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.item_stats.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.item_hero_stats.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.item_player_stats.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hero_player_stats.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.full_set_stats.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAClientToGCQuickStatsResponse {
    fn new() -> CMsgDOTAClientToGCQuickStatsResponse {
        CMsgDOTAClientToGCQuickStatsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAClientToGCQuickStatsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAClientToGCQuickStatsRequest>>(
                    "original_request",
                    CMsgDOTAClientToGCQuickStatsResponse::get_original_request_for_reflect,
                    CMsgDOTAClientToGCQuickStatsResponse::mut_original_request_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats>>(
                    "hero_stats",
                    CMsgDOTAClientToGCQuickStatsResponse::get_hero_stats_for_reflect,
                    CMsgDOTAClientToGCQuickStatsResponse::mut_hero_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats>>(
                    "item_stats",
                    CMsgDOTAClientToGCQuickStatsResponse::get_item_stats_for_reflect,
                    CMsgDOTAClientToGCQuickStatsResponse::mut_item_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats>>(
                    "item_hero_stats",
                    CMsgDOTAClientToGCQuickStatsResponse::get_item_hero_stats_for_reflect,
                    CMsgDOTAClientToGCQuickStatsResponse::mut_item_hero_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats>>(
                    "item_player_stats",
                    CMsgDOTAClientToGCQuickStatsResponse::get_item_player_stats_for_reflect,
                    CMsgDOTAClientToGCQuickStatsResponse::mut_item_player_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats>>(
                    "hero_player_stats",
                    CMsgDOTAClientToGCQuickStatsResponse::get_hero_player_stats_for_reflect,
                    CMsgDOTAClientToGCQuickStatsResponse::mut_hero_player_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats>>(
                    "full_set_stats",
                    CMsgDOTAClientToGCQuickStatsResponse::get_full_set_stats_for_reflect,
                    CMsgDOTAClientToGCQuickStatsResponse::mut_full_set_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAClientToGCQuickStatsResponse>(
                    "CMsgDOTAClientToGCQuickStatsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAClientToGCQuickStatsResponse {
    fn clear(&mut self) {
        self.clear_original_request();
        self.clear_hero_stats();
        self.clear_item_stats();
        self.clear_item_hero_stats();
        self.clear_item_player_stats();
        self.clear_hero_player_stats();
        self.clear_full_set_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAClientToGCQuickStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAClientToGCQuickStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
    // message fields
    win_percent: ::std::option::Option<f32>,
    pick_percent: ::std::option::Option<f32>,
    win_count: ::std::option::Option<u32>,
    pick_count: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {}

impl CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
    pub fn new() -> CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAClientToGCQuickStatsResponse_SimpleStats,
        };
        unsafe {
            instance.get(CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::new)
        }
    }

    // optional float win_percent = 1;

    pub fn clear_win_percent(&mut self) {
        self.win_percent = ::std::option::Option::None;
    }

    pub fn has_win_percent(&self) -> bool {
        self.win_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win_percent(&mut self, v: f32) {
        self.win_percent = ::std::option::Option::Some(v);
    }

    pub fn get_win_percent(&self) -> f32 {
        self.win_percent.unwrap_or(0.)
    }

    fn get_win_percent_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.win_percent
    }

    fn mut_win_percent_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.win_percent
    }

    // optional float pick_percent = 2;

    pub fn clear_pick_percent(&mut self) {
        self.pick_percent = ::std::option::Option::None;
    }

    pub fn has_pick_percent(&self) -> bool {
        self.pick_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pick_percent(&mut self, v: f32) {
        self.pick_percent = ::std::option::Option::Some(v);
    }

    pub fn get_pick_percent(&self) -> f32 {
        self.pick_percent.unwrap_or(0.)
    }

    fn get_pick_percent_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.pick_percent
    }

    fn mut_pick_percent_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.pick_percent
    }

    // optional uint32 win_count = 3;

    pub fn clear_win_count(&mut self) {
        self.win_count = ::std::option::Option::None;
    }

    pub fn has_win_count(&self) -> bool {
        self.win_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win_count(&mut self, v: u32) {
        self.win_count = ::std::option::Option::Some(v);
    }

    pub fn get_win_count(&self) -> u32 {
        self.win_count.unwrap_or(0)
    }

    fn get_win_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.win_count
    }

    fn mut_win_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.win_count
    }

    // optional uint32 pick_count = 4;

    pub fn clear_pick_count(&mut self) {
        self.pick_count = ::std::option::Option::None;
    }

    pub fn has_pick_count(&self) -> bool {
        self.pick_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pick_count(&mut self, v: u32) {
        self.pick_count = ::std::option::Option::Some(v);
    }

    pub fn get_pick_count(&self) -> u32 {
        self.pick_count.unwrap_or(0)
    }

    fn get_pick_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.pick_count
    }

    fn mut_pick_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.pick_count
    }
}

impl ::protobuf::Message for CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.win_percent = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pick_percent = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.win_count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pick_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.win_percent {
            my_size += 5;
        }
        if let Some(v) = self.pick_percent {
            my_size += 5;
        }
        if let Some(v) = self.win_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pick_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.win_percent {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.pick_percent {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.win_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.pick_count {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
    fn new() -> CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
        CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "win_percent",
                    CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::get_win_percent_for_reflect,
                    CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::mut_win_percent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "pick_percent",
                    CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::get_pick_percent_for_reflect,
                    CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::mut_pick_percent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "win_count",
                    CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::get_win_count_for_reflect,
                    CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::mut_win_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pick_count",
                    CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::get_pick_count_for_reflect,
                    CMsgDOTAClientToGCQuickStatsResponse_SimpleStats::mut_pick_count_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAClientToGCQuickStatsResponse_SimpleStats>(
                    "CMsgDOTAClientToGCQuickStatsResponse_SimpleStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
    fn clear(&mut self) {
        self.clear_win_percent();
        self.clear_pick_percent();
        self.clear_win_count();
        self.clear_pick_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAClientToGCQuickStatsResponse_SimpleStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASelectionPriorityChoiceRequest {
    // message fields
    choice: ::std::option::Option<super::dota_shared_enums::DOTASelectionPriorityChoice>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASelectionPriorityChoiceRequest {}

impl CMsgDOTASelectionPriorityChoiceRequest {
    pub fn new() -> CMsgDOTASelectionPriorityChoiceRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASelectionPriorityChoiceRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASelectionPriorityChoiceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASelectionPriorityChoiceRequest,
        };
        unsafe {
            instance.get(CMsgDOTASelectionPriorityChoiceRequest::new)
        }
    }

    // optional .DOTASelectionPriorityChoice choice = 1;

    pub fn clear_choice(&mut self) {
        self.choice = ::std::option::Option::None;
    }

    pub fn has_choice(&self) -> bool {
        self.choice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_choice(&mut self, v: super::dota_shared_enums::DOTASelectionPriorityChoice) {
        self.choice = ::std::option::Option::Some(v);
    }

    pub fn get_choice(&self) -> super::dota_shared_enums::DOTASelectionPriorityChoice {
        self.choice.unwrap_or(super::dota_shared_enums::DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid)
    }

    fn get_choice_for_reflect(&self) -> &::std::option::Option<super::dota_shared_enums::DOTASelectionPriorityChoice> {
        &self.choice
    }

    fn mut_choice_for_reflect(&mut self) -> &mut ::std::option::Option<super::dota_shared_enums::DOTASelectionPriorityChoice> {
        &mut self.choice
    }
}

impl ::protobuf::Message for CMsgDOTASelectionPriorityChoiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.choice = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.choice {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.choice {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASelectionPriorityChoiceRequest {
    fn new() -> CMsgDOTASelectionPriorityChoiceRequest {
        CMsgDOTASelectionPriorityChoiceRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASelectionPriorityChoiceRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::dota_shared_enums::DOTASelectionPriorityChoice>>(
                    "choice",
                    CMsgDOTASelectionPriorityChoiceRequest::get_choice_for_reflect,
                    CMsgDOTASelectionPriorityChoiceRequest::mut_choice_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASelectionPriorityChoiceRequest>(
                    "CMsgDOTASelectionPriorityChoiceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASelectionPriorityChoiceRequest {
    fn clear(&mut self) {
        self.clear_choice();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASelectionPriorityChoiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASelectionPriorityChoiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTASelectionPriorityChoiceResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTASelectionPriorityChoiceResponse_Result>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTASelectionPriorityChoiceResponse {}

impl CMsgDOTASelectionPriorityChoiceResponse {
    pub fn new() -> CMsgDOTASelectionPriorityChoiceResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTASelectionPriorityChoiceResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTASelectionPriorityChoiceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTASelectionPriorityChoiceResponse,
        };
        unsafe {
            instance.get(CMsgDOTASelectionPriorityChoiceResponse::new)
        }
    }

    // optional .CMsgDOTASelectionPriorityChoiceResponse.Result result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTASelectionPriorityChoiceResponse_Result) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTASelectionPriorityChoiceResponse_Result {
        self.result.unwrap_or(CMsgDOTASelectionPriorityChoiceResponse_Result::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTASelectionPriorityChoiceResponse_Result> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTASelectionPriorityChoiceResponse_Result> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgDOTASelectionPriorityChoiceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTASelectionPriorityChoiceResponse {
    fn new() -> CMsgDOTASelectionPriorityChoiceResponse {
        CMsgDOTASelectionPriorityChoiceResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTASelectionPriorityChoiceResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTASelectionPriorityChoiceResponse_Result>>(
                    "result",
                    CMsgDOTASelectionPriorityChoiceResponse::get_result_for_reflect,
                    CMsgDOTASelectionPriorityChoiceResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTASelectionPriorityChoiceResponse>(
                    "CMsgDOTASelectionPriorityChoiceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTASelectionPriorityChoiceResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTASelectionPriorityChoiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASelectionPriorityChoiceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTASelectionPriorityChoiceResponse_Result {
    SUCCESS = 0,
    ERROR_UNKNOWN = 1,
}

impl ::protobuf::ProtobufEnum for CMsgDOTASelectionPriorityChoiceResponse_Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTASelectionPriorityChoiceResponse_Result> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTASelectionPriorityChoiceResponse_Result::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTASelectionPriorityChoiceResponse_Result::ERROR_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTASelectionPriorityChoiceResponse_Result] = &[
            CMsgDOTASelectionPriorityChoiceResponse_Result::SUCCESS,
            CMsgDOTASelectionPriorityChoiceResponse_Result::ERROR_UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTASelectionPriorityChoiceResponse_Result>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTASelectionPriorityChoiceResponse_Result", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTASelectionPriorityChoiceResponse_Result {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTASelectionPriorityChoiceResponse_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAGameAutographReward {
    // message fields
    badge_id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAGameAutographReward {}

impl CMsgDOTAGameAutographReward {
    pub fn new() -> CMsgDOTAGameAutographReward {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAGameAutographReward {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAGameAutographReward> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAGameAutographReward,
        };
        unsafe {
            instance.get(CMsgDOTAGameAutographReward::new)
        }
    }

    // optional string badge_id = 1;

    pub fn clear_badge_id(&mut self) {
        self.badge_id.clear();
    }

    pub fn has_badge_id(&self) -> bool {
        self.badge_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_id(&mut self, v: ::std::string::String) {
        self.badge_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_badge_id(&mut self) -> &mut ::std::string::String {
        if self.badge_id.is_none() {
            self.badge_id.set_default();
        }
        self.badge_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_badge_id(&mut self) -> ::std::string::String {
        self.badge_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_badge_id(&self) -> &str {
        match self.badge_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_badge_id_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.badge_id
    }

    fn mut_badge_id_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.badge_id
    }
}

impl ::protobuf::Message for CMsgDOTAGameAutographReward {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.badge_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.badge_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.badge_id.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAGameAutographReward {
    fn new() -> CMsgDOTAGameAutographReward {
        CMsgDOTAGameAutographReward::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAGameAutographReward>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "badge_id",
                    CMsgDOTAGameAutographReward::get_badge_id_for_reflect,
                    CMsgDOTAGameAutographReward::mut_badge_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAGameAutographReward>(
                    "CMsgDOTAGameAutographReward",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAGameAutographReward {
    fn clear(&mut self) {
        self.clear_badge_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAGameAutographReward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAGameAutographReward {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDOTAGameAutographRewardResponse {
    // message fields
    result: ::std::option::Option<CMsgDOTAGameAutographRewardResponse_Result>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDOTAGameAutographRewardResponse {}

impl CMsgDOTAGameAutographRewardResponse {
    pub fn new() -> CMsgDOTAGameAutographRewardResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDOTAGameAutographRewardResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDOTAGameAutographRewardResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDOTAGameAutographRewardResponse,
        };
        unsafe {
            instance.get(CMsgDOTAGameAutographRewardResponse::new)
        }
    }

    // optional .CMsgDOTAGameAutographRewardResponse.Result result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CMsgDOTAGameAutographRewardResponse_Result) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CMsgDOTAGameAutographRewardResponse_Result {
        self.result.unwrap_or(CMsgDOTAGameAutographRewardResponse_Result::SUCCESS)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CMsgDOTAGameAutographRewardResponse_Result> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgDOTAGameAutographRewardResponse_Result> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgDOTAGameAutographRewardResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDOTAGameAutographRewardResponse {
    fn new() -> CMsgDOTAGameAutographRewardResponse {
        CMsgDOTAGameAutographRewardResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDOTAGameAutographRewardResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgDOTAGameAutographRewardResponse_Result>>(
                    "result",
                    CMsgDOTAGameAutographRewardResponse::get_result_for_reflect,
                    CMsgDOTAGameAutographRewardResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDOTAGameAutographRewardResponse>(
                    "CMsgDOTAGameAutographRewardResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDOTAGameAutographRewardResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDOTAGameAutographRewardResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAGameAutographRewardResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgDOTAGameAutographRewardResponse_Result {
    SUCCESS = 0,
    ERROR_UNKNOWN = 1,
}

impl ::protobuf::ProtobufEnum for CMsgDOTAGameAutographRewardResponse_Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTAGameAutographRewardResponse_Result> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTAGameAutographRewardResponse_Result::SUCCESS),
            1 => ::std::option::Option::Some(CMsgDOTAGameAutographRewardResponse_Result::ERROR_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgDOTAGameAutographRewardResponse_Result] = &[
            CMsgDOTAGameAutographRewardResponse_Result::SUCCESS,
            CMsgDOTAGameAutographRewardResponse_Result::ERROR_UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgDOTAGameAutographRewardResponse_Result>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgDOTAGameAutographRewardResponse_Result", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgDOTAGameAutographRewardResponse_Result {
}

impl ::protobuf::reflect::ProtobufValue for CMsgDOTAGameAutographRewardResponse_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DOTA_WatchReplayType {
    DOTA_WATCH_REPLAY_NORMAL = 0,
    DOTA_WATCH_REPLAY_HIGHLIGHTS = 1,
}

impl ::protobuf::ProtobufEnum for DOTA_WatchReplayType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_WatchReplayType> {
        match value {
            0 => ::std::option::Option::Some(DOTA_WatchReplayType::DOTA_WATCH_REPLAY_NORMAL),
            1 => ::std::option::Option::Some(DOTA_WatchReplayType::DOTA_WATCH_REPLAY_HIGHLIGHTS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DOTA_WatchReplayType] = &[
            DOTA_WatchReplayType::DOTA_WATCH_REPLAY_NORMAL,
            DOTA_WatchReplayType::DOTA_WATCH_REPLAY_HIGHLIGHTS,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<DOTA_WatchReplayType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DOTA_WatchReplayType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DOTA_WatchReplayType {
}

impl ::protobuf::reflect::ProtobufValue for DOTA_WatchReplayType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EItemEditorReservationResult {
    k_EItemEditorReservationResult_OK = 1,
    k_EItemEditorReservationResult_AlreadyExists = 2,
    k_EItemEditorReservationResult_Reserved = 3,
    k_EItemEditorReservationResult_TimedOut = 4,
}

impl ::protobuf::ProtobufEnum for EItemEditorReservationResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EItemEditorReservationResult> {
        match value {
            1 => ::std::option::Option::Some(EItemEditorReservationResult::k_EItemEditorReservationResult_OK),
            2 => ::std::option::Option::Some(EItemEditorReservationResult::k_EItemEditorReservationResult_AlreadyExists),
            3 => ::std::option::Option::Some(EItemEditorReservationResult::k_EItemEditorReservationResult_Reserved),
            4 => ::std::option::Option::Some(EItemEditorReservationResult::k_EItemEditorReservationResult_TimedOut),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EItemEditorReservationResult] = &[
            EItemEditorReservationResult::k_EItemEditorReservationResult_OK,
            EItemEditorReservationResult::k_EItemEditorReservationResult_AlreadyExists,
            EItemEditorReservationResult::k_EItemEditorReservationResult_Reserved,
            EItemEditorReservationResult::k_EItemEditorReservationResult_TimedOut,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EItemEditorReservationResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EItemEditorReservationResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EItemEditorReservationResult {
}

impl ::protobuf::reflect::ProtobufValue for EItemEditorReservationResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EFeaturedHeroTextField {
    k_EFeaturedHeroTextField_NewHero = 0,
    k_EFeaturedHeroTextField_NewItem = 1,
    k_EFeaturedHeroTextField_ItemSetDescription = 2,
    k_EFeaturedHeroTextField_ItemDescription = 3,
    k_EFeaturedHeroTextField_Hype = 4,
    k_EFeaturedHeroTextField_HeroWinLoss = 5,
    k_EFeaturedHeroTextField_FrequentlyPlayedHero = 6,
    k_EFeaturedHeroTextField_FeaturedItem = 7,
    k_EFeaturedHeroTextField_PopularItem = 8,
    k_EFeaturedHeroTextField_SaleItem = 9,
    k_EFeaturedHeroTextField_SaleDiscount = 10,
    k_EFeaturedHeroTextField_Container = 11,
}

impl ::protobuf::ProtobufEnum for EFeaturedHeroTextField {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EFeaturedHeroTextField> {
        match value {
            0 => ::std::option::Option::Some(EFeaturedHeroTextField::k_EFeaturedHeroTextField_NewHero),
            1 => ::std::option::Option::Some(EFeaturedHeroTextField::k_EFeaturedHeroTextField_NewItem),
            2 => ::std::option::Option::Some(EFeaturedHeroTextField::k_EFeaturedHeroTextField_ItemSetDescription),
            3 => ::std::option::Option::Some(EFeaturedHeroTextField::k_EFeaturedHeroTextField_ItemDescription),
            4 => ::std::option::Option::Some(EFeaturedHeroTextField::k_EFeaturedHeroTextField_Hype),
            5 => ::std::option::Option::Some(EFeaturedHeroTextField::k_EFeaturedHeroTextField_HeroWinLoss),
            6 => ::std::option::Option::Some(EFeaturedHeroTextField::k_EFeaturedHeroTextField_FrequentlyPlayedHero),
            7 => ::std::option::Option::Some(EFeaturedHeroTextField::k_EFeaturedHeroTextField_FeaturedItem),
            8 => ::std::option::Option::Some(EFeaturedHeroTextField::k_EFeaturedHeroTextField_PopularItem),
            9 => ::std::option::Option::Some(EFeaturedHeroTextField::k_EFeaturedHeroTextField_SaleItem),
            10 => ::std::option::Option::Some(EFeaturedHeroTextField::k_EFeaturedHeroTextField_SaleDiscount),
            11 => ::std::option::Option::Some(EFeaturedHeroTextField::k_EFeaturedHeroTextField_Container),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EFeaturedHeroTextField] = &[
            EFeaturedHeroTextField::k_EFeaturedHeroTextField_NewHero,
            EFeaturedHeroTextField::k_EFeaturedHeroTextField_NewItem,
            EFeaturedHeroTextField::k_EFeaturedHeroTextField_ItemSetDescription,
            EFeaturedHeroTextField::k_EFeaturedHeroTextField_ItemDescription,
            EFeaturedHeroTextField::k_EFeaturedHeroTextField_Hype,
            EFeaturedHeroTextField::k_EFeaturedHeroTextField_HeroWinLoss,
            EFeaturedHeroTextField::k_EFeaturedHeroTextField_FrequentlyPlayedHero,
            EFeaturedHeroTextField::k_EFeaturedHeroTextField_FeaturedItem,
            EFeaturedHeroTextField::k_EFeaturedHeroTextField_PopularItem,
            EFeaturedHeroTextField::k_EFeaturedHeroTextField_SaleItem,
            EFeaturedHeroTextField::k_EFeaturedHeroTextField_SaleDiscount,
            EFeaturedHeroTextField::k_EFeaturedHeroTextField_Container,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EFeaturedHeroTextField>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EFeaturedHeroTextField", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EFeaturedHeroTextField {
}

impl ::protobuf::reflect::ProtobufValue for EFeaturedHeroTextField {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EFeaturedHeroDataType {
    k_EFeaturedHeroDataType_HeroID = 0,
    k_EFeaturedHeroDataType_ItemDef = 1,
    k_EFeaturedHeroDataType_HypeString = 2,
    k_EFeaturedHeroDataType_StartTimestamp = 3,
    k_EFeaturedHeroDataType_ExpireTimestamp = 4,
    k_EFeaturedHeroDataType_HeroWins = 5,
    k_EFeaturedHeroDataType_HeroLosses = 6,
    k_EFeaturedHeroDataType_SaleDiscount = 7,
    k_EFeaturedHeroDataType_ContainerItemDef = 8,
}

impl ::protobuf::ProtobufEnum for EFeaturedHeroDataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EFeaturedHeroDataType> {
        match value {
            0 => ::std::option::Option::Some(EFeaturedHeroDataType::k_EFeaturedHeroDataType_HeroID),
            1 => ::std::option::Option::Some(EFeaturedHeroDataType::k_EFeaturedHeroDataType_ItemDef),
            2 => ::std::option::Option::Some(EFeaturedHeroDataType::k_EFeaturedHeroDataType_HypeString),
            3 => ::std::option::Option::Some(EFeaturedHeroDataType::k_EFeaturedHeroDataType_StartTimestamp),
            4 => ::std::option::Option::Some(EFeaturedHeroDataType::k_EFeaturedHeroDataType_ExpireTimestamp),
            5 => ::std::option::Option::Some(EFeaturedHeroDataType::k_EFeaturedHeroDataType_HeroWins),
            6 => ::std::option::Option::Some(EFeaturedHeroDataType::k_EFeaturedHeroDataType_HeroLosses),
            7 => ::std::option::Option::Some(EFeaturedHeroDataType::k_EFeaturedHeroDataType_SaleDiscount),
            8 => ::std::option::Option::Some(EFeaturedHeroDataType::k_EFeaturedHeroDataType_ContainerItemDef),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EFeaturedHeroDataType] = &[
            EFeaturedHeroDataType::k_EFeaturedHeroDataType_HeroID,
            EFeaturedHeroDataType::k_EFeaturedHeroDataType_ItemDef,
            EFeaturedHeroDataType::k_EFeaturedHeroDataType_HypeString,
            EFeaturedHeroDataType::k_EFeaturedHeroDataType_StartTimestamp,
            EFeaturedHeroDataType::k_EFeaturedHeroDataType_ExpireTimestamp,
            EFeaturedHeroDataType::k_EFeaturedHeroDataType_HeroWins,
            EFeaturedHeroDataType::k_EFeaturedHeroDataType_HeroLosses,
            EFeaturedHeroDataType::k_EFeaturedHeroDataType_SaleDiscount,
            EFeaturedHeroDataType::k_EFeaturedHeroDataType_ContainerItemDef,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EFeaturedHeroDataType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EFeaturedHeroDataType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EFeaturedHeroDataType {
}

impl ::protobuf::reflect::ProtobufValue for EFeaturedHeroDataType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EWeekendTourneyRichPresenceEvent {
    k_EWeekendTourneyRichPresenceEvent_None = 0,
    k_EWeekendTourneyRichPresenceEvent_StartedMatch = 1,
    k_EWeekendTourneyRichPresenceEvent_WonMatch = 2,
    k_EWeekendTourneyRichPresenceEvent_Eliminated = 3,
}

impl ::protobuf::ProtobufEnum for EWeekendTourneyRichPresenceEvent {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EWeekendTourneyRichPresenceEvent> {
        match value {
            0 => ::std::option::Option::Some(EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_None),
            1 => ::std::option::Option::Some(EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_StartedMatch),
            2 => ::std::option::Option::Some(EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_WonMatch),
            3 => ::std::option::Option::Some(EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_Eliminated),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EWeekendTourneyRichPresenceEvent] = &[
            EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_None,
            EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_StartedMatch,
            EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_WonMatch,
            EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_Eliminated,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EWeekendTourneyRichPresenceEvent>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EWeekendTourneyRichPresenceEvent", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EWeekendTourneyRichPresenceEvent {
}

impl ::protobuf::reflect::ProtobufValue for EWeekendTourneyRichPresenceEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EDOTAEventInviteType {
    k_EDOTAEventInviteType_Direct = 0,
    k_EDOTAEventInviteType_OpenQualifier = 1,
    k_EDOTAEventInviteType_ChampionsCup = 2,
}

impl ::protobuf::ProtobufEnum for EDOTAEventInviteType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDOTAEventInviteType> {
        match value {
            0 => ::std::option::Option::Some(EDOTAEventInviteType::k_EDOTAEventInviteType_Direct),
            1 => ::std::option::Option::Some(EDOTAEventInviteType::k_EDOTAEventInviteType_OpenQualifier),
            2 => ::std::option::Option::Some(EDOTAEventInviteType::k_EDOTAEventInviteType_ChampionsCup),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EDOTAEventInviteType] = &[
            EDOTAEventInviteType::k_EDOTAEventInviteType_Direct,
            EDOTAEventInviteType::k_EDOTAEventInviteType_OpenQualifier,
            EDOTAEventInviteType::k_EDOTAEventInviteType_ChampionsCup,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EDOTAEventInviteType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EDOTAEventInviteType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EDOTAEventInviteType {
}

impl ::protobuf::reflect::ProtobufValue for EDOTAEventInviteType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EDOTATriviaQuestionCategory {
    k_EDOTATriviaQuestionCategory_AbilityIcon = 0,
    k_EDOTATriviaQuestionCategory_AbilityCooldown = 1,
    k_EDOTATriviaQuestionCategory_HeroAttributes = 2,
    k_EDOTATriviaQuestionCategory_HeroMovementSpeed = 3,
    k_EDOTATriviaQuestionCategory_TalentTree = 4,
    k_EDOTATriviaQuestionCategory_HeroStats = 5,
    k_EDOTATriviaQuestionCategory_ItemPrice = 6,
    k_EDOTATriviaQuestionCategory_AbilitySound = 7,
    k_EDOTATriviaQuestionCategory_InvokerSpells = 8,
    k_EDOTATriviaQuestionCategory_AbilityManaCost = 9,
    k_EDOTATriviaQuestionCategory_HeroAttackSound = 10,
    k_EDOTATriviaQuestionCategory_AbilityName = 11,
    k_EDOTATriviaQuestionCategory_ItemComponents = 12,
    k_EDOTATriviaQuestionCategory_ItemLore = 13,
}

impl ::protobuf::ProtobufEnum for EDOTATriviaQuestionCategory {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDOTATriviaQuestionCategory> {
        match value {
            0 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityIcon),
            1 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityCooldown),
            2 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttributes),
            3 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroMovementSpeed),
            4 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_TalentTree),
            5 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroStats),
            6 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemPrice),
            7 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilitySound),
            8 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_InvokerSpells),
            9 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityManaCost),
            10 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttackSound),
            11 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityName),
            12 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemComponents),
            13 => ::std::option::Option::Some(EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemLore),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EDOTATriviaQuestionCategory] = &[
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityIcon,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityCooldown,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttributes,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroMovementSpeed,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_TalentTree,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroStats,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemPrice,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilitySound,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_InvokerSpells,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityManaCost,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_HeroAttackSound,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_AbilityName,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemComponents,
            EDOTATriviaQuestionCategory::k_EDOTATriviaQuestionCategory_ItemLore,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EDOTATriviaQuestionCategory>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EDOTATriviaQuestionCategory", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EDOTATriviaQuestionCategory {
}

impl ::protobuf::reflect::ProtobufValue for EDOTATriviaQuestionCategory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EDOTATriviaAnswerResult {
    k_EDOTATriviaAnswerResult_Success = 0,
    k_EDOTATriviaAnswerResult_InvalidQuestion = 1,
    k_EDOTATriviaAnswerResult_InvalidAnswer = 2,
    k_EDOTATriviaAnswerResult_QuestionLocked = 3,
    k_EDOTATriviaAnswerResult_AlreadyAnswered = 4,
    k_EDOTATriviaAnswerResult_TriviaDisabled = 5,
}

impl ::protobuf::ProtobufEnum for EDOTATriviaAnswerResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDOTATriviaAnswerResult> {
        match value {
            0 => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_Success),
            1 => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_InvalidQuestion),
            2 => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_InvalidAnswer),
            3 => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_QuestionLocked),
            4 => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_AlreadyAnswered),
            5 => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_TriviaDisabled),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EDOTATriviaAnswerResult] = &[
            EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_Success,
            EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_InvalidQuestion,
            EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_InvalidAnswer,
            EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_QuestionLocked,
            EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_AlreadyAnswered,
            EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_TriviaDisabled,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EDOTATriviaAnswerResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EDOTATriviaAnswerResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EDOTATriviaAnswerResult {
}

impl ::protobuf::reflect::ProtobufValue for EDOTATriviaAnswerResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cdota_gcmessages_client.proto\x1a\x13steammessages.proto\x1a\x17dot\
    a_shared_enums.proto\x1a\x1cdota_gcmessages_common.proto\x1a\x16gcsdk_gc\
    messages.proto\x1a-dota_gcmessages_common_match_management.proto\"0\n\
    \x13CMsgClientSuspended\x12\x19\n\x08time_end\x18\x01\x20\x01(\rR\x07tim\
    eEnd\"\x20\n\x1eCMsgRequestInternationalTicket\"\x1a\n\x18CMsgBalancedSh\
    uffleLobby\"G\n\x20CMsgInitialQuestionnaireResponse\x12#\n\rinitial_skil\
    l\x18\x01\x20\x01(\rR\x0cinitialSkill\"9\n\x1aCMsgDOTAPlayerMatchHistory\
    \x12\x1b\n\tmatch_ids\x18\x01\x20\x03(\x04R\x08matchIds\"\xa2\x01\n\x1aC\
    MsgDOTAMatchHistoryFilter\x12\x1b\n\tmatch_ids\x18\x01\x20\x03(\x04R\x08\
    matchIds\x12?\n\x1dnewest_match_id_at_last_query\x18\x02\x20\x01(\x04R\
    \x18newestMatchIdAtLastQuery\x12&\n\x0ftime_last_query\x18\x03\x20\x01(\
    \rR\rtimeLastQuery\"\xc5\x04\n\x16CMsgDOTARequestMatches\x12\x17\n\x07he\
    ro_id\x18\x02\x20\x01(\rR\x06heroId\x12\x1b\n\tgame_mode\x18\x03\x20\x01\
    (\rR\x08gameMode\x12\x19\n\x08date_min\x18\x06\x20\x01(\x07R\x07dateMin\
    \x12\x19\n\x08date_max\x18\x07\x20\x01(\x07R\x07dateMax\x12+\n\x11matche\
    s_requested\x18\n\x20\x01(\rR\x10matchesRequested\x12)\n\x11start_at_mat\
    ch_id\x18\x0b\x20\x01(\x04R\x0estartAtMatchId\x12\x1f\n\x0bmin_players\
    \x18\x0c\x20\x01(\x07R\nminPlayers\x12\x1d\n\nrequest_id\x18\r\x20\x01(\
    \rR\trequestId\x122\n\x15tournament_games_only\x18\x0e\x20\x01(\x08R\x13\
    tournamentGamesOnly\x12\x1d\n\naccount_id\x18\x0f\x20\x01(\rR\taccountId\
    \x12\x1b\n\tleague_id\x18\x10\x20\x01(\rR\x08leagueId\x12=\n\x05skill\
    \x18\x11\x20\x01(\x0e2\".CMsgDOTARequestMatches.SkillLevel:\x03AnyR\x05s\
    kill\x12\x17\n\x07team_id\x18\x12\x20\x01(\rR\x06teamId\x12$\n\x0ecustom\
    _game_id\x18\x14\x20\x01(\x04R\x0ccustomGameId\"9\n\nSkillLevel\x12\x07\
    \n\x03Any\x10\0\x12\n\n\x06Normal\x10\x01\x12\x08\n\x04High\x10\x02\x12\
    \x0c\n\x08VeryHigh\x10\x03\"\xed\x02\n\x1eCMsgDOTARequestMatchesResponse\
    \x12(\n\x07matches\x18\x01\x20\x03(\x0b2\x0e.CMsgDOTAMatchR\x07matches\
    \x12>\n\x06series\x18\x02\x20\x03(\x0b2&.CMsgDOTARequestMatchesResponse.\
    SeriesR\x06series\x12\x1d\n\nrequest_id\x18\x03\x20\x01(\rR\trequestId\
    \x12#\n\rtotal_results\x18\x04\x20\x01(\rR\x0ctotalResults\x12+\n\x11res\
    ults_remaining\x18\x05\x20\x01(\rR\x10resultsRemaining\x1ap\n\x06Series\
    \x12(\n\x07matches\x18\x01\x20\x03(\x0b2\x0e.CMsgDOTAMatchR\x07matches\
    \x12\x1b\n\tseries_id\x18\x02\x20\x01(\rR\x08seriesId\x12\x1f\n\x0bserie\
    s_type\x18\x03\x20\x01(\rR\nseriesType\"\xbe\x0f\n\rCMsgDOTAPopup\x12,\n\
    \x02id\x18\x01\x20\x01(\x0e2\x16.CMsgDOTAPopup.PopupID:\x04NONER\x02id\
    \x12\x1f\n\x0bcustom_text\x18\x02\x20\x01(\tR\ncustomText\x12\x19\n\x08i\
    nt_data\x18\x03\x20\x01(\x11R\x07intData\x12\x1d\n\npopup_data\x18\x04\
    \x20\x01(\x0cR\tpopupData\x12(\n\x10loc_token_header\x18\x05\x20\x01(\tR\
    \x0elocTokenHeader\x12\"\n\rloc_token_msg\x18\x06\x20\x01(\tR\x0blocToke\
    nMsg\x12\x1b\n\tvar_names\x18\x07\x20\x03(\tR\x08varNames\x12\x1d\n\nvar\
    _values\x18\x08\x20\x03(\tR\tvarValues\x12\x1d\n\ndebug_text\x18\t\x20\
    \x01(\tR\tdebugText\"\xfa\x0c\n\x07PopupID\x12\x11\n\x04NONE\x10\xff\xff\
    \xff\xff\xff\xff\xff\xff\xff\x01\x12\x15\n\x11KICKED_FROM_LOBBY\x10\0\
    \x12\x15\n\x11KICKED_FROM_PARTY\x10\x01\x12\x14\n\x10KICKED_FROM_TEAM\
    \x10\x02\x12\x16\n\x12TEAM_WAS_DISBANDED\x10\x03\x12\x20\n\x1cTEAM_MATCH\
    MAKE_ALREADY_MATCH\x10\x04\x12\"\n\x1eTEAM_MATCHMAKE_ALREADY_FINDING\x10\
    \x05\x12\x17\n\x13TEAM_MATCHMAKE_FULL\x10\x06\x12\x1b\n\x17TEAM_MATCHMAK\
    E_FAIL_ADD\x10\x07\x12#\n\x1fTEAM_MATCHMAKE_FAIL_ADD_CURRENT\x10\x08\x12\
    %\n!TEAM_MATCHMAKE_FAILED_TEAM_MEMBER\x10\t\x12\x1f\n\x1bTEAM_MATCHMAKE_\
    ALREADY_GAME\x10\n\x12!\n\x1dTEAM_MATCHMAKE_FAIL_GET_PARTY\x10\x0b\x12\
    \x18\n\x14MATCHMAKING_DISABLED\x10\x0c\x12\x11\n\rINVITE_DENIED\x10\r\
    \x12\x0e\n\nPARTY_FULL\x10\x0e\x12\x0e\n\nMADE_ADMIN\x10\x0f\x12\x14\n\
    \x10NEED_TO_PURCHASE\x10\x10\x12\x12\n\x0eSIGNON_MESSAGE\x10\x11\x12\x10\
    \n\x0cGUILD_KICKED\x10\x12\x12\x1e\n\x1aMATCHMAKING_REGION_OFFLINE\x10\
    \x13\x12\x1d\n\x19TOURNAMENT_GAME_NOT_FOUND\x10\x15\x12\x20\n\x1cTOURNAM\
    ENT_GAME_HAS_LOBBY_ID\x10\x16\x12\x20\n\x1cTOURNAMENT_GAME_HAS_MATCH_ID\
    \x10\x17\x12'\n#TOURNAMENT_GAME_HAS_NO_RADIANT_TEAM\x10\x18\x12$\n\x20TO\
    URNAMENT_GAME_HAS_NO_DIRE_TEAM\x10\x19\x12%\n!TOURNAMENT_GAME_SQL_UPDATE\
    _FAILED\x10\x1a\x12\x14\n\x10NOT_LEAGUE_ADMIN\x10\x1b\x12\x13\n\x0fIN_AN\
    OTHER_GAME\x10\x1d\x12\x20\n\x1cPARTY_MEMBER_IN_ANOTHER_GAME\x10\x1e\x12\
    \x20\n\x1cPARTY_MEMBER_IN_LOW_PRIORITY\x10\x1f\x12\x16\n\x12CLIENT_OUT_O\
    F_DATE\x10\x20\x12\x15\n\x11SAVE_GAME_CORRUPT\x10&\x12\x17\n\x13INSUFFIC\
    IENT_INGOTS\x10'\x129\n5COMPETITIVE_MM_NOT_ENOUGH_SKILL_DATA_PLAY_MORE_C\
    ASUAL\x10*\x12\x1d\n\x19PARTY_LEADER_JOINED_LOBBY\x10,\x12\x1d\n\x19WEEK\
    END_TOURNEY_UNMATCHED\x100\x12\x15\n\x11POST_MATCH_SURVEY\x101\x12\x12\n\
    \x0eTROPHY_AWARDED\x102\x12\x13\n\x0fTROPHY_LEVEL_UP\x103\x12\x1f\n\x1bA\
    LL_HERO_CHALLENGE_PROGRESS\x104\x12\x16\n\x12NEED_INITIAL_SKILL\x105\x12\
    \x1f\n\x1bNEED_INITIAL_SKILL_IN_PARTY\x106\x12\x1a\n\x16TARGET_ENGINE_MI\
    SMATCH\x107\x12\x14\n\x10VAC_NOT_VERIFIED\x108\x12$\n\x20KICKED_FROM_QUE\
    UE_EVENT_STARTING\x109\x12\"\n\x1eKICKED_FROM_QUEUE_EVENT_ENDING\x10:\
    \x12\x0e\n\nLOBBY_FULL\x10>\x12\x17\n\x13EVENT_POINTS_EARNED\x10?\x12!\n\
    \x1dCUSTOM_GAME_INCORRECT_VERSION\x10@\x12\x15\n\x11LIMITED_USER_CHAT\
    \x10B\x12\x1f\n\x1bEVENT_PREMIUM_POINTS_EARNED\x10C\x12\x15\n\x11LOBBY_M\
    VP_AWARDED\x10D\x12\x18\n\x14LOW_BADGE_LEVEL_CHAT\x10G\x12\x11\n\rLOW_WI\
    NS_CHAT\x10H\x12\x18\n\x14UNVERIFIED_USER_CHAT\x10I\x12%\n!PARTY_STARTED\
    _FINDING_EVENT_MATCH\x10J\x12\x10\n\x0cGENERIC_INFO\x10E\x12\x11\n\rGENE\
    RIC_ERROR\x10F\"!\n\x1fCMsgDOTAReportsRemainingRequest\"\xa6\x02\n\x20CM\
    sgDOTAReportsRemainingResponse\x12C\n\x1enum_positive_reports_remaining\
    \x18\x01\x20\x01(\rR\x1bnumPositiveReportsRemaining\x12C\n\x1enum_negati\
    ve_reports_remaining\x18\x02\x20\x01(\rR\x1bnumNegativeReportsRemaining\
    \x12;\n\x1anum_positive_reports_total\x18\x03\x20\x01(\rR\x17numPositive\
    ReportsTotal\x12;\n\x1anum_negative_reports_total\x18\x04\x20\x01(\rR\
    \x17numNegativeReportsTotal\"\xa0\x01\n\x1aCMsgDOTASubmitPlayerReport\
    \x12*\n\x11target_account_id\x18\x01\x20\x01(\rR\x0ftargetAccountId\x12!\
    \n\x0creport_flags\x18\x02\x20\x01(\rR\x0breportFlags\x12\x19\n\x08lobby\
    _id\x18\x04\x20\x01(\x04R\x07lobbyId\x12\x18\n\x07comment\x18\x05\x20\
    \x01(\tR\x07comment\"\xb0\x01\n\"CMsgDOTASubmitPlayerReportResponse\x12*\
    \n\x11target_account_id\x18\x01\x20\x01(\rR\x0ftargetAccountId\x12!\n\
    \x0creport_flags\x18\x02\x20\x01(\rR\x0breportFlags\x12\x16\n\x06result\
    \x18\x03\x20\x01(\rR\x06result\x12#\n\rdebug_message\x18\x04\x20\x01(\tR\
    \x0cdebugMessage\"I\n\x1bCMsgDOTAReportCountsRequest\x12*\n\x11target_ac\
    count_id\x18\x01\x20\x01(\rR\x0ftargetAccountId\"\xec\x01\n\x1cCMsgDOTAR\
    eportCountsResponse\x12*\n\x11target_account_id\x18\x01\x20\x01(\rR\x0ft\
    argetAccountId\x12)\n\x10leadership_count\x18\x02\x20\x01(\rR\x0fleaders\
    hipCount\x12%\n\x0eteaching_count\x18\x03\x20\x01(\rR\rteachingCount\x12\
    %\n\x0efriendly_count\x18\x04\x20\x01(\rR\rfriendlyCount\x12'\n\x0fforgi\
    ving_count\x18\x05\x20\x01(\rR\x0eforgivingCount\"H\n\x1aCMsgDOTASubmitL\
    obbyMVPVote\x12*\n\x11target_account_id\x18\x01\x20\x01(\rR\x0ftargetAcc\
    ountId\"j\n\"CMsgDOTASubmitLobbyMVPVoteResponse\x12*\n\x11target_account\
    _id\x18\x01\x20\x01(\rR\x0ftargetAccountId\x12\x18\n\x07eresult\x18\x02\
    \x20\x01(\rR\x07eresult\"\x9a\x01\n\x1fCMsgDOTALobbyMVPNotifyRecipient\
    \x12(\n\x10voter_account_id\x18\x01\x20\x01(\rR\x0evoterAccountId\x120\n\
    \x14recipient_account_id\x18\x02\x20\x01(\rR\x12recipientAccountId\x12\
    \x1b\n\tnum_votes\x18\x03\x20\x01(\rR\x08numVotes\"?\n\x17CMsgDOTALobbyM\
    VPAwarded\x12$\n\x0emvp_account_id\x18\x01\x20\x01(\rR\x0cmvpAccountId\"\
    b\n\"CMsgDOTAKickedFromMatchmakingQueue\x12<\n\nmatch_type\x18\x01\x20\
    \x01(\x0e2\n.MatchType:\x11MATCH_TYPE_CASUALR\tmatchType\"?\n\x18CMsgDOT\
    ARequestSaveGames\x12#\n\rserver_region\x18\x01\x20\x01(\rR\x0cserverReg\
    ion\"l\n\x20CMsgDOTARequestSaveGamesResponse\x12\x19\n\x08steam_id\x18\
    \x01\x20\x01(\x06R\x07steamId\x12-\n\nsave_games\x18\x02\x20\x03(\x0b2\
    \x0e.CDOTASaveGameR\tsaveGames\"6\n\x19CMsgGCMatchDetailsRequest\x12\x19\
    \n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\"\x95\x01\n\x1aCMsgGCMat\
    chDetailsResponse\x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06result\x12$\
    \n\x05match\x18\x02\x20\x01(\x0b2\x0e.CMsgDOTAMatchR\x05match\x129\n\x04\
    vote\x18\x03\x20\x01(\x0e2\x0e.DOTAMatchVote:\x15DOTAMatchVote_INVALIDR\
    \x04vote\"@\n!CMsgServerToGCMatchDetailsRequest\x12\x1b\n\tmatch_ids\x18\
    \x01\x20\x03(\x04R\x08matchIds\"N\n\"CMsgGCToServerMatchDetailsResponse\
    \x12(\n\x07matches\x18\x01\x20\x03(\x0b2\x0e.CMsgDOTAMatchR\x07matches\"\
    Z\n\x16CMsgDOTAProfileRequest\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\
    \taccountId\x12!\n\x0crequest_name\x18\x02\x20\x01(\x08R\x0brequestName\
    \"\xd8\x08\n\x17CMsgDOTAProfileResponse\x12\x16\n\x06result\x18\x01\x20\
    \x01(\rR\x06result\x12I\n\x13game_account_client\x18\x02\x20\x01(\x0b2\
    \x19.CSODOTAGameAccountClientR\x11gameAccountClient\x125\n\x0elatest_mat\
    ches\x18\x03\x20\x03(\x0b2\x0e.CMsgDOTAMatchR\rlatestMatches\x12;\n\x06h\
    eroes\x18\x04\x20\x03(\x0b2#.CMsgDOTAProfileResponse.PlayedHeroR\x06hero\
    es\x12\x1f\n\x0bplayer_name\x18\x05\x20\x01(\tR\nplayerName\x12\x1b\n\tt\
    eam_name\x18\x06\x20\x01(\tR\x08teamName\x12\x19\n\x08team_tag\x18\x07\
    \x20\x01(\tR\x07teamTag\x12\x1b\n\tteam_logo\x18\x08\x20\x01(\x04R\x08te\
    amLogo\x12J\n\rshowcase_hero\x18\t\x20\x01(\x0b2%.CMsgDOTAProfileRespons\
    e.ShowcaseHeroR\x0cshowcaseHero\x12H\n\rleague_passes\x18\n\x20\x03(\x0b\
    2#.CMsgDOTAProfileResponse.LeaguePassR\x0cleaguePasses\x12I\n\revent_tic\
    kets\x18\x0b\x20\x03(\x0b2$.CMsgDOTAProfileResponse.EventTicketR\x0ceven\
    tTickets\x12\x17\n\x07team_id\x18\x0c\x20\x01(\rR\x06teamId\x12!\n\x0cha\
    s_passport\x18\r\x20\x01(\x08R\x0bhasPassport\x12L\n\x0efeatured_items\
    \x18\x0e\x20\x03(\x0b2%.CMsgDOTAProfileResponse.FeaturedItemR\rfeaturedI\
    tems\x12'\n\x0fabandon_percent\x18\x0f\x20\x01(\rR\x0eabandonPercent\x1a\
    9\n\nPlayedHero\x12\x17\n\x07hero_id\x18\x01\x20\x01(\rR\x06heroId\x12\
    \x12\n\x04wins\x18\x02\x20\x01(\rR\x04wins\x1aH\n\x0cShowcaseHero\x12\
    \x17\n\x07hero_id\x18\x01\x20\x01(\rR\x06heroId\x12\x1f\n\x0bobject_data\
    \x18\x02\x20\x03(\x0cR\nobjectData\x1aD\n\nLeaguePass\x12\x1b\n\tleague_\
    id\x18\x01\x20\x01(\rR\x08leagueId\x12\x19\n\x08item_def\x18\x02\x20\x01\
    (\rR\x07itemDef\x1a(\n\x0bEventTicket\x12\x19\n\x08event_id\x18\x01\x20\
    \x01(\rR\x07eventId\x1ag\n\x0cFeaturedItem\x12\x17\n\x07item_id\x18\x01\
    \x20\x01(\x04R\x06itemId\x12\x1f\n\x0bobject_data\x18\x02\x20\x01(\x0cR\
    \nobjectData\x12\x1d\n\nslot_index\x18\x03\x20\x01(\rR\tslotIndex\"\xd2\
    \x02\n\x16CMsgDOTAProfileTickets\x12\x16\n\x06result\x18\x01\x20\x01(\rR\
    \x06result\x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\taccountId\x12G\n\r\
    league_passes\x18\x03\x20\x03(\x0b2\".CMsgDOTAProfileTickets.LeaguePassR\
    \x0cleaguePasses\x12H\n\revent_tickets\x18\x04\x20\x03(\x0b2#.CMsgDOTAPr\
    ofileTickets.EventTicketR\x0ceventTickets\x1aD\n\nLeaguePass\x12\x1b\n\t\
    league_id\x18\x01\x20\x01(\rR\x08leagueId\x12\x19\n\x08item_def\x18\x02\
    \x20\x01(\rR\x07itemDef\x1a(\n\x0bEventTicket\x12\x19\n\x08event_id\x18\
    \x01\x20\x01(\rR\x07eventId\"@\n\x1fCMsgClientToGCGetProfileTickets\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\":\n\x19CMsgGCSteamPro\
    fileRequest\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\";\n!CM\
    sgGCSteamProfileRequestResponse\x12\x16\n\x06result\x18\x01\x20\x01(\rR\
    \x06result\"%\n#CMsgDOTAClearNotifySuccessfulReport\"\x99\x0b\n\x0fCMsgD\
    OTAWelcome\x12&\n\x0fstore_item_hash\x18\x05\x20\x01(\rR\rstoreItemHash\
    \x128\n\x17timeplayedconsecutively\x18\x06\x20\x01(\rR\x17timeplayedcons\
    ecutively\x12@\n\x1dallow_3rd_party_match_history\x18\x07\x20\x01(\x08R\
    \x19allow3rdPartyMatchHistory\x12S\n\x14partner_account_type\x18\x08\x20\
    \x01(\x0e2\x13.PartnerAccountType:\x0cPARTNER_NONER\x12partnerAccountTyp\
    e\x126\n\x18banned_word_list_word_id\x18\t\x20\x01(\rR\x14bannedWordList\
    WordId\x122\n\x15partner_account_state\x18\x0b\x20\x01(\rR\x13partnerAcc\
    ountState\x12(\n\x10last_time_played\x18\x0c\x20\x01(\rR\x0elastTimePlay\
    ed\x12&\n\x0flast_ip_address\x18\r\x20\x01(\rR\rlastIpAddress\x12@\n\x1b\
    shutdownlawterminateminutes\x18\x0f\x20\x01(\rR\x1bshutdownlawterminatem\
    inutes\x127\n\x18banned_word_list_version\x18\x10\x20\x01(\rR\x15bannedW\
    ordListVersion\x12'\n\x0fprofile_private\x18\x11\x20\x01(\x08R\x0eprofil\
    ePrivate\x12\x1a\n\x08currency\x18\x12\x20\x01(\rR\x08currency\x12\x17\n\
    \x07bang_no\x18\x13\x20\x01(\rR\x06bangNo\x12?\n\x1cshould_request_playe\
    r_origin\x18\x14\x20\x01(\x08R\x19shouldRequestPlayerOrigin\x12-\n\x12co\
    mpendium_unlocks\x18\x15\x20\x01(\x04R\x11compendiumUnlocks\x125\n\x17gc\
    _socache_file_version\x18\x16\x20\x01(\rR\x14gcSocacheFileVersion\x12V\n\
    \x14localization_digests\x18\x17\x20\x03(\x0b2#.CMsgDOTAWelcome.Localiza\
    tionDigestR\x13localizationDigests\x12@\n\x1dis_perfect_world_test_accou\
    nt\x18\x18\x20\x01(\x08R\x19isPerfectWorldTestAccount\x12A\n\x0eextra_me\
    ssages\x18\x1a\x20\x03(\x0b2\x1a.CMsgDOTAWelcome.CExtraMsgR\rextraMessag\
    es\x123\n\x16minimum_recent_item_id\x18\x1b\x20\x01(\x04R\x13minimumRece\
    ntItemId\x129\n\x0cactive_event\x18\x1c\x20\x01(\x0e2\x07.EEvent:\rEVENT\
    _ID_NONER\x0bactiveEvent\x1a\xc8\x01\n\x12LocalizationDigest\x12\x18\n\
    \x07context\x18\x01\x20\x01(\tR\x07context\x12L\n\x1aenglish_language_fi\
    le_sha1\x18\x02\x20\x01(\x0b2\x0f.CMsgSHA1DigestR\x17englishLanguageFile\
    Sha1\x12J\n\x19client_language_file_sha1\x18\x03\x20\x01(\x0b2\x0f.CMsgS\
    HA1DigestR\x16clientLanguageFileSha1\x1a7\n\tCExtraMsg\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\rR\x02id\x12\x1a\n\x08contents\x18\x02\x20\x01(\x0cR\
    \x08contents\"^\n\x18CSODOTAGameHeroFavorites\x12#\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountIdB\x04\x80\xa6\x1d\x01\x12\x1d\n\x07hero_id\x18\
    \x02\x20\x01(\rR\x06heroIdB\x04\x80\xa6\x1d\x01\"3\n\x18CMsgDOTAHeroFavo\
    ritesAdd\x12\x17\n\x07hero_id\x18\x01\x20\x01(\rR\x06heroId\"6\n\x1bCMsg\
    DOTAHeroFavoritesRemove\x12\x17\n\x07hero_id\x18\x01\x20\x01(\rR\x06hero\
    Id\"?\n\x13CMsgSetShowcaseHero\x12(\n\x10showcase_hero_id\x18\x01\x20\
    \x01(\rR\x0eshowcaseHeroId\"@\n\x14CMsgSetFeaturedItems\x12(\n\x10featur\
    ed_item_id\x18\x01\x20\x03(\x04R\x0efeaturedItemId\"\x81\x01\n\x15CMsgDO\
    TAFeaturedItems\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\
    (\n\x10featured_item_id\x18\x02\x20\x03(\x04R\x0efeaturedItemId\x12\x1f\
    \n\x0bobject_data\x18\x03\x20\x03(\x0cR\nobjectData\"\x17\n\x15CMsgReque\
    stLeagueInfo\"\xc8\x02\n\x12CDynamicLeagueData\x12\x1b\n\tleague_id\x18\
    \x01\x20\x01(\rR\x08leagueId\x12&\n\x0flast_match_time\x18\x02\x20\x01(\
    \x07R\rlastMatchTime\x12$\n\x0eprize_pool_usd\x18\x03\x20\x01(\rR\x0cpri\
    zePoolUsd\x12(\n\x10has_live_matches\x18\x04\x20\x01(\x08R\x0ehasLiveMat\
    ches\x120\n\x14is_compendium_public\x18\x05\x20\x01(\x08R\x12isCompendiu\
    mPublic\x12-\n\x12compendium_version\x18\x06\x20\x01(\rR\x11compendiumVe\
    rsion\x12<\n\x1acompendium_content_version\x18\x07\x20\x01(\rR\x18compen\
    diumContentVersion\"\xe9\x05\n\x11CStaticLeagueData\x12\x1b\n\tleague_id\
    \x18\x01\x20\x01(\rR\x08leagueId\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\x12\
    \x1f\n\x0bbanner_name\x18\x04\x20\x01(\tR\nbannerName\x12!\n\x0citemdef_\
    name\x18\x05\x20\x01(\tR\x0bitemdefName\x12\x10\n\x03url\x18\x06\x20\x01\
    (\tR\x03url\x12$\n\x0eitem_def_index\x18\x07\x20\x01(\rR\x0citemDefIndex\
    \x124\n\x17hud_skin_item_def_index\x18\x08\x20\x01(\rR\x13hudSkinItemDef\
    Index\x12.\n\x13loading_screen_name\x18\t\x20\x01(\tR\x11loadingScreenNa\
    me\x12&\n\x0fbase_prize_pool\x18\n\x20\x01(\rR\rbasePrizePool\x12\x19\n\
    \x08is_major\x18\x0b\x20\x01(\x08R\x07isMajor\x12\x12\n\x04tier\x18\r\
    \x20\x01(\rR\x04tier\x12%\n\x0eamateur_region\x18\x0e\x20\x01(\rR\ramate\
    urRegion\x12\x1c\n\torganizer\x18\x0f\x20\x01(\tR\torganizer\x12\x1d\n\n\
    start_date\x18\x10\x20\x01(\rR\tstartDate\x12\x19\n\x08end_date\x18\x11\
    \x20\x01(\rR\x07endDate\x12\x1a\n\x08location\x18\x12\x20\x01(\tR\x08loc\
    ation\x12'\n\x0finventory_image\x18\x13\x20\x01(\tR\x0einventoryImage\
    \x12!\n\x0csquare_image\x18\x14\x20\x01(\tR\x0bsquareImage\x12,\n\x12bat\
    tle_pass_rollup\x18\x15\x20\x01(\x08R\x10battlePassRollup\x123\n\x16base\
    _prize_pool_string\x18\x16\x20\x01(\tR\x13basePrizePoolString\"\x95\x01\
    \n\x0bCLeagueData\x126\n\x0cdynamic_data\x18\x01\x20\x01(\x0b2\x13.CDyna\
    micLeagueDataR\x0bdynamicData\x123\n\x0bstatic_data\x18\x02\x20\x01(\x0b\
    2\x12.CStaticLeagueDataR\nstaticData\x12\x19\n\x08is_owned\x18\x03\x20\
    \x01(\x08R\x07isOwned\"L\n\x1cCMsgResponseLeagueStaticData\x12,\n\x07lea\
    gues\x18\x01\x20\x03(\x0b2\x12.CStaticLeagueDataR\x07leagues\"G\n\x16CMs\
    gResponseLeagueInfo\x12-\n\x07leagues\x18\x01\x20\x03(\x0b2\x13.CDynamic\
    LeagueDataR\x07leagues\"\xa6\x01\n\x12CMsgDOTAMatchVotes\x12\x19\n\x08ma\
    tch_id\x18\x01\x20\x01(\x04R\x07matchId\x124\n\x05votes\x18\x02\x20\x03(\
    \x0b2\x1e.CMsgDOTAMatchVotes.PlayerVoteR\x05votes\x1a?\n\nPlayerVote\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x12\n\x04vote\x18\
    \x02\x20\x01(\rR\x04vote\"i\n\x11CMsgCastMatchVote\x12\x19\n\x08match_id\
    \x18\x01\x20\x01(\x04R\x07matchId\x129\n\x04vote\x18\x02\x20\x01(\x0e2\
    \x0e.DOTAMatchVote:\x15DOTAMatchVote_INVALIDR\x04vote\"T\n\x15CMsgRetrie\
    veMatchVote\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\
    \x20\n\x0bincremental\x18\x02\x20\x01(\rR\x0bincremental\"\xbd\x01\n\x15\
    CMsgMatchVoteResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\r:\x012R\x07\
    eresult\x129\n\x04vote\x18\x02\x20\x01(\x0e2\x0e.DOTAMatchVote:\x15DOTAM\
    atchVote_INVALIDR\x04vote\x12%\n\x0epositive_votes\x18\x03\x20\x01(\rR\r\
    positiveVotes\x12%\n\x0enegative_votes\x18\x04\x20\x01(\rR\rnegativeVote\
    s\"\xe8\x03\n\x12CMsgDOTAHallOfFame\x12\x12\n\x04week\x18\x01\x20\x01(\r\
    R\x04week\x12M\n\x10featured_players\x18\x02\x20\x03(\x0b2\".CMsgDOTAHal\
    lOfFame.FeaturedPlayerR\x0ffeaturedPlayers\x12K\n\x0ffeatured_farmer\x18\
    \x03\x20\x01(\x0b2\".CMsgDOTAHallOfFame.FeaturedFarmerR\x0efeaturedFarme\
    r\x1a\x99\x01\n\x0eFeaturedPlayer\x12\x1d\n\naccount_id\x18\x01\x20\x01(\
    \rR\taccountId\x12\x17\n\x07hero_id\x18\x02\x20\x01(\rR\x06heroId\x122\n\
    \x15average_scaled_metric\x18\x03\x20\x01(\x02R\x13averageScaledMetric\
    \x12\x1b\n\tnum_games\x18\x04\x20\x01(\rR\x08numGames\x1a\x85\x01\n\x0eF\
    eaturedFarmer\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\
    \x17\n\x07hero_id\x18\x02\x20\x01(\rR\x06heroId\x12\x20\n\x0cgold_per_mi\
    n\x18\x03\x20\x01(\rR\ngoldPerMin\x12\x19\n\x08match_id\x18\x04\x20\x01(\
    \x04R\x07matchId\"/\n\x19CMsgDOTAHallOfFameRequest\x12\x12\n\x04week\x18\
    \x01\x20\x01(\rR\x04week\"p\n\x1aCMsgDOTAHallOfFameResponse\x125\n\x0cha\
    ll_of_fame\x18\x01\x20\x01(\x0b2\x13.CMsgDOTAHallOfFameR\nhallOfFame\x12\
    \x1b\n\x07eresult\x18\x02\x20\x01(\r:\x012R\x07eresult\"=\n!CMsgDOTAHall\
    oweenHighScoreRequest\x12\x18\n\x05round\x18\x01\x20\x01(\x05:\x02-1R\
    \x05round\"\x90\x01\n\"CMsgDOTAHalloweenHighScoreResponse\x12\x14\n\x05s\
    core\x18\x01\x20\x01(\rR\x05score\x12$\n\x05match\x18\x02\x20\x01(\x0b2\
    \x0e.CMsgDOTAMatchR\x05match\x12\x18\n\x07eresult\x18\x03\x20\x01(\rR\
    \x07eresult\x12\x14\n\x05round\x18\x04\x20\x01(\x05R\x05round\"C\n\x1eCM\
    sgDOTAStorePromoPagesRequest\x12!\n\x0cversion_seen\x18\x01\x20\x01(\rR\
    \x0bversionSeen\"\xb3\x01\n\x1fCMsgDOTAStorePromoPagesResponse\x12@\n\
    \x05pages\x18\x01\x20\x03(\x0b2*.CMsgDOTAStorePromoPagesResponse.PromoPa\
    geR\x05pages\x1aN\n\tPromoPage\x12\x19\n\x08promo_id\x18\x01\x20\x01(\rR\
    \x07promoId\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12\x10\n\
    \x03url\x18\x03\x20\x01(\tR\x03url\"b\n\x1fCMsgLeagueScheduleBlockTeamIn\
    fo\x12\x17\n\x07team_id\x18\x01\x20\x01(\rR\x06teamId\x12\x12\n\x04name\
    \x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04logo\x18\x04\x20\x01(\x04R\x04\
    logo\"\xbd\x01\n\x17CMsgLeagueScheduleBlock\x12\x19\n\x08block_id\x18\
    \x01\x20\x01(\rR\x07blockId\x12\x1d\n\nstart_time\x18\x02\x20\x01(\rR\ts\
    tartTime\x12\x16\n\x06finals\x18\x04\x20\x01(\x08R\x06finals\x12\x18\n\
    \x07comment\x18\x05\x20\x01(\tR\x07comment\x126\n\x05teams\x18\x06\x20\
    \x03(\x0b2\x20.CMsgLeagueScheduleBlockTeamInfoR\x05teams\"c\n\x0eCMsgDOT\
    ALeague\x12\x1b\n\tleague_id\x18\x01\x20\x01(\rR\x08leagueId\x124\n\x08s\
    chedule\x18\x02\x20\x03(\x0b2\x18.CMsgLeagueScheduleBlockR\x08schedule\"\
    <\n\x1dCMsgDOTALeagueScheduleRequest\x12\x1b\n\tleague_id\x18\x01\x20\
    \x01(\rR\x08leagueId\"f\n\x1eCMsgDOTALeagueScheduleResponse\x12'\n\x06le\
    ague\x18\x01\x20\x01(\x0b2\x0f.CMsgDOTALeagueR\x06league\x12\x1b\n\x07er\
    esult\x18\x02\x20\x01(\r:\x012R\x07eresult\"\x92\x01\n\x1aCMsgDOTALeague\
    ScheduleEdit\x12\x1b\n\tleague_id\x18\x01\x20\x01(\rR\x08leagueId\x124\n\
    \x08schedule\x18\x02\x20\x01(\x0b2\x18.CMsgLeagueScheduleBlockR\x08sched\
    ule\x12!\n\x0cdelete_block\x18\x03\x20\x01(\x08R\x0bdeleteBlock\"j\n\"CM\
    sgDOTALeagueScheduleEditResponse\x12'\n\x06league\x18\x01\x20\x01(\x0b2\
    \x0f.CMsgDOTALeagueR\x06league\x12\x1b\n\x07eresult\x18\x02\x20\x01(\r:\
    \x012R\x07eresult\"]\n\x1dCMsgDOTALeaguesInMonthRequest\x12\x14\n\x05mon\
    th\x18\x01\x20\x01(\rR\x05month\x12\x12\n\x04year\x18\x02\x20\x01(\rR\
    \x04year\x12\x12\n\x04tier\x18\x03\x20\x01(\rR\x04tier\"\x92\x01\n\x1eCM\
    sgDOTALeaguesInMonthResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\r:\
    \x012R\x07eresult\x12\x14\n\x05month\x18\x02\x20\x01(\rR\x05month\x12\
    \x12\n\x04year\x18\x03\x20\x01(\rR\x04year\x12)\n\x07leagues\x18\x04\x20\
    \x03(\x0b2\x0f.CMsgDOTALeagueR\x07leagues\"\xe2\x01\n\x1dCMsgMatchmaking\
    MatchGroupInfo\x12+\n\x11players_searching\x18\x01\x20\x01(\rR\x10player\
    sSearching\x12D\n\x1fauto_region_select_ping_penalty\x18\x02\x20\x01(\
    \x11R\x1bautoRegionSelectPingPenalty\x12N\n\x06status\x18\x03\x20\x01(\
    \x0e2\x18.EMatchGroupServerStatus:\x1ck_EMatchGroupServerStatus_OKR\x06s\
    tatus\"!\n\x1fCMsgDOTAMatchmakingStatsRequest\"\xef\x01\n\x20CMsgDOTAMat\
    chmakingStatsResponse\x12/\n\x13matchgroups_version\x18\x01\x20\x01(\rR\
    \x12matchgroupsVersion\x12W\n)legacy_searching_players_by_group_source2\
    \x18\x07\x20\x03(\rR$legacySearchingPlayersByGroupSource2\x12A\n\x0cmatc\
    h_groups\x18\x08\x20\x03(\x0b2\x1e.CMsgMatchmakingMatchGroupInfoR\x0bmat\
    chGroups\"Y\n\x1eCMsgDOTAUpdateMatchmakingStats\x127\n\x05stats\x18\x01\
    \x20\x01(\x0b2!.CMsgDOTAMatchmakingStatsResponseR\x05stats\"]\n\"CMsgDOT\
    AUpdateMatchManagementStats\x127\n\x05stats\x18\x01\x20\x01(\x0b2!.CMsgD\
    OTAMatchmakingStatsResponseR\x05stats\"a\n\x1dCMsgDOTASetMatchHistoryAcc\
    ess\x12@\n\x1dallow_3rd_party_match_history\x18\x01\x20\x01(\x08R\x19all\
    ow3rdPartyMatchHistory\"D\n%CMsgDOTASetMatchHistoryAccessResponse\x12\
    \x1b\n\x07eresult\x18\x01\x20\x01(\r:\x012R\x07eresult\"e\n\x20CMsgDOTAN\
    otifyAccountFlagsChange\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccoun\
    tid\x12#\n\raccount_flags\x18\x02\x20\x01(\rR\x0caccountFlags\"D\n\x19CM\
    sgDOTASetProfilePrivacy\x12'\n\x0fprofile_private\x18\x01\x20\x01(\x08R\
    \x0eprofilePrivate\"=\n!CMsgDOTASetProfilePrivacyResponse\x12\x18\n\x07e\
    result\x18\x01\x20\x01(\rR\x07eresult\"O\n\x15CMsgUpgradeLeagueItem\x12\
    \x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\x1b\n\tleague_id\
    \x18\x02\x20\x01(\rR\x08leagueId\"\x1f\n\x1dCMsgUpgradeLeagueItemRespons\
    e\"\x88\x01\n\x1bCMsgGCWatchDownloadedReplay\x12\x19\n\x08match_id\x18\
    \x01\x20\x01(\x04R\x07matchId\x12N\n\nwatch_type\x18\x02\x20\x01(\x0e2\
    \x15.DOTA_WatchReplayType:\x18DOTA_WATCH_REPLAY_NORMALR\twatchType\"X\n\
    \x17CMsgSetMapLocationState\x12\x1f\n\x0blocation_id\x18\x01\x20\x01(\
    \x05R\nlocationId\x12\x1c\n\tcompleted\x18\x02\x20\x01(\x08R\tcompleted\
    \">\n\x1fCMsgSetMapLocationStateResponse\x12\x1b\n\x07eresult\x18\x01\
    \x20\x01(\r:\x012R\x07eresult\"\x17\n\x15CMsgResetMapLocations\"<\n\x1dC\
    MsgResetMapLocationsResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\r:\
    \x012R\x07eresult\"B\n\x1dCMsgRefreshPartnerAccountLink\x12!\n\x0cpartne\
    r_type\x18\x01\x20\x01(\x05R\x0bpartnerType\"\x1f\n\x1dCMsgClientsRejoin\
    ChatChannels\"8\n\x1aCMsgDOTASendFriendRecruits\x12\x1a\n\x08recruits\
    \x18\x01\x20\x03(\rR\x08recruits\"@\n\x1dCMsgDOTAFriendRecruitsRequest\
    \x12\x1f\n\x0baccount_ids\x18\x01\x20\x03(\rR\naccountIds\"\xc9\x03\n\
    \x1eCMsgDOTAFriendRecruitsResponse\x12H\n\x06result\x18\x01\x20\x01(\x0e\
    2'.CMsgDOTAFriendRecruitsResponse.EResult:\x07SUCCESSR\x06result\x12O\n\
    \x08recruits\x18\x02\x20\x03(\x0b23.CMsgDOTAFriendRecruitsResponse.Frien\
    dRecruitStatusR\x08recruits\x12S\n\nrecruiters\x18\x03\x20\x03(\x0b23.CM\
    sgDOTAFriendRecruitsResponse.FriendRecruitStatusR\nrecruiters\x1a\x87\
    \x01\n\x13FriendRecruitStatus\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\
    \taccountId\x12\x16\n\x06status\x18\x02\x20\x01(\rR\x06status\x12#\n\rle\
    vels_earned\x18\x03\x20\x01(\rR\x0clevelsEarned\x12\x14\n\x05bonus\x18\
    \x04\x20\x01(\x08R\x05bonus\"-\n\x07EResult\x12\x0b\n\x07SUCCESS\x10\0\
    \x12\x15\n\x11ERROR_UNSPECIFIED\x10\x01\"e\n(CMsgDOTAFriendRecruitInvite\
    AcceptDecline\x12\x1a\n\x08accepted\x18\x01\x20\x01(\x08R\x08accepted\
    \x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\taccountId\"9\n\x1aCMsgReques\
    tLeaguePrizePool\x12\x1b\n\tleague_id\x18\x01\x20\x01(\rR\x08leagueId\"`\
    \n\"CMsgRequestLeaguePrizePoolResponse\x12\x1b\n\tleague_id\x18\x01\x20\
    \x01(\rR\x08leagueId\x12\x1d\n\nprize_pool\x18\x02\x20\x01(\rR\tprizePoo\
    l\"\x18\n\x16CMsgGCGetHeroStandings\"\xa2\x04\n\x1eCMsgGCGetHeroStanding\
    sResponse\x12B\n\tstandings\x18\x01\x20\x03(\x0b2$.CMsgGCGetHeroStanding\
    sResponse.HeroR\tstandings\x1a\xbb\x03\n\x04Hero\x12\x17\n\x07hero_id\
    \x18\x01\x20\x01(\rR\x06heroId\x12\x12\n\x04wins\x18\x02\x20\x01(\rR\x04\
    wins\x12\x16\n\x06losses\x18\x03\x20\x01(\rR\x06losses\x12\x1d\n\nwin_st\
    reak\x18\x04\x20\x01(\rR\twinStreak\x12&\n\x0fbest_win_streak\x18\x05\
    \x20\x01(\rR\rbestWinStreak\x12\x1b\n\tavg_kills\x18\x06\x20\x01(\x02R\
    \x08avgKills\x12\x1d\n\navg_deaths\x18\x07\x20\x01(\x02R\tavgDeaths\x12\
    \x1f\n\x0bavg_assists\x18\x08\x20\x01(\x02R\navgAssists\x12\x17\n\x07avg\
    _gpm\x18\t\x20\x01(\x02R\x06avgGpm\x12\x17\n\x07avg_xpm\x18\n\x20\x01(\
    \x02R\x06avgXpm\x12\x1d\n\nbest_kills\x18\x0b\x20\x01(\rR\tbestKills\x12\
    !\n\x0cbest_assists\x18\x0c\x20\x01(\rR\x0bbestAssists\x12\x19\n\x08best\
    _gpm\x18\r\x20\x01(\rR\x07bestGpm\x12\x19\n\x08best_xpm\x18\x0e\x20\x01(\
    \rR\x07bestXpm\x12\x20\n\x0bperformance\x18\x0f\x20\x01(\x02R\x0bperform\
    ance\"%\n#CMsgGCItemEditorReservationsRequest\"N\n\x1bCMsgGCItemEditorRe\
    servation\x12\x1b\n\tdef_index\x18\x01\x20\x01(\rR\x08defIndex\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\"h\n$CMsgGCItemEditorReservationsRe\
    sponse\x12@\n\x0creservations\x18\x01\x20\x03(\x0b2\x1c.CMsgGCItemEditor\
    ReservationR\x0creservations\"Y\n\x1eCMsgGCItemEditorReserveItemDef\x12\
    \x1b\n\tdef_index\x18\x01\x20\x01(\rR\x08defIndex\x12\x1a\n\x08username\
    \x18\x02\x20\x01(\tR\x08username\"y\n&CMsgGCItemEditorReserveItemDefResp\
    onse\x12\x1b\n\tdef_index\x18\x01\x20\x01(\rR\x08defIndex\x12\x1a\n\x08u\
    sername\x18\x02\x20\x01(\tR\x08username\x12\x16\n\x06result\x18\x03\x20\
    \x01(\rR\x06result\"]\n\"CMsgGCItemEditorReleaseReservation\x12\x1b\n\td\
    ef_index\x18\x01\x20\x01(\rR\x08defIndex\x12\x1a\n\x08username\x18\x02\
    \x20\x01(\tR\x08username\"e\n*CMsgGCItemEditorReleaseReservationResponse\
    \x12\x1b\n\tdef_index\x18\x01\x20\x01(\rR\x08defIndex\x12\x1a\n\x08relea\
    sed\x18\x02\x20\x01(\x08R\x08released\"@\n!CMsgGCItemEditorRequestLeague\
    Info\x12\x1b\n\tleague_id\x18\x01\x20\x01(\rR\x08leagueId\"\x8b\x02\n\"C\
    MsgGCItemEditorLeagueInfoResponse\x12\x1b\n\tleague_id\x18\x01\x20\x01(\
    \rR\x08leagueId\x12\x1f\n\x0bleague_name\x18\x02\x20\x01(\tR\nleagueName\
    \x12\x1f\n\x0bleague_desc\x18\x03\x20\x01(\tR\nleagueDesc\x12\x1d\n\nlea\
    gue_url\x18\x04\x20\x01(\tR\tleagueUrl\x12\x1f\n\x0brevenue_url\x18\x05\
    \x20\x01(\tR\nrevenueUrl\x12\x12\n\x04tier\x18\x06\x20\x01(\rR\x04tier\
    \x12\x1a\n\x08location\x18\x07\x20\x01(\rR\x08location\x12\x16\n\x06resu\
    lt\x18\x08\x20\x01(\rR\x06result\"d\n\x1cCMsgDOTARewardTutorialPrizes\
    \x12\x1f\n\x0blocation_id\x18\x01\x20\x01(\rR\nlocationId\x12#\n\rtracki\
    ng_only\x18\x02\x20\x01(\x08R\x0ctrackingOnly\"_\n%CMsgDOTALastHitChalle\
    ngeHighScorePost\x12\x17\n\x07hero_id\x18\x01\x20\x01(\rR\x06heroId\x12\
    \x1d\n\nhigh_score\x18\x02\x20\x01(\rR\thighScore\"C\n(CMsgDOTALastHitCh\
    allengeHighScoreRequest\x12\x17\n\x07hero_id\x18\x01\x20\x01(\rR\x06hero\
    Id\"[\n)CMsgDOTALastHitChallengeHighScoreResponse\x12\x14\n\x05score\x18\
    \x01\x20\x01(\rR\x05score\x12\x18\n\x07eresult\x18\x02\x20\x01(\rR\x07er\
    esult\"\x14\n\x12CMsgFlipLobbyTeams\"!\n\x1fCMsgPresentedClientTerminate\
    Dlg\"\xb0\x01\n%CMsgGCLobbyUpdateBroadcastChannelInfo\x12\x1d\n\nchannel\
    _id\x18\x01\x20\x01(\rR\tchannelId\x12!\n\x0ccountry_code\x18\x02\x20\
    \x01(\tR\x0bcountryCode\x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0b\
    description\x12#\n\rlanguage_code\x18\x04\x20\x01(\tR\x0clanguageCode\"n\
    \n\x18CMsgDOTAClaimEventAction\x12\x19\n\x08event_id\x18\x01\x20\x01(\rR\
    \x07eventId\x12\x1b\n\taction_id\x18\x02\x20\x01(\rR\x08actionId\x12\x1a\
    \n\x08quantity\x18\x03\x20\x01(\rR\x08quantity\"\xe3\x05\n\x20CMsgDOTACl\
    aimEventActionResponse\x12M\n\x06result\x18\x01\x20\x01(\x0e2,.CMsgDOTAC\
    laimEventActionResponse.ResultCode:\x07SuccessR\x06result\x12Z\n\x0erewa\
    rd_results\x18\x02\x20\x03(\x0b23.CMsgDOTAClaimEventActionResponse.Grant\
    edRewardDataR\rrewardResults\x1aW\n\x15MysteryItemRewardData\x12\x19\n\
    \x08item_def\x18\x01\x20\x01(\rR\x07itemDef\x12#\n\ritem_category\x18\
    \x02\x20\x01(\rR\x0citemCategory\x1a/\n\x12LootListRewardData\x12\x19\n\
    \x08item_def\x18\x01\x20\x03(\rR\x07itemDef\x1a\x99\x01\n\x11GrantedRewa\
    rdData\x12\x1f\n\x0bgrant_index\x18\x01\x20\x01(\rR\ngrantIndex\x12\x1f\
    \n\x0bscore_index\x18\x02\x20\x01(\rR\nscoreIndex\x12!\n\x0creward_index\
    \x18\x03\x20\x01(\rR\x0brewardIndex\x12\x1f\n\x0breward_data\x18\x04\x20\
    \x01(\x0cR\nrewardData\"\xed\x01\n\nResultCode\x12\x0b\n\x07Success\x10\
    \0\x12\x10\n\x0cInvalidEvent\x10\x01\x12\x12\n\x0eEventNotActive\x10\x02\
    \x12\x11\n\rInvalidAction\x10\x03\x12\x0f\n\x0bServerError\x10\x04\x12\
    \x16\n\x12InsufficientPoints\x10\x05\x12\x14\n\x10InsufficentLevel\x10\
    \x06\x12\x12\n\x0eAlreadyClaimed\x10\x07\x12\x12\n\x0eSDOLockFailure\x10\
    \x08\x12\x12\n\x0eSDOLoadFailure\x10\t\x12\x11\n\rEventNotOwned\x10\n\
    \x12\x0b\n\x07Timeout\x10\x0b\"R\n\x16CMsgDOTAGetEventPoints\x12\x19\n\
    \x08event_id\x18\x01\x20\x01(\rR\x07eventId\x12\x1d\n\naccount_id\x18\
    \x02\x20\x01(\rR\taccountId\"\xcf\x03\n\x1eCMsgDOTAGetEventPointsRespons\
    e\x12!\n\x0ctotal_points\x18\x01\x20\x01(\rR\x0btotalPoints\x120\n\x14to\
    tal_premium_points\x18\x02\x20\x01(\rR\x12totalPremiumPoints\x12\x19\n\
    \x08event_id\x18\x03\x20\x01(\rR\x07eventId\x12\x16\n\x06points\x18\x04\
    \x20\x01(\rR\x06points\x12%\n\x0epremium_points\x18\x05\x20\x01(\rR\rpre\
    miumPoints\x12S\n\x11completed_actions\x18\x06\x20\x03(\x0b2&.CMsgDOTAGe\
    tEventPointsResponse.ActionR\x10completedActions\x12\x1d\n\naccount_id\
    \x18\x07\x20\x01(\rR\taccountId\x12\x14\n\x05owned\x18\x08\x20\x01(\x08R\
    \x05owned\x12!\n\x0caudit_action\x18\t\x20\x01(\rR\x0bauditAction\x1aQ\n\
    \x06Action\x12\x1b\n\taction_id\x18\x01\x20\x01(\rR\x08actionId\x12*\n\
    \x0ftimes_completed\x18\x02\x20\x01(\r:\x011R\x0etimesCompleted\"\x8c\
    \x01\n\x1bCMsgDOTAGetPeriodicResource\x12\x1d\n\naccount_id\x18\x01\x20\
    \x01(\rR\taccountId\x120\n\x14periodic_resource_id\x18\x02\x20\x01(\rR\
    \x12periodicResourceId\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\rR\ttimesta\
    mp\"\x8f\x01\n#CMsgDOTAGetPeriodicResourceResponse\x122\n\x15periodic_re\
    source_max\x18\x01\x20\x01(\rR\x13periodicResourceMax\x124\n\x16periodic\
    _resource_used\x18\x02\x20\x01(\rR\x14periodicResourceUsed\"\xd1\x01\n\
    \x1fCMsgDOTAPeriodicResourceUpdated\x12P\n\x15periodic_resource_key\x18\
    \x01\x20\x01(\x0b2\x1c.CMsgDOTAGetPeriodicResourceR\x13periodicResourceK\
    ey\x12\\\n\x17periodic_resource_value\x18\x02\x20\x01(\x0b2$.CMsgDOTAGet\
    PeriodicResourceResponseR\x15periodicResourceValue\"J\n\x1cCMsgDOTALiveL\
    eagueGameUpdate\x12*\n\x11live_league_games\x18\x01\x20\x01(\rR\x0fliveL\
    eagueGames\"\x80\x01\n\x1bCMsgDOTACompendiumSelection\x12'\n\x0fselectio\
    n_index\x18\x01\x20\x01(\rR\x0eselectionIndex\x12\x1c\n\tselection\x18\
    \x02\x20\x01(\rR\tselection\x12\x1a\n\x08leagueid\x18\x03\x20\x01(\rR\
    \x08leagueid\"\x8b\x01\n#CMsgDOTACompendiumSelectionResponse\x12\x1b\n\
    \x07eresult\x18\x01\x20\x01(\r:\x012R\x07eresult\x12G\n\x10extra_selecti\
    ons\x18\x02\x20\x03(\x0b2\x1c.CMsgDOTACompendiumSelectionR\x0fextraSelec\
    tions\"V\n\x16CMsgDOTACompendiumData\x12<\n\nselections\x18\x01\x20\x03(\
    \x0b2\x1c.CMsgDOTACompendiumSelectionR\nselections\"Z\n\x1dCMsgDOTACompe\
    ndiumDataRequest\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\
    \x12\x1a\n\x08leagueid\x18\x02\x20\x01(\rR\x08leagueid\"\xb8\x01\n\x1eCM\
    sgDOTACompendiumDataResponse\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\t\
    accountId\x12\x1a\n\x08leagueid\x18\x02\x20\x01(\rR\x08leagueid\x12\x19\
    \n\x06result\x18\x03\x20\x01(\r:\x012R\x06result\x12@\n\x0fcompendium_da\
    ta\x18\x04\x20\x01(\x0b2\x17.CMsgDOTACompendiumDataR\x0ecompendiumData\"\
    \xea\x02\n\x1dCMsgDOTAGetPlayerMatchHistory\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12)\n\x11start_at_match_id\x18\x02\x20\x01(\
    \x04R\x0estartAtMatchId\x12+\n\x11matches_requested\x18\x03\x20\x01(\rR\
    \x10matchesRequested\x12\x17\n\x07hero_id\x18\x04\x20\x01(\rR\x06heroId\
    \x12\x1d\n\nrequest_id\x18\x05\x20\x01(\rR\trequestId\x128\n\x18include_\
    practice_matches\x18\x07\x20\x01(\x08R\x16includePracticeMatches\x120\n\
    \x14include_custom_games\x18\x08\x20\x01(\x08R\x12includeCustomGames\x12\
    .\n\x13include_event_games\x18\t\x20\x01(\x08R\x11includeEventGames\"\
    \xb4\x06\n%CMsgDOTAGetPlayerMatchHistoryResponse\x12F\n\x07matches\x18\
    \x01\x20\x03(\x0b2,.CMsgDOTAGetPlayerMatchHistoryResponse.MatchR\x07matc\
    hes\x12\x1d\n\nrequest_id\x18\x02\x20\x01(\rR\trequestId\x1a\xa3\x05\n\
    \x05Match\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\x1d\
    \n\nstart_time\x18\x02\x20\x01(\rR\tstartTime\x12\x17\n\x07hero_id\x18\
    \x03\x20\x01(\rR\x06heroId\x12\x16\n\x06winner\x18\x04\x20\x01(\x08R\x06\
    winner\x12\x1b\n\tgame_mode\x18\x05\x20\x01(\rR\x08gameMode\x12\x1f\n\
    \x0brank_change\x18\x06\x20\x01(\x05R\nrankChange\x12#\n\rprevious_rank\
    \x18\x07\x20\x01(\rR\x0cpreviousRank\x12\x1d\n\nlobby_type\x18\x08\x20\
    \x01(\rR\tlobbyType\x12\x1b\n\tsolo_rank\x18\t\x20\x01(\x08R\x08soloRank\
    \x12\x18\n\x07abandon\x18\n\x20\x01(\x08R\x07abandon\x12\x1a\n\x08durati\
    on\x18\x0b\x20\x01(\rR\x08duration\x12\x16\n\x06engine\x18\x0c\x20\x01(\
    \rR\x06engine\x12,\n\x12active_battle_pass\x18\r\x20\x01(\x08R\x10active\
    BattlePass\x12#\n\rseasonal_rank\x18\x0e\x20\x01(\x08R\x0cseasonalRank\
    \x12\x1d\n\ntourney_id\x18\x0f\x20\x01(\rR\ttourneyId\x12#\n\rtourney_ro\
    und\x18\x10\x20\x01(\rR\x0ctourneyRound\x12!\n\x0ctourney_tier\x18\x11\
    \x20\x01(\rR\x0btourneyTier\x12)\n\x10tourney_division\x18\x12\x20\x01(\
    \rR\x0ftourneyDivision\x12\x17\n\x07team_id\x18\x13\x20\x01(\rR\x06teamI\
    d\x12\x1b\n\tteam_name\x18\x14\x20\x01(\tR\x08teamName\x12'\n\x10ugc_tea\
    m_ui_logo\x18\x15\x20\x01(\x04R\rugcTeamUiLogo\"!\n\x1fCMsgDOTAStartDail\
    yHeroChallenge\"\x1c\n\x1aCMsgGCNotificationsRequest\"\xcc\x03\n\x1bCMsg\
    GCNotificationsResponse\x12E\n\x06result\x18\x01\x20\x01(\x0e2$.CMsgGCNo\
    tificationsResponse.EResult:\x07SUCCESSR\x06result\x12O\n\rnotifications\
    \x18\x02\x20\x03(\x0b2).CMsgGCNotificationsResponse.NotificationR\rnotif\
    ications\x1a\xe5\x01\n\x0cNotification\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \x04R\x02id\x12\x12\n\x04type\x18\x02\x20\x01(\rR\x04type\x12\x1c\n\ttim\
    estamp\x18\x03\x20\x01(\rR\ttimestamp\x12\x1f\n\x0breference_a\x18\x04\
    \x20\x01(\rR\nreferenceA\x12\x1f\n\x0breference_b\x18\x05\x20\x01(\rR\nr\
    eferenceB\x12\x1f\n\x0breference_c\x18\x06\x20\x01(\rR\nreferenceC\x12\
    \x18\n\x07message\x18\x07\x20\x01(\tR\x07message\x12\x16\n\x06unread\x18\
    \x08\x20\x01(\x08R\x06unread\"-\n\x07EResult\x12\x0b\n\x07SUCCESS\x10\0\
    \x12\x15\n\x11ERROR_UNSPECIFIED\x10\x01\"$\n\"CMsgGCNotificationsMarkRea\
    dRequest\"S\n&CMsgClientToGCMarkNotificationListRead\x12)\n\x10notificat\
    ion_ids\x18\x01\x20\x03(\x04R\x0fnotificationIds\"\xc2\x01\n\x16CMsgGCLe\
    agueAdminState\x12\x18\n\x07leagues\x18\x01\x20\x03(\rR\x07leagues\x12=\
    \n\x04keys\x18\x02\x20\x03(\x0b2).CMsgGCLeagueAdminState.PrivateLeagueKe\
    ysR\x04keys\x1aO\n\x11PrivateLeagueKeys\x12\x1a\n\x08leagueid\x18\x01\
    \x20\x01(\rR\x08leagueid\x12\x1e\n\nprivatekey\x18\x02\x20\x01(\rR\npriv\
    atekey\"\xac\x01\n\x17CMsgGCPlayerInfoRequest\x12F\n\x0cplayer_infos\x18\
    \x01\x20\x03(\x0b2#.CMsgGCPlayerInfoRequest.PlayerInfoR\x0bplayerInfos\
    \x1aI\n\nPlayerInfo\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\
    \x12\x1c\n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\"\xa5\x01\n\x16CMsg\
    GCPlayerInfoSubmit\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12!\n\
    \x0ccountry_code\x18\x02\x20\x01(\tR\x0bcountryCode\x12!\n\x0cfantasy_ro\
    le\x18\x03\x20\x01(\rR\x0bfantasyRole\x12\x17\n\x07team_id\x18\x04\x20\
    \x01(\rR\x06teamId\x12\x18\n\x07sponsor\x18\x05\x20\x01(\tR\x07sponsor\"\
    \xb0\x01\n\x1eCMsgGCPlayerInfoSubmitResponse\x12H\n\x06result\x18\x01\
    \x20\x01(\x0e2'.CMsgGCPlayerInfoSubmitResponse.EResult:\x07SUCCESSR\x06r\
    esult\"D\n\x07EResult\x12\x0b\n\x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNSP\
    ECIFIED\x10\x01\x12\x15\n\x11ERROR_INFO_LOCKED\x10\x02\"\xd5\x01\n\x1dCM\
    sgClientProvideSurveyResult\x12E\n\tresponses\x18\x01\x20\x03(\x0b2'.CMs\
    gClientProvideSurveyResult.ResponseR\tresponses\x12\x1d\n\nsurvey_key\
    \x18\x02\x20\x01(\x04R\tsurveyKey\x1aN\n\x08Response\x12\x1f\n\x0bquesti\
    on_id\x18\x01\x20\x01(\rR\nquestionId\x12!\n\x0csurvey_value\x18\x02\x20\
    \x01(\rR\x0bsurveyValue\"i\n\x19CMsgDOTAEmoticonAccessSDO\x12\x1d\n\nacc\
    ount_id\x18\x01\x20\x01(\rR\taccountId\x12-\n\x12unlocked_emoticons\x18\
    \x02\x20\x01(\x0cR\x11unlockedEmoticons\"#\n!CMsgClientToGCEmoticonDataR\
    equest\"a\n\x1aCMsgGCToClientEmoticonData\x12C\n\x0femoticon_access\x18\
    \x01\x20\x01(\x0b2\x1a.CMsgDOTAEmoticonAccessSDOR\x0eemoticonAccess\"T\n\
    \x1fCMsgClientToGCTrackDialogResult\x12\x1b\n\tdialog_id\x18\x01\x20\x01\
    (\rR\x08dialogId\x12\x14\n\x05value\x18\x02\x20\x01(\rR\x05value\"\\\n\
    \x20CMsgGCToClientTournamentItemDrop\x12\x19\n\x08item_def\x18\x01\x20\
    \x01(\rR\x07itemDef\x12\x1d\n\nevent_type\x18\x02\x20\x01(\rR\teventType\
    \"R\n!CMsgClientToGCSetAdditionalEquips\x12-\n\x06equips\x18\x01\x20\x03\
    (\x0b2\x15.CAdditionalEquipSlotR\x06equips\"+\n)CMsgClientToGCSetAdditio\
    nalEquipsResponse\"#\n!CMsgClientToGCGetAdditionalEquips\"Z\n)CMsgClient\
    ToGCGetAdditionalEquipsResponse\x12-\n\x06equips\x18\x01\x20\x03(\x0b2\
    \x15.CAdditionalEquipSlotR\x06equips\"\x1f\n\x1dCMsgClientToGCGetAllHero\
    Order\"B\n%CMsgClientToGCGetAllHeroOrderResponse\x12\x19\n\x08hero_ids\
    \x18\x01\x20\x03(\rR\x07heroIds\"A\n\x20CMsgClientToGCGetAllHeroProgress\
    \x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\"\xc0\x06\n(CMsgCl\
    ientToGCGetAllHeroProgressResponse\x12\x1d\n\naccount_id\x18\x01\x20\x01\
    (\rR\taccountId\x12\x20\n\x0ccurr_hero_id\x18\x02\x20\x01(\rR\ncurrHeroI\
    d\x12%\n\x0elaps_completed\x18\x03\x20\x01(\rR\rlapsCompleted\x12&\n\x0f\
    curr_hero_games\x18\x04\x20\x01(\rR\rcurrHeroGames\x121\n\x15curr_lap_ti\
    me_started\x18\x05\x20\x01(\rR\x12currLapTimeStarted\x12$\n\x0ecurr_lap_\
    games\x18\x06\x20\x01(\rR\x0ccurrLapGames\x12$\n\x0ebest_lap_games\x18\
    \x07\x20\x01(\rR\x0cbestLapGames\x12\"\n\rbest_lap_time\x18\x08\x20\x01(\
    \rR\x0bbestLapTime\x120\n\x14lap_heroes_completed\x18\t\x20\x01(\rR\x12l\
    apHeroesCompleted\x120\n\x14lap_heroes_remaining\x18\n\x20\x01(\rR\x12la\
    pHeroesRemaining\x12\x20\n\x0cnext_hero_id\x18\x0b\x20\x01(\rR\nnextHero\
    Id\x12\x20\n\x0cprev_hero_id\x18\x0c\x20\x01(\rR\nprevHeroId\x12&\n\x0fp\
    rev_hero_games\x18\r\x20\x01(\rR\rprevHeroGames\x12$\n\x0eprev_avg_tries\
    \x18\x0e\x20\x01(\x02R\x0cprevAvgTries\x12$\n\x0ecurr_avg_tries\x18\x0f\
    \x20\x01(\x02R\x0ccurrAvgTries\x12$\n\x0enext_avg_tries\x18\x10\x20\x01(\
    \x02R\x0cnextAvgTries\x12+\n\x12full_lap_avg_tries\x18\x11\x20\x01(\x02R\
    \x0ffullLapAvgTries\x12+\n\x12curr_lap_avg_tries\x18\x12\x20\x01(\x02R\
    \x0fcurrLapAvgTries\x12!\n\x0cprofile_name\x18\x13\x20\x01(\tR\x0bprofil\
    eName\x12\"\n\rstart_hero_id\x18\x14\x20\x01(\rR\x0bstartHeroId\"<\n\x1b\
    CMsgClientToGCGetTrophyList\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\ta\
    ccountId\"\x9d\x02\n#CMsgClientToGCGetTrophyListResponse\x12\x1d\n\nacco\
    unt_id\x18\x01\x20\x01(\rR\taccountId\x12G\n\x08trophies\x18\x02\x20\x03\
    (\x0b2+.CMsgClientToGCGetTrophyListResponse.TrophyR\x08trophies\x12!\n\
    \x0cprofile_name\x18\x03\x20\x01(\tR\x0bprofileName\x1ak\n\x06Trophy\x12\
    \x1b\n\ttrophy_id\x18\x01\x20\x01(\rR\x08trophyId\x12!\n\x0ctrophy_score\
    \x18\x02\x20\x01(\rR\x0btrophyScore\x12!\n\x0clast_updated\x18\x03\x20\
    \x01(\rR\x0blastUpdated\"\xaa\x01\n\x1bCMsgGCToClientTrophyAwarded\x12\
    \x1b\n\ttrophy_id\x18\x01\x20\x01(\rR\x08trophyId\x12!\n\x0ctrophy_score\
    \x18\x02\x20\x01(\rR\x0btrophyScore\x12(\n\x10trophy_old_score\x18\x03\
    \x20\x01(\rR\x0etrophyOldScore\x12!\n\x0clast_updated\x18\x04\x20\x01(\r\
    R\x0blastUpdated\"=\n\x1cCMsgClientToGCGetProfileCard\x12\x1d\n\naccount\
    _id\x18\x01\x20\x01(\rR\taccountId\"\xfd\x01\n!CMsgClientToGCSetProfileC\
    ardSlots\x12A\n\x05slots\x18\x01\x20\x03(\x0b2+.CMsgClientToGCSetProfile\
    CardSlots.CardSlotR\x05slots\x1a\x94\x01\n\x08CardSlot\x12\x17\n\x07slot\
    _id\x18\x01\x20\x01(\rR\x06slotId\x12P\n\tslot_type\x18\x02\x20\x01(\x0e\
    2\x15.EProfileCardSlotType:\x1ck_EProfileCardSlotType_EmptyR\x08slotType\
    \x12\x1d\n\nslot_value\x18\x03\x20\x01(\x04R\tslotValue\"#\n!CMsgClientT\
    oGCGetProfileCardStats\"\xbb\x02\n\x1eCMsgClientToGCCreateHeroStatue\x12\
    \x1f\n\x0bsource_item\x18\x01\x20\x01(\x04R\nsourceItem\x12\x17\n\x07her\
    o_id\x18\x03\x20\x01(\rR\x06heroId\x12#\n\rsequence_name\x18\x04\x20\x01\
    (\tR\x0csequenceName\x12\x14\n\x05cycle\x18\x05\x20\x01(\x02R\x05cycle\
    \x12\x1c\n\twearables\x18\x06\x20\x03(\rR\twearables\x12\x20\n\x0binscri\
    ption\x18\x07\x20\x01(\tR\x0binscription\x12\x16\n\x06styles\x18\x08\x20\
    \x03(\rR\x06styles\x12#\n\rreforger_item\x18\t\x20\x01(\x04R\x0creforger\
    Item\x12'\n\x0ftournament_drop\x18\n\x20\x01(\x08R\x0etournamentDrop\"M\
    \n$CMsgGCToClientHeroStatueCreateResult\x12%\n\x0eresulting_item\x18\x01\
    \x20\x01(\x04R\rresultingItem\"\xd5\x01\n#CMsgClientToGCRecordCompendium\
    Stats\x12\x1b\n\tleague_id\x18\x01\x20\x01(\rR\x08leagueId\x12&\n\x0fvie\
    w_duration_s\x18\x02\x20\x01(\rR\rviewDurationS\x12#\n\rvideos_viewed\
    \x18\x03\x20\x01(\rR\x0cvideosViewed\x12\x1d\n\npage_turns\x18\x04\x20\
    \x01(\rR\tpageTurns\x12%\n\x0elinks_followed\x18\x05\x20\x01(\rR\rlinksF\
    ollowed\"]\n\x20CMsgGCToClientEventStatusChanged\x129\n\x0cactive_event\
    \x18\x02\x20\x01(\x0e2\x07.EEvent:\rEVENT_ID_NONER\x0bactiveEvent\"A\n\
    \x20CMsgClientToGCPlayerStatsRequest\x12\x1d\n\naccount_id\x18\x01\x20\
    \x01(\rR\taccountId\"\xcf\x05\n!CMsgGCToClientPlayerStatsResponse\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12!\n\x0cplayer_stats\
    \x18\x02\x20\x03(\x02R\x0bplayerStats\x12\x1f\n\x0bmatch_count\x18\x03\
    \x20\x01(\rR\nmatchCount\x12\x19\n\x08mean_gpm\x18\x04\x20\x01(\x02R\x07\
    meanGpm\x12\x1b\n\tmean_xppm\x18\x05\x20\x01(\x02R\x08meanXppm\x12#\n\rm\
    ean_lasthits\x18\x06\x20\x01(\x02R\x0cmeanLasthits\x12\x1a\n\x08rampages\
    \x18\x07\x20\x01(\rR\x08rampages\x12!\n\x0ctriple_kills\x18\x08\x20\x01(\
    \rR\x0btripleKills\x12.\n\x13first_blood_claimed\x18\t\x20\x01(\rR\x11fi\
    rstBloodClaimed\x12*\n\x11first_blood_given\x18\n\x20\x01(\rR\x0ffirstBl\
    oodGiven\x12'\n\x0fcouriers_killed\x18\x0b\x20\x01(\rR\x0ecouriersKilled\
    \x12)\n\x10aegises_snatched\x18\x0c\x20\x01(\rR\x0faegisesSnatched\x12#\
    \n\rcheeses_eaten\x18\r\x20\x01(\rR\x0ccheesesEaten\x12%\n\x0ecreeps_sta\
    cked\x18\x0e\x20\x01(\rR\rcreepsStacked\x12\x1f\n\x0bfight_score\x18\x0f\
    \x20\x01(\x02R\nfightScore\x12\x1d\n\nfarm_score\x18\x10\x20\x01(\x02R\t\
    farmScore\x12#\n\rsupport_score\x18\x11\x20\x01(\x02R\x0csupportScore\
    \x12\x1d\n\npush_score\x18\x12\x20\x01(\x02R\tpushScore\x12+\n\x11versat\
    ility_score\x18\x13\x20\x01(\x02R\x10versatilityScore\"R\n*CMsgClientToG\
    CCustomGamePlayerCountRequest\x12$\n\x0ecustom_game_id\x18\x01\x20\x01(\
    \x04R\x0ccustomGameId\"\x9f\x01\n+CMsgGCToClientCustomGamePlayerCountRes\
    ponse\x12$\n\x0ecustom_game_id\x18\x01\x20\x01(\x04R\x0ccustomGameId\x12\
    !\n\x0cplayer_count\x18\x02\x20\x01(\x04R\x0bplayerCount\x12'\n\x0fspect\
    ator_count\x18\x03\x20\x01(\x04R\x0espectatorCount\"/\n-CMsgClientToGCCu\
    stomGamesFriendsPlayedRequest\"\xf6\x01\n.CMsgGCToClientCustomGamesFrien\
    dsPlayedResponse\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\
    \x12P\n\x05games\x18\x02\x20\x03(\x0b2:.CMsgGCToClientCustomGamesFriends\
    PlayedResponse.CustomGameR\x05games\x1aS\n\nCustomGame\x12$\n\x0ecustom_\
    game_id\x18\x01\x20\x01(\x04R\x0ccustomGameId\x12\x1f\n\x0baccount_ids\
    \x18\x02\x20\x03(\rR\naccountIds\"a\n*CMsgClientToGCSocialFeedPostCommen\
    tRequest\x12\x19\n\x08event_id\x18\x01\x20\x01(\x04R\x07eventId\x12\x18\
    \n\x07comment\x18\x02\x20\x01(\tR\x07comment\"G\n+CMsgGCToClientSocialFe\
    edPostCommentResponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07succ\
    ess\"\x8a\x01\n*CMsgClientToGCSocialFeedPostMessageRequest\x12\x18\n\x07\
    message\x18\x01\x20\x01(\tR\x07message\x12\x19\n\x08match_id\x18\x02\x20\
    \x01(\x04R\x07matchId\x12'\n\x0fmatch_timestamp\x18\x03\x20\x01(\rR\x0em\
    atchTimestamp\"G\n+CMsgGCToClientSocialFeedPostMessageResponse\x12\x18\n\
    \x07success\x18\x01\x20\x01(\x08R\x07success\"T\n,CMsgClientToGCFriendsP\
    layedCustomGameRequest\x12$\n\x0ecustom_game_id\x18\x01\x20\x01(\x04R\
    \x0ccustomGameId\"v\n-CMsgGCToClientFriendsPlayedCustomGameResponse\x12$\
    \n\x0ecustom_game_id\x18\x01\x20\x01(\x04R\x0ccustomGameId\x12\x1f\n\x0b\
    account_ids\x18\x02\x20\x03(\rR\naccountIds\"%\n#CMsgClientToGCFeaturedH\
    eroesRequest\"\x92\x05\n$CMsgGCToClientFeaturedHeroesResponse\x12N\n\nca\
    tegories\x18\x01\x20\x03(\x0b2..CMsgGCToClientFeaturedHeroesResponse.Cat\
    egoryR\ncategories\x1a\xea\x01\n\tDataField\x12S\n\tdata_type\x18\x01\
    \x20\x01(\x0e2\x16.EFeaturedHeroDataType:\x1ek_EFeaturedHeroDataType_Her\
    oIDR\x08dataType\x12!\n\x0cuint32_value\x18\x02\x20\x01(\rR\x0buint32Val\
    ue\x12!\n\x0cuint64_value\x18\x03\x20\x01(\x04R\x0buint64Value\x12!\n\
    \x0cstring_value\x18\x04\x20\x01(\tR\x0bstringValue\x12\x1f\n\x0bfloat_v\
    alue\x18\x05\x20\x01(\x02R\nfloatValue\x1a`\n\x0cFeaturedHero\x12P\n\x0b\
    data_fields\x18\x01\x20\x03(\x0b2/.CMsgGCToClientFeaturedHeroesResponse.\
    DataFieldR\ndataFields\x1a\xca\x01\n\x08Category\x12'\n\x0fcategory_weig\
    ht\x18\x01\x20\x01(\x05R\x0ecategoryWeight\x128\n\x0btext_fields\x18\x02\
    \x20\x03(\x0e2\x17.EFeaturedHeroTextFieldR\ntextFields\x12[\n\x0ffeature\
    d_heroes\x18\x03\x20\x03(\x0b22.CMsgGCToClientFeaturedHeroesResponse.Fea\
    turedHeroR\x0efeaturedHeroes\"b\n+CMsgClientToGCSocialMatchPostCommentRe\
    quest\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\x18\n\
    \x07comment\x18\x02\x20\x01(\tR\x07comment\"H\n,CMsgGCToClientSocialMatc\
    hPostCommentResponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07succe\
    ss\"w\n'CMsgClientToGCSocialMatchDetailsRequest\x12\x19\n\x08match_id\
    \x18\x01\x20\x01(\x04R\x07matchId\x121\n\x14pagination_timestamp\x18\x02\
    \x20\x01(\rR\x13paginationTimestamp\"\x99\x02\n(CMsgGCToClientSocialMatc\
    hDetailsResponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\
    \x12M\n\x08comments\x18\x02\x20\x03(\x0b21.CMsgGCToClientSocialMatchDeta\
    ilsResponse.CommentR\x08comments\x1a\x83\x01\n\x07Comment\x12\x1d\n\nacc\
    ount_id\x18\x01\x20\x01(\rR\taccountId\x12!\n\x0cpersona_name\x18\x02\
    \x20\x01(\tR\x0bpersonaName\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\rR\tti\
    mestamp\x12\x18\n\x07comment\x18\x04\x20\x01(\tR\x07comment\"\x84\x06\n\
    \x19CMsgDOTAPartyRichPresence\x12\x19\n\x08party_id\x18\x01\x20\x01(\x06\
    R\x07partyId\x128\n\x0bparty_state\x18\x02\x20\x01(\x0e2\x13.CSODOTAPart\
    y.State:\x02UIR\npartyState\x12\x12\n\x04open\x18\x03\x20\x01(\x08R\x04o\
    pen\x12!\n\x0clow_priority\x18\x05\x20\x01(\x08R\x0blowPriority\x12\x17\
    \n\x07team_id\x18\x07\x20\x01(\rR\x06teamId\x12\x1b\n\tteam_name\x18\x08\
    \x20\x01(\tR\x08teamName\x12'\n\x10ugc_team_ui_logo\x18\t\x20\x01(\x04R\
    \rugcTeamUiLogo\x12;\n\x07members\x18\x04\x20\x03(\x0b2!.CMsgDOTAPartyRi\
    chPresence.MemberR\x07members\x12R\n\x0fweekend_tourney\x18\x06\x20\x01(\
    \x0b2).CMsgDOTAPartyRichPresence.WeekendTourneyR\x0eweekendTourney\x1a9\
    \n\x06Member\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12\
    \x14\n\x05coach\x18\x02\x20\x01(\x08R\x05coach\x1a\xaf\x02\n\x0eWeekendT\
    ourney\x12\x1a\n\x08division\x18\x01\x20\x01(\rR\x08division\x12\x1f\n\
    \x0bskill_level\x18\x02\x20\x01(\rR\nskillLevel\x12\x14\n\x05round\x18\
    \x03\x20\x01(\rR\x05round\x12#\n\rtournament_id\x18\x04\x20\x01(\rR\x0ct\
    ournamentId\x12\"\n\rstate_seq_num\x18\x05\x20\x01(\rR\x0bstateSeqNum\
    \x12`\n\x05event\x18\x06\x20\x01(\x0e2!.EWeekendTourneyRichPresenceEvent\
    :'k_EWeekendTourneyRichPresenceEvent_NoneR\x05event\x12\x1f\n\x0bevent_r\
    ound\x18\x07\x20\x01(\rR\neventRound\"\xf3\x02\n\x19CMsgDOTALobbyRichPre\
    sence\x12\x19\n\x08lobby_id\x18\x01\x20\x01(\x06R\x07lobbyId\x128\n\x0bl\
    obby_state\x18\x02\x20\x01(\x0e2\x13.CSODOTALobby.State:\x02UIR\nlobbySt\
    ate\x12\x1a\n\x08password\x18\x03\x20\x01(\x08R\x08password\x12?\n\tgame\
    _mode\x18\x04\x20\x01(\x0e2\x0e.DOTA_GameMode:\x12DOTA_GAMEMODE_NONER\
    \x08gameMode\x12!\n\x0cmember_count\x18\x05\x20\x01(\rR\x0bmemberCount\
    \x12(\n\x10max_member_count\x18\x06\x20\x01(\rR\x0emaxMemberCount\x12$\n\
    \x0ecustom_game_id\x18\x07\x20\x01(\x06R\x0ccustomGameId\x12\x12\n\x04na\
    me\x18\x08\x20\x01(\tR\x04name\x12\x1d\n\nlobby_type\x18\t\x20\x01(\rR\t\
    lobbyType\"\xb3\x01\n,CMsgDOTACustomGameListenServerStartedLoading\x12\
    \x19\n\x08lobby_id\x18\x01\x20\x01(\x06R\x07lobbyId\x12$\n\x0ecustom_gam\
    e_id\x18\x02\x20\x01(\x04R\x0ccustomGameId\x12#\n\rlobby_members\x18\x03\
    \x20\x03(\rR\x0clobbyMembers\x12\x1d\n\nstart_time\x18\x04\x20\x01(\rR\t\
    startTime\"\xf4\x01\n'CMsgDOTACustomGameClientFinishedLoading\x12\x19\n\
    \x08lobby_id\x18\x01\x20\x01(\x06R\x07lobbyId\x12)\n\x10loading_duration\
    \x18\x02\x20\x01(\rR\x0floadingDuration\x12\x1f\n\x0bresult_code\x18\x03\
    \x20\x01(\x11R\nresultCode\x12#\n\rresult_string\x18\x04\x20\x01(\tR\x0c\
    resultString\x12#\n\rsignon_states\x18\x05\x20\x01(\rR\x0csignonStates\
    \x12\x18\n\x07comment\x18\x06\x20\x01(\tR\x07comment\"<\n\x1dCMsgClientT\
    oGCGetLeagueSeries\x12\x1b\n\tleague_id\x18\x01\x20\x01(\rR\x08leagueId\
    \"\xca\x04\n%CMsgClientToGCGetLeagueSeriesResponse\x12E\n\x06series\x18\
    \x01\x20\x03(\x0b2-.CMsgClientToGCGetLeagueSeriesResponse.SeriesR\x06ser\
    ies\x1a\xd9\x03\n\x06Series\x12\x1b\n\tseries_id\x18\x01\x20\x01(\rR\x08\
    seriesId\x12\x1b\n\tnum_games\x18\x02\x20\x01(\rR\x08numGames\x12H\n\x05\
    teams\x18\x03\x20\x03(\x0b22.CMsgClientToGCGetLeagueSeriesResponse.Serie\
    s.TeamR\x05teams\x12\x1f\n\x0bseries_name\x18\x04\x20\x01(\tR\nseriesNam\
    e\x12\x1d\n\nphase_name\x18\x05\x20\x01(\tR\tphaseName\x12\x1d\n\nstart_\
    time\x18\x06\x20\x01(\rR\tstartTime\x12&\n\x0fafter_series_id\x18\x07\
    \x20\x01(\rR\rafterSeriesId\x12.\n\x13num_completed_games\x18\x08\x20\
    \x01(\rR\x11numCompletedGames\x1a\x93\x01\n\x04Team\x12\x17\n\x07team_id\
    \x18\x01\x20\x01(\rR\x06teamId\x12\x1b\n\tteam_name\x18\x02\x20\x01(\tR\
    \x08teamName\x12\x19\n\x08team_tag\x18\x03\x20\x01(\tR\x07teamTag\x12\
    \x1d\n\nteam_score\x18\x04\x20\x01(\rR\tteamScore\x12\x1b\n\tteam_wins\
    \x18\x05\x20\x01(\rR\x08teamWins\"X\n\x1eCMsgClientToGCApplyGemCombiner\
    \x12\x1a\n\titem_id_1\x18\x01\x20\x01(\x04R\x07itemId1\x12\x1a\n\titem_i\
    d_2\x18\x02\x20\x01(\x04R\x07itemId2\"\x1f\n\x1dCMsgClientToGCH264Unsupp\
    orted\"\"\n\x20CMsgClientToGCRequestH264Support\"=\n\x1eCMsgClientToGCGe\
    tQuestProgress\x12\x1b\n\tquest_ids\x18\x01\x20\x03(\rR\x08questIds\"\
    \xe7\x03\n&CMsgClientToGCGetQuestProgressResponse\x12\x18\n\x07success\
    \x18\x01\x20\x01(\x08R\x07success\x12E\n\x06quests\x18\x02\x20\x03(\x0b2\
    -.CMsgClientToGCGetQuestProgressResponse.QuestR\x06quests\x1a\xd0\x01\n\
    \tChallenge\x12!\n\x0cchallenge_id\x18\x01\x20\x01(\rR\x0bchallengeId\
    \x12%\n\x0etime_completed\x18\x02\x20\x01(\rR\rtimeCompleted\x12\x1a\n\
    \x08attempts\x18\x03\x20\x01(\rR\x08attempts\x12\x17\n\x07hero_id\x18\
    \x04\x20\x01(\rR\x06heroId\x12%\n\x0echallenge_type\x18\x05\x20\x01(\rR\
    \rchallengeType\x12\x1d\n\nquest_rank\x18\x06\x20\x01(\rR\tquestRank\x1a\
    \x88\x01\n\x05Quest\x12\x19\n\x08quest_id\x18\x01\x20\x01(\rR\x07questId\
    \x12d\n\x14completed_challenges\x18\x02\x20\x03(\x0b21.CMsgClientToGCGet\
    QuestProgressResponse.ChallengeR\x13completedChallenges\"9\n\x1cCMsgGCTo\
    ClientMatchSignedOut\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matc\
    hId\"4\n\x19CMsgGCGetHeroStatsHistory\x12\x17\n\x07hero_id\x18\x01\x20\
    \x01(\rR\x06heroId\"t\n!CMsgGCGetHeroStatsHistoryResponse\x12\x17\n\x07h\
    ero_id\x18\x01\x20\x01(\rR\x06heroId\x126\n\x07records\x18\x02\x20\x03(\
    \x0b2\x1c.CMsgDOTASDOHeroStatsHistoryR\x07records\"#\n!CMsgPlayerConduct\
    ScorecardRequest\"\xd6\x03\n\x1aCMsgPlayerConductScorecard\x12\x1d\n\nac\
    count_id\x18\x01\x20\x01(\rR\taccountId\x12\x19\n\x08match_id\x18\x02\
    \x20\x01(\x04R\x07matchId\x12\x17\n\x07seq_num\x18\x03\x20\x01(\rR\x06se\
    qNum\x12\x18\n\x07reasons\x18\x04\x20\x01(\rR\x07reasons\x12*\n\x11match\
    es_in_report\x18\x05\x20\x01(\rR\x0fmatchesInReport\x12#\n\rmatches_clea\
    n\x18\x06\x20\x01(\rR\x0cmatchesClean\x12)\n\x10matches_reported\x18\x07\
    \x20\x01(\rR\x0fmatchesReported\x12+\n\x11matches_abandoned\x18\x08\x20\
    \x01(\rR\x10matchesAbandoned\x12#\n\rreports_count\x18\t\x20\x01(\rR\x0c\
    reportsCount\x12'\n\x0freports_parties\x18\n\x20\x01(\rR\x0ereportsParti\
    es\x12#\n\rcommend_count\x18\x0b\x20\x01(\rR\x0ccommendCount\x12\x1b\n\t\
    end_score\x18\r\x20\x01(\rR\x08endScore\x12\x12\n\x04date\x18\x0e\x20\
    \x01(\rR\x04date\":\n\x1dCMsgClientToGCWageringRequest\x12\x19\n\x08even\
    t_id\x18\x01\x20\x01(\rR\x07eventId\"\xa1\x03\n\x1eCMsgGCToClientWagerin\
    gResponse\x12'\n\x0fcoins_remaining\x18\x01\x20\x01(\rR\x0ecoinsRemainin\
    g\x12(\n\x10total_points_won\x18\x02\x20\x01(\rR\x0etotalPointsWon\x120\
    \n\x14total_points_wagered\x18\x03\x20\x01(\rR\x12totalPointsWagered\x12\
    .\n\x13total_points_tipped\x18\x04\x20\x01(\rR\x11totalPointsTipped\x12!\
    \n\x0csuccess_rate\x18\x05\x20\x01(\rR\x0bsuccessRate\x12.\n\x13total_ga\
    mes_wagered\x18\x06\x20\x01(\rR\x11totalGamesWagered\x12\x1b\n\tcoins_ma\
    x\x18\x07\x20\x01(\rR\x08coinsMax\x122\n\x15rank_wagers_remaining\x18\
    \x08\x20\x01(\rR\x13rankWagersRemaining\x12&\n\x0frank_wagers_max\x18\t\
    \x20\x01(\rR\rrankWagersMax\"\x7f\n\x1cCMsgGCToClientWageringUpdate\x12\
    \x19\n\x08event_id\x18\x01\x20\x01(\rR\x07eventId\x12D\n\rwagering_info\
    \x18\x02\x20\x01(\x0b2\x1f.CMsgGCToClientWageringResponseR\x0cwageringIn\
    fo\"\x93\x01\n\x1fCMsgGCToClientArcanaVotesUpdate\x12\x19\n\x08event_id\
    \x18\x01\x20\x01(\rR\x07eventId\x12U\n\x0carcana_votes\x18\x02\x20\x01(\
    \x0b22.CMsgClientToGCRequestArcanaVotesRemainingResponseR\x0barcanaVotes\
    \"C\n\x1bCMsgClientToGCGetEventGoals\x12$\n\tevent_ids\x18\x01\x20\x03(\
    \x0e2\x07.EEventR\x08eventIds\"\xbb\x01\n\x0eCMsgEventGoals\x12:\n\x0bev\
    ent_goals\x18\x01\x20\x03(\x0b2\x19.CMsgEventGoals.EventGoalR\neventGoal\
    s\x1am\n\tEventGoal\x121\n\x08event_id\x18\x01\x20\x01(\x0e2\x07.EEvent:\
    \rEVENT_ID_NONER\x07eventId\x12\x17\n\x07goal_id\x18\x02\x20\x01(\rR\x06\
    goalId\x12\x14\n\x05value\x18\x03\x20\x01(\x04R\x05value\":\n\x1bCMsgGCT\
    oGCLeaguePredictions\x12\x1b\n\tleague_id\x18\x01\x20\x01(\rR\x08leagueI\
    d\"\xf8\x02\n\x16CMsgPredictionRankings\x12D\n\x0bpredictions\x18\x01\
    \x20\x03(\x0b2\".CMsgPredictionRankings.PredictionR\x0bpredictions\x1a\
    \x92\x01\n\x0ePredictionLine\x12\x1b\n\tanswer_id\x18\x01\x20\x01(\rR\
    \x08answerId\x12\x1f\n\x0banswer_name\x18\x02\x20\x01(\tR\nanswerName\
    \x12\x1f\n\x0banswer_logo\x18\x03\x20\x01(\x04R\nanswerLogo\x12!\n\x0can\
    swer_value\x18\x04\x20\x01(\x02R\x0banswerValue\x1a\x82\x01\n\nPredictio\
    n\x12!\n\x0cselection_id\x18\x01\x20\x01(\rR\x0bselectionId\x12Q\n\x10pr\
    ediction_lines\x18\x02\x20\x03(\x0b2&.CMsgPredictionRankings.PredictionL\
    ineR\x0fpredictionLines\"\xb1\x02\n\x15CMsgPredictionResults\x127\n\x07r\
    esults\x18\x01\x20\x03(\x0b2\x1d.CMsgPredictionResults.ResultR\x07result\
    s\x1a_\n\x0fResultBreakdown\x12)\n\x10answer_selection\x18\x02\x20\x01(\
    \rR\x0fanswerSelection\x12!\n\x0canswer_value\x18\x03\x20\x01(\x02R\x0ba\
    nswerValue\x1a~\n\x06Result\x12!\n\x0cselection_id\x18\x01\x20\x01(\rR\
    \x0bselectionId\x12Q\n\x10result_breakdown\x18\x02\x20\x03(\x0b2&.CMsgPr\
    edictionResults.ResultBreakdownR\x0fresultBreakdown\"=\n\x20CMsgClientTo\
    GCSuspiciousActivity\x12\x19\n\x08app_data\x18\x01\x20\x01(\x04R\x07appD\
    ata\"?\n\"CMsgClientToGCHasPlayerVotedForMVP\x12\x19\n\x08match_id\x18\
    \x01\x20\x01(\x04R\x07matchId\"D\n*CMsgClientToGCHasPlayerVotedForMVPRes\
    ponse\x12\x16\n\x06result\x18\x01\x20\x01(\x08R\x06result\"T\n\x18CMsgCl\
    ientToGCVoteForMVP\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchI\
    d\x12\x1d\n\naccount_id\x18\x03\x20\x01(\rR\taccountId\":\n\x20CMsgClien\
    tToGCVoteForMVPResponse\x12\x16\n\x06result\x18\x01\x20\x01(\x08R\x06res\
    ult\"\x96\x01\n\x14CMsgMVPVotesForMatch\x126\n\x07players\x18\x01\x20\
    \x03(\x0b2\x1c.CMsgMVPVotesForMatch.PlayerR\x07players\x1aF\n\x06Player\
    \x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1d\n\nvote_co\
    unt\x18\x02\x20\x01(\rR\tvoteCount\"f\n\x13CMsgLeaguePrizePool\x12\x1d\n\
    \nprize_pool\x18\x01\x20\x01(\rR\tprizePool\x120\n\x14increment_per_seco\
    nd\x18\x02\x20\x01(\x02R\x12incrementPerSecond\"$\n\"CMsgClientToGCTeamm\
    ateStatsRequest\"\x8c\x03\n#CMsgClientToGCTeammateStatsResponse\x12\x18\
    \n\x07success\x18\x01\x20\x01(\x08R\x07success\x12X\n\x0eteammate_stats\
    \x18\x02\x20\x03(\x0b21.CMsgClientToGCTeammateStatsResponse.TeammateStat\
    R\rteammateStats\x1a\xf0\x01\n\x0cTeammateStat\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12\x14\n\x05games\x18\x02\x20\x01(\rR\x05ga\
    mes\x12\x12\n\x04wins\x18\x03\x20\x01(\rR\x04wins\x12;\n\x1amost_recent_\
    game_timestamp\x18\x04\x20\x01(\rR\x17mostRecentGameTimestamp\x128\n\x19\
    most_recent_game_match_id\x18\x05\x20\x01(\x04R\x15mostRecentGameMatchId\
    \x12\x20\n\x0bperformance\x18d\x20\x01(\x02R\x0bperformance\"\xbf\x01\n\
    \x1bCMsgClientToGCVoteForArcana\x12@\n\x07matches\x18\x01\x20\x03(\x0b2&\
    .CMsgClientToGCVoteForArcana.MatchVoteR\x07matches\x1a^\n\tMatchVote\x12\
    \x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\x17\n\x07hero_id\
    \x18\x02\x20\x01(\rR\x06heroId\x12\x1d\n\nvote_count\x18\x03\x20\x01(\rR\
    \tvoteCount\"\xc5\x01\n#CMsgClientToGCVoteForArcanaResponse\x12N\n\x06re\
    sult\x18\x01\x20\x01(\x0e2+.CMsgClientToGCVoteForArcanaResponse.Result:\
    \tSUCCEEDEDR\x06result\"N\n\x06Result\x12\r\n\tSUCCEEDED\x10\0\x12\x20\n\
    \x1cVOTING_NOT_ENABLED_FOR_ROUND\x10\x01\x12\x13\n\x0fUNKNOWN_FAILURE\
    \x10\x02\"\xa4\x06\n\x0fCMsgArcanaVotes\x120\n\x07matches\x18\x01\x20\
    \x03(\x0b2\x16.CMsgArcanaVotes.MatchR\x07matches\x120\n\x14round_time_re\
    maining\x18\x02\x20\x01(\rR\x12roundTimeRemaining\x12!\n\x0cround_number\
    \x18\x03\x20\x01(\rR\x0broundNumber\x12!\n\x0cvoting_state\x18\x04\x20\
    \x01(\rR\x0bvotingState\x12?\n\x1cis_current_round_calibrating\x18\x05\
    \x20\x01(\x08R\x19isCurrentRoundCalibrating\x125\n\x17closest_active_mat\
    ch_id\x18\x06\x20\x01(\rR\x14closestActiveMatchId\x12\x19\n\x08event_id\
    \x18\x07\x20\x01(\rR\x07eventId\x1a\x96\x03\n\x05Match\x12\x19\n\x08matc\
    h_id\x18\x01\x20\x01(\rR\x07matchId\x12\x1a\n\thero_id_0\x18\x02\x20\x01\
    (\rR\x07heroId0\x12\x1a\n\thero_id_1\x18\x03\x20\x01(\rR\x07heroId1\x12$\
    \n\x0ehero_seeding_0\x18\x04\x20\x01(\rR\x0cheroSeeding0\x12$\n\x0ehero_\
    seeding_1\x18\x05\x20\x01(\rR\x0cheroSeeding1\x12\x20\n\x0cvote_count_0\
    \x18\x06\x20\x01(\rR\nvoteCount0\x12\x20\n\x0cvote_count_1\x18\x07\x20\
    \x01(\rR\nvoteCount1\x12!\n\x0cvoting_state\x18\x08\x20\x01(\rR\x0bvotin\
    gState\x12!\n\x0cround_number\x18\t\x20\x01(\rR\x0broundNumber\x12&\n\
    \x0fis_votes_hidden\x18\n\x20\x01(\x08R\risVotesHidden\x12<\n\x1acalibra\
    tion_time_remaining\x18\x0b\x20\x01(\rR\x18calibrationTimeRemaining\";\n\
    \x0bVotingState\x12\x0c\n\x08FINISHED\x10\0\x12\x0f\n\x0bIN_PROGRESS\x10\
    \x01\x12\r\n\tIN_FUTURE\x10\x02\"+\n)CMsgClientToGCRequestArcanaVotesRem\
    aining\"\xf4\x02\n1CMsgClientToGCRequestArcanaVotesRemainingResponse\x12\
    \x16\n\x06result\x18\x01\x20\x01(\x08R\x06result\x12'\n\x0fvotes_remaini\
    ng\x18\x02\x20\x01(\rR\x0evotesRemaining\x12\x1f\n\x0bvotes_total\x18\
    \x03\x20\x01(\rR\nvotesTotal\x12}\n\x1cmatches_previously_voted_for\x18\
    \x04\x20\x03(\x0b2<.CMsgClientToGCRequestArcanaVotesRemainingResponse.Ma\
    tchVoteR\x19matchesPreviouslyVotedFor\x1a^\n\tMatchVote\x12\x19\n\x08mat\
    ch_id\x18\x01\x20\x01(\x04R\x07matchId\x12\x17\n\x07hero_id\x18\x02\x20\
    \x01(\rR\x06heroId\x12\x1d\n\nvote_count\x18\x03\x20\x01(\rR\tvoteCount\
    \"?\n\"CMsgClientToGCRequestEventPointLog\x12\x19\n\x08event_id\x18\x01\
    \x20\x01(\rR\x07eventId\"\xb4\x16\n*CMsgClientToGCRequestEventPointLogRe\
    sponse\x12\x16\n\x06result\x18\x01\x20\x01(\x08R\x06result\x12e\n\x0ctra\
    nsactions\x18\x02\x20\x03(\x0b2A.CMsgClientToGCRequestEventPointLogRespo\
    nse.EventPointTransactionR\x0ctransactions\x12\x19\n\x08event_id\x18\x03\
    \x20\x01(\rR\x07eventId\x1ag\n\x13QuestChallengeEvent\x12\x19\n\x08quest\
    _id\x18\x01\x20\x01(\rR\x07questId\x12!\n\x0cchallenge_id\x18\x02\x20\
    \x01(\rR\x0bchallengeId\x12\x12\n\x04rank\x18\x03\x20\x01(\rR\x04rank\
    \x1a*\n\rWagerWonEvent\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07ma\
    tchId\x1ah\n\rTipGivenEvent\x120\n\x14recipient_account_id\x18\x01\x20\
    \x01(\rR\x12recipientAccountId\x12%\n\x0erecipient_name\x18\x02\x20\x01(\
    \tR\rrecipientName\x1a[\n\x10TipReceivedEvent\x12(\n\x10giver_account_id\
    \x18\x01\x20\x01(\rR\x0egiverAccountId\x12\x1d\n\ngiver_name\x18\x02\x20\
    \x01(\tR\tgiverName\x1aF\n\x11RecycledItemEvent\x121\n\x15recipe_item_de\
    f_index\x18\x01\x20\x01(\rR\x12recipeItemDefIndex\x1aS\n\x11ActionReward\
    Event\x12\x1b\n\taction_id\x18\x01\x20\x01(\rR\x08actionId\x12!\n\x0cact\
    ion_score\x18\x02\x20\x01(\rR\x0bactionScore\x1aJ\n\x18MysteryItemReceiv\
    edEvent\x12.\n\x13community_goal_item\x18\x01\x20\x01(\x08R\x11community\
    GoalItem\x1a=\n\x16CorrectPredictionEvent\x12#\n\rprediction_id\x18\x01\
    \x20\x01(\rR\x0cpredictionId\x1a9\n\x1cInGamePredictionCorrectEvent\x12\
    \x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x1a6\n\x19WeekendTou\
    rneyPayoutEvent\x12\x19\n\x08team_gid\x18\x01\x20\x01(\x04R\x07teamGid\
    \x1a4\n\x12FantasyRewardEvent\x12\x1e\n\npercentile\x18\x01\x20\x01(\rR\
    \npercentile\x1a=\n\x12BracketRewardEvent\x12'\n\x0fcorrect_answers\x18\
    \x01\x20\x01(\rR\x0ecorrectAnswers\x1a0\n\x0fWeeklyGameEvent\x12\x1d\n\n\
    points_won\x18\x01\x20\x01(\rR\tpointsWon\x1aC\n\x16ExploitCorrectionEve\
    nt\x12)\n\x10points_corrected\x18\x01\x20\x01(\rR\x0fpointsCorrected\x1a\
    \x88\r\n\x15EventPointTransaction\x12\x12\n\x04time\x18\x01\x20\x01(\rR\
    \x04time\x12!\n\x0cevent_points\x18\x02\x20\x01(\x05R\x0beventPoints\x12\
    <\n\x1acompendium_activated_event\x18\x03\x20\x01(\x08R\x18compendiumAct\
    ivatedEvent\x121\n\x15point_item_used_event\x18\x04\x20\x01(\x08R\x12poi\
    ntItemUsedEvent\x12a\n\x0fwager_won_event\x18\x05\x20\x01(\x0b29.CMsgCli\
    entToGCRequestEventPointLogResponse.WagerWonEventR\rwagerWonEvent\x12\
    \x83\x01\n\x1bmystery_item_received_event\x18\x06\x20\x01(\x0b2D.CMsgCli\
    entToGCRequestEventPointLogResponse.MysteryItemReceivedEventR\x18mystery\
    ItemReceivedEvent\x12s\n\x15quest_challenge_event\x18\x07\x20\x01(\x0b2?\
    .CMsgClientToGCRequestEventPointLogResponse.QuestChallengeEventR\x13ques\
    tChallengeEvent\x12a\n\x0ftip_given_event\x18\x08\x20\x01(\x0b29.CMsgCli\
    entToGCRequestEventPointLogResponse.TipGivenEventR\rtipGivenEvent\x12j\n\
    \x12tip_received_event\x18\t\x20\x01(\x0b2<.CMsgClientToGCRequestEventPo\
    intLogResponse.TipReceivedEventR\x10tipReceivedEvent\x12m\n\x13recycled_\
    item_event\x18\n\x20\x01(\x0b2=.CMsgClientToGCRequestEventPointLogRespon\
    se.RecycledItemEventR\x11recycledItemEvent\x12m\n\x13action_reward_event\
    \x18\x0b\x20\x01(\x0b2=.CMsgClientToGCRequestEventPointLogResponse.Actio\
    nRewardEventR\x11actionRewardEvent\x12\x81\x01\n\x18in_game_prediction_e\
    vent\x18\x0c\x20\x01(\x0b2H.CMsgClientToGCRequestEventPointLogResponse.I\
    nGamePredictionCorrectEventR\x15inGamePredictionEvent\x12m\n\x10predicti\
    on_event\x18\r\x20\x01(\x0b2B.CMsgClientToGCRequestEventPointLogResponse\
    .CorrectPredictionEventR\x0fpredictionEvent\x12p\n\x14fantasy_reward_eve\
    nt\x18\x0f\x20\x01(\x0b2>.CMsgClientToGCRequestEventPointLogResponse.Fan\
    tasyRewardEventR\x12fantasyRewardEvent\x12p\n\x14bracket_reward_event\
    \x18\x10\x20\x01(\x0b2>.CMsgClientToGCRequestEventPointLogResponse.Brack\
    etRewardEventR\x12bracketRewardEvent\x12g\n\x11weekly_game_event\x18\x13\
    \x20\x01(\x0b2;.CMsgClientToGCRequestEventPointLogResponse.WeeklyGameEve\
    ntR\x0fweeklyGameEvent\x12|\n\x18exploit_correction_event\x18\x14\x20\
    \x01(\x0b2B.CMsgClientToGCRequestEventPointLogResponse.ExploitCorrection\
    EventR\x16exploitCorrectionEvent\"p\n\x1dCMsgClientToGCPublishUserStat\
    \x12(\n\x10user_stats_event\x18\x01\x20\x01(\rR\x0euserStatsEvent\x12%\n\
    \x0ereference_data\x18\x02\x20\x01(\x04R\rreferenceData\"8\n\x20CMsgClie\
    ntToGCAddTI6TreeProgress\x12\x14\n\x05trees\x18\x01\x20\x01(\rR\x05trees\
    \"\\\n'CMsgClientToGCRequestLinaPlaysRemaining\x121\n\x08event_id\x18\
    \x01\x20\x01(\x0e2\x07.EEvent:\rEVENT_ID_NONER\x07eventId\"{\n/CMsgClien\
    tToGCRequestLinaPlaysRemainingResponse\x12'\n\x0fplays_remaining\x18\x01\
    \x20\x01(\rR\x0eplaysRemaining\x12\x1f\n\x0bplays_total\x18\x02\x20\x01(\
    \rR\nplaysTotal\"y\n#CMsgClientToGCRequestLinaGameResult\x121\n\x08event\
    _id\x18\x01\x20\x01(\x0e2\x07.EEvent:\rEVENT_ID_NONER\x07eventId\x12\x1f\
    \n\x0bslot_chosen\x18\x02\x20\x01(\rR\nslotChosen\"E\n+CMsgClientToGCReq\
    uestLinaGameResultResponse\x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06re\
    sult\"\x8e\x01\n$CMsgClientToGCRequestSlarkGameResult\x121\n\x08event_id\
    \x18\x01\x20\x01(\x0e2\x07.EEvent:\rEVENT_ID_NONER\x07eventId\x12\x1f\n\
    \x0bslot_chosen\x18\x02\x20\x01(\rR\nslotChosen\x12\x12\n\x04week\x18\
    \x03\x20\x01(\rR\x04week\"h\n,CMsgClientToGCRequestSlarkGameResultRespon\
    se\x12\x1d\n\npoints_won\x18\x01\x20\x01(\rR\tpointsWon\x12\x19\n\x08aur\
    a_won\x18\x02\x20\x01(\x08R\x07auraWon\"\xf4\x02\n\"CMsgGCToClientQuestP\
    rogressUpdated\x12\x19\n\x08quest_id\x18\x01\x20\x01(\rR\x07questId\x12`\
    \n\x14completed_challenges\x18\x02\x20\x03(\x0b2-.CMsgGCToClientQuestPro\
    gressUpdated.ChallengeR\x13completedChallenges\x1a\xd0\x01\n\tChallenge\
    \x12!\n\x0cchallenge_id\x18\x01\x20\x01(\rR\x0bchallengeId\x12%\n\x0etim\
    e_completed\x18\x02\x20\x01(\rR\rtimeCompleted\x12\x1a\n\x08attempts\x18\
    \x03\x20\x01(\rR\x08attempts\x12\x17\n\x07hero_id\x18\x04\x20\x01(\rR\
    \x06heroId\x12%\n\x0echallenge_type\x18\x05\x20\x01(\rR\rchallengeType\
    \x12\x1d\n\nquest_rank\x18\x06\x20\x01(\rR\tquestRank\"X\n\x12CMsgDOTARe\
    deemItem\x12\x1f\n\x0bcurrency_id\x18\x01\x20\x01(\x04R\ncurrencyId\x12!\
    \n\x0cpurchase_def\x18\x02\x20\x01(\rR\x0bpurchaseDef\"\x9c\x01\n\x1aCMs\
    gDOTARedeemItemResponse\x12P\n\x08response\x18\x01\x20\x01(\x0e2'.CMsgDO\
    TARedeemItemResponse.EResultCode:\x0bk_SucceededR\x08response\",\n\x0bER\
    esultCode\x12\x0f\n\x0bk_Succeeded\x10\0\x12\x0c\n\x08k_Failed\x10\x01\"\
    @\n!CMsgPerfectWorldUserLookupRequest\x12\x1b\n\tuser_name\x18\x01\x20\
    \x01(\tR\x08userName\"\xdf\x02\n\"CMsgPerfectWorldUserLookupResponse\x12\
    g\n\x0bresult_code\x18\x01\x20\x01(\x0e2/.CMsgPerfectWorldUserLookupResp\
    onse.EResultCode:\x15SUCCESS_ACCOUNT_FOUNDR\nresultCode\x12\x1d\n\naccou\
    nt_id\x18\x02\x20\x01(\rR\taccountId\"\xb0\x01\n\x0bEResultCode\x12\x19\
    \n\x15SUCCESS_ACCOUNT_FOUND\x10\0\x12\x11\n\rERROR_UNKNOWN\x10\x01\x12\
    \x20\n\x1cERROR_USER_NAME_WRONG_FORMAT\x10\x02\x12(\n$ERROR_NO_PERFECT_W\
    ORLD_ACCOUNT_FOUND\x10\x03\x12'\n#ERROR_NO_LINKED_STEAM_ACCOUNT_FOUND\
    \x10\x04\"~\n\x16CMsgNexonPartnerUpdate\x12\x20\n\x0bmessagetype\x18\x01\
    \x20\x01(\rR\x0bmessagetype\x12$\n\rtimeremaining\x18\x02\x20\x01(\rR\rt\
    imeremaining\x12\x1c\n\tterminate\x18\x03\x20\x01(\x08R\tterminate\"+\n\
    \x10CMsgMakeOffering\x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06itemI\
    d\"\x16\n\x14CMsgRequestOfferings\"\xd4\x01\n\x1cCMsgRequestOfferingsRes\
    ponse\x12L\n\tofferings\x18\x01\x20\x03(\x0b2..CMsgRequestOfferingsRespo\
    nse.NewYearsOfferingR\tofferings\x12\x1c\n\tcompleted\x18\x02\x20\x01(\
    \x08R\tcompleted\x1aH\n\x10NewYearsOffering\x12\x1b\n\tdef_index\x18\x01\
    \x20\x01(\rR\x08defIndex\x12\x17\n\x07item_id\x18\x02\x20\x01(\x04R\x06i\
    temId\"o\n\x19CMsgDOTAPCBangTimedReward\x12\x18\n\x07persona\x18\x01\x20\
    \x01(\tR\x07persona\x12\x18\n\x07itemdef\x18\x02\x20\x01(\rR\x07itemdef\
    \x12\x1e\n\npcbangname\x18\x03\x20\x01(\tR\npcbangname\"\xb2\x02\n)CMsgD\
    OTACompendiumInGamePredictionResults\x12U\n\x07results\x18\x01\x20\x03(\
    \x0b2;.CMsgDOTACompendiumInGamePredictionResults.PredictionResultR\x07re\
    sults\x12\x1b\n\tleague_id\x18\x02\x20\x01(\rR\x08leagueId\x12-\n\x12pre\
    dictions_closed\x18\x03\x20\x01(\x08R\x11predictionsClosed\x1ab\n\x10Pre\
    dictionResult\x12#\n\rprediction_id\x18\x01\x20\x01(\rR\x0cpredictionId\
    \x12)\n\x10prediction_value\x18\x02\x20\x01(\rR\x0fpredictionValue\"\x87\
    \x02\n.CMsgClientToGCSelectCompendiumInGamePrediction\x12\x19\n\x08match\
    _id\x18\x01\x20\x01(\x04R\x07matchId\x12\\\n\x0bpredictions\x18\x02\x20\
    \x03(\x0b2:.CMsgClientToGCSelectCompendiumInGamePrediction.PredictionR\
    \x0bpredictions\x1a\\\n\nPrediction\x12#\n\rprediction_id\x18\x01\x20\
    \x01(\rR\x0cpredictionId\x12)\n\x10prediction_value\x18\x02\x20\x01(\rR\
    \x0fpredictionValue\"\xf2\x01\n6CMsgClientToGCSelectCompendiumInGamePred\
    ictionResponse\x12`\n\x06result\x18\x01\x20\x01(\x0e2?.CMsgClientToGCSel\
    ectCompendiumInGamePredictionResponse.EResult:\x07SUCCESSR\x06result\"V\
    \n\x07EResult\x12\x0b\n\x07SUCCESS\x10\0\x12\x11\n\rINVALID_MATCH\x10\
    \x01\x12\x1a\n\x16PREDICTIONS_ARE_CLOSED\x10\x02\x12\x0f\n\x0bOTHER_ERRO\
    R\x10\x03\"Z\n\x20CMsgClientToGCOpenPlayerCardPack\x126\n\x18player_card\
    _pack_item_id\x18\x01\x20\x01(\x04R\x14playerCardPackItemId\"\xb5\x02\n(\
    CMsgClientToGCOpenPlayerCardPackResponse\x12Q\n\x06result\x18\x01\x20\
    \x01(\x0e20.CMsgClientToGCOpenPlayerCardPackResponse.Result:\x07SUCCESSR\
    \x06result\x12/\n\x14player_card_item_ids\x18\x02\x20\x03(\x04R\x11playe\
    rCardItemIds\"\x84\x01\n\x06Result\x12\x0b\n\x07SUCCESS\x10\x01\x12\x12\
    \n\x0eERROR_INTERNAL\x10\x02\x12\x1d\n\x19ERROR_FAILED_TO_FIND_PACK\x10\
    \x03\x12\x1c\n\x18ERROR_ITEM_NOT_CARD_PACK\x10\x04\x12\x1c\n\x18ERROR_FA\
    ILED_CARD_CREATE\x10\x05\"m\n\x1fCMsgClientToGCRecyclePlayerCard\x12/\n\
    \x14player_card_item_ids\x18\x03\x20\x03(\x04R\x11playerCardItemIds\x12\
    \x19\n\x08event_id\x18\x02\x20\x01(\rR\x07eventId\"\xc8\x02\n'CMsgClient\
    ToGCRecyclePlayerCardResponse\x12P\n\x06result\x18\x01\x20\x01(\x0e2/.CM\
    sgClientToGCRecyclePlayerCardResponse.Result:\x07SUCCESSR\x06result\x12\
    \x1f\n\x0bdust_amount\x18\x02\x20\x01(\rR\ndustAmount\"\xa9\x01\n\x06Res\
    ult\x12\x0b\n\x07SUCCESS\x10\x01\x12\x12\n\x0eERROR_INTERNAL\x10\x02\x12\
    $\n\x20ERROR_FAILED_TO_FIND_PLAYER_CARD\x10\x03\x12\x1e\n\x1aERROR_ITEM_\
    NOT_PLAYER_CARD\x10\x04\x12!\n\x1dERROR_FAILED_DUST_CARD_CREATE\x10\x05\
    \x12\x15\n\x11ERROR_CARD_LOCKED\x10\x06\"\x8d\x01\n\"CMsgClientToGCCreat\
    ePlayerCardPack\x12)\n\x11card_dust_item_id\x18\x01\x20\x01(\x04R\x0ecar\
    dDustItemId\x12\x19\n\x08event_id\x18\x02\x20\x01(\rR\x07eventId\x12!\n\
    \x0cpremium_pack\x18\x03\x20\x01(\x08R\x0bpremiumPack\"\x8b\x02\n*CMsgCl\
    ientToGCCreatePlayerCardPackResponse\x12S\n\x06result\x18\x01\x20\x01(\
    \x0e22.CMsgClientToGCCreatePlayerCardPackResponse.Result:\x07SUCCESSR\
    \x06result\"\x87\x01\n\x06Result\x12\x0b\n\x07SUCCESS\x10\x01\x12\x12\n\
    \x0eERROR_INTERNAL\x10\x02\x12\x1b\n\x17ERROR_INSUFFICIENT_DUST\x10\x03\
    \x12\x1c\n\x18ERROR_ITEM_NOT_DUST_ITEM\x10\x04\x12!\n\x1dERROR_FAILED_CA\
    RD_PACK_CREATE\x10\x05\"\xdc\x0c\n0CMsgGCToClientBattlePassRollup_Intern\
    ational2016\x12*\n\x11battle_pass_level\x18\x01\x20\x01(\rR\x0fbattlePas\
    sLevel\x12\\\n\nquestlines\x18\x02\x20\x03(\x0b2<.CMsgGCToClientBattlePa\
    ssRollup_International2016.QuestlinesR\nquestlines\x12V\n\x08wagering\
    \x18\x03\x20\x01(\x0b2:.CMsgGCToClientBattlePassRollup_International2016\
    .WageringR\x08wagering\x12b\n\x0cachievements\x18\x04\x20\x01(\x0b2>.CMs\
    gGCToClientBattlePassRollup_International2016.AchievementsR\x0cachieveme\
    nts\x12Z\n\nbattle_cup\x18\x05\x20\x01(\x0b2;.CMsgGCToClientBattlePassRo\
    llup_International2016.BattleCupR\tbattleCup\x12_\n\x0bpredictions\x18\
    \x06\x20\x01(\x0b2=.CMsgGCToClientBattlePassRollup_International2016.Pre\
    dictionsR\x0bpredictions\x12S\n\x07bracket\x18\x07\x20\x01(\x0b29.CMsgGC\
    ToClientBattlePassRollup_International2016.BracketR\x07bracket\x12_\n\
    \x0cplayer_cards\x18\x08\x20\x03(\x0b2<.CMsgGCToClientBattlePassRollup_I\
    nternational2016.PlayerCardR\x0bplayerCards\x12o\n\x11fantasy_challenge\
    \x18\t\x20\x01(\x0b2B.CMsgGCToClientBattlePassRollup_International2016.F\
    antasyChallengeR\x10fantasyChallenge\x1a\x88\x01\n\nQuestlines\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\x18\n\x07onestar\x18\x02\x20\
    \x01(\rR\x07onestar\x12\x18\n\x07twostar\x18\x03\x20\x01(\rR\x07twostar\
    \x12\x1c\n\tthreestar\x18\x04\x20\x01(\rR\tthreestar\x12\x14\n\x05total\
    \x18\x05\x20\x01(\rR\x05total\x1a\xaf\x01\n\x08Wagering\x12#\n\rtotal_wa\
    gered\x18\x01\x20\x01(\rR\x0ctotalWagered\x12\x1b\n\ttotal_won\x18\x02\
    \x20\x01(\rR\x08totalWon\x12\x1f\n\x0baverage_won\x18\x03\x20\x01(\rR\na\
    verageWon\x12!\n\x0csuccess_rate\x18\x04\x20\x01(\rR\x0bsuccessRate\x12\
    \x1d\n\ntotal_tips\x18\x05\x20\x01(\rR\ttotalTips\x1aZ\n\x0cAchievements\
    \x12\x1c\n\tcompleted\x18\x01\x20\x01(\rR\tcompleted\x12\x14\n\x05total\
    \x18\x02\x20\x01(\rR\x05total\x12\x16\n\x06points\x18\x03\x20\x01(\rR\
    \x06points\x1a5\n\tBattleCup\x12\x12\n\x04wins\x18\x01\x20\x01(\rR\x04wi\
    ns\x12\x14\n\x05score\x18\x02\x20\x01(\rR\x05score\x1aU\n\x0bPredictions\
    \x12\x18\n\x07correct\x18\x01\x20\x01(\rR\x07correct\x12\x14\n\x05total\
    \x18\x02\x20\x01(\rR\x05total\x12\x16\n\x06points\x18\x03\x20\x01(\rR\
    \x06points\x1a;\n\x07Bracket\x12\x18\n\x07correct\x18\x01\x20\x01(\rR\
    \x07correct\x12\x16\n\x06points\x18\x02\x20\x01(\rR\x06points\x1aE\n\nPl\
    ayerCard\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x18\n\
    \x07quality\x18\x02\x20\x01(\rR\x07quality\x1aS\n\x10FantasyChallenge\
    \x12\x1f\n\x0btotal_score\x18\x01\x20\x01(\x02R\ntotalScore\x12\x1e\n\np\
    ercentile\x18\x02\x20\x01(\x02R\npercentile\"\x8b\x0c\n'CMsgGCToClientBa\
    ttlePassRollup_Fall2016\x12*\n\x11battle_pass_level\x18\x01\x20\x01(\rR\
    \x0fbattlePassLevel\x12S\n\nquestlines\x18\x02\x20\x03(\x0b23.CMsgGCToCl\
    ientBattlePassRollup_Fall2016.QuestlinesR\nquestlines\x12M\n\x08wagering\
    \x18\x03\x20\x01(\x0b21.CMsgGCToClientBattlePassRollup_Fall2016.Wagering\
    R\x08wagering\x12Y\n\x0cachievements\x18\x04\x20\x01(\x0b25.CMsgGCToClie\
    ntBattlePassRollup_Fall2016.AchievementsR\x0cachievements\x12Q\n\nbattle\
    _cup\x18\x05\x20\x01(\x0b22.CMsgGCToClientBattlePassRollup_Fall2016.Batt\
    leCupR\tbattleCup\x12V\n\x0bpredictions\x18\x06\x20\x01(\x0b24.CMsgGCToC\
    lientBattlePassRollup_Fall2016.PredictionsR\x0bpredictions\x12J\n\x07bra\
    cket\x18\x07\x20\x01(\x0b20.CMsgGCToClientBattlePassRollup_Fall2016.Brac\
    ketR\x07bracket\x12V\n\x0cplayer_cards\x18\x08\x20\x03(\x0b23.CMsgGCToCl\
    ientBattlePassRollup_Fall2016.PlayerCardR\x0bplayerCards\x12f\n\x11fanta\
    sy_challenge\x18\t\x20\x01(\x0b29.CMsgGCToClientBattlePassRollup_Fall201\
    6.FantasyChallengeR\x10fantasyChallenge\x1a\x88\x01\n\nQuestlines\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x18\n\x07onestar\x18\x02\
    \x20\x01(\rR\x07onestar\x12\x18\n\x07twostar\x18\x03\x20\x01(\rR\x07twos\
    tar\x12\x1c\n\tthreestar\x18\x04\x20\x01(\rR\tthreestar\x12\x14\n\x05tot\
    al\x18\x05\x20\x01(\rR\x05total\x1a\xaf\x01\n\x08Wagering\x12#\n\rtotal_\
    wagered\x18\x01\x20\x01(\rR\x0ctotalWagered\x12\x1b\n\ttotal_won\x18\x02\
    \x20\x01(\rR\x08totalWon\x12\x1f\n\x0baverage_won\x18\x03\x20\x01(\rR\na\
    verageWon\x12!\n\x0csuccess_rate\x18\x04\x20\x01(\rR\x0bsuccessRate\x12\
    \x1d\n\ntotal_tips\x18\x05\x20\x01(\rR\ttotalTips\x1aZ\n\x0cAchievements\
    \x12\x1c\n\tcompleted\x18\x01\x20\x01(\rR\tcompleted\x12\x14\n\x05total\
    \x18\x02\x20\x01(\rR\x05total\x12\x16\n\x06points\x18\x03\x20\x01(\rR\
    \x06points\x1a5\n\tBattleCup\x12\x12\n\x04wins\x18\x01\x20\x01(\rR\x04wi\
    ns\x12\x14\n\x05score\x18\x02\x20\x01(\rR\x05score\x1aU\n\x0bPredictions\
    \x12\x18\n\x07correct\x18\x01\x20\x01(\rR\x07correct\x12\x14\n\x05total\
    \x18\x02\x20\x01(\rR\x05total\x12\x16\n\x06points\x18\x03\x20\x01(\rR\
    \x06points\x1a;\n\x07Bracket\x12\x18\n\x07correct\x18\x01\x20\x01(\rR\
    \x07correct\x12\x16\n\x06points\x18\x02\x20\x01(\rR\x06points\x1aE\n\nPl\
    ayerCard\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x18\n\
    \x07quality\x18\x02\x20\x01(\rR\x07quality\x1aS\n\x10FantasyChallenge\
    \x12\x1f\n\x0btotal_score\x18\x01\x20\x01(\x02R\ntotalScore\x12\x1e\n\np\
    ercentile\x18\x02\x20\x01(\x02R\npercentile\"\x9d\x0c\n)CMsgGCToClientBa\
    ttlePassRollup_Winter2017\x12*\n\x11battle_pass_level\x18\x01\x20\x01(\r\
    R\x0fbattlePassLevel\x12U\n\nquestlines\x18\x02\x20\x03(\x0b25.CMsgGCToC\
    lientBattlePassRollup_Winter2017.QuestlinesR\nquestlines\x12O\n\x08wager\
    ing\x18\x03\x20\x01(\x0b23.CMsgGCToClientBattlePassRollup_Winter2017.Wag\
    eringR\x08wagering\x12[\n\x0cachievements\x18\x04\x20\x01(\x0b27.CMsgGCT\
    oClientBattlePassRollup_Winter2017.AchievementsR\x0cachievements\x12S\n\
    \nbattle_cup\x18\x05\x20\x01(\x0b24.CMsgGCToClientBattlePassRollup_Winte\
    r2017.BattleCupR\tbattleCup\x12X\n\x0bpredictions\x18\x06\x20\x01(\x0b26\
    .CMsgGCToClientBattlePassRollup_Winter2017.PredictionsR\x0bpredictions\
    \x12L\n\x07bracket\x18\x07\x20\x01(\x0b22.CMsgGCToClientBattlePassRollup\
    _Winter2017.BracketR\x07bracket\x12X\n\x0cplayer_cards\x18\x08\x20\x03(\
    \x0b25.CMsgGCToClientBattlePassRollup_Winter2017.PlayerCardR\x0bplayerCa\
    rds\x12h\n\x11fantasy_challenge\x18\t\x20\x01(\x0b2;.CMsgGCToClientBattl\
    ePassRollup_Winter2017.FantasyChallengeR\x10fantasyChallenge\x1a\x88\x01\
    \n\nQuestlines\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x18\n\
    \x07onestar\x18\x02\x20\x01(\rR\x07onestar\x12\x18\n\x07twostar\x18\x03\
    \x20\x01(\rR\x07twostar\x12\x1c\n\tthreestar\x18\x04\x20\x01(\rR\tthrees\
    tar\x12\x14\n\x05total\x18\x05\x20\x01(\rR\x05total\x1a\xaf\x01\n\x08Wag\
    ering\x12#\n\rtotal_wagered\x18\x01\x20\x01(\rR\x0ctotalWagered\x12\x1b\
    \n\ttotal_won\x18\x02\x20\x01(\rR\x08totalWon\x12\x1f\n\x0baverage_won\
    \x18\x03\x20\x01(\rR\naverageWon\x12!\n\x0csuccess_rate\x18\x04\x20\x01(\
    \rR\x0bsuccessRate\x12\x1d\n\ntotal_tips\x18\x05\x20\x01(\rR\ttotalTips\
    \x1aZ\n\x0cAchievements\x12\x1c\n\tcompleted\x18\x01\x20\x01(\rR\tcomple\
    ted\x12\x14\n\x05total\x18\x02\x20\x01(\rR\x05total\x12\x16\n\x06points\
    \x18\x03\x20\x01(\rR\x06points\x1a5\n\tBattleCup\x12\x12\n\x04wins\x18\
    \x01\x20\x01(\rR\x04wins\x12\x14\n\x05score\x18\x02\x20\x01(\rR\x05score\
    \x1aU\n\x0bPredictions\x12\x18\n\x07correct\x18\x01\x20\x01(\rR\x07corre\
    ct\x12\x14\n\x05total\x18\x02\x20\x01(\rR\x05total\x12\x16\n\x06points\
    \x18\x03\x20\x01(\rR\x06points\x1a;\n\x07Bracket\x12\x18\n\x07correct\
    \x18\x01\x20\x01(\rR\x07correct\x12\x16\n\x06points\x18\x02\x20\x01(\rR\
    \x06points\x1aE\n\nPlayerCard\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\
    \taccountId\x12\x18\n\x07quality\x18\x02\x20\x01(\rR\x07quality\x1aS\n\
    \x10FantasyChallenge\x12\x1f\n\x0btotal_score\x18\x01\x20\x01(\x02R\ntot\
    alScore\x12\x1e\n\npercentile\x18\x02\x20\x01(\x02R\npercentile\"a\n%CMs\
    gGCToClientBattlePassRollupRequest\x12\x19\n\x08event_id\x18\x01\x20\x01\
    (\rR\x07eventId\x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\taccountId\"\
    \xa0\x02\n&CMsgGCToClientBattlePassRollupResponse\x12N\n\tevent_ti6\x18\
    \x01\x20\x01(\x0b21.CMsgGCToClientBattlePassRollup_International2016R\
    \x08eventTi6\x12O\n\x0eevent_fall2016\x18\x02\x20\x01(\x0b2(.CMsgGCToCli\
    entBattlePassRollup_Fall2016R\reventFall2016\x12U\n\x10event_winter2017\
    \x18\x03\x20\x01(\x0b2*.CMsgGCToClientBattlePassRollup_Winter2017R\x0fev\
    entWinter2017\"J\n)CMsgGCToClientBattlePassRollupListRequest\x12\x1d\n\n\
    account_id\x18\x01\x20\x01(\rR\taccountId\"G\n*CMsgGCToClientBattlePassR\
    ollupListResponse\x12\x19\n\x08event_id\x18\x01\x20\x03(\rR\x07eventId\"\
    E\n(CMsgClientToGCTransferSeasonalMMRRequest\x12\x19\n\x08is_party\x18\
    \x01\x20\x01(\x08R\x07isParty\"E\n)CMsgClientToGCTransferSeasonalMMRResp\
    onse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\"6\n\x1cCMsgG\
    CToClientPlaytestStatus\x12\x16\n\x06active\x18\x01\x20\x01(\x08R\x06act\
    ive\"C\n\x1aCMsgClientToGCJoinPlaytest\x12%\n\x0eclient_version\x18\x01\
    \x20\x01(\rR\rclientVersion\":\n\"CMsgClientToGCJoinPlaytestResponse\x12\
    \x14\n\x05error\x18\x01\x20\x01(\tR\x05error\"\xcc\x02\n\x13CMsgDOTAEven\
    tInvite\x12/\n\x05teams\x18\x01\x20\x03(\x0b2\x19.CMsgDOTAEventInvite.Te\
    amR\x05teams\x1a\x83\x02\n\x04Team\x12\x17\n\x07team_id\x18\x01\x20\x01(\
    \rR\x06teamId\x12+\n\x11announcement_date\x18\x02\x20\x01(\rR\x10announc\
    ementDate\x12\x1b\n\tteam_name\x18\x03\x20\x01(\tR\x08teamName\x12U\n\
    \x0binvite_type\x18\x04\x20\x01(\x0e2\x15.EDOTAEventInviteType:\x1dk_EDO\
    TAEventInviteType_DirectR\ninviteType\x12\x16\n\x06region\x18\x05\x20\
    \x01(\rR\x06region\x12)\n\x10qualifier_winner\x18\x06\x20\x01(\x08R\x0fq\
    ualifierWinner\"M\n\x17CMsgDOTASetFavoriteTeam\x12\x17\n\x07team_id\x18\
    \x01\x20\x01(\rR\x06teamId\x12\x19\n\x08event_id\x18\x02\x20\x01(\rR\x07\
    eventId\"\xba\x02\n\x16CMsgDOTATriviaQuestion\x12\x1f\n\x0bquestion_id\
    \x18\x01\x20\x01(\rR\nquestionId\x12c\n\x08category\x18\x02\x20\x01(\x0e\
    2\x1c.EDOTATriviaQuestionCategory:)k_EDOTATriviaQuestionCategory_Ability\
    IconR\x08category\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\rR\ttimestamp\
    \x12%\n\x0equestion_value\x18\x04\x20\x01(\tR\rquestionValue\x12#\n\rans\
    wer_values\x18\x05\x20\x03(\tR\x0canswerValues\x120\n\x14correct_answer_\
    index\x18\x06\x20\x01(\rR\x12correctAnswerIndex\"~\n\x1eCMsgDOTATriviaCu\
    rrentQuestions\x125\n\tquestions\x18\x01\x20\x03(\x0b2\x17.CMsgDOTATrivi\
    aQuestionR\tquestions\x12%\n\x0etrivia_enabled\x18\x02\x20\x01(\x08R\rtr\
    iviaEnabled\"v\n$CMsgDOTATriviaQuestionAnswersSummary\x12+\n\x11summary_\
    available\x18\x01\x20\x01(\x08R\x10summaryAvailable\x12!\n\x0cpicked_cou\
    nt\x18\x02\x20\x03(\rR\x0bpickedCount\"h\n\"CMsgDOTASubmitTriviaQuestion\
    Answer\x12\x1f\n\x0bquestion_id\x18\x01\x20\x01(\rR\nquestionId\x12!\n\
    \x0canswer_index\x18\x02\x20\x01(\rR\x0banswerIndex\"\x81\x01\n*CMsgDOTA\
    SubmitTriviaQuestionAnswerResponse\x12S\n\x06result\x18\x01\x20\x01(\x0e\
    2\x18.EDOTATriviaAnswerResult:!k_EDOTATriviaAnswerResult_SuccessR\x06res\
    ult\"\x1c\n\x1aCMsgDOTAStartTriviaSession\"x\n\"CMsgDOTAStartTriviaSessi\
    onResponse\x12%\n\x0etrivia_enabled\x18\x01\x20\x01(\x08R\rtriviaEnabled\
    \x12+\n\x11current_timestamp\x18\x02\x20\x01(\rR\x10currentTimestamp\"\
    \x7f\n\x15CMsgClientToGCGiveTip\x120\n\x14recipient_account_id\x18\x01\
    \x20\x01(\rR\x12recipientAccountId\x12\x19\n\x08match_id\x18\x02\x20\x01\
    (\x04R\x07matchId\x12\x19\n\x08event_id\x18\x03\x20\x01(\rR\x07eventId\"\
    \xcf\x02\n\x1dCMsgClientToGCGiveTipResponse\x12F\n\x06result\x18\x01\x20\
    \x01(\x0e2%.CMsgClientToGCGiveTipResponse.Result:\x07SUCCESSR\x06result\
    \"\xe5\x01\n\x06Result\x12\x0b\n\x07SUCCESS\x10\0\x12\x18\n\x14ERROR_ALR\
    EADY_TIPPED\x10\x01\x12\x1a\n\x16ERROR_INVALID_MATCH_ID\x10\x02\x12\x1a\
    \n\x16ERROR_INVALID_EVENT_ID\x10\x03\x12\x1c\n\x18ERROR_INVALID_MATCH_TI\
    ME\x10\x04\x12\x14\n\x10ERROR_NOT_WINNER\x10\x05\x12\x17\n\x13ERROR_UNOW\
    NED_EVENT\x10\x06\x12\x1c\n\x18ERROR_INVALID_LOBBY_TYPE\x10\x07\x12\x11\
    \n\rERROR_UNKNOWN\x10\x08\"\"\n\x20CMsgDOTAAnchorPhoneNumberRequest\"\
    \xe8\x01\n!CMsgDOTAAnchorPhoneNumberResponse\x12J\n\x06result\x18\x01\
    \x20\x01(\x0e2).CMsgDOTAAnchorPhoneNumberResponse.Result:\x07SUCCESSR\
    \x06result\"w\n\x06Result\x12\x0b\n\x07SUCCESS\x10\0\x12\x11\n\rERROR_UN\
    KNOWN\x10\x01\x12\x18\n\x14ERROR_NO_STEAM_PHONE\x10\x02\x12\x18\n\x14ERR\
    OR_ALREADY_IN_USE\x10\x03\x12\x19\n\x15ERROR_COOLDOWN_ACTIVE\x10\x04\"$\
    \n\"CMsgDOTAUnanchorPhoneNumberRequest\"\x9d\x01\n#CMsgDOTAUnanchorPhone\
    NumberResponse\x12L\n\x06result\x18\x01\x20\x01(\x0e2+.CMsgDOTAUnanchorP\
    honeNumberResponse.Result:\x07SUCCESSR\x06result\"(\n\x06Result\x12\x0b\
    \n\x07SUCCESS\x10\0\x12\x11\n\rERROR_UNKNOWN\x10\x01\"\xe0\x01\n\x1dCMsg\
    GCToClientTipNotification\x12*\n\x11tipper_account_id\x18\x01\x20\x01(\r\
    R\x0ftipperAccountId\x12\x1f\n\x0btipper_name\x18\x02\x20\x01(\tR\ntippe\
    rName\x120\n\x14recipient_account_id\x18\x03\x20\x01(\rR\x12recipientAcc\
    ountId\x12%\n\x0erecipient_name\x18\x04\x20\x01(\tR\rrecipientName\x12\
    \x19\n\x08event_id\x18\x05\x20\x01(\rR\x07eventId\">\n!CMsgGCToClientAll\
    StarVotesRequest\x12\x19\n\x08event_id\x18\x01\x20\x01(\rR\x07eventId\"O\
    \n\x1fCMsgGCToClientAllStarVotesReply\x12,\n\x12player_account_ids\x18\
    \x01\x20\x03(\rR\x10playerAccountIds\"k\n\x20CMsgGCToClientAllStarVotesS\
    ubmit\x12\x19\n\x08event_id\x18\x01\x20\x01(\rR\x07eventId\x12,\n\x12pla\
    yer_account_ids\x18\x02\x20\x03(\rR\x10playerAccountIds\"\xfa\x01\n%CMsg\
    GCToClientAllStarVotesSubmitReply\x12N\n\x06result\x18\x01\x20\x01(\x0e2\
    -.CMsgGCToClientAllStarVotesSubmitReply.Result:\x07SUCCESSR\x06result\"\
    \x80\x01\n\x06Result\x12\x0b\n\x07SUCCESS\x10\x01\x12\x12\n\x0eERROR_INT\
    ERNAL\x10\x02\x12\x1a\n\x16ERROR_INVALID_EVENT_ID\x10\x03\x12\x1c\n\x18E\
    RROR_INVALID_ACCOUNT_ID\x10\x04\x12\x1b\n\x17ERROR_SELECTIONS_LOCKED\x10\
    \x05\"\xa0\x01\n#CMsgDOTAClientToGCQuickStatsRequest\x12*\n\x11player_ac\
    count_id\x18\x01\x20\x01(\rR\x0fplayerAccountId\x12\x17\n\x07hero_id\x18\
    \x02\x20\x01(\rR\x06heroId\x12\x17\n\x07item_id\x18\x03\x20\x01(\rR\x06i\
    temId\x12\x1b\n\tleague_id\x18\x04\x20\x01(\rR\x08leagueId\"\x9d\x06\n$C\
    MsgDOTAClientToGCQuickStatsResponse\x12O\n\x10original_request\x18\x01\
    \x20\x01(\x0b2$.CMsgDOTAClientToGCQuickStatsRequestR\x0foriginalRequest\
    \x12P\n\nhero_stats\x18\x02\x20\x01(\x0b21.CMsgDOTAClientToGCQuickStatsR\
    esponse.SimpleStatsR\theroStats\x12P\n\nitem_stats\x18\x03\x20\x01(\x0b2\
    1.CMsgDOTAClientToGCQuickStatsResponse.SimpleStatsR\titemStats\x12Y\n\
    \x0fitem_hero_stats\x18\x04\x20\x01(\x0b21.CMsgDOTAClientToGCQuickStatsR\
    esponse.SimpleStatsR\ritemHeroStats\x12]\n\x11item_player_stats\x18\x05\
    \x20\x01(\x0b21.CMsgDOTAClientToGCQuickStatsResponse.SimpleStatsR\x0fite\
    mPlayerStats\x12]\n\x11hero_player_stats\x18\x06\x20\x01(\x0b21.CMsgDOTA\
    ClientToGCQuickStatsResponse.SimpleStatsR\x0fheroPlayerStats\x12W\n\x0ef\
    ull_set_stats\x18\x07\x20\x01(\x0b21.CMsgDOTAClientToGCQuickStatsRespons\
    e.SimpleStatsR\x0cfullSetStats\x1a\x8d\x01\n\x0bSimpleStats\x12\x1f\n\
    \x0bwin_percent\x18\x01\x20\x01(\x02R\nwinPercent\x12!\n\x0cpick_percent\
    \x18\x02\x20\x01(\x02R\x0bpickPercent\x12\x1b\n\twin_count\x18\x03\x20\
    \x01(\rR\x08winCount\x12\x1d\n\npick_count\x18\x04\x20\x01(\rR\tpickCoun\
    t\"\x85\x01\n&CMsgDOTASelectionPriorityChoiceRequest\x12[\n\x06choice\
    \x18\x01\x20\x01(\x0e2\x1c.DOTASelectionPriorityChoice:%k_DOTASelectionP\
    riorityChoice_InvalidR\x06choice\"\xa5\x01\n'CMsgDOTASelectionPriorityCh\
    oiceResponse\x12P\n\x06result\x18\x01\x20\x01(\x0e2/.CMsgDOTASelectionPr\
    iorityChoiceResponse.Result:\x07SUCCESSR\x06result\"(\n\x06Result\x12\
    \x0b\n\x07SUCCESS\x10\0\x12\x11\n\rERROR_UNKNOWN\x10\x01\"8\n\x1bCMsgDOT\
    AGameAutographReward\x12\x19\n\x08badge_id\x18\x01\x20\x01(\tR\x07badgeI\
    d\"\x9d\x01\n#CMsgDOTAGameAutographRewardResponse\x12L\n\x06result\x18\
    \x01\x20\x01(\x0e2+.CMsgDOTAGameAutographRewardResponse.Result:\x07SUCCE\
    SSR\x06result\"(\n\x06Result\x12\x0b\n\x07SUCCESS\x10\0\x12\x11\n\rERROR\
    _UNKNOWN\x10\x01*V\n\x14DOTA_WatchReplayType\x12\x1c\n\x18DOTA_WATCH_REP\
    LAY_NORMAL\x10\0\x12\x20\n\x1cDOTA_WATCH_REPLAY_HIGHLIGHTS\x10\x01*\xd1\
    \x01\n\x1cEItemEditorReservationResult\x12%\n!k_EItemEditorReservationRe\
    sult_OK\x10\x01\x120\n,k_EItemEditorReservationResult_AlreadyExists\x10\
    \x02\x12+\n'k_EItemEditorReservationResult_Reserved\x10\x03\x12+\n'k_EIt\
    emEditorReservationResult_TimedOut\x10\x04*\x92\x04\n\x16EFeaturedHeroTe\
    xtField\x12$\n\x20k_EFeaturedHeroTextField_NewHero\x10\0\x12$\n\x20k_EFe\
    aturedHeroTextField_NewItem\x10\x01\x12/\n+k_EFeaturedHeroTextField_Item\
    SetDescription\x10\x02\x12,\n(k_EFeaturedHeroTextField_ItemDescription\
    \x10\x03\x12!\n\x1dk_EFeaturedHeroTextField_Hype\x10\x04\x12(\n$k_EFeatu\
    redHeroTextField_HeroWinLoss\x10\x05\x121\n-k_EFeaturedHeroTextField_Fre\
    quentlyPlayedHero\x10\x06\x12)\n%k_EFeaturedHeroTextField_FeaturedItem\
    \x10\x07\x12(\n$k_EFeaturedHeroTextField_PopularItem\x10\x08\x12%\n!k_EF\
    eaturedHeroTextField_SaleItem\x10\t\x12)\n%k_EFeaturedHeroTextField_Sale\
    Discount\x10\n\x12&\n\"k_EFeaturedHeroTextField_Container\x10\x0b*\x87\
    \x03\n\x15EFeaturedHeroDataType\x12\"\n\x1ek_EFeaturedHeroDataType_HeroI\
    D\x10\0\x12#\n\x1fk_EFeaturedHeroDataType_ItemDef\x10\x01\x12&\n\"k_EFea\
    turedHeroDataType_HypeString\x10\x02\x12*\n&k_EFeaturedHeroDataType_Star\
    tTimestamp\x10\x03\x12+\n'k_EFeaturedHeroDataType_ExpireTimestamp\x10\
    \x04\x12$\n\x20k_EFeaturedHeroDataType_HeroWins\x10\x05\x12&\n\"k_EFeatu\
    redHeroDataType_HeroLosses\x10\x06\x12(\n$k_EFeaturedHeroDataType_SaleDi\
    scount\x10\x07\x12,\n(k_EFeaturedHeroDataType_ContainerItemDef\x10\x08*\
    \xe8\x01\n\x20EWeekendTourneyRichPresenceEvent\x12+\n'k_EWeekendTourneyR\
    ichPresenceEvent_None\x10\0\x123\n/k_EWeekendTourneyRichPresenceEvent_St\
    artedMatch\x10\x01\x12/\n+k_EWeekendTourneyRichPresenceEvent_WonMatch\
    \x10\x02\x121\n-k_EWeekendTourneyRichPresenceEvent_Eliminated\x10\x03*\
    \x8c\x01\n\x14EDOTAEventInviteType\x12!\n\x1dk_EDOTAEventInviteType_Dire\
    ct\x10\0\x12(\n$k_EDOTAEventInviteType_OpenQualifier\x10\x01\x12'\n#k_ED\
    OTAEventInviteType_ChampionsCup\x10\x02*\xc2\x05\n\x1bEDOTATriviaQuestio\
    nCategory\x12-\n)k_EDOTATriviaQuestionCategory_AbilityIcon\x10\0\x121\n-\
    k_EDOTATriviaQuestionCategory_AbilityCooldown\x10\x01\x120\n,k_EDOTATriv\
    iaQuestionCategory_HeroAttributes\x10\x02\x123\n/k_EDOTATriviaQuestionCa\
    tegory_HeroMovementSpeed\x10\x03\x12,\n(k_EDOTATriviaQuestionCategory_Ta\
    lentTree\x10\x04\x12+\n'k_EDOTATriviaQuestionCategory_HeroStats\x10\x05\
    \x12+\n'k_EDOTATriviaQuestionCategory_ItemPrice\x10\x06\x12.\n*k_EDOTATr\
    iviaQuestionCategory_AbilitySound\x10\x07\x12/\n+k_EDOTATriviaQuestionCa\
    tegory_InvokerSpells\x10\x08\x121\n-k_EDOTATriviaQuestionCategory_Abilit\
    yManaCost\x10\t\x121\n-k_EDOTATriviaQuestionCategory_HeroAttackSound\x10\
    \n\x12-\n)k_EDOTATriviaQuestionCategory_AbilityName\x10\x0b\x120\n,k_EDO\
    TATriviaQuestionCategory_ItemComponents\x10\x0c\x12*\n&k_EDOTATriviaQues\
    tionCategory_ItemLore\x10\r*\xa7\x02\n\x17EDOTATriviaAnswerResult\x12%\n\
    !k_EDOTATriviaAnswerResult_Success\x10\0\x12-\n)k_EDOTATriviaAnswerResul\
    t_InvalidQuestion\x10\x01\x12+\n'k_EDOTATriviaAnswerResult_InvalidAnswer\
    \x10\x02\x12,\n(k_EDOTATriviaAnswerResult_QuestionLocked\x10\x03\x12-\n)\
    k_EDOTATriviaAnswerResult_AlreadyAnswered\x10\x04\x12,\n(k_EDOTATriviaAn\
    swerResult_TriviaDisabled\x10\x05B\x05H\x01\x80\x01\0\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
