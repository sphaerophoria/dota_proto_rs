// This file is generated. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct CMsgApplyAutograph {
    // message fields
    autograph_item_id: ::std::option::Option<u64>,
    item_item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgApplyAutograph {}

impl CMsgApplyAutograph {
    pub fn new() -> CMsgApplyAutograph {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgApplyAutograph {
        static mut instance: ::protobuf::lazy::Lazy<CMsgApplyAutograph> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgApplyAutograph,
        };
        unsafe {
            instance.get(CMsgApplyAutograph::new)
        }
    }

    // optional uint64 autograph_item_id = 1;

    pub fn clear_autograph_item_id(&mut self) {
        self.autograph_item_id = ::std::option::Option::None;
    }

    pub fn has_autograph_item_id(&self) -> bool {
        self.autograph_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autograph_item_id(&mut self, v: u64) {
        self.autograph_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_autograph_item_id(&self) -> u64 {
        self.autograph_item_id.unwrap_or(0)
    }

    fn get_autograph_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.autograph_item_id
    }

    fn mut_autograph_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.autograph_item_id
    }

    // optional uint64 item_item_id = 2;

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    fn get_item_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_item_id
    }

    fn mut_item_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_item_id
    }
}

impl ::protobuf::Message for CMsgApplyAutograph {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.autograph_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.autograph_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.autograph_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgApplyAutograph {
    fn new() -> CMsgApplyAutograph {
        CMsgApplyAutograph::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgApplyAutograph>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "autograph_item_id",
                    CMsgApplyAutograph::get_autograph_item_id_for_reflect,
                    CMsgApplyAutograph::mut_autograph_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_item_id",
                    CMsgApplyAutograph::get_item_item_id_for_reflect,
                    CMsgApplyAutograph::mut_item_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgApplyAutograph>(
                    "CMsgApplyAutograph",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgApplyAutograph {
    fn clear(&mut self) {
        self.clear_autograph_item_id();
        self.clear_item_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgApplyAutograph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyAutograph {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgAdjustItemEquippedState {
    // message fields
    item_id: ::std::option::Option<u64>,
    new_class: ::std::option::Option<u32>,
    new_slot: ::std::option::Option<u32>,
    style_index: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgAdjustItemEquippedState {}

impl CMsgAdjustItemEquippedState {
    pub fn new() -> CMsgAdjustItemEquippedState {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgAdjustItemEquippedState {
        static mut instance: ::protobuf::lazy::Lazy<CMsgAdjustItemEquippedState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgAdjustItemEquippedState,
        };
        unsafe {
            instance.get(CMsgAdjustItemEquippedState::new)
        }
    }

    // optional uint64 item_id = 1;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }

    // optional uint32 new_class = 2;

    pub fn clear_new_class(&mut self) {
        self.new_class = ::std::option::Option::None;
    }

    pub fn has_new_class(&self) -> bool {
        self.new_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_class(&mut self, v: u32) {
        self.new_class = ::std::option::Option::Some(v);
    }

    pub fn get_new_class(&self) -> u32 {
        self.new_class.unwrap_or(0)
    }

    fn get_new_class_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.new_class
    }

    fn mut_new_class_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.new_class
    }

    // optional uint32 new_slot = 3;

    pub fn clear_new_slot(&mut self) {
        self.new_slot = ::std::option::Option::None;
    }

    pub fn has_new_slot(&self) -> bool {
        self.new_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_slot(&mut self, v: u32) {
        self.new_slot = ::std::option::Option::Some(v);
    }

    pub fn get_new_slot(&self) -> u32 {
        self.new_slot.unwrap_or(0)
    }

    fn get_new_slot_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.new_slot
    }

    fn mut_new_slot_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.new_slot
    }

    // optional uint32 style_index = 4;

    pub fn clear_style_index(&mut self) {
        self.style_index = ::std::option::Option::None;
    }

    pub fn has_style_index(&self) -> bool {
        self.style_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_index(&mut self, v: u32) {
        self.style_index = ::std::option::Option::Some(v);
    }

    pub fn get_style_index(&self) -> u32 {
        self.style_index.unwrap_or(0)
    }

    fn get_style_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.style_index
    }

    fn mut_style_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.style_index
    }
}

impl ::protobuf::Message for CMsgAdjustItemEquippedState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.new_class = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.new_slot = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.style_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.new_class {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.new_slot {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.style_index {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.new_class {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.new_slot {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.style_index {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgAdjustItemEquippedState {
    fn new() -> CMsgAdjustItemEquippedState {
        CMsgAdjustItemEquippedState::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgAdjustItemEquippedState>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgAdjustItemEquippedState::get_item_id_for_reflect,
                    CMsgAdjustItemEquippedState::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "new_class",
                    CMsgAdjustItemEquippedState::get_new_class_for_reflect,
                    CMsgAdjustItemEquippedState::mut_new_class_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "new_slot",
                    CMsgAdjustItemEquippedState::get_new_slot_for_reflect,
                    CMsgAdjustItemEquippedState::mut_new_slot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "style_index",
                    CMsgAdjustItemEquippedState::get_style_index_for_reflect,
                    CMsgAdjustItemEquippedState::mut_style_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgAdjustItemEquippedState>(
                    "CMsgAdjustItemEquippedState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgAdjustItemEquippedState {
    fn clear(&mut self) {
        self.clear_item_id();
        self.clear_new_class();
        self.clear_new_slot();
        self.clear_style_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAdjustItemEquippedState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAdjustItemEquippedState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgEconPlayerStrangeCountAdjustment {
    // message fields
    account_id: ::std::option::Option<u32>,
    strange_count_adjustments: ::protobuf::RepeatedField<CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgEconPlayerStrangeCountAdjustment {}

impl CMsgEconPlayerStrangeCountAdjustment {
    pub fn new() -> CMsgEconPlayerStrangeCountAdjustment {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgEconPlayerStrangeCountAdjustment {
        static mut instance: ::protobuf::lazy::Lazy<CMsgEconPlayerStrangeCountAdjustment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgEconPlayerStrangeCountAdjustment,
        };
        unsafe {
            instance.get(CMsgEconPlayerStrangeCountAdjustment::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // repeated .CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment strange_count_adjustments = 2;

    pub fn clear_strange_count_adjustments(&mut self) {
        self.strange_count_adjustments.clear();
    }

    // Param is passed by value, moved
    pub fn set_strange_count_adjustments(&mut self, v: ::protobuf::RepeatedField<CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment>) {
        self.strange_count_adjustments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_strange_count_adjustments(&mut self) -> &mut ::protobuf::RepeatedField<CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment> {
        &mut self.strange_count_adjustments
    }

    // Take field
    pub fn take_strange_count_adjustments(&mut self) -> ::protobuf::RepeatedField<CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment> {
        ::std::mem::replace(&mut self.strange_count_adjustments, ::protobuf::RepeatedField::new())
    }

    pub fn get_strange_count_adjustments(&self) -> &[CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment] {
        &self.strange_count_adjustments
    }

    fn get_strange_count_adjustments_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment> {
        &self.strange_count_adjustments
    }

    fn mut_strange_count_adjustments_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment> {
        &mut self.strange_count_adjustments
    }
}

impl ::protobuf::Message for CMsgEconPlayerStrangeCountAdjustment {
    fn is_initialized(&self) -> bool {
        for v in &self.strange_count_adjustments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.strange_count_adjustments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.strange_count_adjustments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.strange_count_adjustments {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgEconPlayerStrangeCountAdjustment {
    fn new() -> CMsgEconPlayerStrangeCountAdjustment {
        CMsgEconPlayerStrangeCountAdjustment::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgEconPlayerStrangeCountAdjustment>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgEconPlayerStrangeCountAdjustment::get_account_id_for_reflect,
                    CMsgEconPlayerStrangeCountAdjustment::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment>>(
                    "strange_count_adjustments",
                    CMsgEconPlayerStrangeCountAdjustment::get_strange_count_adjustments_for_reflect,
                    CMsgEconPlayerStrangeCountAdjustment::mut_strange_count_adjustments_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgEconPlayerStrangeCountAdjustment>(
                    "CMsgEconPlayerStrangeCountAdjustment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgEconPlayerStrangeCountAdjustment {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_strange_count_adjustments();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgEconPlayerStrangeCountAdjustment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgEconPlayerStrangeCountAdjustment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
    // message fields
    event_type: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u64>,
    adjustment: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {}

impl CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
    pub fn new() -> CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
        static mut instance: ::protobuf::lazy::Lazy<CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment,
        };
        unsafe {
            instance.get(CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment::new)
        }
    }

    // optional uint32 event_type = 1;

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    pub fn get_event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }

    fn get_event_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_type
    }

    fn mut_event_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_type
    }

    // optional uint64 item_id = 2;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }

    // optional uint32 adjustment = 3;

    pub fn clear_adjustment(&mut self) {
        self.adjustment = ::std::option::Option::None;
    }

    pub fn has_adjustment(&self) -> bool {
        self.adjustment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adjustment(&mut self, v: u32) {
        self.adjustment = ::std::option::Option::Some(v);
    }

    pub fn get_adjustment(&self) -> u32 {
        self.adjustment.unwrap_or(0)
    }

    fn get_adjustment_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.adjustment
    }

    fn mut_adjustment_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.adjustment
    }
}

impl ::protobuf::Message for CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.adjustment = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.adjustment {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.adjustment {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
    fn new() -> CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
        CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_type",
                    CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment::get_event_type_for_reflect,
                    CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment::mut_event_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment::get_item_id_for_reflect,
                    CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "adjustment",
                    CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment::get_adjustment_for_reflect,
                    CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment::mut_adjustment_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment>(
                    "CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
    fn clear(&mut self) {
        self.clear_event_type();
        self.clear_item_id();
        self.clear_adjustment();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestItemPurgatory_FinalizePurchase {
    // message fields
    item_ids: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgRequestItemPurgatory_FinalizePurchase {}

impl CMsgRequestItemPurgatory_FinalizePurchase {
    pub fn new() -> CMsgRequestItemPurgatory_FinalizePurchase {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgRequestItemPurgatory_FinalizePurchase {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRequestItemPurgatory_FinalizePurchase> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRequestItemPurgatory_FinalizePurchase,
        };
        unsafe {
            instance.get(CMsgRequestItemPurgatory_FinalizePurchase::new)
        }
    }

    // repeated uint64 item_ids = 1;

    pub fn clear_item_ids(&mut self) {
        self.item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }

    // Take field
    pub fn take_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.item_ids, ::std::vec::Vec::new())
    }

    pub fn get_item_ids(&self) -> &[u64] {
        &self.item_ids
    }

    fn get_item_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.item_ids
    }

    fn mut_item_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }
}

impl ::protobuf::Message for CMsgRequestItemPurgatory_FinalizePurchase {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.item_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgRequestItemPurgatory_FinalizePurchase {
    fn new() -> CMsgRequestItemPurgatory_FinalizePurchase {
        CMsgRequestItemPurgatory_FinalizePurchase::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgRequestItemPurgatory_FinalizePurchase>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_ids",
                    CMsgRequestItemPurgatory_FinalizePurchase::get_item_ids_for_reflect,
                    CMsgRequestItemPurgatory_FinalizePurchase::mut_item_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRequestItemPurgatory_FinalizePurchase>(
                    "CMsgRequestItemPurgatory_FinalizePurchase",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgRequestItemPurgatory_FinalizePurchase {
    fn clear(&mut self) {
        self.clear_item_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestItemPurgatory_FinalizePurchase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestItemPurgatory_FinalizePurchase {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    // message fields
    result: ::std::option::Option<u32>,
    item_ids: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgRequestItemPurgatory_FinalizePurchaseResponse {}

impl CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    pub fn new() -> CMsgRequestItemPurgatory_FinalizePurchaseResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgRequestItemPurgatory_FinalizePurchaseResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRequestItemPurgatory_FinalizePurchaseResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRequestItemPurgatory_FinalizePurchaseResponse,
        };
        unsafe {
            instance.get(CMsgRequestItemPurgatory_FinalizePurchaseResponse::new)
        }
    }

    // optional uint32 result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.result
    }

    // repeated uint64 item_ids = 2;

    pub fn clear_item_ids(&mut self) {
        self.item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }

    // Take field
    pub fn take_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.item_ids, ::std::vec::Vec::new())
    }

    pub fn get_item_ids(&self) -> &[u64] {
        &self.item_ids
    }

    fn get_item_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.item_ids
    }

    fn mut_item_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }
}

impl ::protobuf::Message for CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.item_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.item_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        for v in &self.item_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    fn new() -> CMsgRequestItemPurgatory_FinalizePurchaseResponse {
        CMsgRequestItemPurgatory_FinalizePurchaseResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgRequestItemPurgatory_FinalizePurchaseResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "result",
                    CMsgRequestItemPurgatory_FinalizePurchaseResponse::get_result_for_reflect,
                    CMsgRequestItemPurgatory_FinalizePurchaseResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_ids",
                    CMsgRequestItemPurgatory_FinalizePurchaseResponse::get_item_ids_for_reflect,
                    CMsgRequestItemPurgatory_FinalizePurchaseResponse::mut_item_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRequestItemPurgatory_FinalizePurchaseResponse>(
                    "CMsgRequestItemPurgatory_FinalizePurchaseResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_item_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestItemPurgatory_RefundPurchase {
    // message fields
    item_ids: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgRequestItemPurgatory_RefundPurchase {}

impl CMsgRequestItemPurgatory_RefundPurchase {
    pub fn new() -> CMsgRequestItemPurgatory_RefundPurchase {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgRequestItemPurgatory_RefundPurchase {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRequestItemPurgatory_RefundPurchase> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRequestItemPurgatory_RefundPurchase,
        };
        unsafe {
            instance.get(CMsgRequestItemPurgatory_RefundPurchase::new)
        }
    }

    // repeated uint64 item_ids = 1;

    pub fn clear_item_ids(&mut self) {
        self.item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }

    // Take field
    pub fn take_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.item_ids, ::std::vec::Vec::new())
    }

    pub fn get_item_ids(&self) -> &[u64] {
        &self.item_ids
    }

    fn get_item_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.item_ids
    }

    fn mut_item_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }
}

impl ::protobuf::Message for CMsgRequestItemPurgatory_RefundPurchase {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.item_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgRequestItemPurgatory_RefundPurchase {
    fn new() -> CMsgRequestItemPurgatory_RefundPurchase {
        CMsgRequestItemPurgatory_RefundPurchase::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgRequestItemPurgatory_RefundPurchase>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_ids",
                    CMsgRequestItemPurgatory_RefundPurchase::get_item_ids_for_reflect,
                    CMsgRequestItemPurgatory_RefundPurchase::mut_item_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRequestItemPurgatory_RefundPurchase>(
                    "CMsgRequestItemPurgatory_RefundPurchase",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgRequestItemPurgatory_RefundPurchase {
    fn clear(&mut self) {
        self.clear_item_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestItemPurgatory_RefundPurchase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestItemPurgatory_RefundPurchase {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestItemPurgatory_RefundPurchaseResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgRequestItemPurgatory_RefundPurchaseResponse {}

impl CMsgRequestItemPurgatory_RefundPurchaseResponse {
    pub fn new() -> CMsgRequestItemPurgatory_RefundPurchaseResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgRequestItemPurgatory_RefundPurchaseResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRequestItemPurgatory_RefundPurchaseResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRequestItemPurgatory_RefundPurchaseResponse,
        };
        unsafe {
            instance.get(CMsgRequestItemPurgatory_RefundPurchaseResponse::new)
        }
    }

    // optional uint32 result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.result
    }
}

impl ::protobuf::Message for CMsgRequestItemPurgatory_RefundPurchaseResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgRequestItemPurgatory_RefundPurchaseResponse {
    fn new() -> CMsgRequestItemPurgatory_RefundPurchaseResponse {
        CMsgRequestItemPurgatory_RefundPurchaseResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgRequestItemPurgatory_RefundPurchaseResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "result",
                    CMsgRequestItemPurgatory_RefundPurchaseResponse::get_result_for_reflect,
                    CMsgRequestItemPurgatory_RefundPurchaseResponse::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRequestItemPurgatory_RefundPurchaseResponse>(
                    "CMsgRequestItemPurgatory_RefundPurchaseResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgRequestItemPurgatory_RefundPurchaseResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestItemPurgatory_RefundPurchaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestItemPurgatory_RefundPurchaseResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCraftingResponse {
    // message fields
    item_ids: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgCraftingResponse {}

impl CMsgCraftingResponse {
    pub fn new() -> CMsgCraftingResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgCraftingResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgCraftingResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgCraftingResponse,
        };
        unsafe {
            instance.get(CMsgCraftingResponse::new)
        }
    }

    // repeated uint64 item_ids = 1;

    pub fn clear_item_ids(&mut self) {
        self.item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }

    // Take field
    pub fn take_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.item_ids, ::std::vec::Vec::new())
    }

    pub fn get_item_ids(&self) -> &[u64] {
        &self.item_ids
    }

    fn get_item_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.item_ids
    }

    fn mut_item_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }
}

impl ::protobuf::Message for CMsgCraftingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.item_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgCraftingResponse {
    fn new() -> CMsgCraftingResponse {
        CMsgCraftingResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgCraftingResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_ids",
                    CMsgCraftingResponse::get_item_ids_for_reflect,
                    CMsgCraftingResponse::mut_item_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgCraftingResponse>(
                    "CMsgCraftingResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgCraftingResponse {
    fn clear(&mut self) {
        self.clear_item_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCraftingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCraftingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCRequestStoreSalesData {
    // message fields
    version: ::std::option::Option<u32>,
    currency: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCRequestStoreSalesData {}

impl CMsgGCRequestStoreSalesData {
    pub fn new() -> CMsgGCRequestStoreSalesData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCRequestStoreSalesData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCRequestStoreSalesData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCRequestStoreSalesData,
        };
        unsafe {
            instance.get(CMsgGCRequestStoreSalesData::new)
        }
    }

    // optional uint32 version = 1;

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    fn get_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.version
    }

    fn mut_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.version
    }

    // optional uint32 currency = 2;

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: u32) {
        self.currency = ::std::option::Option::Some(v);
    }

    pub fn get_currency(&self) -> u32 {
        self.currency.unwrap_or(0)
    }

    fn get_currency_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.currency
    }

    fn mut_currency_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.currency
    }
}

impl ::protobuf::Message for CMsgGCRequestStoreSalesData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.currency = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.currency {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCRequestStoreSalesData {
    fn new() -> CMsgGCRequestStoreSalesData {
        CMsgGCRequestStoreSalesData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCRequestStoreSalesData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    CMsgGCRequestStoreSalesData::get_version_for_reflect,
                    CMsgGCRequestStoreSalesData::mut_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "currency",
                    CMsgGCRequestStoreSalesData::get_currency_for_reflect,
                    CMsgGCRequestStoreSalesData::mut_currency_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCRequestStoreSalesData>(
                    "CMsgGCRequestStoreSalesData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCRequestStoreSalesData {
    fn clear(&mut self) {
        self.clear_version();
        self.clear_currency();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCRequestStoreSalesData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestStoreSalesData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCRequestStoreSalesDataResponse {
    // message fields
    sale_price: ::protobuf::RepeatedField<CMsgGCRequestStoreSalesDataResponse_Price>,
    version: ::std::option::Option<u32>,
    expiration_time: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCRequestStoreSalesDataResponse {}

impl CMsgGCRequestStoreSalesDataResponse {
    pub fn new() -> CMsgGCRequestStoreSalesDataResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCRequestStoreSalesDataResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCRequestStoreSalesDataResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCRequestStoreSalesDataResponse,
        };
        unsafe {
            instance.get(CMsgGCRequestStoreSalesDataResponse::new)
        }
    }

    // repeated .CMsgGCRequestStoreSalesDataResponse.Price sale_price = 1;

    pub fn clear_sale_price(&mut self) {
        self.sale_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_sale_price(&mut self, v: ::protobuf::RepeatedField<CMsgGCRequestStoreSalesDataResponse_Price>) {
        self.sale_price = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sale_price(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCRequestStoreSalesDataResponse_Price> {
        &mut self.sale_price
    }

    // Take field
    pub fn take_sale_price(&mut self) -> ::protobuf::RepeatedField<CMsgGCRequestStoreSalesDataResponse_Price> {
        ::std::mem::replace(&mut self.sale_price, ::protobuf::RepeatedField::new())
    }

    pub fn get_sale_price(&self) -> &[CMsgGCRequestStoreSalesDataResponse_Price] {
        &self.sale_price
    }

    fn get_sale_price_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCRequestStoreSalesDataResponse_Price> {
        &self.sale_price
    }

    fn mut_sale_price_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCRequestStoreSalesDataResponse_Price> {
        &mut self.sale_price
    }

    // optional uint32 version = 2;

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    fn get_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.version
    }

    fn mut_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.version
    }

    // optional uint32 expiration_time = 3;

    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }

    pub fn get_expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }

    fn get_expiration_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.expiration_time
    }

    fn mut_expiration_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.expiration_time
    }
}

impl ::protobuf::Message for CMsgGCRequestStoreSalesDataResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.sale_price {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sale_price)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expiration_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sale_price {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sale_price {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCRequestStoreSalesDataResponse {
    fn new() -> CMsgGCRequestStoreSalesDataResponse {
        CMsgGCRequestStoreSalesDataResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCRequestStoreSalesDataResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCRequestStoreSalesDataResponse_Price>>(
                    "sale_price",
                    CMsgGCRequestStoreSalesDataResponse::get_sale_price_for_reflect,
                    CMsgGCRequestStoreSalesDataResponse::mut_sale_price_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    CMsgGCRequestStoreSalesDataResponse::get_version_for_reflect,
                    CMsgGCRequestStoreSalesDataResponse::mut_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "expiration_time",
                    CMsgGCRequestStoreSalesDataResponse::get_expiration_time_for_reflect,
                    CMsgGCRequestStoreSalesDataResponse::mut_expiration_time_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCRequestStoreSalesDataResponse>(
                    "CMsgGCRequestStoreSalesDataResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCRequestStoreSalesDataResponse {
    fn clear(&mut self) {
        self.clear_sale_price();
        self.clear_version();
        self.clear_expiration_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCRequestStoreSalesDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestStoreSalesDataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCRequestStoreSalesDataResponse_Price {
    // message fields
    item_def: ::std::option::Option<u32>,
    price: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCRequestStoreSalesDataResponse_Price {}

impl CMsgGCRequestStoreSalesDataResponse_Price {
    pub fn new() -> CMsgGCRequestStoreSalesDataResponse_Price {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCRequestStoreSalesDataResponse_Price {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCRequestStoreSalesDataResponse_Price> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCRequestStoreSalesDataResponse_Price,
        };
        unsafe {
            instance.get(CMsgGCRequestStoreSalesDataResponse_Price::new)
        }
    }

    // optional uint32 item_def = 1;

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    pub fn get_item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    fn get_item_def_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_def
    }

    fn mut_item_def_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_def
    }

    // optional uint32 price = 2;

    pub fn clear_price(&mut self) {
        self.price = ::std::option::Option::None;
    }

    pub fn has_price(&self) -> bool {
        self.price.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: u32) {
        self.price = ::std::option::Option::Some(v);
    }

    pub fn get_price(&self) -> u32 {
        self.price.unwrap_or(0)
    }

    fn get_price_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.price
    }

    fn mut_price_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.price
    }
}

impl ::protobuf::Message for CMsgGCRequestStoreSalesDataResponse_Price {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.price = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.price {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.price {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCRequestStoreSalesDataResponse_Price {
    fn new() -> CMsgGCRequestStoreSalesDataResponse_Price {
        CMsgGCRequestStoreSalesDataResponse_Price::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCRequestStoreSalesDataResponse_Price>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_def",
                    CMsgGCRequestStoreSalesDataResponse_Price::get_item_def_for_reflect,
                    CMsgGCRequestStoreSalesDataResponse_Price::mut_item_def_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "price",
                    CMsgGCRequestStoreSalesDataResponse_Price::get_price_for_reflect,
                    CMsgGCRequestStoreSalesDataResponse_Price::mut_price_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCRequestStoreSalesDataResponse_Price>(
                    "CMsgGCRequestStoreSalesDataResponse_Price",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCRequestStoreSalesDataResponse_Price {
    fn clear(&mut self) {
        self.clear_item_def();
        self.clear_price();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCRequestStoreSalesDataResponse_Price {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestStoreSalesDataResponse_Price {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCRequestStoreSalesDataUpToDateResponse {
    // message fields
    version: ::std::option::Option<u32>,
    expiration_time: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCRequestStoreSalesDataUpToDateResponse {}

impl CMsgGCRequestStoreSalesDataUpToDateResponse {
    pub fn new() -> CMsgGCRequestStoreSalesDataUpToDateResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCRequestStoreSalesDataUpToDateResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCRequestStoreSalesDataUpToDateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCRequestStoreSalesDataUpToDateResponse,
        };
        unsafe {
            instance.get(CMsgGCRequestStoreSalesDataUpToDateResponse::new)
        }
    }

    // optional uint32 version = 1;

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    fn get_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.version
    }

    fn mut_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.version
    }

    // optional uint32 expiration_time = 2;

    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }

    pub fn get_expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }

    fn get_expiration_time_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.expiration_time
    }

    fn mut_expiration_time_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.expiration_time
    }
}

impl ::protobuf::Message for CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expiration_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn new() -> CMsgGCRequestStoreSalesDataUpToDateResponse {
        CMsgGCRequestStoreSalesDataUpToDateResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCRequestStoreSalesDataUpToDateResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    CMsgGCRequestStoreSalesDataUpToDateResponse::get_version_for_reflect,
                    CMsgGCRequestStoreSalesDataUpToDateResponse::mut_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "expiration_time",
                    CMsgGCRequestStoreSalesDataUpToDateResponse::get_expiration_time_for_reflect,
                    CMsgGCRequestStoreSalesDataUpToDateResponse::mut_expiration_time_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCRequestStoreSalesDataUpToDateResponse>(
                    "CMsgGCRequestStoreSalesDataUpToDateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn clear(&mut self) {
        self.clear_version();
        self.clear_expiration_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCPingRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCPingRequest {}

impl CMsgGCToGCPingRequest {
    pub fn new() -> CMsgGCToGCPingRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCPingRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCPingRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCPingRequest,
        };
        unsafe {
            instance.get(CMsgGCToGCPingRequest::new)
        }
    }
}

impl ::protobuf::Message for CMsgGCToGCPingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCPingRequest {
    fn new() -> CMsgGCToGCPingRequest {
        CMsgGCToGCPingRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCPingRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCPingRequest>(
                    "CMsgGCToGCPingRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCPingRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCPingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCPingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCPingResponse {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCPingResponse {}

impl CMsgGCToGCPingResponse {
    pub fn new() -> CMsgGCToGCPingResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCPingResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCPingResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCPingResponse,
        };
        unsafe {
            instance.get(CMsgGCToGCPingResponse::new)
        }
    }
}

impl ::protobuf::Message for CMsgGCToGCPingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCPingResponse {
    fn new() -> CMsgGCToGCPingResponse {
        CMsgGCToGCPingResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCPingResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCPingResponse>(
                    "CMsgGCToGCPingResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCPingResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCPingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCPingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCGetUserSessionServer {
    // message fields
    account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCGetUserSessionServer {}

impl CMsgGCToGCGetUserSessionServer {
    pub fn new() -> CMsgGCToGCGetUserSessionServer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCGetUserSessionServer {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCGetUserSessionServer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCGetUserSessionServer,
        };
        unsafe {
            instance.get(CMsgGCToGCGetUserSessionServer::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserSessionServer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCGetUserSessionServer {
    fn new() -> CMsgGCToGCGetUserSessionServer {
        CMsgGCToGCGetUserSessionServer::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCGetUserSessionServer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCToGCGetUserSessionServer::get_account_id_for_reflect,
                    CMsgGCToGCGetUserSessionServer::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCGetUserSessionServer>(
                    "CMsgGCToGCGetUserSessionServer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCGetUserSessionServer {
    fn clear(&mut self) {
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCGetUserSessionServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserSessionServer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCGetUserSessionServerResponse {
    // message fields
    server_steam_id: ::std::option::Option<u64>,
    is_online: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCGetUserSessionServerResponse {}

impl CMsgGCToGCGetUserSessionServerResponse {
    pub fn new() -> CMsgGCToGCGetUserSessionServerResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCGetUserSessionServerResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCGetUserSessionServerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCGetUserSessionServerResponse,
        };
        unsafe {
            instance.get(CMsgGCToGCGetUserSessionServerResponse::new)
        }
    }

    // optional fixed64 server_steam_id = 1;

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    fn get_server_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.server_steam_id
    }

    fn mut_server_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.server_steam_id
    }

    // optional bool is_online = 2;

    pub fn clear_is_online(&mut self) {
        self.is_online = ::std::option::Option::None;
    }

    pub fn has_is_online(&self) -> bool {
        self.is_online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_online(&mut self, v: bool) {
        self.is_online = ::std::option::Option::Some(v);
    }

    pub fn get_is_online(&self) -> bool {
        self.is_online.unwrap_or(false)
    }

    fn get_is_online_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_online
    }

    fn mut_is_online_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_online
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserSessionServerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.server_steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_online = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.is_online {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.is_online {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCGetUserSessionServerResponse {
    fn new() -> CMsgGCToGCGetUserSessionServerResponse {
        CMsgGCToGCGetUserSessionServerResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCGetUserSessionServerResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "server_steam_id",
                    CMsgGCToGCGetUserSessionServerResponse::get_server_steam_id_for_reflect,
                    CMsgGCToGCGetUserSessionServerResponse::mut_server_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_online",
                    CMsgGCToGCGetUserSessionServerResponse::get_is_online_for_reflect,
                    CMsgGCToGCGetUserSessionServerResponse::mut_is_online_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCGetUserSessionServerResponse>(
                    "CMsgGCToGCGetUserSessionServerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCGetUserSessionServerResponse {
    fn clear(&mut self) {
        self.clear_server_steam_id();
        self.clear_is_online();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCGetUserSessionServerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserSessionServerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCGetUserServerMembers {
    // message fields
    account_id: ::std::option::Option<u32>,
    max_spectators: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCGetUserServerMembers {}

impl CMsgGCToGCGetUserServerMembers {
    pub fn new() -> CMsgGCToGCGetUserServerMembers {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCGetUserServerMembers {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCGetUserServerMembers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCGetUserServerMembers,
        };
        unsafe {
            instance.get(CMsgGCToGCGetUserServerMembers::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 max_spectators = 2;

    pub fn clear_max_spectators(&mut self) {
        self.max_spectators = ::std::option::Option::None;
    }

    pub fn has_max_spectators(&self) -> bool {
        self.max_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_spectators(&mut self, v: u32) {
        self.max_spectators = ::std::option::Option::Some(v);
    }

    pub fn get_max_spectators(&self) -> u32 {
        self.max_spectators.unwrap_or(0)
    }

    fn get_max_spectators_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.max_spectators
    }

    fn mut_max_spectators_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.max_spectators
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserServerMembers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_spectators = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_spectators {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.max_spectators {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCGetUserServerMembers {
    fn new() -> CMsgGCToGCGetUserServerMembers {
        CMsgGCToGCGetUserServerMembers::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCGetUserServerMembers>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCToGCGetUserServerMembers::get_account_id_for_reflect,
                    CMsgGCToGCGetUserServerMembers::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_spectators",
                    CMsgGCToGCGetUserServerMembers::get_max_spectators_for_reflect,
                    CMsgGCToGCGetUserServerMembers::mut_max_spectators_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCGetUserServerMembers>(
                    "CMsgGCToGCGetUserServerMembers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCGetUserServerMembers {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_max_spectators();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCGetUserServerMembers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserServerMembers {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCGetUserServerMembersResponse {
    // message fields
    member_account_id: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCGetUserServerMembersResponse {}

impl CMsgGCToGCGetUserServerMembersResponse {
    pub fn new() -> CMsgGCToGCGetUserServerMembersResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCGetUserServerMembersResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCGetUserServerMembersResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCGetUserServerMembersResponse,
        };
        unsafe {
            instance.get(CMsgGCToGCGetUserServerMembersResponse::new)
        }
    }

    // repeated uint32 member_account_id = 1;

    pub fn clear_member_account_id(&mut self) {
        self.member_account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_member_account_id(&mut self, v: ::std::vec::Vec<u32>) {
        self.member_account_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_member_account_id(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.member_account_id
    }

    // Take field
    pub fn take_member_account_id(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.member_account_id, ::std::vec::Vec::new())
    }

    pub fn get_member_account_id(&self) -> &[u32] {
        &self.member_account_id
    }

    fn get_member_account_id_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.member_account_id
    }

    fn mut_member_account_id_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.member_account_id
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserServerMembersResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.member_account_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.member_account_id {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.member_account_id {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCGetUserServerMembersResponse {
    fn new() -> CMsgGCToGCGetUserServerMembersResponse {
        CMsgGCToGCGetUserServerMembersResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCGetUserServerMembersResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "member_account_id",
                    CMsgGCToGCGetUserServerMembersResponse::get_member_account_id_for_reflect,
                    CMsgGCToGCGetUserServerMembersResponse::mut_member_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCGetUserServerMembersResponse>(
                    "CMsgGCToGCGetUserServerMembersResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCGetUserServerMembersResponse {
    fn clear(&mut self) {
        self.clear_member_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCGetUserServerMembersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserServerMembersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLookupMultipleAccountNames {
    // message fields
    accountids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgLookupMultipleAccountNames {}

impl CMsgLookupMultipleAccountNames {
    pub fn new() -> CMsgLookupMultipleAccountNames {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgLookupMultipleAccountNames {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLookupMultipleAccountNames> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLookupMultipleAccountNames,
        };
        unsafe {
            instance.get(CMsgLookupMultipleAccountNames::new)
        }
    }

    // repeated uint32 accountids = 1;

    pub fn clear_accountids(&mut self) {
        self.accountids.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountids(&mut self, v: ::std::vec::Vec<u32>) {
        self.accountids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accountids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.accountids
    }

    // Take field
    pub fn take_accountids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.accountids, ::std::vec::Vec::new())
    }

    pub fn get_accountids(&self) -> &[u32] {
        &self.accountids
    }

    fn get_accountids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.accountids
    }

    fn mut_accountids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.accountids
    }
}

impl ::protobuf::Message for CMsgLookupMultipleAccountNames {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.accountids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountids.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(1, &self.accountids);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.accountids.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.accountids))?;
            for v in &self.accountids {
                os.write_uint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgLookupMultipleAccountNames {
    fn new() -> CMsgLookupMultipleAccountNames {
        CMsgLookupMultipleAccountNames::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgLookupMultipleAccountNames>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountids",
                    CMsgLookupMultipleAccountNames::get_accountids_for_reflect,
                    CMsgLookupMultipleAccountNames::mut_accountids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLookupMultipleAccountNames>(
                    "CMsgLookupMultipleAccountNames",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgLookupMultipleAccountNames {
    fn clear(&mut self) {
        self.clear_accountids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLookupMultipleAccountNames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLookupMultipleAccountNames {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLookupMultipleAccountNamesResponse {
    // message fields
    accounts: ::protobuf::RepeatedField<CMsgLookupMultipleAccountNamesResponse_Account>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgLookupMultipleAccountNamesResponse {}

impl CMsgLookupMultipleAccountNamesResponse {
    pub fn new() -> CMsgLookupMultipleAccountNamesResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgLookupMultipleAccountNamesResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLookupMultipleAccountNamesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLookupMultipleAccountNamesResponse,
        };
        unsafe {
            instance.get(CMsgLookupMultipleAccountNamesResponse::new)
        }
    }

    // repeated .CMsgLookupMultipleAccountNamesResponse.Account accounts = 1;

    pub fn clear_accounts(&mut self) {
        self.accounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_accounts(&mut self, v: ::protobuf::RepeatedField<CMsgLookupMultipleAccountNamesResponse_Account>) {
        self.accounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accounts(&mut self) -> &mut ::protobuf::RepeatedField<CMsgLookupMultipleAccountNamesResponse_Account> {
        &mut self.accounts
    }

    // Take field
    pub fn take_accounts(&mut self) -> ::protobuf::RepeatedField<CMsgLookupMultipleAccountNamesResponse_Account> {
        ::std::mem::replace(&mut self.accounts, ::protobuf::RepeatedField::new())
    }

    pub fn get_accounts(&self) -> &[CMsgLookupMultipleAccountNamesResponse_Account] {
        &self.accounts
    }

    fn get_accounts_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgLookupMultipleAccountNamesResponse_Account> {
        &self.accounts
    }

    fn mut_accounts_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgLookupMultipleAccountNamesResponse_Account> {
        &mut self.accounts
    }
}

impl ::protobuf::Message for CMsgLookupMultipleAccountNamesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.accounts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.accounts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.accounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.accounts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgLookupMultipleAccountNamesResponse {
    fn new() -> CMsgLookupMultipleAccountNamesResponse {
        CMsgLookupMultipleAccountNamesResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgLookupMultipleAccountNamesResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgLookupMultipleAccountNamesResponse_Account>>(
                    "accounts",
                    CMsgLookupMultipleAccountNamesResponse::get_accounts_for_reflect,
                    CMsgLookupMultipleAccountNamesResponse::mut_accounts_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLookupMultipleAccountNamesResponse>(
                    "CMsgLookupMultipleAccountNamesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgLookupMultipleAccountNamesResponse {
    fn clear(&mut self) {
        self.clear_accounts();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLookupMultipleAccountNamesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLookupMultipleAccountNamesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLookupMultipleAccountNamesResponse_Account {
    // message fields
    accountid: ::std::option::Option<u32>,
    persona: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgLookupMultipleAccountNamesResponse_Account {}

impl CMsgLookupMultipleAccountNamesResponse_Account {
    pub fn new() -> CMsgLookupMultipleAccountNamesResponse_Account {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgLookupMultipleAccountNamesResponse_Account {
        static mut instance: ::protobuf::lazy::Lazy<CMsgLookupMultipleAccountNamesResponse_Account> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgLookupMultipleAccountNamesResponse_Account,
        };
        unsafe {
            instance.get(CMsgLookupMultipleAccountNamesResponse_Account::new)
        }
    }

    // optional uint32 accountid = 1;

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    fn get_accountid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.accountid
    }

    fn mut_accountid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.accountid
    }

    // optional string persona = 2;

    pub fn clear_persona(&mut self) {
        self.persona.clear();
    }

    pub fn has_persona(&self) -> bool {
        self.persona.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona(&mut self, v: ::std::string::String) {
        self.persona = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona(&mut self) -> &mut ::std::string::String {
        if self.persona.is_none() {
            self.persona.set_default();
        }
        self.persona.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona(&mut self) -> ::std::string::String {
        self.persona.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_persona(&self) -> &str {
        match self.persona.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_persona_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.persona
    }

    fn mut_persona_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.persona
    }
}

impl ::protobuf::Message for CMsgLookupMultipleAccountNamesResponse_Account {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.persona.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.persona.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgLookupMultipleAccountNamesResponse_Account {
    fn new() -> CMsgLookupMultipleAccountNamesResponse_Account {
        CMsgLookupMultipleAccountNamesResponse_Account::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgLookupMultipleAccountNamesResponse_Account>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    CMsgLookupMultipleAccountNamesResponse_Account::get_accountid_for_reflect,
                    CMsgLookupMultipleAccountNamesResponse_Account::mut_accountid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "persona",
                    CMsgLookupMultipleAccountNamesResponse_Account::get_persona_for_reflect,
                    CMsgLookupMultipleAccountNamesResponse_Account::mut_persona_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgLookupMultipleAccountNamesResponse_Account>(
                    "CMsgLookupMultipleAccountNamesResponse_Account",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgLookupMultipleAccountNamesResponse_Account {
    fn clear(&mut self) {
        self.clear_accountid();
        self.clear_persona();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLookupMultipleAccountNamesResponse_Account {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLookupMultipleAccountNamesResponse_Account {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCGetUserPCBangNo {
    // message fields
    account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCGetUserPCBangNo {}

impl CMsgGCToGCGetUserPCBangNo {
    pub fn new() -> CMsgGCToGCGetUserPCBangNo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCGetUserPCBangNo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCGetUserPCBangNo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCGetUserPCBangNo,
        };
        unsafe {
            instance.get(CMsgGCToGCGetUserPCBangNo::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserPCBangNo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCGetUserPCBangNo {
    fn new() -> CMsgGCToGCGetUserPCBangNo {
        CMsgGCToGCGetUserPCBangNo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCGetUserPCBangNo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCToGCGetUserPCBangNo::get_account_id_for_reflect,
                    CMsgGCToGCGetUserPCBangNo::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCGetUserPCBangNo>(
                    "CMsgGCToGCGetUserPCBangNo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCGetUserPCBangNo {
    fn clear(&mut self) {
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCGetUserPCBangNo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserPCBangNo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCGetUserPCBangNoResponse {
    // message fields
    pc_bang_no: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCGetUserPCBangNoResponse {}

impl CMsgGCToGCGetUserPCBangNoResponse {
    pub fn new() -> CMsgGCToGCGetUserPCBangNoResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCGetUserPCBangNoResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCGetUserPCBangNoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCGetUserPCBangNoResponse,
        };
        unsafe {
            instance.get(CMsgGCToGCGetUserPCBangNoResponse::new)
        }
    }

    // optional uint32 pc_bang_no = 1;

    pub fn clear_pc_bang_no(&mut self) {
        self.pc_bang_no = ::std::option::Option::None;
    }

    pub fn has_pc_bang_no(&self) -> bool {
        self.pc_bang_no.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pc_bang_no(&mut self, v: u32) {
        self.pc_bang_no = ::std::option::Option::Some(v);
    }

    pub fn get_pc_bang_no(&self) -> u32 {
        self.pc_bang_no.unwrap_or(0)
    }

    fn get_pc_bang_no_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.pc_bang_no
    }

    fn mut_pc_bang_no_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.pc_bang_no
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserPCBangNoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pc_bang_no = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.pc_bang_no {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.pc_bang_no {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCGetUserPCBangNoResponse {
    fn new() -> CMsgGCToGCGetUserPCBangNoResponse {
        CMsgGCToGCGetUserPCBangNoResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCGetUserPCBangNoResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pc_bang_no",
                    CMsgGCToGCGetUserPCBangNoResponse::get_pc_bang_no_for_reflect,
                    CMsgGCToGCGetUserPCBangNoResponse::mut_pc_bang_no_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCGetUserPCBangNoResponse>(
                    "CMsgGCToGCGetUserPCBangNoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCGetUserPCBangNoResponse {
    fn clear(&mut self) {
        self.clear_pc_bang_no();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCGetUserPCBangNoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserPCBangNoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestCrateItems {
    // message fields
    crate_item_def: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgRequestCrateItems {}

impl CMsgRequestCrateItems {
    pub fn new() -> CMsgRequestCrateItems {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgRequestCrateItems {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRequestCrateItems> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRequestCrateItems,
        };
        unsafe {
            instance.get(CMsgRequestCrateItems::new)
        }
    }

    // optional uint32 crate_item_def = 1;

    pub fn clear_crate_item_def(&mut self) {
        self.crate_item_def = ::std::option::Option::None;
    }

    pub fn has_crate_item_def(&self) -> bool {
        self.crate_item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crate_item_def(&mut self, v: u32) {
        self.crate_item_def = ::std::option::Option::Some(v);
    }

    pub fn get_crate_item_def(&self) -> u32 {
        self.crate_item_def.unwrap_or(0)
    }

    fn get_crate_item_def_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.crate_item_def
    }

    fn mut_crate_item_def_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.crate_item_def
    }
}

impl ::protobuf::Message for CMsgRequestCrateItems {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.crate_item_def = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.crate_item_def {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.crate_item_def {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgRequestCrateItems {
    fn new() -> CMsgRequestCrateItems {
        CMsgRequestCrateItems::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgRequestCrateItems>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "crate_item_def",
                    CMsgRequestCrateItems::get_crate_item_def_for_reflect,
                    CMsgRequestCrateItems::mut_crate_item_def_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRequestCrateItems>(
                    "CMsgRequestCrateItems",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgRequestCrateItems {
    fn clear(&mut self) {
        self.clear_crate_item_def();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestCrateItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestCrateItems {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestCrateItemsResponse {
    // message fields
    response: ::std::option::Option<u32>,
    item_defs: ::std::vec::Vec<u32>,
    peek_item_def: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgRequestCrateItemsResponse {}

impl CMsgRequestCrateItemsResponse {
    pub fn new() -> CMsgRequestCrateItemsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgRequestCrateItemsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRequestCrateItemsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRequestCrateItemsResponse,
        };
        unsafe {
            instance.get(CMsgRequestCrateItemsResponse::new)
        }
    }

    // optional uint32 response = 1;

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: u32) {
        self.response = ::std::option::Option::Some(v);
    }

    pub fn get_response(&self) -> u32 {
        self.response.unwrap_or(0)
    }

    fn get_response_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.response
    }

    fn mut_response_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.response
    }

    // repeated uint32 item_defs = 2;

    pub fn clear_item_defs(&mut self) {
        self.item_defs.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_defs(&mut self, v: ::std::vec::Vec<u32>) {
        self.item_defs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_defs(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.item_defs
    }

    // Take field
    pub fn take_item_defs(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.item_defs, ::std::vec::Vec::new())
    }

    pub fn get_item_defs(&self) -> &[u32] {
        &self.item_defs
    }

    fn get_item_defs_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.item_defs
    }

    fn mut_item_defs_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.item_defs
    }

    // optional uint32 peek_item_def = 3;

    pub fn clear_peek_item_def(&mut self) {
        self.peek_item_def = ::std::option::Option::None;
    }

    pub fn has_peek_item_def(&self) -> bool {
        self.peek_item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peek_item_def(&mut self, v: u32) {
        self.peek_item_def = ::std::option::Option::Some(v);
    }

    pub fn get_peek_item_def(&self) -> u32 {
        self.peek_item_def.unwrap_or(0)
    }

    fn get_peek_item_def_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.peek_item_def
    }

    fn mut_peek_item_def_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.peek_item_def
    }
}

impl ::protobuf::Message for CMsgRequestCrateItemsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.response = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.item_defs)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.peek_item_def = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.item_defs {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.peek_item_def {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.response {
            os.write_uint32(1, v)?;
        }
        for v in &self.item_defs {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.peek_item_def {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgRequestCrateItemsResponse {
    fn new() -> CMsgRequestCrateItemsResponse {
        CMsgRequestCrateItemsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgRequestCrateItemsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "response",
                    CMsgRequestCrateItemsResponse::get_response_for_reflect,
                    CMsgRequestCrateItemsResponse::mut_response_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_defs",
                    CMsgRequestCrateItemsResponse::get_item_defs_for_reflect,
                    CMsgRequestCrateItemsResponse::mut_item_defs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "peek_item_def",
                    CMsgRequestCrateItemsResponse::get_peek_item_def_for_reflect,
                    CMsgRequestCrateItemsResponse::mut_peek_item_def_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRequestCrateItemsResponse>(
                    "CMsgRequestCrateItemsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgRequestCrateItemsResponse {
    fn clear(&mut self) {
        self.clear_response();
        self.clear_item_defs();
        self.clear_peek_item_def();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestCrateItemsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestCrateItemsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgRequestCrateItemsResponse_EResult {
    k_Succeeded = 0,
    k_Failed = 1,
}

impl ::protobuf::ProtobufEnum for CMsgRequestCrateItemsResponse_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgRequestCrateItemsResponse_EResult> {
        match value {
            0 => ::std::option::Option::Some(CMsgRequestCrateItemsResponse_EResult::k_Succeeded),
            1 => ::std::option::Option::Some(CMsgRequestCrateItemsResponse_EResult::k_Failed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgRequestCrateItemsResponse_EResult] = &[
            CMsgRequestCrateItemsResponse_EResult::k_Succeeded,
            CMsgRequestCrateItemsResponse_EResult::k_Failed,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgRequestCrateItemsResponse_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgRequestCrateItemsResponse_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgRequestCrateItemsResponse_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestCrateItemsResponse_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCCanUseDropRateBonus {
    // message fields
    account_id: ::std::option::Option<u32>,
    drop_rate_bonus: ::std::option::Option<f32>,
    booster_type: ::std::option::Option<u32>,
    exclusive_item_def: ::std::option::Option<u32>,
    allow_equal_rate: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCCanUseDropRateBonus {}

impl CMsgGCToGCCanUseDropRateBonus {
    pub fn new() -> CMsgGCToGCCanUseDropRateBonus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCCanUseDropRateBonus {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCCanUseDropRateBonus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCCanUseDropRateBonus,
        };
        unsafe {
            instance.get(CMsgGCToGCCanUseDropRateBonus::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional float drop_rate_bonus = 2;

    pub fn clear_drop_rate_bonus(&mut self) {
        self.drop_rate_bonus = ::std::option::Option::None;
    }

    pub fn has_drop_rate_bonus(&self) -> bool {
        self.drop_rate_bonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drop_rate_bonus(&mut self, v: f32) {
        self.drop_rate_bonus = ::std::option::Option::Some(v);
    }

    pub fn get_drop_rate_bonus(&self) -> f32 {
        self.drop_rate_bonus.unwrap_or(0.)
    }

    fn get_drop_rate_bonus_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.drop_rate_bonus
    }

    fn mut_drop_rate_bonus_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.drop_rate_bonus
    }

    // optional uint32 booster_type = 3;

    pub fn clear_booster_type(&mut self) {
        self.booster_type = ::std::option::Option::None;
    }

    pub fn has_booster_type(&self) -> bool {
        self.booster_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_booster_type(&mut self, v: u32) {
        self.booster_type = ::std::option::Option::Some(v);
    }

    pub fn get_booster_type(&self) -> u32 {
        self.booster_type.unwrap_or(0)
    }

    fn get_booster_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.booster_type
    }

    fn mut_booster_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.booster_type
    }

    // optional uint32 exclusive_item_def = 4;

    pub fn clear_exclusive_item_def(&mut self) {
        self.exclusive_item_def = ::std::option::Option::None;
    }

    pub fn has_exclusive_item_def(&self) -> bool {
        self.exclusive_item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclusive_item_def(&mut self, v: u32) {
        self.exclusive_item_def = ::std::option::Option::Some(v);
    }

    pub fn get_exclusive_item_def(&self) -> u32 {
        self.exclusive_item_def.unwrap_or(0)
    }

    fn get_exclusive_item_def_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.exclusive_item_def
    }

    fn mut_exclusive_item_def_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.exclusive_item_def
    }

    // optional bool allow_equal_rate = 5;

    pub fn clear_allow_equal_rate(&mut self) {
        self.allow_equal_rate = ::std::option::Option::None;
    }

    pub fn has_allow_equal_rate(&self) -> bool {
        self.allow_equal_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_equal_rate(&mut self, v: bool) {
        self.allow_equal_rate = ::std::option::Option::Some(v);
    }

    pub fn get_allow_equal_rate(&self) -> bool {
        self.allow_equal_rate.unwrap_or(false)
    }

    fn get_allow_equal_rate_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.allow_equal_rate
    }

    fn mut_allow_equal_rate_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.allow_equal_rate
    }
}

impl ::protobuf::Message for CMsgGCToGCCanUseDropRateBonus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.drop_rate_bonus = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.booster_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.exclusive_item_def = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_equal_rate = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.drop_rate_bonus {
            my_size += 5;
        }
        if let Some(v) = self.booster_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.exclusive_item_def {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.allow_equal_rate {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.drop_rate_bonus {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.booster_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.exclusive_item_def {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.allow_equal_rate {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCCanUseDropRateBonus {
    fn new() -> CMsgGCToGCCanUseDropRateBonus {
        CMsgGCToGCCanUseDropRateBonus::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCCanUseDropRateBonus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCToGCCanUseDropRateBonus::get_account_id_for_reflect,
                    CMsgGCToGCCanUseDropRateBonus::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "drop_rate_bonus",
                    CMsgGCToGCCanUseDropRateBonus::get_drop_rate_bonus_for_reflect,
                    CMsgGCToGCCanUseDropRateBonus::mut_drop_rate_bonus_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "booster_type",
                    CMsgGCToGCCanUseDropRateBonus::get_booster_type_for_reflect,
                    CMsgGCToGCCanUseDropRateBonus::mut_booster_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "exclusive_item_def",
                    CMsgGCToGCCanUseDropRateBonus::get_exclusive_item_def_for_reflect,
                    CMsgGCToGCCanUseDropRateBonus::mut_exclusive_item_def_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "allow_equal_rate",
                    CMsgGCToGCCanUseDropRateBonus::get_allow_equal_rate_for_reflect,
                    CMsgGCToGCCanUseDropRateBonus::mut_allow_equal_rate_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCCanUseDropRateBonus>(
                    "CMsgGCToGCCanUseDropRateBonus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCCanUseDropRateBonus {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_drop_rate_bonus();
        self.clear_booster_type();
        self.clear_exclusive_item_def();
        self.clear_allow_equal_rate();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCCanUseDropRateBonus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCCanUseDropRateBonus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSQLAddDropRateBonus {
    // message fields
    account_id: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u64>,
    item_def: ::std::option::Option<u32>,
    drop_rate_bonus: ::std::option::Option<f32>,
    booster_type: ::std::option::Option<u32>,
    seconds_duration: ::std::option::Option<u32>,
    end_time_stamp: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSQLAddDropRateBonus {}

impl CMsgSQLAddDropRateBonus {
    pub fn new() -> CMsgSQLAddDropRateBonus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSQLAddDropRateBonus {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSQLAddDropRateBonus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSQLAddDropRateBonus,
        };
        unsafe {
            instance.get(CMsgSQLAddDropRateBonus::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint64 item_id = 2;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }

    // optional uint32 item_def = 3;

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    pub fn get_item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    fn get_item_def_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_def
    }

    fn mut_item_def_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_def
    }

    // optional float drop_rate_bonus = 4;

    pub fn clear_drop_rate_bonus(&mut self) {
        self.drop_rate_bonus = ::std::option::Option::None;
    }

    pub fn has_drop_rate_bonus(&self) -> bool {
        self.drop_rate_bonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drop_rate_bonus(&mut self, v: f32) {
        self.drop_rate_bonus = ::std::option::Option::Some(v);
    }

    pub fn get_drop_rate_bonus(&self) -> f32 {
        self.drop_rate_bonus.unwrap_or(0.)
    }

    fn get_drop_rate_bonus_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.drop_rate_bonus
    }

    fn mut_drop_rate_bonus_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.drop_rate_bonus
    }

    // optional uint32 booster_type = 5;

    pub fn clear_booster_type(&mut self) {
        self.booster_type = ::std::option::Option::None;
    }

    pub fn has_booster_type(&self) -> bool {
        self.booster_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_booster_type(&mut self, v: u32) {
        self.booster_type = ::std::option::Option::Some(v);
    }

    pub fn get_booster_type(&self) -> u32 {
        self.booster_type.unwrap_or(0)
    }

    fn get_booster_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.booster_type
    }

    fn mut_booster_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.booster_type
    }

    // optional uint32 seconds_duration = 6;

    pub fn clear_seconds_duration(&mut self) {
        self.seconds_duration = ::std::option::Option::None;
    }

    pub fn has_seconds_duration(&self) -> bool {
        self.seconds_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_duration(&mut self, v: u32) {
        self.seconds_duration = ::std::option::Option::Some(v);
    }

    pub fn get_seconds_duration(&self) -> u32 {
        self.seconds_duration.unwrap_or(0)
    }

    fn get_seconds_duration_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.seconds_duration
    }

    fn mut_seconds_duration_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.seconds_duration
    }

    // optional uint32 end_time_stamp = 7;

    pub fn clear_end_time_stamp(&mut self) {
        self.end_time_stamp = ::std::option::Option::None;
    }

    pub fn has_end_time_stamp(&self) -> bool {
        self.end_time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time_stamp(&mut self, v: u32) {
        self.end_time_stamp = ::std::option::Option::Some(v);
    }

    pub fn get_end_time_stamp(&self) -> u32 {
        self.end_time_stamp.unwrap_or(0)
    }

    fn get_end_time_stamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.end_time_stamp
    }

    fn mut_end_time_stamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.end_time_stamp
    }
}

impl ::protobuf::Message for CMsgSQLAddDropRateBonus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.drop_rate_bonus = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.booster_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_duration = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.end_time_stamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.drop_rate_bonus {
            my_size += 5;
        }
        if let Some(v) = self.booster_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds_duration {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end_time_stamp {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.item_def {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.drop_rate_bonus {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.booster_type {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.seconds_duration {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.end_time_stamp {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSQLAddDropRateBonus {
    fn new() -> CMsgSQLAddDropRateBonus {
        CMsgSQLAddDropRateBonus::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSQLAddDropRateBonus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgSQLAddDropRateBonus::get_account_id_for_reflect,
                    CMsgSQLAddDropRateBonus::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgSQLAddDropRateBonus::get_item_id_for_reflect,
                    CMsgSQLAddDropRateBonus::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_def",
                    CMsgSQLAddDropRateBonus::get_item_def_for_reflect,
                    CMsgSQLAddDropRateBonus::mut_item_def_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "drop_rate_bonus",
                    CMsgSQLAddDropRateBonus::get_drop_rate_bonus_for_reflect,
                    CMsgSQLAddDropRateBonus::mut_drop_rate_bonus_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "booster_type",
                    CMsgSQLAddDropRateBonus::get_booster_type_for_reflect,
                    CMsgSQLAddDropRateBonus::mut_booster_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "seconds_duration",
                    CMsgSQLAddDropRateBonus::get_seconds_duration_for_reflect,
                    CMsgSQLAddDropRateBonus::mut_seconds_duration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "end_time_stamp",
                    CMsgSQLAddDropRateBonus::get_end_time_stamp_for_reflect,
                    CMsgSQLAddDropRateBonus::mut_end_time_stamp_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSQLAddDropRateBonus>(
                    "CMsgSQLAddDropRateBonus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSQLAddDropRateBonus {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_item_id();
        self.clear_item_def();
        self.clear_drop_rate_bonus();
        self.clear_booster_type();
        self.clear_seconds_duration();
        self.clear_end_time_stamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSQLAddDropRateBonus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSQLAddDropRateBonus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSQLUpgradeBattleBooster {
    // message fields
    account_id: ::std::option::Option<u32>,
    item_def: ::std::option::Option<u32>,
    bonus_to_add: ::std::option::Option<f32>,
    booster_type: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSQLUpgradeBattleBooster {}

impl CMsgSQLUpgradeBattleBooster {
    pub fn new() -> CMsgSQLUpgradeBattleBooster {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSQLUpgradeBattleBooster {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSQLUpgradeBattleBooster> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSQLUpgradeBattleBooster,
        };
        unsafe {
            instance.get(CMsgSQLUpgradeBattleBooster::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 item_def = 2;

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    pub fn get_item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    fn get_item_def_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_def
    }

    fn mut_item_def_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_def
    }

    // optional float bonus_to_add = 3;

    pub fn clear_bonus_to_add(&mut self) {
        self.bonus_to_add = ::std::option::Option::None;
    }

    pub fn has_bonus_to_add(&self) -> bool {
        self.bonus_to_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_to_add(&mut self, v: f32) {
        self.bonus_to_add = ::std::option::Option::Some(v);
    }

    pub fn get_bonus_to_add(&self) -> f32 {
        self.bonus_to_add.unwrap_or(0.)
    }

    fn get_bonus_to_add_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.bonus_to_add
    }

    fn mut_bonus_to_add_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.bonus_to_add
    }

    // optional uint32 booster_type = 4;

    pub fn clear_booster_type(&mut self) {
        self.booster_type = ::std::option::Option::None;
    }

    pub fn has_booster_type(&self) -> bool {
        self.booster_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_booster_type(&mut self, v: u32) {
        self.booster_type = ::std::option::Option::Some(v);
    }

    pub fn get_booster_type(&self) -> u32 {
        self.booster_type.unwrap_or(0)
    }

    fn get_booster_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.booster_type
    }

    fn mut_booster_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.booster_type
    }
}

impl ::protobuf::Message for CMsgSQLUpgradeBattleBooster {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.bonus_to_add = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.booster_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bonus_to_add {
            my_size += 5;
        }
        if let Some(v) = self.booster_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_def {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bonus_to_add {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.booster_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSQLUpgradeBattleBooster {
    fn new() -> CMsgSQLUpgradeBattleBooster {
        CMsgSQLUpgradeBattleBooster::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSQLUpgradeBattleBooster>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgSQLUpgradeBattleBooster::get_account_id_for_reflect,
                    CMsgSQLUpgradeBattleBooster::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_def",
                    CMsgSQLUpgradeBattleBooster::get_item_def_for_reflect,
                    CMsgSQLUpgradeBattleBooster::mut_item_def_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "bonus_to_add",
                    CMsgSQLUpgradeBattleBooster::get_bonus_to_add_for_reflect,
                    CMsgSQLUpgradeBattleBooster::mut_bonus_to_add_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "booster_type",
                    CMsgSQLUpgradeBattleBooster::get_booster_type_for_reflect,
                    CMsgSQLUpgradeBattleBooster::mut_booster_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSQLUpgradeBattleBooster>(
                    "CMsgSQLUpgradeBattleBooster",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSQLUpgradeBattleBooster {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_item_def();
        self.clear_bonus_to_add();
        self.clear_booster_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSQLUpgradeBattleBooster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSQLUpgradeBattleBooster {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCRefreshSOCache {
    // message fields
    account_id: ::std::option::Option<u32>,
    reload: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCRefreshSOCache {}

impl CMsgGCToGCRefreshSOCache {
    pub fn new() -> CMsgGCToGCRefreshSOCache {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCRefreshSOCache {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCRefreshSOCache> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCRefreshSOCache,
        };
        unsafe {
            instance.get(CMsgGCToGCRefreshSOCache::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional bool reload = 2;

    pub fn clear_reload(&mut self) {
        self.reload = ::std::option::Option::None;
    }

    pub fn has_reload(&self) -> bool {
        self.reload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reload(&mut self, v: bool) {
        self.reload = ::std::option::Option::Some(v);
    }

    pub fn get_reload(&self) -> bool {
        self.reload.unwrap_or(false)
    }

    fn get_reload_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.reload
    }

    fn mut_reload_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.reload
    }
}

impl ::protobuf::Message for CMsgGCToGCRefreshSOCache {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reload = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reload {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reload {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCRefreshSOCache {
    fn new() -> CMsgGCToGCRefreshSOCache {
        CMsgGCToGCRefreshSOCache::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCRefreshSOCache>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCToGCRefreshSOCache::get_account_id_for_reflect,
                    CMsgGCToGCRefreshSOCache::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "reload",
                    CMsgGCToGCRefreshSOCache::get_reload_for_reflect,
                    CMsgGCToGCRefreshSOCache::mut_reload_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCRefreshSOCache>(
                    "CMsgGCToGCRefreshSOCache",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCRefreshSOCache {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_reload();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCRefreshSOCache {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCRefreshSOCache {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCCheckAccountTradeStatus {
    // message fields
    account_id: ::std::option::Option<u32>,
    initiator: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCCheckAccountTradeStatus {}

impl CMsgGCToGCCheckAccountTradeStatus {
    pub fn new() -> CMsgGCToGCCheckAccountTradeStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCCheckAccountTradeStatus {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCCheckAccountTradeStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCCheckAccountTradeStatus,
        };
        unsafe {
            instance.get(CMsgGCToGCCheckAccountTradeStatus::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional bool initiator = 2;

    pub fn clear_initiator(&mut self) {
        self.initiator = ::std::option::Option::None;
    }

    pub fn has_initiator(&self) -> bool {
        self.initiator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator(&mut self, v: bool) {
        self.initiator = ::std::option::Option::Some(v);
    }

    pub fn get_initiator(&self) -> bool {
        self.initiator.unwrap_or(false)
    }

    fn get_initiator_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.initiator
    }

    fn mut_initiator_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.initiator
    }
}

impl ::protobuf::Message for CMsgGCToGCCheckAccountTradeStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.initiator = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initiator {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.initiator {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCCheckAccountTradeStatus {
    fn new() -> CMsgGCToGCCheckAccountTradeStatus {
        CMsgGCToGCCheckAccountTradeStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCCheckAccountTradeStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCToGCCheckAccountTradeStatus::get_account_id_for_reflect,
                    CMsgGCToGCCheckAccountTradeStatus::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "initiator",
                    CMsgGCToGCCheckAccountTradeStatus::get_initiator_for_reflect,
                    CMsgGCToGCCheckAccountTradeStatus::mut_initiator_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCCheckAccountTradeStatus>(
                    "CMsgGCToGCCheckAccountTradeStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCCheckAccountTradeStatus {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_initiator();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCCheckAccountTradeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCCheckAccountTradeStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCCheckAccountTradeStatusResponse {
    // message fields
    can_trade: ::std::option::Option<bool>,
    error_code: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCCheckAccountTradeStatusResponse {}

impl CMsgGCToGCCheckAccountTradeStatusResponse {
    pub fn new() -> CMsgGCToGCCheckAccountTradeStatusResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCCheckAccountTradeStatusResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCCheckAccountTradeStatusResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCCheckAccountTradeStatusResponse,
        };
        unsafe {
            instance.get(CMsgGCToGCCheckAccountTradeStatusResponse::new)
        }
    }

    // optional bool can_trade = 1;

    pub fn clear_can_trade(&mut self) {
        self.can_trade = ::std::option::Option::None;
    }

    pub fn has_can_trade(&self) -> bool {
        self.can_trade.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_trade(&mut self, v: bool) {
        self.can_trade = ::std::option::Option::Some(v);
    }

    pub fn get_can_trade(&self) -> bool {
        self.can_trade.unwrap_or(false)
    }

    fn get_can_trade_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.can_trade
    }

    fn mut_can_trade_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.can_trade
    }

    // optional uint32 error_code = 2;

    pub fn clear_error_code(&mut self) {
        self.error_code = ::std::option::Option::None;
    }

    pub fn has_error_code(&self) -> bool {
        self.error_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_code(&mut self, v: u32) {
        self.error_code = ::std::option::Option::Some(v);
    }

    pub fn get_error_code(&self) -> u32 {
        self.error_code.unwrap_or(0)
    }

    fn get_error_code_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.error_code
    }

    fn mut_error_code_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.error_code
    }
}

impl ::protobuf::Message for CMsgGCToGCCheckAccountTradeStatusResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_trade = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.error_code = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.can_trade {
            my_size += 2;
        }
        if let Some(v) = self.error_code {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.can_trade {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.error_code {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCCheckAccountTradeStatusResponse {
    fn new() -> CMsgGCToGCCheckAccountTradeStatusResponse {
        CMsgGCToGCCheckAccountTradeStatusResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCCheckAccountTradeStatusResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "can_trade",
                    CMsgGCToGCCheckAccountTradeStatusResponse::get_can_trade_for_reflect,
                    CMsgGCToGCCheckAccountTradeStatusResponse::mut_can_trade_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "error_code",
                    CMsgGCToGCCheckAccountTradeStatusResponse::get_error_code_for_reflect,
                    CMsgGCToGCCheckAccountTradeStatusResponse::mut_error_code_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCCheckAccountTradeStatusResponse>(
                    "CMsgGCToGCCheckAccountTradeStatusResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCCheckAccountTradeStatusResponse {
    fn clear(&mut self) {
        self.clear_can_trade();
        self.clear_error_code();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCCheckAccountTradeStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCCheckAccountTradeStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCGrantAccountRolledItems {
    // message fields
    account_id: ::std::option::Option<u32>,
    items: ::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item>,
    audit_action: ::std::option::Option<u32>,
    audit_data: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCGrantAccountRolledItems {}

impl CMsgGCToGCGrantAccountRolledItems {
    pub fn new() -> CMsgGCToGCGrantAccountRolledItems {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCGrantAccountRolledItems {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCGrantAccountRolledItems> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCGrantAccountRolledItems,
        };
        unsafe {
            instance.get(CMsgGCToGCGrantAccountRolledItems::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // repeated .CMsgGCToGCGrantAccountRolledItems.Item items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[CMsgGCToGCGrantAccountRolledItems_Item] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item> {
        &mut self.items
    }

    // optional uint32 audit_action = 3;

    pub fn clear_audit_action(&mut self) {
        self.audit_action = ::std::option::Option::None;
    }

    pub fn has_audit_action(&self) -> bool {
        self.audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_action(&mut self, v: u32) {
        self.audit_action = ::std::option::Option::Some(v);
    }

    pub fn get_audit_action(&self) -> u32 {
        self.audit_action.unwrap_or(0)
    }

    fn get_audit_action_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.audit_action
    }

    fn mut_audit_action_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.audit_action
    }

    // optional uint64 audit_data = 4;

    pub fn clear_audit_data(&mut self) {
        self.audit_data = ::std::option::Option::None;
    }

    pub fn has_audit_data(&self) -> bool {
        self.audit_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_data(&mut self, v: u64) {
        self.audit_data = ::std::option::Option::Some(v);
    }

    pub fn get_audit_data(&self) -> u64 {
        self.audit_data.unwrap_or(0)
    }

    fn get_audit_data_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.audit_data
    }

    fn mut_audit_data_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.audit_data
    }
}

impl ::protobuf::Message for CMsgGCToGCGrantAccountRolledItems {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.audit_action = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.audit_data = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.audit_action {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.audit_data {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.audit_action {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.audit_data {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCGrantAccountRolledItems {
    fn new() -> CMsgGCToGCGrantAccountRolledItems {
        CMsgGCToGCGrantAccountRolledItems::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCGrantAccountRolledItems>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCToGCGrantAccountRolledItems::get_account_id_for_reflect,
                    CMsgGCToGCGrantAccountRolledItems::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToGCGrantAccountRolledItems_Item>>(
                    "items",
                    CMsgGCToGCGrantAccountRolledItems::get_items_for_reflect,
                    CMsgGCToGCGrantAccountRolledItems::mut_items_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "audit_action",
                    CMsgGCToGCGrantAccountRolledItems::get_audit_action_for_reflect,
                    CMsgGCToGCGrantAccountRolledItems::mut_audit_action_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "audit_data",
                    CMsgGCToGCGrantAccountRolledItems::get_audit_data_for_reflect,
                    CMsgGCToGCGrantAccountRolledItems::mut_audit_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCGrantAccountRolledItems>(
                    "CMsgGCToGCGrantAccountRolledItems",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCGrantAccountRolledItems {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_items();
        self.clear_audit_action();
        self.clear_audit_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCGrantAccountRolledItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGrantAccountRolledItems {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCGrantAccountRolledItems_Item {
    // message fields
    item_def: ::std::option::Option<u32>,
    loot_lists: ::protobuf::RepeatedField<::std::string::String>,
    ignore_limit: ::std::option::Option<bool>,
    origin: ::std::option::Option<u32>,
    dynamic_attributes: ::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute>,
    additional_audit_entries: ::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry>,
    inventory_token: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCGrantAccountRolledItems_Item {}

impl CMsgGCToGCGrantAccountRolledItems_Item {
    pub fn new() -> CMsgGCToGCGrantAccountRolledItems_Item {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCGrantAccountRolledItems_Item {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCGrantAccountRolledItems_Item> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCGrantAccountRolledItems_Item,
        };
        unsafe {
            instance.get(CMsgGCToGCGrantAccountRolledItems_Item::new)
        }
    }

    // optional uint32 item_def = 1;

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    pub fn get_item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    fn get_item_def_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_def
    }

    fn mut_item_def_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_def
    }

    // repeated string loot_lists = 2;

    pub fn clear_loot_lists(&mut self) {
        self.loot_lists.clear();
    }

    // Param is passed by value, moved
    pub fn set_loot_lists(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.loot_lists = v;
    }

    // Mutable pointer to the field.
    pub fn mut_loot_lists(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.loot_lists
    }

    // Take field
    pub fn take_loot_lists(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.loot_lists, ::protobuf::RepeatedField::new())
    }

    pub fn get_loot_lists(&self) -> &[::std::string::String] {
        &self.loot_lists
    }

    fn get_loot_lists_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.loot_lists
    }

    fn mut_loot_lists_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.loot_lists
    }

    // optional bool ignore_limit = 3;

    pub fn clear_ignore_limit(&mut self) {
        self.ignore_limit = ::std::option::Option::None;
    }

    pub fn has_ignore_limit(&self) -> bool {
        self.ignore_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignore_limit(&mut self, v: bool) {
        self.ignore_limit = ::std::option::Option::Some(v);
    }

    pub fn get_ignore_limit(&self) -> bool {
        self.ignore_limit.unwrap_or(false)
    }

    fn get_ignore_limit_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.ignore_limit
    }

    fn mut_ignore_limit_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.ignore_limit
    }

    // optional uint32 origin = 4;

    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    pub fn get_origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }

    fn get_origin_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.origin
    }

    fn mut_origin_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.origin
    }

    // repeated .CMsgGCToGCGrantAccountRolledItems.Item.DynamicAttribute dynamic_attributes = 5;

    pub fn clear_dynamic_attributes(&mut self) {
        self.dynamic_attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_dynamic_attributes(&mut self, v: ::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute>) {
        self.dynamic_attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dynamic_attributes(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute> {
        &mut self.dynamic_attributes
    }

    // Take field
    pub fn take_dynamic_attributes(&mut self) -> ::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute> {
        ::std::mem::replace(&mut self.dynamic_attributes, ::protobuf::RepeatedField::new())
    }

    pub fn get_dynamic_attributes(&self) -> &[CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute] {
        &self.dynamic_attributes
    }

    fn get_dynamic_attributes_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute> {
        &self.dynamic_attributes
    }

    fn mut_dynamic_attributes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute> {
        &mut self.dynamic_attributes
    }

    // repeated .CMsgGCToGCGrantAccountRolledItems.Item.AdditionalAuditEntry additional_audit_entries = 6;

    pub fn clear_additional_audit_entries(&mut self) {
        self.additional_audit_entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_audit_entries(&mut self, v: ::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry>) {
        self.additional_audit_entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additional_audit_entries(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry> {
        &mut self.additional_audit_entries
    }

    // Take field
    pub fn take_additional_audit_entries(&mut self) -> ::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry> {
        ::std::mem::replace(&mut self.additional_audit_entries, ::protobuf::RepeatedField::new())
    }

    pub fn get_additional_audit_entries(&self) -> &[CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry] {
        &self.additional_audit_entries
    }

    fn get_additional_audit_entries_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry> {
        &self.additional_audit_entries
    }

    fn mut_additional_audit_entries_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry> {
        &mut self.additional_audit_entries
    }

    // optional uint32 inventory_token = 7;

    pub fn clear_inventory_token(&mut self) {
        self.inventory_token = ::std::option::Option::None;
    }

    pub fn has_inventory_token(&self) -> bool {
        self.inventory_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory_token(&mut self, v: u32) {
        self.inventory_token = ::std::option::Option::Some(v);
    }

    pub fn get_inventory_token(&self) -> u32 {
        self.inventory_token.unwrap_or(0)
    }

    fn get_inventory_token_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.inventory_token
    }

    fn mut_inventory_token_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.inventory_token
    }
}

impl ::protobuf::Message for CMsgGCToGCGrantAccountRolledItems_Item {
    fn is_initialized(&self) -> bool {
        for v in &self.dynamic_attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.additional_audit_entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.loot_lists)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ignore_limit = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.origin = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dynamic_attributes)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.additional_audit_entries)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.inventory_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.loot_lists {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.ignore_limit {
            my_size += 2;
        }
        if let Some(v) = self.origin {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.dynamic_attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.additional_audit_entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.inventory_token {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        for v in &self.loot_lists {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.ignore_limit {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(4, v)?;
        }
        for v in &self.dynamic_attributes {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.additional_audit_entries {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.inventory_token {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCGrantAccountRolledItems_Item {
    fn new() -> CMsgGCToGCGrantAccountRolledItems_Item {
        CMsgGCToGCGrantAccountRolledItems_Item::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCGrantAccountRolledItems_Item>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_def",
                    CMsgGCToGCGrantAccountRolledItems_Item::get_item_def_for_reflect,
                    CMsgGCToGCGrantAccountRolledItems_Item::mut_item_def_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "loot_lists",
                    CMsgGCToGCGrantAccountRolledItems_Item::get_loot_lists_for_reflect,
                    CMsgGCToGCGrantAccountRolledItems_Item::mut_loot_lists_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ignore_limit",
                    CMsgGCToGCGrantAccountRolledItems_Item::get_ignore_limit_for_reflect,
                    CMsgGCToGCGrantAccountRolledItems_Item::mut_ignore_limit_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "origin",
                    CMsgGCToGCGrantAccountRolledItems_Item::get_origin_for_reflect,
                    CMsgGCToGCGrantAccountRolledItems_Item::mut_origin_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute>>(
                    "dynamic_attributes",
                    CMsgGCToGCGrantAccountRolledItems_Item::get_dynamic_attributes_for_reflect,
                    CMsgGCToGCGrantAccountRolledItems_Item::mut_dynamic_attributes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry>>(
                    "additional_audit_entries",
                    CMsgGCToGCGrantAccountRolledItems_Item::get_additional_audit_entries_for_reflect,
                    CMsgGCToGCGrantAccountRolledItems_Item::mut_additional_audit_entries_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "inventory_token",
                    CMsgGCToGCGrantAccountRolledItems_Item::get_inventory_token_for_reflect,
                    CMsgGCToGCGrantAccountRolledItems_Item::mut_inventory_token_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCGrantAccountRolledItems_Item>(
                    "CMsgGCToGCGrantAccountRolledItems_Item",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCGrantAccountRolledItems_Item {
    fn clear(&mut self) {
        self.clear_item_def();
        self.clear_loot_lists();
        self.clear_ignore_limit();
        self.clear_origin();
        self.clear_dynamic_attributes();
        self.clear_additional_audit_entries();
        self.clear_inventory_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCGrantAccountRolledItems_Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGrantAccountRolledItems_Item {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value_uint32: ::std::option::Option<u32>,
    value_float: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute {}

impl CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute {
    pub fn new() -> CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute,
        };
        unsafe {
            instance.get(CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional uint32 value_uint32 = 2;

    pub fn clear_value_uint32(&mut self) {
        self.value_uint32 = ::std::option::Option::None;
    }

    pub fn has_value_uint32(&self) -> bool {
        self.value_uint32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_uint32(&mut self, v: u32) {
        self.value_uint32 = ::std::option::Option::Some(v);
    }

    pub fn get_value_uint32(&self) -> u32 {
        self.value_uint32.unwrap_or(0)
    }

    fn get_value_uint32_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.value_uint32
    }

    fn mut_value_uint32_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.value_uint32
    }

    // optional float value_float = 3;

    pub fn clear_value_float(&mut self) {
        self.value_float = ::std::option::Option::None;
    }

    pub fn has_value_float(&self) -> bool {
        self.value_float.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_float(&mut self, v: f32) {
        self.value_float = ::std::option::Option::Some(v);
    }

    pub fn get_value_float(&self) -> f32 {
        self.value_float.unwrap_or(0.)
    }

    fn get_value_float_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.value_float
    }

    fn mut_value_float_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.value_float
    }
}

impl ::protobuf::Message for CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value_uint32 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.value_float = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value_uint32 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value_float {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.value_uint32 {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.value_float {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute {
    fn new() -> CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute {
        CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute::get_name_for_reflect,
                    CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "value_uint32",
                    CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute::get_value_uint32_for_reflect,
                    CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute::mut_value_uint32_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "value_float",
                    CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute::get_value_float_for_reflect,
                    CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute::mut_value_float_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute>(
                    "CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_value_uint32();
        self.clear_value_float();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGrantAccountRolledItems_Item_DynamicAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry {
    // message fields
    owner_account_id: ::std::option::Option<u32>,
    audit_action: ::std::option::Option<u32>,
    audit_data: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry {}

impl CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry {
    pub fn new() -> CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry,
        };
        unsafe {
            instance.get(CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry::new)
        }
    }

    // optional uint32 owner_account_id = 1;

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    fn get_owner_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.owner_account_id
    }

    fn mut_owner_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.owner_account_id
    }

    // optional uint32 audit_action = 2;

    pub fn clear_audit_action(&mut self) {
        self.audit_action = ::std::option::Option::None;
    }

    pub fn has_audit_action(&self) -> bool {
        self.audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_action(&mut self, v: u32) {
        self.audit_action = ::std::option::Option::Some(v);
    }

    pub fn get_audit_action(&self) -> u32 {
        self.audit_action.unwrap_or(0)
    }

    fn get_audit_action_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.audit_action
    }

    fn mut_audit_action_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.audit_action
    }

    // optional uint64 audit_data = 3;

    pub fn clear_audit_data(&mut self) {
        self.audit_data = ::std::option::Option::None;
    }

    pub fn has_audit_data(&self) -> bool {
        self.audit_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_data(&mut self, v: u64) {
        self.audit_data = ::std::option::Option::Some(v);
    }

    pub fn get_audit_data(&self) -> u64 {
        self.audit_data.unwrap_or(0)
    }

    fn get_audit_data_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.audit_data
    }

    fn mut_audit_data_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.audit_data
    }
}

impl ::protobuf::Message for CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.audit_action = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.audit_data = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.audit_action {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.audit_data {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.owner_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.audit_action {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.audit_data {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry {
    fn new() -> CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry {
        CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "owner_account_id",
                    CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry::get_owner_account_id_for_reflect,
                    CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry::mut_owner_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "audit_action",
                    CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry::get_audit_action_for_reflect,
                    CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry::mut_audit_action_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "audit_data",
                    CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry::get_audit_data_for_reflect,
                    CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry::mut_audit_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry>(
                    "CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry {
    fn clear(&mut self) {
        self.clear_owner_account_id();
        self.clear_audit_action();
        self.clear_audit_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGrantAccountRolledItems_Item_AdditionalAuditEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCGrantSelfMadeItemToAccount {
    // message fields
    item_def_index: ::std::option::Option<u32>,
    accountid: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCGrantSelfMadeItemToAccount {}

impl CMsgGCToGCGrantSelfMadeItemToAccount {
    pub fn new() -> CMsgGCToGCGrantSelfMadeItemToAccount {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCGrantSelfMadeItemToAccount {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCGrantSelfMadeItemToAccount> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCGrantSelfMadeItemToAccount,
        };
        unsafe {
            instance.get(CMsgGCToGCGrantSelfMadeItemToAccount::new)
        }
    }

    // optional uint32 item_def_index = 1;

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    pub fn get_item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    fn get_item_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_def_index
    }

    fn mut_item_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_def_index
    }

    // optional uint32 accountid = 2;

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    fn get_accountid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.accountid
    }

    fn mut_accountid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.accountid
    }
}

impl ::protobuf::Message for CMsgGCToGCGrantSelfMadeItemToAccount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.accountid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCGrantSelfMadeItemToAccount {
    fn new() -> CMsgGCToGCGrantSelfMadeItemToAccount {
        CMsgGCToGCGrantSelfMadeItemToAccount::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCGrantSelfMadeItemToAccount>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_def_index",
                    CMsgGCToGCGrantSelfMadeItemToAccount::get_item_def_index_for_reflect,
                    CMsgGCToGCGrantSelfMadeItemToAccount::mut_item_def_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    CMsgGCToGCGrantSelfMadeItemToAccount::get_accountid_for_reflect,
                    CMsgGCToGCGrantSelfMadeItemToAccount::mut_accountid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCGrantSelfMadeItemToAccount>(
                    "CMsgGCToGCGrantSelfMadeItemToAccount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCGrantSelfMadeItemToAccount {
    fn clear(&mut self) {
        self.clear_item_def_index();
        self.clear_accountid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCGrantSelfMadeItemToAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGrantSelfMadeItemToAccount {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgUseItem {
    // message fields
    item_id: ::std::option::Option<u64>,
    target_steam_id: ::std::option::Option<u64>,
    gift__potential_targets: ::std::vec::Vec<u32>,
    duel__class_lock: ::std::option::Option<u32>,
    initiator_steam_id: ::std::option::Option<u64>,
    itempack__ack_immediately: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgUseItem {}

impl CMsgUseItem {
    pub fn new() -> CMsgUseItem {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgUseItem {
        static mut instance: ::protobuf::lazy::Lazy<CMsgUseItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgUseItem,
        };
        unsafe {
            instance.get(CMsgUseItem::new)
        }
    }

    // optional uint64 item_id = 1;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }

    // optional fixed64 target_steam_id = 2;

    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }

    fn get_target_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.target_steam_id
    }

    fn mut_target_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.target_steam_id
    }

    // repeated uint32 gift__potential_targets = 3;

    pub fn clear_gift__potential_targets(&mut self) {
        self.gift__potential_targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_gift__potential_targets(&mut self, v: ::std::vec::Vec<u32>) {
        self.gift__potential_targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gift__potential_targets(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.gift__potential_targets
    }

    // Take field
    pub fn take_gift__potential_targets(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.gift__potential_targets, ::std::vec::Vec::new())
    }

    pub fn get_gift__potential_targets(&self) -> &[u32] {
        &self.gift__potential_targets
    }

    fn get_gift__potential_targets_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.gift__potential_targets
    }

    fn mut_gift__potential_targets_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.gift__potential_targets
    }

    // optional uint32 duel__class_lock = 4;

    pub fn clear_duel__class_lock(&mut self) {
        self.duel__class_lock = ::std::option::Option::None;
    }

    pub fn has_duel__class_lock(&self) -> bool {
        self.duel__class_lock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel__class_lock(&mut self, v: u32) {
        self.duel__class_lock = ::std::option::Option::Some(v);
    }

    pub fn get_duel__class_lock(&self) -> u32 {
        self.duel__class_lock.unwrap_or(0)
    }

    fn get_duel__class_lock_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.duel__class_lock
    }

    fn mut_duel__class_lock_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.duel__class_lock
    }

    // optional uint64 initiator_steam_id = 5;

    pub fn clear_initiator_steam_id(&mut self) {
        self.initiator_steam_id = ::std::option::Option::None;
    }

    pub fn has_initiator_steam_id(&self) -> bool {
        self.initiator_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator_steam_id(&mut self, v: u64) {
        self.initiator_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_initiator_steam_id(&self) -> u64 {
        self.initiator_steam_id.unwrap_or(0)
    }

    fn get_initiator_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.initiator_steam_id
    }

    fn mut_initiator_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.initiator_steam_id
    }

    // optional bool itempack__ack_immediately = 6;

    pub fn clear_itempack__ack_immediately(&mut self) {
        self.itempack__ack_immediately = ::std::option::Option::None;
    }

    pub fn has_itempack__ack_immediately(&self) -> bool {
        self.itempack__ack_immediately.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itempack__ack_immediately(&mut self, v: bool) {
        self.itempack__ack_immediately = ::std::option::Option::Some(v);
    }

    pub fn get_itempack__ack_immediately(&self) -> bool {
        self.itempack__ack_immediately.unwrap_or(false)
    }

    fn get_itempack__ack_immediately_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.itempack__ack_immediately
    }

    fn mut_itempack__ack_immediately_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.itempack__ack_immediately
    }
}

impl ::protobuf::Message for CMsgUseItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.target_steam_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.gift__potential_targets)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.duel__class_lock = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.initiator_steam_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.itempack__ack_immediately = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_steam_id {
            my_size += 9;
        }
        for value in &self.gift__potential_targets {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.duel__class_lock {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initiator_steam_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.itempack__ack_immediately {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.gift__potential_targets {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.duel__class_lock {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.initiator_steam_id {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.itempack__ack_immediately {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgUseItem {
    fn new() -> CMsgUseItem {
        CMsgUseItem::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgUseItem>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgUseItem::get_item_id_for_reflect,
                    CMsgUseItem::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "target_steam_id",
                    CMsgUseItem::get_target_steam_id_for_reflect,
                    CMsgUseItem::mut_target_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gift__potential_targets",
                    CMsgUseItem::get_gift__potential_targets_for_reflect,
                    CMsgUseItem::mut_gift__potential_targets_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "duel__class_lock",
                    CMsgUseItem::get_duel__class_lock_for_reflect,
                    CMsgUseItem::mut_duel__class_lock_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "initiator_steam_id",
                    CMsgUseItem::get_initiator_steam_id_for_reflect,
                    CMsgUseItem::mut_initiator_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "itempack__ack_immediately",
                    CMsgUseItem::get_itempack__ack_immediately_for_reflect,
                    CMsgUseItem::mut_itempack__ack_immediately_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgUseItem>(
                    "CMsgUseItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgUseItem {
    fn clear(&mut self) {
        self.clear_item_id();
        self.clear_target_steam_id();
        self.clear_gift__potential_targets();
        self.clear_duel__class_lock();
        self.clear_initiator_steam_id();
        self.clear_itempack__ack_immediately();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgUseItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUseItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerUseItem {
    // message fields
    initiator_account_id: ::std::option::Option<u32>,
    use_item_msg: ::protobuf::SingularPtrField<CMsgUseItem>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgServerUseItem {}

impl CMsgServerUseItem {
    pub fn new() -> CMsgServerUseItem {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgServerUseItem {
        static mut instance: ::protobuf::lazy::Lazy<CMsgServerUseItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgServerUseItem,
        };
        unsafe {
            instance.get(CMsgServerUseItem::new)
        }
    }

    // optional uint32 initiator_account_id = 1;

    pub fn clear_initiator_account_id(&mut self) {
        self.initiator_account_id = ::std::option::Option::None;
    }

    pub fn has_initiator_account_id(&self) -> bool {
        self.initiator_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator_account_id(&mut self, v: u32) {
        self.initiator_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_initiator_account_id(&self) -> u32 {
        self.initiator_account_id.unwrap_or(0)
    }

    fn get_initiator_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.initiator_account_id
    }

    fn mut_initiator_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.initiator_account_id
    }

    // optional .CMsgUseItem use_item_msg = 2;

    pub fn clear_use_item_msg(&mut self) {
        self.use_item_msg.clear();
    }

    pub fn has_use_item_msg(&self) -> bool {
        self.use_item_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_item_msg(&mut self, v: CMsgUseItem) {
        self.use_item_msg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_use_item_msg(&mut self) -> &mut CMsgUseItem {
        if self.use_item_msg.is_none() {
            self.use_item_msg.set_default();
        }
        self.use_item_msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_use_item_msg(&mut self) -> CMsgUseItem {
        self.use_item_msg.take().unwrap_or_else(|| CMsgUseItem::new())
    }

    pub fn get_use_item_msg(&self) -> &CMsgUseItem {
        self.use_item_msg.as_ref().unwrap_or_else(|| CMsgUseItem::default_instance())
    }

    fn get_use_item_msg_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgUseItem> {
        &self.use_item_msg
    }

    fn mut_use_item_msg_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgUseItem> {
        &mut self.use_item_msg
    }
}

impl ::protobuf::Message for CMsgServerUseItem {
    fn is_initialized(&self) -> bool {
        for v in &self.use_item_msg {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initiator_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.use_item_msg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.initiator_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.use_item_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.initiator_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.use_item_msg.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgServerUseItem {
    fn new() -> CMsgServerUseItem {
        CMsgServerUseItem::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgServerUseItem>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "initiator_account_id",
                    CMsgServerUseItem::get_initiator_account_id_for_reflect,
                    CMsgServerUseItem::mut_initiator_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgUseItem>>(
                    "use_item_msg",
                    CMsgServerUseItem::get_use_item_msg_for_reflect,
                    CMsgServerUseItem::mut_use_item_msg_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgServerUseItem>(
                    "CMsgServerUseItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgServerUseItem {
    fn clear(&mut self) {
        self.clear_initiator_account_id();
        self.clear_use_item_msg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerUseItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerUseItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgUseMultipleItems {
    // message fields
    item_ids: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgUseMultipleItems {}

impl CMsgUseMultipleItems {
    pub fn new() -> CMsgUseMultipleItems {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgUseMultipleItems {
        static mut instance: ::protobuf::lazy::Lazy<CMsgUseMultipleItems> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgUseMultipleItems,
        };
        unsafe {
            instance.get(CMsgUseMultipleItems::new)
        }
    }

    // repeated uint64 item_ids = 1;

    pub fn clear_item_ids(&mut self) {
        self.item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }

    // Take field
    pub fn take_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.item_ids, ::std::vec::Vec::new())
    }

    pub fn get_item_ids(&self) -> &[u64] {
        &self.item_ids
    }

    fn get_item_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.item_ids
    }

    fn mut_item_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }
}

impl ::protobuf::Message for CMsgUseMultipleItems {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.item_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgUseMultipleItems {
    fn new() -> CMsgUseMultipleItems {
        CMsgUseMultipleItems::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgUseMultipleItems>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_ids",
                    CMsgUseMultipleItems::get_item_ids_for_reflect,
                    CMsgUseMultipleItems::mut_item_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgUseMultipleItems>(
                    "CMsgUseMultipleItems",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgUseMultipleItems {
    fn clear(&mut self) {
        self.clear_item_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgUseMultipleItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUseMultipleItems {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCPartnerBalanceRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCPartnerBalanceRequest {}

impl CMsgGCPartnerBalanceRequest {
    pub fn new() -> CMsgGCPartnerBalanceRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCPartnerBalanceRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCPartnerBalanceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCPartnerBalanceRequest,
        };
        unsafe {
            instance.get(CMsgGCPartnerBalanceRequest::new)
        }
    }
}

impl ::protobuf::Message for CMsgGCPartnerBalanceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCPartnerBalanceRequest {
    fn new() -> CMsgGCPartnerBalanceRequest {
        CMsgGCPartnerBalanceRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCPartnerBalanceRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCPartnerBalanceRequest>(
                    "CMsgGCPartnerBalanceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCPartnerBalanceRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCPartnerBalanceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCPartnerBalanceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCPartnerBalanceResponse {
    // message fields
    result: ::std::option::Option<super::econ_shared_enums::EGCPartnerRequestResponse>,
    balance: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCPartnerBalanceResponse {}

impl CMsgGCPartnerBalanceResponse {
    pub fn new() -> CMsgGCPartnerBalanceResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCPartnerBalanceResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCPartnerBalanceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCPartnerBalanceResponse,
        };
        unsafe {
            instance.get(CMsgGCPartnerBalanceResponse::new)
        }
    }

    // optional .EGCPartnerRequestResponse result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::econ_shared_enums::EGCPartnerRequestResponse) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> super::econ_shared_enums::EGCPartnerRequestResponse {
        self.result.unwrap_or(super::econ_shared_enums::EGCPartnerRequestResponse::k_EPartnerRequestOK)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<super::econ_shared_enums::EGCPartnerRequestResponse> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<super::econ_shared_enums::EGCPartnerRequestResponse> {
        &mut self.result
    }

    // optional uint32 balance = 2;

    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: u32) {
        self.balance = ::std::option::Option::Some(v);
    }

    pub fn get_balance(&self) -> u32 {
        self.balance.unwrap_or(0)
    }

    fn get_balance_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.balance
    }

    fn mut_balance_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.balance
    }
}

impl ::protobuf::Message for CMsgGCPartnerBalanceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.balance = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.balance {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.balance {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCPartnerBalanceResponse {
    fn new() -> CMsgGCPartnerBalanceResponse {
        CMsgGCPartnerBalanceResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCPartnerBalanceResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::econ_shared_enums::EGCPartnerRequestResponse>>(
                    "result",
                    CMsgGCPartnerBalanceResponse::get_result_for_reflect,
                    CMsgGCPartnerBalanceResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "balance",
                    CMsgGCPartnerBalanceResponse::get_balance_for_reflect,
                    CMsgGCPartnerBalanceResponse::mut_balance_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCPartnerBalanceResponse>(
                    "CMsgGCPartnerBalanceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCPartnerBalanceResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_balance();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCPartnerBalanceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCPartnerBalanceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGCStoreRechargeRedirect_LineItem {
    // message fields
    item_def_id: ::std::option::Option<u32>,
    quantity: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CGCStoreRechargeRedirect_LineItem {}

impl CGCStoreRechargeRedirect_LineItem {
    pub fn new() -> CGCStoreRechargeRedirect_LineItem {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CGCStoreRechargeRedirect_LineItem {
        static mut instance: ::protobuf::lazy::Lazy<CGCStoreRechargeRedirect_LineItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CGCStoreRechargeRedirect_LineItem,
        };
        unsafe {
            instance.get(CGCStoreRechargeRedirect_LineItem::new)
        }
    }

    // optional uint32 item_def_id = 1;

    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: u32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_def_id(&self) -> u32 {
        self.item_def_id.unwrap_or(0)
    }

    fn get_item_def_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_def_id
    }

    fn mut_item_def_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_def_id
    }

    // optional uint32 quantity = 2;

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    pub fn get_quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    fn get_quantity_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.quantity
    }

    fn mut_quantity_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.quantity
    }
}

impl ::protobuf::Message for CGCStoreRechargeRedirect_LineItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quantity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CGCStoreRechargeRedirect_LineItem {
    fn new() -> CGCStoreRechargeRedirect_LineItem {
        CGCStoreRechargeRedirect_LineItem::new()
    }

    fn descriptor_static(_: ::std::option::Option<CGCStoreRechargeRedirect_LineItem>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_def_id",
                    CGCStoreRechargeRedirect_LineItem::get_item_def_id_for_reflect,
                    CGCStoreRechargeRedirect_LineItem::mut_item_def_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quantity",
                    CGCStoreRechargeRedirect_LineItem::get_quantity_for_reflect,
                    CGCStoreRechargeRedirect_LineItem::mut_quantity_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CGCStoreRechargeRedirect_LineItem>(
                    "CGCStoreRechargeRedirect_LineItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CGCStoreRechargeRedirect_LineItem {
    fn clear(&mut self) {
        self.clear_item_def_id();
        self.clear_quantity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCStoreRechargeRedirect_LineItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCStoreRechargeRedirect_LineItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCPartnerRechargeRedirectURLRequest {
    // message fields
    line_items: ::protobuf::RepeatedField<CGCStoreRechargeRedirect_LineItem>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCPartnerRechargeRedirectURLRequest {}

impl CMsgGCPartnerRechargeRedirectURLRequest {
    pub fn new() -> CMsgGCPartnerRechargeRedirectURLRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCPartnerRechargeRedirectURLRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCPartnerRechargeRedirectURLRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCPartnerRechargeRedirectURLRequest,
        };
        unsafe {
            instance.get(CMsgGCPartnerRechargeRedirectURLRequest::new)
        }
    }

    // repeated .CGCStoreRechargeRedirect_LineItem line_items = 1;

    pub fn clear_line_items(&mut self) {
        self.line_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_line_items(&mut self, v: ::protobuf::RepeatedField<CGCStoreRechargeRedirect_LineItem>) {
        self.line_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_line_items(&mut self) -> &mut ::protobuf::RepeatedField<CGCStoreRechargeRedirect_LineItem> {
        &mut self.line_items
    }

    // Take field
    pub fn take_line_items(&mut self) -> ::protobuf::RepeatedField<CGCStoreRechargeRedirect_LineItem> {
        ::std::mem::replace(&mut self.line_items, ::protobuf::RepeatedField::new())
    }

    pub fn get_line_items(&self) -> &[CGCStoreRechargeRedirect_LineItem] {
        &self.line_items
    }

    fn get_line_items_for_reflect(&self) -> &::protobuf::RepeatedField<CGCStoreRechargeRedirect_LineItem> {
        &self.line_items
    }

    fn mut_line_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CGCStoreRechargeRedirect_LineItem> {
        &mut self.line_items
    }
}

impl ::protobuf::Message for CMsgGCPartnerRechargeRedirectURLRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.line_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.line_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.line_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.line_items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCPartnerRechargeRedirectURLRequest {
    fn new() -> CMsgGCPartnerRechargeRedirectURLRequest {
        CMsgGCPartnerRechargeRedirectURLRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCPartnerRechargeRedirectURLRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CGCStoreRechargeRedirect_LineItem>>(
                    "line_items",
                    CMsgGCPartnerRechargeRedirectURLRequest::get_line_items_for_reflect,
                    CMsgGCPartnerRechargeRedirectURLRequest::mut_line_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCPartnerRechargeRedirectURLRequest>(
                    "CMsgGCPartnerRechargeRedirectURLRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCPartnerRechargeRedirectURLRequest {
    fn clear(&mut self) {
        self.clear_line_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCPartnerRechargeRedirectURLRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCPartnerRechargeRedirectURLRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCPartnerRechargeRedirectURLResponse {
    // message fields
    result: ::std::option::Option<super::econ_shared_enums::EGCPartnerRequestResponse>,
    url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCPartnerRechargeRedirectURLResponse {}

impl CMsgGCPartnerRechargeRedirectURLResponse {
    pub fn new() -> CMsgGCPartnerRechargeRedirectURLResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCPartnerRechargeRedirectURLResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCPartnerRechargeRedirectURLResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCPartnerRechargeRedirectURLResponse,
        };
        unsafe {
            instance.get(CMsgGCPartnerRechargeRedirectURLResponse::new)
        }
    }

    // optional .EGCPartnerRequestResponse result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::econ_shared_enums::EGCPartnerRequestResponse) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> super::econ_shared_enums::EGCPartnerRequestResponse {
        self.result.unwrap_or(super::econ_shared_enums::EGCPartnerRequestResponse::k_EPartnerRequestOK)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<super::econ_shared_enums::EGCPartnerRequestResponse> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<super::econ_shared_enums::EGCPartnerRequestResponse> {
        &mut self.result
    }

    // optional string url = 2;

    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_url_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.url
    }

    fn mut_url_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.url
    }
}

impl ::protobuf::Message for CMsgGCPartnerRechargeRedirectURLResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCPartnerRechargeRedirectURLResponse {
    fn new() -> CMsgGCPartnerRechargeRedirectURLResponse {
        CMsgGCPartnerRechargeRedirectURLResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCPartnerRechargeRedirectURLResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::econ_shared_enums::EGCPartnerRequestResponse>>(
                    "result",
                    CMsgGCPartnerRechargeRedirectURLResponse::get_result_for_reflect,
                    CMsgGCPartnerRechargeRedirectURLResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    CMsgGCPartnerRechargeRedirectURLResponse::get_url_for_reflect,
                    CMsgGCPartnerRechargeRedirectURLResponse::mut_url_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCPartnerRechargeRedirectURLResponse>(
                    "CMsgGCPartnerRechargeRedirectURLResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCPartnerRechargeRedirectURLResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_url();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCPartnerRechargeRedirectURLResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCPartnerRechargeRedirectURLResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    // message fields
    account_id: ::std::option::Option<u32>,
    deleted_item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCEconSQLWorkItemEmbeddedRollbackData {}

impl CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    pub fn new() -> CMsgGCEconSQLWorkItemEmbeddedRollbackData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCEconSQLWorkItemEmbeddedRollbackData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCEconSQLWorkItemEmbeddedRollbackData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCEconSQLWorkItemEmbeddedRollbackData,
        };
        unsafe {
            instance.get(CMsgGCEconSQLWorkItemEmbeddedRollbackData::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint64 deleted_item_id = 2;

    pub fn clear_deleted_item_id(&mut self) {
        self.deleted_item_id = ::std::option::Option::None;
    }

    pub fn has_deleted_item_id(&self) -> bool {
        self.deleted_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted_item_id(&mut self, v: u64) {
        self.deleted_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_deleted_item_id(&self) -> u64 {
        self.deleted_item_id.unwrap_or(0)
    }

    fn get_deleted_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.deleted_item_id
    }

    fn mut_deleted_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.deleted_item_id
    }
}

impl ::protobuf::Message for CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.deleted_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deleted_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.deleted_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    fn new() -> CMsgGCEconSQLWorkItemEmbeddedRollbackData {
        CMsgGCEconSQLWorkItemEmbeddedRollbackData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCEconSQLWorkItemEmbeddedRollbackData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCEconSQLWorkItemEmbeddedRollbackData::get_account_id_for_reflect,
                    CMsgGCEconSQLWorkItemEmbeddedRollbackData::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "deleted_item_id",
                    CMsgGCEconSQLWorkItemEmbeddedRollbackData::get_deleted_item_id_for_reflect,
                    CMsgGCEconSQLWorkItemEmbeddedRollbackData::mut_deleted_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCEconSQLWorkItemEmbeddedRollbackData>(
                    "CMsgGCEconSQLWorkItemEmbeddedRollbackData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_deleted_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCEconSQLWorkItemEmbeddedRollbackData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCraftStatue {
    // message fields
    heroid: ::std::option::Option<u32>,
    sequencename: ::protobuf::SingularField<::std::string::String>,
    cycle: ::std::option::Option<f32>,
    description: ::protobuf::SingularField<::std::string::String>,
    pedestal_itemdef: ::std::option::Option<u32>,
    toolid: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgCraftStatue {}

impl CMsgCraftStatue {
    pub fn new() -> CMsgCraftStatue {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgCraftStatue {
        static mut instance: ::protobuf::lazy::Lazy<CMsgCraftStatue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgCraftStatue,
        };
        unsafe {
            instance.get(CMsgCraftStatue::new)
        }
    }

    // optional uint32 heroid = 1;

    pub fn clear_heroid(&mut self) {
        self.heroid = ::std::option::Option::None;
    }

    pub fn has_heroid(&self) -> bool {
        self.heroid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heroid(&mut self, v: u32) {
        self.heroid = ::std::option::Option::Some(v);
    }

    pub fn get_heroid(&self) -> u32 {
        self.heroid.unwrap_or(0)
    }

    fn get_heroid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.heroid
    }

    fn mut_heroid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.heroid
    }

    // optional string sequencename = 2;

    pub fn clear_sequencename(&mut self) {
        self.sequencename.clear();
    }

    pub fn has_sequencename(&self) -> bool {
        self.sequencename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequencename(&mut self, v: ::std::string::String) {
        self.sequencename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequencename(&mut self) -> &mut ::std::string::String {
        if self.sequencename.is_none() {
            self.sequencename.set_default();
        }
        self.sequencename.as_mut().unwrap()
    }

    // Take field
    pub fn take_sequencename(&mut self) -> ::std::string::String {
        self.sequencename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_sequencename(&self) -> &str {
        match self.sequencename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_sequencename_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.sequencename
    }

    fn mut_sequencename_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.sequencename
    }

    // optional float cycle = 3;

    pub fn clear_cycle(&mut self) {
        self.cycle = ::std::option::Option::None;
    }

    pub fn has_cycle(&self) -> bool {
        self.cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cycle(&mut self, v: f32) {
        self.cycle = ::std::option::Option::Some(v);
    }

    pub fn get_cycle(&self) -> f32 {
        self.cycle.unwrap_or(0.)
    }

    fn get_cycle_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.cycle
    }

    fn mut_cycle_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.cycle
    }

    // optional string description = 4;

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_description_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.description
    }

    fn mut_description_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.description
    }

    // optional uint32 pedestal_itemdef = 5;

    pub fn clear_pedestal_itemdef(&mut self) {
        self.pedestal_itemdef = ::std::option::Option::None;
    }

    pub fn has_pedestal_itemdef(&self) -> bool {
        self.pedestal_itemdef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pedestal_itemdef(&mut self, v: u32) {
        self.pedestal_itemdef = ::std::option::Option::Some(v);
    }

    pub fn get_pedestal_itemdef(&self) -> u32 {
        self.pedestal_itemdef.unwrap_or(0)
    }

    fn get_pedestal_itemdef_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.pedestal_itemdef
    }

    fn mut_pedestal_itemdef_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.pedestal_itemdef
    }

    // optional uint64 toolid = 6;

    pub fn clear_toolid(&mut self) {
        self.toolid = ::std::option::Option::None;
    }

    pub fn has_toolid(&self) -> bool {
        self.toolid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toolid(&mut self, v: u64) {
        self.toolid = ::std::option::Option::Some(v);
    }

    pub fn get_toolid(&self) -> u64 {
        self.toolid.unwrap_or(0)
    }

    fn get_toolid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.toolid
    }

    fn mut_toolid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.toolid
    }
}

impl ::protobuf::Message for CMsgCraftStatue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.heroid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sequencename)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cycle = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pedestal_itemdef = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.toolid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.heroid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sequencename.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.cycle {
            my_size += 5;
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.pedestal_itemdef {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.toolid {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.heroid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.sequencename.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.cycle {
            os.write_float(3, v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.pedestal_itemdef {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.toolid {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgCraftStatue {
    fn new() -> CMsgCraftStatue {
        CMsgCraftStatue::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgCraftStatue>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "heroid",
                    CMsgCraftStatue::get_heroid_for_reflect,
                    CMsgCraftStatue::mut_heroid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sequencename",
                    CMsgCraftStatue::get_sequencename_for_reflect,
                    CMsgCraftStatue::mut_sequencename_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "cycle",
                    CMsgCraftStatue::get_cycle_for_reflect,
                    CMsgCraftStatue::mut_cycle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    CMsgCraftStatue::get_description_for_reflect,
                    CMsgCraftStatue::mut_description_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pedestal_itemdef",
                    CMsgCraftStatue::get_pedestal_itemdef_for_reflect,
                    CMsgCraftStatue::mut_pedestal_itemdef_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "toolid",
                    CMsgCraftStatue::get_toolid_for_reflect,
                    CMsgCraftStatue::mut_toolid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgCraftStatue>(
                    "CMsgCraftStatue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgCraftStatue {
    fn clear(&mut self) {
        self.clear_heroid();
        self.clear_sequencename();
        self.clear_cycle();
        self.clear_description();
        self.clear_pedestal_itemdef();
        self.clear_toolid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCraftStatue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCraftStatue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRedeemCode {
    // message fields
    code: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgRedeemCode {}

impl CMsgRedeemCode {
    pub fn new() -> CMsgRedeemCode {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgRedeemCode {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRedeemCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRedeemCode,
        };
        unsafe {
            instance.get(CMsgRedeemCode::new)
        }
    }

    // optional string code = 1;

    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        self.code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_code(&self) -> &str {
        match self.code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_code_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.code
    }

    fn mut_code_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.code
    }
}

impl ::protobuf::Message for CMsgRedeemCode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.code.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgRedeemCode {
    fn new() -> CMsgRedeemCode {
        CMsgRedeemCode::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgRedeemCode>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "code",
                    CMsgRedeemCode::get_code_for_reflect,
                    CMsgRedeemCode::mut_code_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRedeemCode>(
                    "CMsgRedeemCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgRedeemCode {
    fn clear(&mut self) {
        self.clear_code();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRedeemCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRedeemCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRedeemCodeResponse {
    // message fields
    response: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgRedeemCodeResponse {}

impl CMsgRedeemCodeResponse {
    pub fn new() -> CMsgRedeemCodeResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgRedeemCodeResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgRedeemCodeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgRedeemCodeResponse,
        };
        unsafe {
            instance.get(CMsgRedeemCodeResponse::new)
        }
    }

    // optional uint32 response = 1;

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: u32) {
        self.response = ::std::option::Option::Some(v);
    }

    pub fn get_response(&self) -> u32 {
        self.response.unwrap_or(0)
    }

    fn get_response_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.response
    }

    fn mut_response_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.response
    }

    // optional uint64 item_id = 2;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }
}

impl ::protobuf::Message for CMsgRedeemCodeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.response = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.response {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgRedeemCodeResponse {
    fn new() -> CMsgRedeemCodeResponse {
        CMsgRedeemCodeResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgRedeemCodeResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "response",
                    CMsgRedeemCodeResponse::get_response_for_reflect,
                    CMsgRedeemCodeResponse::mut_response_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgRedeemCodeResponse::get_item_id_for_reflect,
                    CMsgRedeemCodeResponse::mut_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgRedeemCodeResponse>(
                    "CMsgRedeemCodeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgRedeemCodeResponse {
    fn clear(&mut self) {
        self.clear_response();
        self.clear_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRedeemCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRedeemCodeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgRedeemCodeResponse_EResultCode {
    k_Succeeded = 0,
    k_Failed_CodeNotFound = 1,
    k_Failed_CodeAlreadyUsed = 2,
    k_Failed_OtherError = 3,
}

impl ::protobuf::ProtobufEnum for CMsgRedeemCodeResponse_EResultCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgRedeemCodeResponse_EResultCode> {
        match value {
            0 => ::std::option::Option::Some(CMsgRedeemCodeResponse_EResultCode::k_Succeeded),
            1 => ::std::option::Option::Some(CMsgRedeemCodeResponse_EResultCode::k_Failed_CodeNotFound),
            2 => ::std::option::Option::Some(CMsgRedeemCodeResponse_EResultCode::k_Failed_CodeAlreadyUsed),
            3 => ::std::option::Option::Some(CMsgRedeemCodeResponse_EResultCode::k_Failed_OtherError),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgRedeemCodeResponse_EResultCode] = &[
            CMsgRedeemCodeResponse_EResultCode::k_Succeeded,
            CMsgRedeemCodeResponse_EResultCode::k_Failed_CodeNotFound,
            CMsgRedeemCodeResponse_EResultCode::k_Failed_CodeAlreadyUsed,
            CMsgRedeemCodeResponse_EResultCode::k_Failed_OtherError,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgRedeemCodeResponse_EResultCode>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgRedeemCodeResponse_EResultCode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgRedeemCodeResponse_EResultCode {
}

impl ::protobuf::reflect::ProtobufValue for CMsgRedeemCodeResponse_EResultCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDevNewItemRequest {
    // message fields
    item_def_name: ::protobuf::SingularField<::std::string::String>,
    loot_list_name: ::protobuf::SingularField<::std::string::String>,
    attr_def_name: ::protobuf::RepeatedField<::std::string::String>,
    attr_value: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDevNewItemRequest {}

impl CMsgDevNewItemRequest {
    pub fn new() -> CMsgDevNewItemRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDevNewItemRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDevNewItemRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDevNewItemRequest,
        };
        unsafe {
            instance.get(CMsgDevNewItemRequest::new)
        }
    }

    // optional string item_def_name = 3;

    pub fn clear_item_def_name(&mut self) {
        self.item_def_name.clear();
    }

    pub fn has_item_def_name(&self) -> bool {
        self.item_def_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_name(&mut self, v: ::std::string::String) {
        self.item_def_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_def_name(&mut self) -> &mut ::std::string::String {
        if self.item_def_name.is_none() {
            self.item_def_name.set_default();
        }
        self.item_def_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_def_name(&mut self) -> ::std::string::String {
        self.item_def_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_item_def_name(&self) -> &str {
        match self.item_def_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_item_def_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.item_def_name
    }

    fn mut_item_def_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.item_def_name
    }

    // optional string loot_list_name = 4;

    pub fn clear_loot_list_name(&mut self) {
        self.loot_list_name.clear();
    }

    pub fn has_loot_list_name(&self) -> bool {
        self.loot_list_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loot_list_name(&mut self, v: ::std::string::String) {
        self.loot_list_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loot_list_name(&mut self) -> &mut ::std::string::String {
        if self.loot_list_name.is_none() {
            self.loot_list_name.set_default();
        }
        self.loot_list_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_loot_list_name(&mut self) -> ::std::string::String {
        self.loot_list_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_loot_list_name(&self) -> &str {
        match self.loot_list_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_loot_list_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.loot_list_name
    }

    fn mut_loot_list_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.loot_list_name
    }

    // repeated string attr_def_name = 5;

    pub fn clear_attr_def_name(&mut self) {
        self.attr_def_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_attr_def_name(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.attr_def_name = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attr_def_name(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.attr_def_name
    }

    // Take field
    pub fn take_attr_def_name(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.attr_def_name, ::protobuf::RepeatedField::new())
    }

    pub fn get_attr_def_name(&self) -> &[::std::string::String] {
        &self.attr_def_name
    }

    fn get_attr_def_name_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.attr_def_name
    }

    fn mut_attr_def_name_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.attr_def_name
    }

    // repeated string attr_value = 6;

    pub fn clear_attr_value(&mut self) {
        self.attr_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_attr_value(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.attr_value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attr_value(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.attr_value
    }

    // Take field
    pub fn take_attr_value(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.attr_value, ::protobuf::RepeatedField::new())
    }

    pub fn get_attr_value(&self) -> &[::std::string::String] {
        &self.attr_value
    }

    fn get_attr_value_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.attr_value
    }

    fn mut_attr_value_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.attr_value
    }
}

impl ::protobuf::Message for CMsgDevNewItemRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.item_def_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loot_list_name)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.attr_def_name)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.attr_value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.item_def_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.loot_list_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.attr_def_name {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.attr_value {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.item_def_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.loot_list_name.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.attr_def_name {
            os.write_string(5, &v)?;
        };
        for v in &self.attr_value {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDevNewItemRequest {
    fn new() -> CMsgDevNewItemRequest {
        CMsgDevNewItemRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDevNewItemRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "item_def_name",
                    CMsgDevNewItemRequest::get_item_def_name_for_reflect,
                    CMsgDevNewItemRequest::mut_item_def_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "loot_list_name",
                    CMsgDevNewItemRequest::get_loot_list_name_for_reflect,
                    CMsgDevNewItemRequest::mut_loot_list_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "attr_def_name",
                    CMsgDevNewItemRequest::get_attr_def_name_for_reflect,
                    CMsgDevNewItemRequest::mut_attr_def_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "attr_value",
                    CMsgDevNewItemRequest::get_attr_value_for_reflect,
                    CMsgDevNewItemRequest::mut_attr_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDevNewItemRequest>(
                    "CMsgDevNewItemRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDevNewItemRequest {
    fn clear(&mut self) {
        self.clear_item_def_name();
        self.clear_loot_list_name();
        self.clear_attr_def_name();
        self.clear_attr_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDevNewItemRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDevNewItemRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDevNewItemRequestResponse {
    // message fields
    success: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgDevNewItemRequestResponse {}

impl CMsgDevNewItemRequestResponse {
    pub fn new() -> CMsgDevNewItemRequestResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgDevNewItemRequestResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgDevNewItemRequestResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgDevNewItemRequestResponse,
        };
        unsafe {
            instance.get(CMsgDevNewItemRequestResponse::new)
        }
    }

    // optional bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    fn get_success_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.success
    }

    fn mut_success_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.success
    }
}

impl ::protobuf::Message for CMsgDevNewItemRequestResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgDevNewItemRequestResponse {
    fn new() -> CMsgDevNewItemRequestResponse {
        CMsgDevNewItemRequestResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgDevNewItemRequestResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    CMsgDevNewItemRequestResponse::get_success_for_reflect,
                    CMsgDevNewItemRequestResponse::mut_success_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgDevNewItemRequestResponse>(
                    "CMsgDevNewItemRequestResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgDevNewItemRequestResponse {
    fn clear(&mut self) {
        self.clear_success();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDevNewItemRequestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDevNewItemRequestResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCheckAccountSubscription {
    // message fields
    account_id: ::std::option::Option<u32>,
    def_index: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCheckAccountSubscription {}

impl CMsgGCCheckAccountSubscription {
    pub fn new() -> CMsgGCCheckAccountSubscription {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCheckAccountSubscription {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCheckAccountSubscription> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCheckAccountSubscription,
        };
        unsafe {
            instance.get(CMsgGCCheckAccountSubscription::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 def_index = 2;

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    fn get_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.def_index
    }

    fn mut_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.def_index
    }
}

impl ::protobuf::Message for CMsgGCCheckAccountSubscription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCheckAccountSubscription {
    fn new() -> CMsgGCCheckAccountSubscription {
        CMsgGCCheckAccountSubscription::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCheckAccountSubscription>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCCheckAccountSubscription::get_account_id_for_reflect,
                    CMsgGCCheckAccountSubscription::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "def_index",
                    CMsgGCCheckAccountSubscription::get_def_index_for_reflect,
                    CMsgGCCheckAccountSubscription::mut_def_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCheckAccountSubscription>(
                    "CMsgGCCheckAccountSubscription",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCheckAccountSubscription {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_def_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCheckAccountSubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCheckAccountSubscription {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCheckAccountSubscriptionResponse {
    // message fields
    state: ::std::option::Option<CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState>,
    cache_until: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCCheckAccountSubscriptionResponse {}

impl CMsgGCCheckAccountSubscriptionResponse {
    pub fn new() -> CMsgGCCheckAccountSubscriptionResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCCheckAccountSubscriptionResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCCheckAccountSubscriptionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCCheckAccountSubscriptionResponse,
        };
        unsafe {
            instance.get(CMsgGCCheckAccountSubscriptionResponse::new)
        }
    }

    // optional .CMsgGCCheckAccountSubscriptionResponse.ESubscriptionState state = 1;

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState) {
        self.state = ::std::option::Option::Some(v);
    }

    pub fn get_state(&self) -> CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState {
        self.state.unwrap_or(CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState::STATE_UNKNOWN)
    }

    fn get_state_for_reflect(&self) -> &::std::option::Option<CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState> {
        &self.state
    }

    fn mut_state_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState> {
        &mut self.state
    }

    // optional uint32 cache_until = 2;

    pub fn clear_cache_until(&mut self) {
        self.cache_until = ::std::option::Option::None;
    }

    pub fn has_cache_until(&self) -> bool {
        self.cache_until.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_until(&mut self, v: u32) {
        self.cache_until = ::std::option::Option::Some(v);
    }

    pub fn get_cache_until(&self) -> u32 {
        self.cache_until.unwrap_or(0)
    }

    fn get_cache_until_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cache_until
    }

    fn mut_cache_until_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cache_until
    }
}

impl ::protobuf::Message for CMsgGCCheckAccountSubscriptionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.state = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cache_until = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.cache_until {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.state {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.cache_until {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCCheckAccountSubscriptionResponse {
    fn new() -> CMsgGCCheckAccountSubscriptionResponse {
        CMsgGCCheckAccountSubscriptionResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCCheckAccountSubscriptionResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState>>(
                    "state",
                    CMsgGCCheckAccountSubscriptionResponse::get_state_for_reflect,
                    CMsgGCCheckAccountSubscriptionResponse::mut_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cache_until",
                    CMsgGCCheckAccountSubscriptionResponse::get_cache_until_for_reflect,
                    CMsgGCCheckAccountSubscriptionResponse::mut_cache_until_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCCheckAccountSubscriptionResponse>(
                    "CMsgGCCheckAccountSubscriptionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCCheckAccountSubscriptionResponse {
    fn clear(&mut self) {
        self.clear_state();
        self.clear_cache_until();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCheckAccountSubscriptionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCheckAccountSubscriptionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState {
    STATE_UNKNOWN = 0,
    STATE_INACTIVE = 1,
    STATE_ACTIVE = 2,
}

impl ::protobuf::ProtobufEnum for CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState> {
        match value {
            0 => ::std::option::Option::Some(CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState::STATE_UNKNOWN),
            1 => ::std::option::Option::Some(CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState::STATE_INACTIVE),
            2 => ::std::option::Option::Some(CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState::STATE_ACTIVE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState] = &[
            CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState::STATE_UNKNOWN,
            CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState::STATE_INACTIVE,
            CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState::STATE_ACTIVE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState {
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCheckAccountSubscriptionResponse_ESubscriptionState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCAddGiftItem {
    // message fields
    account_id: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCAddGiftItem {}

impl CMsgGCAddGiftItem {
    pub fn new() -> CMsgGCAddGiftItem {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCAddGiftItem {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCAddGiftItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCAddGiftItem,
        };
        unsafe {
            instance.get(CMsgGCAddGiftItem::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint64 item_id = 2;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }
}

impl ::protobuf::Message for CMsgGCAddGiftItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCAddGiftItem {
    fn new() -> CMsgGCAddGiftItem {
        CMsgGCAddGiftItem::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCAddGiftItem>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgGCAddGiftItem::get_account_id_for_reflect,
                    CMsgGCAddGiftItem::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgGCAddGiftItem::get_item_id_for_reflect,
                    CMsgGCAddGiftItem::mut_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCAddGiftItem>(
                    "CMsgGCAddGiftItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCAddGiftItem {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCAddGiftItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCAddGiftItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCWrapAndDeliverGift {
    // message fields
    item_id: ::std::option::Option<u64>,
    give_to_account_id: ::std::option::Option<u32>,
    gift_message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCWrapAndDeliverGift {}

impl CMsgClientToGCWrapAndDeliverGift {
    pub fn new() -> CMsgClientToGCWrapAndDeliverGift {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCWrapAndDeliverGift {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCWrapAndDeliverGift> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCWrapAndDeliverGift,
        };
        unsafe {
            instance.get(CMsgClientToGCWrapAndDeliverGift::new)
        }
    }

    // optional uint64 item_id = 1;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }

    // optional uint32 give_to_account_id = 2;

    pub fn clear_give_to_account_id(&mut self) {
        self.give_to_account_id = ::std::option::Option::None;
    }

    pub fn has_give_to_account_id(&self) -> bool {
        self.give_to_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_give_to_account_id(&mut self, v: u32) {
        self.give_to_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_give_to_account_id(&self) -> u32 {
        self.give_to_account_id.unwrap_or(0)
    }

    fn get_give_to_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.give_to_account_id
    }

    fn mut_give_to_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.give_to_account_id
    }

    // optional string gift_message = 3;

    pub fn clear_gift_message(&mut self) {
        self.gift_message.clear();
    }

    pub fn has_gift_message(&self) -> bool {
        self.gift_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gift_message(&mut self, v: ::std::string::String) {
        self.gift_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gift_message(&mut self) -> &mut ::std::string::String {
        if self.gift_message.is_none() {
            self.gift_message.set_default();
        }
        self.gift_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_gift_message(&mut self) -> ::std::string::String {
        self.gift_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gift_message(&self) -> &str {
        match self.gift_message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gift_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gift_message
    }

    fn mut_gift_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gift_message
    }
}

impl ::protobuf::Message for CMsgClientToGCWrapAndDeliverGift {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.give_to_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gift_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.give_to_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.gift_message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.give_to_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.gift_message.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCWrapAndDeliverGift {
    fn new() -> CMsgClientToGCWrapAndDeliverGift {
        CMsgClientToGCWrapAndDeliverGift::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCWrapAndDeliverGift>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgClientToGCWrapAndDeliverGift::get_item_id_for_reflect,
                    CMsgClientToGCWrapAndDeliverGift::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "give_to_account_id",
                    CMsgClientToGCWrapAndDeliverGift::get_give_to_account_id_for_reflect,
                    CMsgClientToGCWrapAndDeliverGift::mut_give_to_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gift_message",
                    CMsgClientToGCWrapAndDeliverGift::get_gift_message_for_reflect,
                    CMsgClientToGCWrapAndDeliverGift::mut_gift_message_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCWrapAndDeliverGift>(
                    "CMsgClientToGCWrapAndDeliverGift",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCWrapAndDeliverGift {
    fn clear(&mut self) {
        self.clear_item_id();
        self.clear_give_to_account_id();
        self.clear_gift_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCWrapAndDeliverGift {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCWrapAndDeliverGift {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCWrapAndDeliverGiftResponse {
    // message fields
    response: ::std::option::Option<super::econ_shared_enums::EGCMsgResponse>,
    gifting_charge_uses: ::std::option::Option<u32>,
    gifting_charge_max: ::std::option::Option<i32>,
    gifting_uses: ::std::option::Option<u32>,
    gifting_max: ::std::option::Option<i32>,
    gifting_window_hours: ::std::option::Option<u32>,
    trade_restriction: ::std::option::Option<EGCMsgInitiateTradeResponse>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCWrapAndDeliverGiftResponse {}

impl CMsgClientToGCWrapAndDeliverGiftResponse {
    pub fn new() -> CMsgClientToGCWrapAndDeliverGiftResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCWrapAndDeliverGiftResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCWrapAndDeliverGiftResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCWrapAndDeliverGiftResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCWrapAndDeliverGiftResponse::new)
        }
    }

    // optional .EGCMsgResponse response = 1;

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: super::econ_shared_enums::EGCMsgResponse) {
        self.response = ::std::option::Option::Some(v);
    }

    pub fn get_response(&self) -> super::econ_shared_enums::EGCMsgResponse {
        self.response.unwrap_or(super::econ_shared_enums::EGCMsgResponse::k_EGCMsgResponseOK)
    }

    fn get_response_for_reflect(&self) -> &::std::option::Option<super::econ_shared_enums::EGCMsgResponse> {
        &self.response
    }

    fn mut_response_for_reflect(&mut self) -> &mut ::std::option::Option<super::econ_shared_enums::EGCMsgResponse> {
        &mut self.response
    }

    // optional uint32 gifting_charge_uses = 2;

    pub fn clear_gifting_charge_uses(&mut self) {
        self.gifting_charge_uses = ::std::option::Option::None;
    }

    pub fn has_gifting_charge_uses(&self) -> bool {
        self.gifting_charge_uses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifting_charge_uses(&mut self, v: u32) {
        self.gifting_charge_uses = ::std::option::Option::Some(v);
    }

    pub fn get_gifting_charge_uses(&self) -> u32 {
        self.gifting_charge_uses.unwrap_or(0)
    }

    fn get_gifting_charge_uses_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gifting_charge_uses
    }

    fn mut_gifting_charge_uses_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gifting_charge_uses
    }

    // optional int32 gifting_charge_max = 3;

    pub fn clear_gifting_charge_max(&mut self) {
        self.gifting_charge_max = ::std::option::Option::None;
    }

    pub fn has_gifting_charge_max(&self) -> bool {
        self.gifting_charge_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifting_charge_max(&mut self, v: i32) {
        self.gifting_charge_max = ::std::option::Option::Some(v);
    }

    pub fn get_gifting_charge_max(&self) -> i32 {
        self.gifting_charge_max.unwrap_or(0)
    }

    fn get_gifting_charge_max_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.gifting_charge_max
    }

    fn mut_gifting_charge_max_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.gifting_charge_max
    }

    // optional uint32 gifting_uses = 4;

    pub fn clear_gifting_uses(&mut self) {
        self.gifting_uses = ::std::option::Option::None;
    }

    pub fn has_gifting_uses(&self) -> bool {
        self.gifting_uses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifting_uses(&mut self, v: u32) {
        self.gifting_uses = ::std::option::Option::Some(v);
    }

    pub fn get_gifting_uses(&self) -> u32 {
        self.gifting_uses.unwrap_or(0)
    }

    fn get_gifting_uses_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gifting_uses
    }

    fn mut_gifting_uses_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gifting_uses
    }

    // optional int32 gifting_max = 5;

    pub fn clear_gifting_max(&mut self) {
        self.gifting_max = ::std::option::Option::None;
    }

    pub fn has_gifting_max(&self) -> bool {
        self.gifting_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifting_max(&mut self, v: i32) {
        self.gifting_max = ::std::option::Option::Some(v);
    }

    pub fn get_gifting_max(&self) -> i32 {
        self.gifting_max.unwrap_or(0)
    }

    fn get_gifting_max_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.gifting_max
    }

    fn mut_gifting_max_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.gifting_max
    }

    // optional uint32 gifting_window_hours = 6;

    pub fn clear_gifting_window_hours(&mut self) {
        self.gifting_window_hours = ::std::option::Option::None;
    }

    pub fn has_gifting_window_hours(&self) -> bool {
        self.gifting_window_hours.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifting_window_hours(&mut self, v: u32) {
        self.gifting_window_hours = ::std::option::Option::Some(v);
    }

    pub fn get_gifting_window_hours(&self) -> u32 {
        self.gifting_window_hours.unwrap_or(0)
    }

    fn get_gifting_window_hours_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gifting_window_hours
    }

    fn mut_gifting_window_hours_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gifting_window_hours
    }

    // optional .EGCMsgInitiateTradeResponse trade_restriction = 7;

    pub fn clear_trade_restriction(&mut self) {
        self.trade_restriction = ::std::option::Option::None;
    }

    pub fn has_trade_restriction(&self) -> bool {
        self.trade_restriction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_restriction(&mut self, v: EGCMsgInitiateTradeResponse) {
        self.trade_restriction = ::std::option::Option::Some(v);
    }

    pub fn get_trade_restriction(&self) -> EGCMsgInitiateTradeResponse {
        self.trade_restriction.unwrap_or(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted)
    }

    fn get_trade_restriction_for_reflect(&self) -> &::std::option::Option<EGCMsgInitiateTradeResponse> {
        &self.trade_restriction
    }

    fn mut_trade_restriction_for_reflect(&mut self) -> &mut ::std::option::Option<EGCMsgInitiateTradeResponse> {
        &mut self.trade_restriction
    }
}

impl ::protobuf::Message for CMsgClientToGCWrapAndDeliverGiftResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.response = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gifting_charge_uses = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.gifting_charge_max = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gifting_uses = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.gifting_max = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gifting_window_hours = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.trade_restriction = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.gifting_charge_uses {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gifting_charge_max {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gifting_uses {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gifting_max {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gifting_window_hours {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.trade_restriction {
            my_size += ::protobuf::rt::enum_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.response {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.gifting_charge_uses {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.gifting_charge_max {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.gifting_uses {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.gifting_max {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.gifting_window_hours {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.trade_restriction {
            os.write_enum(7, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCWrapAndDeliverGiftResponse {
    fn new() -> CMsgClientToGCWrapAndDeliverGiftResponse {
        CMsgClientToGCWrapAndDeliverGiftResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCWrapAndDeliverGiftResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::econ_shared_enums::EGCMsgResponse>>(
                    "response",
                    CMsgClientToGCWrapAndDeliverGiftResponse::get_response_for_reflect,
                    CMsgClientToGCWrapAndDeliverGiftResponse::mut_response_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gifting_charge_uses",
                    CMsgClientToGCWrapAndDeliverGiftResponse::get_gifting_charge_uses_for_reflect,
                    CMsgClientToGCWrapAndDeliverGiftResponse::mut_gifting_charge_uses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "gifting_charge_max",
                    CMsgClientToGCWrapAndDeliverGiftResponse::get_gifting_charge_max_for_reflect,
                    CMsgClientToGCWrapAndDeliverGiftResponse::mut_gifting_charge_max_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gifting_uses",
                    CMsgClientToGCWrapAndDeliverGiftResponse::get_gifting_uses_for_reflect,
                    CMsgClientToGCWrapAndDeliverGiftResponse::mut_gifting_uses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "gifting_max",
                    CMsgClientToGCWrapAndDeliverGiftResponse::get_gifting_max_for_reflect,
                    CMsgClientToGCWrapAndDeliverGiftResponse::mut_gifting_max_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gifting_window_hours",
                    CMsgClientToGCWrapAndDeliverGiftResponse::get_gifting_window_hours_for_reflect,
                    CMsgClientToGCWrapAndDeliverGiftResponse::mut_gifting_window_hours_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EGCMsgInitiateTradeResponse>>(
                    "trade_restriction",
                    CMsgClientToGCWrapAndDeliverGiftResponse::get_trade_restriction_for_reflect,
                    CMsgClientToGCWrapAndDeliverGiftResponse::mut_trade_restriction_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCWrapAndDeliverGiftResponse>(
                    "CMsgClientToGCWrapAndDeliverGiftResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCWrapAndDeliverGiftResponse {
    fn clear(&mut self) {
        self.clear_response();
        self.clear_gifting_charge_uses();
        self.clear_gifting_charge_max();
        self.clear_gifting_uses();
        self.clear_gifting_max();
        self.clear_gifting_window_hours();
        self.clear_trade_restriction();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCWrapAndDeliverGiftResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCWrapAndDeliverGiftResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCUnwrapGift {
    // message fields
    item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCUnwrapGift {}

impl CMsgClientToGCUnwrapGift {
    pub fn new() -> CMsgClientToGCUnwrapGift {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCUnwrapGift {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCUnwrapGift> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCUnwrapGift,
        };
        unsafe {
            instance.get(CMsgClientToGCUnwrapGift::new)
        }
    }

    // optional uint64 item_id = 1;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }
}

impl ::protobuf::Message for CMsgClientToGCUnwrapGift {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCUnwrapGift {
    fn new() -> CMsgClientToGCUnwrapGift {
        CMsgClientToGCUnwrapGift::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCUnwrapGift>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgClientToGCUnwrapGift::get_item_id_for_reflect,
                    CMsgClientToGCUnwrapGift::mut_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCUnwrapGift>(
                    "CMsgClientToGCUnwrapGift",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCUnwrapGift {
    fn clear(&mut self) {
        self.clear_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCUnwrapGift {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCUnwrapGift {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetGiftPermissions {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetGiftPermissions {}

impl CMsgClientToGCGetGiftPermissions {
    pub fn new() -> CMsgClientToGCGetGiftPermissions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetGiftPermissions {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetGiftPermissions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetGiftPermissions,
        };
        unsafe {
            instance.get(CMsgClientToGCGetGiftPermissions::new)
        }
    }
}

impl ::protobuf::Message for CMsgClientToGCGetGiftPermissions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetGiftPermissions {
    fn new() -> CMsgClientToGCGetGiftPermissions {
        CMsgClientToGCGetGiftPermissions::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetGiftPermissions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetGiftPermissions>(
                    "CMsgClientToGCGetGiftPermissions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetGiftPermissions {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetGiftPermissions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetGiftPermissions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetGiftPermissionsResponse {
    // message fields
    is_unlimited: ::std::option::Option<bool>,
    has_two_factor: ::std::option::Option<bool>,
    sender_permission: ::std::option::Option<EGCMsgInitiateTradeResponse>,
    friendship_age_requirement: ::std::option::Option<u32>,
    friendship_age_requirement_two_factor: ::std::option::Option<u32>,
    friend_permissions: ::protobuf::RepeatedField<CMsgClientToGCGetGiftPermissionsResponse_FriendPermission>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetGiftPermissionsResponse {}

impl CMsgClientToGCGetGiftPermissionsResponse {
    pub fn new() -> CMsgClientToGCGetGiftPermissionsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetGiftPermissionsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetGiftPermissionsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetGiftPermissionsResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCGetGiftPermissionsResponse::new)
        }
    }

    // optional bool is_unlimited = 1;

    pub fn clear_is_unlimited(&mut self) {
        self.is_unlimited = ::std::option::Option::None;
    }

    pub fn has_is_unlimited(&self) -> bool {
        self.is_unlimited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_unlimited(&mut self, v: bool) {
        self.is_unlimited = ::std::option::Option::Some(v);
    }

    pub fn get_is_unlimited(&self) -> bool {
        self.is_unlimited.unwrap_or(false)
    }

    fn get_is_unlimited_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_unlimited
    }

    fn mut_is_unlimited_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_unlimited
    }

    // optional bool has_two_factor = 3;

    pub fn clear_has_two_factor(&mut self) {
        self.has_two_factor = ::std::option::Option::None;
    }

    pub fn has_has_two_factor(&self) -> bool {
        self.has_two_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_two_factor(&mut self, v: bool) {
        self.has_two_factor = ::std::option::Option::Some(v);
    }

    pub fn get_has_two_factor(&self) -> bool {
        self.has_two_factor.unwrap_or(false)
    }

    fn get_has_two_factor_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.has_two_factor
    }

    fn mut_has_two_factor_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.has_two_factor
    }

    // optional .EGCMsgInitiateTradeResponse sender_permission = 6;

    pub fn clear_sender_permission(&mut self) {
        self.sender_permission = ::std::option::Option::None;
    }

    pub fn has_sender_permission(&self) -> bool {
        self.sender_permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_permission(&mut self, v: EGCMsgInitiateTradeResponse) {
        self.sender_permission = ::std::option::Option::Some(v);
    }

    pub fn get_sender_permission(&self) -> EGCMsgInitiateTradeResponse {
        self.sender_permission.unwrap_or(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted)
    }

    fn get_sender_permission_for_reflect(&self) -> &::std::option::Option<EGCMsgInitiateTradeResponse> {
        &self.sender_permission
    }

    fn mut_sender_permission_for_reflect(&mut self) -> &mut ::std::option::Option<EGCMsgInitiateTradeResponse> {
        &mut self.sender_permission
    }

    // optional uint32 friendship_age_requirement = 7;

    pub fn clear_friendship_age_requirement(&mut self) {
        self.friendship_age_requirement = ::std::option::Option::None;
    }

    pub fn has_friendship_age_requirement(&self) -> bool {
        self.friendship_age_requirement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendship_age_requirement(&mut self, v: u32) {
        self.friendship_age_requirement = ::std::option::Option::Some(v);
    }

    pub fn get_friendship_age_requirement(&self) -> u32 {
        self.friendship_age_requirement.unwrap_or(0)
    }

    fn get_friendship_age_requirement_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.friendship_age_requirement
    }

    fn mut_friendship_age_requirement_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.friendship_age_requirement
    }

    // optional uint32 friendship_age_requirement_two_factor = 8;

    pub fn clear_friendship_age_requirement_two_factor(&mut self) {
        self.friendship_age_requirement_two_factor = ::std::option::Option::None;
    }

    pub fn has_friendship_age_requirement_two_factor(&self) -> bool {
        self.friendship_age_requirement_two_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendship_age_requirement_two_factor(&mut self, v: u32) {
        self.friendship_age_requirement_two_factor = ::std::option::Option::Some(v);
    }

    pub fn get_friendship_age_requirement_two_factor(&self) -> u32 {
        self.friendship_age_requirement_two_factor.unwrap_or(0)
    }

    fn get_friendship_age_requirement_two_factor_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.friendship_age_requirement_two_factor
    }

    fn mut_friendship_age_requirement_two_factor_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.friendship_age_requirement_two_factor
    }

    // repeated .CMsgClientToGCGetGiftPermissionsResponse.FriendPermission friend_permissions = 9;

    pub fn clear_friend_permissions(&mut self) {
        self.friend_permissions.clear();
    }

    // Param is passed by value, moved
    pub fn set_friend_permissions(&mut self, v: ::protobuf::RepeatedField<CMsgClientToGCGetGiftPermissionsResponse_FriendPermission>) {
        self.friend_permissions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friend_permissions(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCGetGiftPermissionsResponse_FriendPermission> {
        &mut self.friend_permissions
    }

    // Take field
    pub fn take_friend_permissions(&mut self) -> ::protobuf::RepeatedField<CMsgClientToGCGetGiftPermissionsResponse_FriendPermission> {
        ::std::mem::replace(&mut self.friend_permissions, ::protobuf::RepeatedField::new())
    }

    pub fn get_friend_permissions(&self) -> &[CMsgClientToGCGetGiftPermissionsResponse_FriendPermission] {
        &self.friend_permissions
    }

    fn get_friend_permissions_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientToGCGetGiftPermissionsResponse_FriendPermission> {
        &self.friend_permissions
    }

    fn mut_friend_permissions_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCGetGiftPermissionsResponse_FriendPermission> {
        &mut self.friend_permissions
    }
}

impl ::protobuf::Message for CMsgClientToGCGetGiftPermissionsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.friend_permissions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_unlimited = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_two_factor = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.sender_permission = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.friendship_age_requirement = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.friendship_age_requirement_two_factor = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.friend_permissions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.is_unlimited {
            my_size += 2;
        }
        if let Some(v) = self.has_two_factor {
            my_size += 2;
        }
        if let Some(v) = self.sender_permission {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(v) = self.friendship_age_requirement {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friendship_age_requirement_two_factor {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.friend_permissions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.is_unlimited {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.has_two_factor {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.sender_permission {
            os.write_enum(6, v.value())?;
        }
        if let Some(v) = self.friendship_age_requirement {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.friendship_age_requirement_two_factor {
            os.write_uint32(8, v)?;
        }
        for v in &self.friend_permissions {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetGiftPermissionsResponse {
    fn new() -> CMsgClientToGCGetGiftPermissionsResponse {
        CMsgClientToGCGetGiftPermissionsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetGiftPermissionsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_unlimited",
                    CMsgClientToGCGetGiftPermissionsResponse::get_is_unlimited_for_reflect,
                    CMsgClientToGCGetGiftPermissionsResponse::mut_is_unlimited_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "has_two_factor",
                    CMsgClientToGCGetGiftPermissionsResponse::get_has_two_factor_for_reflect,
                    CMsgClientToGCGetGiftPermissionsResponse::mut_has_two_factor_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EGCMsgInitiateTradeResponse>>(
                    "sender_permission",
                    CMsgClientToGCGetGiftPermissionsResponse::get_sender_permission_for_reflect,
                    CMsgClientToGCGetGiftPermissionsResponse::mut_sender_permission_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "friendship_age_requirement",
                    CMsgClientToGCGetGiftPermissionsResponse::get_friendship_age_requirement_for_reflect,
                    CMsgClientToGCGetGiftPermissionsResponse::mut_friendship_age_requirement_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "friendship_age_requirement_two_factor",
                    CMsgClientToGCGetGiftPermissionsResponse::get_friendship_age_requirement_two_factor_for_reflect,
                    CMsgClientToGCGetGiftPermissionsResponse::mut_friendship_age_requirement_two_factor_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCGetGiftPermissionsResponse_FriendPermission>>(
                    "friend_permissions",
                    CMsgClientToGCGetGiftPermissionsResponse::get_friend_permissions_for_reflect,
                    CMsgClientToGCGetGiftPermissionsResponse::mut_friend_permissions_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetGiftPermissionsResponse>(
                    "CMsgClientToGCGetGiftPermissionsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetGiftPermissionsResponse {
    fn clear(&mut self) {
        self.clear_is_unlimited();
        self.clear_has_two_factor();
        self.clear_sender_permission();
        self.clear_friendship_age_requirement();
        self.clear_friendship_age_requirement_two_factor();
        self.clear_friend_permissions();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetGiftPermissionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetGiftPermissionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCGetGiftPermissionsResponse_FriendPermission {
    // message fields
    account_id: ::std::option::Option<u32>,
    permission: ::std::option::Option<EGCMsgInitiateTradeResponse>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCGetGiftPermissionsResponse_FriendPermission {}

impl CMsgClientToGCGetGiftPermissionsResponse_FriendPermission {
    pub fn new() -> CMsgClientToGCGetGiftPermissionsResponse_FriendPermission {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCGetGiftPermissionsResponse_FriendPermission {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCGetGiftPermissionsResponse_FriendPermission> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCGetGiftPermissionsResponse_FriendPermission,
        };
        unsafe {
            instance.get(CMsgClientToGCGetGiftPermissionsResponse_FriendPermission::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional .EGCMsgInitiateTradeResponse permission = 2;

    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: EGCMsgInitiateTradeResponse) {
        self.permission = ::std::option::Option::Some(v);
    }

    pub fn get_permission(&self) -> EGCMsgInitiateTradeResponse {
        self.permission.unwrap_or(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted)
    }

    fn get_permission_for_reflect(&self) -> &::std::option::Option<EGCMsgInitiateTradeResponse> {
        &self.permission
    }

    fn mut_permission_for_reflect(&mut self) -> &mut ::std::option::Option<EGCMsgInitiateTradeResponse> {
        &mut self.permission
    }
}

impl ::protobuf::Message for CMsgClientToGCGetGiftPermissionsResponse_FriendPermission {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.permission = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.permission {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.permission {
            os.write_enum(2, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCGetGiftPermissionsResponse_FriendPermission {
    fn new() -> CMsgClientToGCGetGiftPermissionsResponse_FriendPermission {
        CMsgClientToGCGetGiftPermissionsResponse_FriendPermission::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCGetGiftPermissionsResponse_FriendPermission>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgClientToGCGetGiftPermissionsResponse_FriendPermission::get_account_id_for_reflect,
                    CMsgClientToGCGetGiftPermissionsResponse_FriendPermission::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EGCMsgInitiateTradeResponse>>(
                    "permission",
                    CMsgClientToGCGetGiftPermissionsResponse_FriendPermission::get_permission_for_reflect,
                    CMsgClientToGCGetGiftPermissionsResponse_FriendPermission::mut_permission_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCGetGiftPermissionsResponse_FriendPermission>(
                    "CMsgClientToGCGetGiftPermissionsResponse_FriendPermission",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCGetGiftPermissionsResponse_FriendPermission {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_permission();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCGetGiftPermissionsResponse_FriendPermission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCGetGiftPermissionsResponse_FriendPermission {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCUnpackBundle {
    // message fields
    item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCUnpackBundle {}

impl CMsgClientToGCUnpackBundle {
    pub fn new() -> CMsgClientToGCUnpackBundle {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCUnpackBundle {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCUnpackBundle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCUnpackBundle,
        };
        unsafe {
            instance.get(CMsgClientToGCUnpackBundle::new)
        }
    }

    // optional uint64 item_id = 1;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }
}

impl ::protobuf::Message for CMsgClientToGCUnpackBundle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCUnpackBundle {
    fn new() -> CMsgClientToGCUnpackBundle {
        CMsgClientToGCUnpackBundle::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCUnpackBundle>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgClientToGCUnpackBundle::get_item_id_for_reflect,
                    CMsgClientToGCUnpackBundle::mut_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCUnpackBundle>(
                    "CMsgClientToGCUnpackBundle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCUnpackBundle {
    fn clear(&mut self) {
        self.clear_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCUnpackBundle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCUnpackBundle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCUnpackBundleResponse {
    // message fields
    unpacked_item_ids: ::std::vec::Vec<u64>,
    response: ::std::option::Option<CMsgClientToGCUnpackBundleResponse_EUnpackBundle>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCUnpackBundleResponse {}

impl CMsgClientToGCUnpackBundleResponse {
    pub fn new() -> CMsgClientToGCUnpackBundleResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCUnpackBundleResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCUnpackBundleResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCUnpackBundleResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCUnpackBundleResponse::new)
        }
    }

    // repeated uint64 unpacked_item_ids = 1;

    pub fn clear_unpacked_item_ids(&mut self) {
        self.unpacked_item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_unpacked_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.unpacked_item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unpacked_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.unpacked_item_ids
    }

    // Take field
    pub fn take_unpacked_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.unpacked_item_ids, ::std::vec::Vec::new())
    }

    pub fn get_unpacked_item_ids(&self) -> &[u64] {
        &self.unpacked_item_ids
    }

    fn get_unpacked_item_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.unpacked_item_ids
    }

    fn mut_unpacked_item_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.unpacked_item_ids
    }

    // optional .CMsgClientToGCUnpackBundleResponse.EUnpackBundle response = 2;

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: CMsgClientToGCUnpackBundleResponse_EUnpackBundle) {
        self.response = ::std::option::Option::Some(v);
    }

    pub fn get_response(&self) -> CMsgClientToGCUnpackBundleResponse_EUnpackBundle {
        self.response.unwrap_or(CMsgClientToGCUnpackBundleResponse_EUnpackBundle::k_UnpackBundle_Succeeded)
    }

    fn get_response_for_reflect(&self) -> &::std::option::Option<CMsgClientToGCUnpackBundleResponse_EUnpackBundle> {
        &self.response
    }

    fn mut_response_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgClientToGCUnpackBundleResponse_EUnpackBundle> {
        &mut self.response
    }
}

impl ::protobuf::Message for CMsgClientToGCUnpackBundleResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.unpacked_item_ids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.response = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.unpacked_item_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.unpacked_item_ids {
            os.write_uint64(1, *v)?;
        };
        if let Some(v) = self.response {
            os.write_enum(2, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCUnpackBundleResponse {
    fn new() -> CMsgClientToGCUnpackBundleResponse {
        CMsgClientToGCUnpackBundleResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCUnpackBundleResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "unpacked_item_ids",
                    CMsgClientToGCUnpackBundleResponse::get_unpacked_item_ids_for_reflect,
                    CMsgClientToGCUnpackBundleResponse::mut_unpacked_item_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgClientToGCUnpackBundleResponse_EUnpackBundle>>(
                    "response",
                    CMsgClientToGCUnpackBundleResponse::get_response_for_reflect,
                    CMsgClientToGCUnpackBundleResponse::mut_response_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCUnpackBundleResponse>(
                    "CMsgClientToGCUnpackBundleResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCUnpackBundleResponse {
    fn clear(&mut self) {
        self.clear_unpacked_item_ids();
        self.clear_response();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCUnpackBundleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCUnpackBundleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgClientToGCUnpackBundleResponse_EUnpackBundle {
    k_UnpackBundle_Succeeded = 0,
    k_UnpackBundle_Failed_ItemIsNotBundle = 1,
    k_UnpackBundle_Failed_UnableToCreateContainedItem = 2,
    k_UnpackBundle_Failed_SOCacheError = 3,
    k_UnpackBundle_Failed_ItemIsInvalid = 4,
    k_UnpackBundle_Failed_BadItemQuantity = 5,
    k_UnpackBundle_Failed_UnableToDeleteItem = 6,
}

impl ::protobuf::ProtobufEnum for CMsgClientToGCUnpackBundleResponse_EUnpackBundle {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgClientToGCUnpackBundleResponse_EUnpackBundle> {
        match value {
            0 => ::std::option::Option::Some(CMsgClientToGCUnpackBundleResponse_EUnpackBundle::k_UnpackBundle_Succeeded),
            1 => ::std::option::Option::Some(CMsgClientToGCUnpackBundleResponse_EUnpackBundle::k_UnpackBundle_Failed_ItemIsNotBundle),
            2 => ::std::option::Option::Some(CMsgClientToGCUnpackBundleResponse_EUnpackBundle::k_UnpackBundle_Failed_UnableToCreateContainedItem),
            3 => ::std::option::Option::Some(CMsgClientToGCUnpackBundleResponse_EUnpackBundle::k_UnpackBundle_Failed_SOCacheError),
            4 => ::std::option::Option::Some(CMsgClientToGCUnpackBundleResponse_EUnpackBundle::k_UnpackBundle_Failed_ItemIsInvalid),
            5 => ::std::option::Option::Some(CMsgClientToGCUnpackBundleResponse_EUnpackBundle::k_UnpackBundle_Failed_BadItemQuantity),
            6 => ::std::option::Option::Some(CMsgClientToGCUnpackBundleResponse_EUnpackBundle::k_UnpackBundle_Failed_UnableToDeleteItem),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgClientToGCUnpackBundleResponse_EUnpackBundle] = &[
            CMsgClientToGCUnpackBundleResponse_EUnpackBundle::k_UnpackBundle_Succeeded,
            CMsgClientToGCUnpackBundleResponse_EUnpackBundle::k_UnpackBundle_Failed_ItemIsNotBundle,
            CMsgClientToGCUnpackBundleResponse_EUnpackBundle::k_UnpackBundle_Failed_UnableToCreateContainedItem,
            CMsgClientToGCUnpackBundleResponse_EUnpackBundle::k_UnpackBundle_Failed_SOCacheError,
            CMsgClientToGCUnpackBundleResponse_EUnpackBundle::k_UnpackBundle_Failed_ItemIsInvalid,
            CMsgClientToGCUnpackBundleResponse_EUnpackBundle::k_UnpackBundle_Failed_BadItemQuantity,
            CMsgClientToGCUnpackBundleResponse_EUnpackBundle::k_UnpackBundle_Failed_UnableToDeleteItem,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgClientToGCUnpackBundleResponse_EUnpackBundle>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgClientToGCUnpackBundleResponse_EUnpackBundle", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgClientToGCUnpackBundleResponse_EUnpackBundle {
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCUnpackBundleResponse_EUnpackBundle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToClientStoreTransactionCompleted {
    // message fields
    txn_id: ::std::option::Option<u64>,
    item_ids: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToClientStoreTransactionCompleted {}

impl CMsgGCToClientStoreTransactionCompleted {
    pub fn new() -> CMsgGCToClientStoreTransactionCompleted {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToClientStoreTransactionCompleted {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToClientStoreTransactionCompleted> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToClientStoreTransactionCompleted,
        };
        unsafe {
            instance.get(CMsgGCToClientStoreTransactionCompleted::new)
        }
    }

    // optional uint64 txn_id = 1;

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }

    pub fn get_txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    fn get_txn_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.txn_id
    }

    fn mut_txn_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.txn_id
    }

    // repeated uint64 item_ids = 2;

    pub fn clear_item_ids(&mut self) {
        self.item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }

    // Take field
    pub fn take_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.item_ids, ::std::vec::Vec::new())
    }

    pub fn get_item_ids(&self) -> &[u64] {
        &self.item_ids
    }

    fn get_item_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.item_ids
    }

    fn mut_item_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }
}

impl ::protobuf::Message for CMsgGCToClientStoreTransactionCompleted {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txn_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.item_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.item_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.item_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToClientStoreTransactionCompleted {
    fn new() -> CMsgGCToClientStoreTransactionCompleted {
        CMsgGCToClientStoreTransactionCompleted::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToClientStoreTransactionCompleted>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "txn_id",
                    CMsgGCToClientStoreTransactionCompleted::get_txn_id_for_reflect,
                    CMsgGCToClientStoreTransactionCompleted::mut_txn_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_ids",
                    CMsgGCToClientStoreTransactionCompleted::get_item_ids_for_reflect,
                    CMsgGCToClientStoreTransactionCompleted::mut_item_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToClientStoreTransactionCompleted>(
                    "CMsgGCToClientStoreTransactionCompleted",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToClientStoreTransactionCompleted {
    fn clear(&mut self) {
        self.clear_txn_id();
        self.clear_item_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToClientStoreTransactionCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientStoreTransactionCompleted {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCEquipItems {
    // message fields
    equips: ::protobuf::RepeatedField<CMsgAdjustItemEquippedState>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCEquipItems {}

impl CMsgClientToGCEquipItems {
    pub fn new() -> CMsgClientToGCEquipItems {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCEquipItems {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCEquipItems> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCEquipItems,
        };
        unsafe {
            instance.get(CMsgClientToGCEquipItems::new)
        }
    }

    // repeated .CMsgAdjustItemEquippedState equips = 1;

    pub fn clear_equips(&mut self) {
        self.equips.clear();
    }

    // Param is passed by value, moved
    pub fn set_equips(&mut self, v: ::protobuf::RepeatedField<CMsgAdjustItemEquippedState>) {
        self.equips = v;
    }

    // Mutable pointer to the field.
    pub fn mut_equips(&mut self) -> &mut ::protobuf::RepeatedField<CMsgAdjustItemEquippedState> {
        &mut self.equips
    }

    // Take field
    pub fn take_equips(&mut self) -> ::protobuf::RepeatedField<CMsgAdjustItemEquippedState> {
        ::std::mem::replace(&mut self.equips, ::protobuf::RepeatedField::new())
    }

    pub fn get_equips(&self) -> &[CMsgAdjustItemEquippedState] {
        &self.equips
    }

    fn get_equips_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgAdjustItemEquippedState> {
        &self.equips
    }

    fn mut_equips_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgAdjustItemEquippedState> {
        &mut self.equips
    }
}

impl ::protobuf::Message for CMsgClientToGCEquipItems {
    fn is_initialized(&self) -> bool {
        for v in &self.equips {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.equips)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.equips {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.equips {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCEquipItems {
    fn new() -> CMsgClientToGCEquipItems {
        CMsgClientToGCEquipItems::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCEquipItems>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgAdjustItemEquippedState>>(
                    "equips",
                    CMsgClientToGCEquipItems::get_equips_for_reflect,
                    CMsgClientToGCEquipItems::mut_equips_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCEquipItems>(
                    "CMsgClientToGCEquipItems",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCEquipItems {
    fn clear(&mut self) {
        self.clear_equips();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCEquipItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCEquipItems {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCEquipItemsResponse {
    // message fields
    so_cache_version_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCEquipItemsResponse {}

impl CMsgClientToGCEquipItemsResponse {
    pub fn new() -> CMsgClientToGCEquipItemsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCEquipItemsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCEquipItemsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCEquipItemsResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCEquipItemsResponse::new)
        }
    }

    // optional fixed64 so_cache_version_id = 1;

    pub fn clear_so_cache_version_id(&mut self) {
        self.so_cache_version_id = ::std::option::Option::None;
    }

    pub fn has_so_cache_version_id(&self) -> bool {
        self.so_cache_version_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_so_cache_version_id(&mut self, v: u64) {
        self.so_cache_version_id = ::std::option::Option::Some(v);
    }

    pub fn get_so_cache_version_id(&self) -> u64 {
        self.so_cache_version_id.unwrap_or(0)
    }

    fn get_so_cache_version_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.so_cache_version_id
    }

    fn mut_so_cache_version_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.so_cache_version_id
    }
}

impl ::protobuf::Message for CMsgClientToGCEquipItemsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.so_cache_version_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.so_cache_version_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.so_cache_version_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCEquipItemsResponse {
    fn new() -> CMsgClientToGCEquipItemsResponse {
        CMsgClientToGCEquipItemsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCEquipItemsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "so_cache_version_id",
                    CMsgClientToGCEquipItemsResponse::get_so_cache_version_id_for_reflect,
                    CMsgClientToGCEquipItemsResponse::mut_so_cache_version_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCEquipItemsResponse>(
                    "CMsgClientToGCEquipItemsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCEquipItemsResponse {
    fn clear(&mut self) {
        self.clear_so_cache_version_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCEquipItemsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCEquipItemsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCSetItemStyle {
    // message fields
    item_id: ::std::option::Option<u64>,
    style_index: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCSetItemStyle {}

impl CMsgClientToGCSetItemStyle {
    pub fn new() -> CMsgClientToGCSetItemStyle {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCSetItemStyle {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCSetItemStyle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCSetItemStyle,
        };
        unsafe {
            instance.get(CMsgClientToGCSetItemStyle::new)
        }
    }

    // optional uint64 item_id = 1;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }

    // optional uint32 style_index = 2;

    pub fn clear_style_index(&mut self) {
        self.style_index = ::std::option::Option::None;
    }

    pub fn has_style_index(&self) -> bool {
        self.style_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_index(&mut self, v: u32) {
        self.style_index = ::std::option::Option::Some(v);
    }

    pub fn get_style_index(&self) -> u32 {
        self.style_index.unwrap_or(0)
    }

    fn get_style_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.style_index
    }

    fn mut_style_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.style_index
    }
}

impl ::protobuf::Message for CMsgClientToGCSetItemStyle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.style_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.style_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.style_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCSetItemStyle {
    fn new() -> CMsgClientToGCSetItemStyle {
        CMsgClientToGCSetItemStyle::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCSetItemStyle>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgClientToGCSetItemStyle::get_item_id_for_reflect,
                    CMsgClientToGCSetItemStyle::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "style_index",
                    CMsgClientToGCSetItemStyle::get_style_index_for_reflect,
                    CMsgClientToGCSetItemStyle::mut_style_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCSetItemStyle>(
                    "CMsgClientToGCSetItemStyle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCSetItemStyle {
    fn clear(&mut self) {
        self.clear_item_id();
        self.clear_style_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCSetItemStyle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetItemStyle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCSetItemStyleResponse {
    // message fields
    response: ::std::option::Option<CMsgClientToGCSetItemStyleResponse_ESetStyle>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCSetItemStyleResponse {}

impl CMsgClientToGCSetItemStyleResponse {
    pub fn new() -> CMsgClientToGCSetItemStyleResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCSetItemStyleResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCSetItemStyleResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCSetItemStyleResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCSetItemStyleResponse::new)
        }
    }

    // optional .CMsgClientToGCSetItemStyleResponse.ESetStyle response = 1;

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: CMsgClientToGCSetItemStyleResponse_ESetStyle) {
        self.response = ::std::option::Option::Some(v);
    }

    pub fn get_response(&self) -> CMsgClientToGCSetItemStyleResponse_ESetStyle {
        self.response.unwrap_or(CMsgClientToGCSetItemStyleResponse_ESetStyle::k_SetStyle_Succeeded)
    }

    fn get_response_for_reflect(&self) -> &::std::option::Option<CMsgClientToGCSetItemStyleResponse_ESetStyle> {
        &self.response
    }

    fn mut_response_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgClientToGCSetItemStyleResponse_ESetStyle> {
        &mut self.response
    }
}

impl ::protobuf::Message for CMsgClientToGCSetItemStyleResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.response = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.response {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCSetItemStyleResponse {
    fn new() -> CMsgClientToGCSetItemStyleResponse {
        CMsgClientToGCSetItemStyleResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCSetItemStyleResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgClientToGCSetItemStyleResponse_ESetStyle>>(
                    "response",
                    CMsgClientToGCSetItemStyleResponse::get_response_for_reflect,
                    CMsgClientToGCSetItemStyleResponse::mut_response_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCSetItemStyleResponse>(
                    "CMsgClientToGCSetItemStyleResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCSetItemStyleResponse {
    fn clear(&mut self) {
        self.clear_response();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCSetItemStyleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetItemStyleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgClientToGCSetItemStyleResponse_ESetStyle {
    k_SetStyle_Succeeded = 0,
    k_SetStyle_Failed = 1,
    k_SetStyle_Failed_StyleIsLocked = 2,
}

impl ::protobuf::ProtobufEnum for CMsgClientToGCSetItemStyleResponse_ESetStyle {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgClientToGCSetItemStyleResponse_ESetStyle> {
        match value {
            0 => ::std::option::Option::Some(CMsgClientToGCSetItemStyleResponse_ESetStyle::k_SetStyle_Succeeded),
            1 => ::std::option::Option::Some(CMsgClientToGCSetItemStyleResponse_ESetStyle::k_SetStyle_Failed),
            2 => ::std::option::Option::Some(CMsgClientToGCSetItemStyleResponse_ESetStyle::k_SetStyle_Failed_StyleIsLocked),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgClientToGCSetItemStyleResponse_ESetStyle] = &[
            CMsgClientToGCSetItemStyleResponse_ESetStyle::k_SetStyle_Succeeded,
            CMsgClientToGCSetItemStyleResponse_ESetStyle::k_SetStyle_Failed,
            CMsgClientToGCSetItemStyleResponse_ESetStyle::k_SetStyle_Failed_StyleIsLocked,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgClientToGCSetItemStyleResponse_ESetStyle>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgClientToGCSetItemStyleResponse_ESetStyle", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgClientToGCSetItemStyleResponse_ESetStyle {
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetItemStyleResponse_ESetStyle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCUnlockItemStyle {
    // message fields
    item_to_unlock: ::std::option::Option<u64>,
    style_index: ::std::option::Option<u32>,
    consumable_item_ids: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCUnlockItemStyle {}

impl CMsgClientToGCUnlockItemStyle {
    pub fn new() -> CMsgClientToGCUnlockItemStyle {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCUnlockItemStyle {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCUnlockItemStyle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCUnlockItemStyle,
        };
        unsafe {
            instance.get(CMsgClientToGCUnlockItemStyle::new)
        }
    }

    // optional uint64 item_to_unlock = 1;

    pub fn clear_item_to_unlock(&mut self) {
        self.item_to_unlock = ::std::option::Option::None;
    }

    pub fn has_item_to_unlock(&self) -> bool {
        self.item_to_unlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_to_unlock(&mut self, v: u64) {
        self.item_to_unlock = ::std::option::Option::Some(v);
    }

    pub fn get_item_to_unlock(&self) -> u64 {
        self.item_to_unlock.unwrap_or(0)
    }

    fn get_item_to_unlock_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_to_unlock
    }

    fn mut_item_to_unlock_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_to_unlock
    }

    // optional uint32 style_index = 2;

    pub fn clear_style_index(&mut self) {
        self.style_index = ::std::option::Option::None;
    }

    pub fn has_style_index(&self) -> bool {
        self.style_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_index(&mut self, v: u32) {
        self.style_index = ::std::option::Option::Some(v);
    }

    pub fn get_style_index(&self) -> u32 {
        self.style_index.unwrap_or(0)
    }

    fn get_style_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.style_index
    }

    fn mut_style_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.style_index
    }

    // repeated uint64 consumable_item_ids = 3;

    pub fn clear_consumable_item_ids(&mut self) {
        self.consumable_item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_consumable_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.consumable_item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_consumable_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.consumable_item_ids
    }

    // Take field
    pub fn take_consumable_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.consumable_item_ids, ::std::vec::Vec::new())
    }

    pub fn get_consumable_item_ids(&self) -> &[u64] {
        &self.consumable_item_ids
    }

    fn get_consumable_item_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.consumable_item_ids
    }

    fn mut_consumable_item_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.consumable_item_ids
    }
}

impl ::protobuf::Message for CMsgClientToGCUnlockItemStyle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_to_unlock = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.style_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.consumable_item_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_to_unlock {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.style_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.consumable_item_ids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_to_unlock {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.style_index {
            os.write_uint32(2, v)?;
        }
        for v in &self.consumable_item_ids {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCUnlockItemStyle {
    fn new() -> CMsgClientToGCUnlockItemStyle {
        CMsgClientToGCUnlockItemStyle::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCUnlockItemStyle>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_to_unlock",
                    CMsgClientToGCUnlockItemStyle::get_item_to_unlock_for_reflect,
                    CMsgClientToGCUnlockItemStyle::mut_item_to_unlock_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "style_index",
                    CMsgClientToGCUnlockItemStyle::get_style_index_for_reflect,
                    CMsgClientToGCUnlockItemStyle::mut_style_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "consumable_item_ids",
                    CMsgClientToGCUnlockItemStyle::get_consumable_item_ids_for_reflect,
                    CMsgClientToGCUnlockItemStyle::mut_consumable_item_ids_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCUnlockItemStyle>(
                    "CMsgClientToGCUnlockItemStyle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCUnlockItemStyle {
    fn clear(&mut self) {
        self.clear_item_to_unlock();
        self.clear_style_index();
        self.clear_consumable_item_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCUnlockItemStyle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCUnlockItemStyle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCUnlockItemStyleResponse {
    // message fields
    response: ::std::option::Option<CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle>,
    item_id: ::std::option::Option<u64>,
    style_index: ::std::option::Option<u32>,
    style_prereq: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCUnlockItemStyleResponse {}

impl CMsgClientToGCUnlockItemStyleResponse {
    pub fn new() -> CMsgClientToGCUnlockItemStyleResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCUnlockItemStyleResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCUnlockItemStyleResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCUnlockItemStyleResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCUnlockItemStyleResponse::new)
        }
    }

    // optional .CMsgClientToGCUnlockItemStyleResponse.EUnlockStyle response = 1;

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle) {
        self.response = ::std::option::Option::Some(v);
    }

    pub fn get_response(&self) -> CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle {
        self.response.unwrap_or(CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Succeeded)
    }

    fn get_response_for_reflect(&self) -> &::std::option::Option<CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle> {
        &self.response
    }

    fn mut_response_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle> {
        &mut self.response
    }

    // optional uint64 item_id = 2;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }

    // optional uint32 style_index = 3;

    pub fn clear_style_index(&mut self) {
        self.style_index = ::std::option::Option::None;
    }

    pub fn has_style_index(&self) -> bool {
        self.style_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_index(&mut self, v: u32) {
        self.style_index = ::std::option::Option::Some(v);
    }

    pub fn get_style_index(&self) -> u32 {
        self.style_index.unwrap_or(0)
    }

    fn get_style_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.style_index
    }

    fn mut_style_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.style_index
    }

    // optional uint32 style_prereq = 4;

    pub fn clear_style_prereq(&mut self) {
        self.style_prereq = ::std::option::Option::None;
    }

    pub fn has_style_prereq(&self) -> bool {
        self.style_prereq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style_prereq(&mut self, v: u32) {
        self.style_prereq = ::std::option::Option::Some(v);
    }

    pub fn get_style_prereq(&self) -> u32 {
        self.style_prereq.unwrap_or(0)
    }

    fn get_style_prereq_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.style_prereq
    }

    fn mut_style_prereq_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.style_prereq
    }
}

impl ::protobuf::Message for CMsgClientToGCUnlockItemStyleResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.response = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.style_index = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.style_prereq = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.style_index {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.style_prereq {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.response {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.style_index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.style_prereq {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCUnlockItemStyleResponse {
    fn new() -> CMsgClientToGCUnlockItemStyleResponse {
        CMsgClientToGCUnlockItemStyleResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCUnlockItemStyleResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle>>(
                    "response",
                    CMsgClientToGCUnlockItemStyleResponse::get_response_for_reflect,
                    CMsgClientToGCUnlockItemStyleResponse::mut_response_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgClientToGCUnlockItemStyleResponse::get_item_id_for_reflect,
                    CMsgClientToGCUnlockItemStyleResponse::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "style_index",
                    CMsgClientToGCUnlockItemStyleResponse::get_style_index_for_reflect,
                    CMsgClientToGCUnlockItemStyleResponse::mut_style_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "style_prereq",
                    CMsgClientToGCUnlockItemStyleResponse::get_style_prereq_for_reflect,
                    CMsgClientToGCUnlockItemStyleResponse::mut_style_prereq_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCUnlockItemStyleResponse>(
                    "CMsgClientToGCUnlockItemStyleResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCUnlockItemStyleResponse {
    fn clear(&mut self) {
        self.clear_response();
        self.clear_item_id();
        self.clear_style_index();
        self.clear_style_prereq();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCUnlockItemStyleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCUnlockItemStyleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle {
    k_UnlockStyle_Succeeded = 0,
    k_UnlockStyle_Failed_PreReq = 1,
    k_UnlockStyle_Failed_CantAfford = 2,
    k_UnlockStyle_Failed_CantCommit = 3,
    k_UnlockStyle_Failed_CantLockCache = 4,
    k_UnlockStyle_Failed_CantAffordAttrib = 5,
    k_UnlockStyle_Failed_CantAffordGem = 6,
    k_UnlockStyle_Failed_NoCompendiumLevel = 7,
    k_UnlockStyle_Failed_AlreadyUnlocked = 8,
    k_UnlockStyle_Failed_OtherError = 9,
    k_UnlockStyle_Failed_ItemIsInvalid = 10,
    k_UnlockStyle_Failed_ToolIsInvalid = 11,
}

impl ::protobuf::ProtobufEnum for CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle> {
        match value {
            0 => ::std::option::Option::Some(CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Succeeded),
            1 => ::std::option::Option::Some(CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_PreReq),
            2 => ::std::option::Option::Some(CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_CantAfford),
            3 => ::std::option::Option::Some(CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_CantCommit),
            4 => ::std::option::Option::Some(CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_CantLockCache),
            5 => ::std::option::Option::Some(CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_CantAffordAttrib),
            6 => ::std::option::Option::Some(CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_CantAffordGem),
            7 => ::std::option::Option::Some(CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_NoCompendiumLevel),
            8 => ::std::option::Option::Some(CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_AlreadyUnlocked),
            9 => ::std::option::Option::Some(CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_OtherError),
            10 => ::std::option::Option::Some(CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_ItemIsInvalid),
            11 => ::std::option::Option::Some(CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_ToolIsInvalid),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle] = &[
            CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Succeeded,
            CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_PreReq,
            CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_CantAfford,
            CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_CantCommit,
            CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_CantLockCache,
            CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_CantAffordAttrib,
            CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_CantAffordGem,
            CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_NoCompendiumLevel,
            CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_AlreadyUnlocked,
            CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_OtherError,
            CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_ItemIsInvalid,
            CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle::k_UnlockStyle_Failed_ToolIsInvalid,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle {
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCUnlockItemStyleResponse_EUnlockStyle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCSetItemInventoryCategory {
    // message fields
    item_ids: ::std::vec::Vec<u64>,
    set_to_value: ::std::option::Option<u32>,
    remove_categories: ::std::option::Option<u32>,
    add_categories: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCSetItemInventoryCategory {}

impl CMsgClientToGCSetItemInventoryCategory {
    pub fn new() -> CMsgClientToGCSetItemInventoryCategory {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCSetItemInventoryCategory {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCSetItemInventoryCategory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCSetItemInventoryCategory,
        };
        unsafe {
            instance.get(CMsgClientToGCSetItemInventoryCategory::new)
        }
    }

    // repeated uint64 item_ids = 1;

    pub fn clear_item_ids(&mut self) {
        self.item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }

    // Take field
    pub fn take_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.item_ids, ::std::vec::Vec::new())
    }

    pub fn get_item_ids(&self) -> &[u64] {
        &self.item_ids
    }

    fn get_item_ids_for_reflect(&self) -> &::std::vec::Vec<u64> {
        &self.item_ids
    }

    fn mut_item_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }

    // optional uint32 set_to_value = 2;

    pub fn clear_set_to_value(&mut self) {
        self.set_to_value = ::std::option::Option::None;
    }

    pub fn has_set_to_value(&self) -> bool {
        self.set_to_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set_to_value(&mut self, v: u32) {
        self.set_to_value = ::std::option::Option::Some(v);
    }

    pub fn get_set_to_value(&self) -> u32 {
        self.set_to_value.unwrap_or(0)
    }

    fn get_set_to_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.set_to_value
    }

    fn mut_set_to_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.set_to_value
    }

    // optional uint32 remove_categories = 3;

    pub fn clear_remove_categories(&mut self) {
        self.remove_categories = ::std::option::Option::None;
    }

    pub fn has_remove_categories(&self) -> bool {
        self.remove_categories.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove_categories(&mut self, v: u32) {
        self.remove_categories = ::std::option::Option::Some(v);
    }

    pub fn get_remove_categories(&self) -> u32 {
        self.remove_categories.unwrap_or(0)
    }

    fn get_remove_categories_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.remove_categories
    }

    fn mut_remove_categories_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.remove_categories
    }

    // optional uint32 add_categories = 4;

    pub fn clear_add_categories(&mut self) {
        self.add_categories = ::std::option::Option::None;
    }

    pub fn has_add_categories(&self) -> bool {
        self.add_categories.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_categories(&mut self, v: u32) {
        self.add_categories = ::std::option::Option::Some(v);
    }

    pub fn get_add_categories(&self) -> u32 {
        self.add_categories.unwrap_or(0)
    }

    fn get_add_categories_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.add_categories
    }

    fn mut_add_categories_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.add_categories
    }
}

impl ::protobuf::Message for CMsgClientToGCSetItemInventoryCategory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.item_ids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.set_to_value = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.remove_categories = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.add_categories = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.set_to_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.remove_categories {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.add_categories {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        if let Some(v) = self.set_to_value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.remove_categories {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.add_categories {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCSetItemInventoryCategory {
    fn new() -> CMsgClientToGCSetItemInventoryCategory {
        CMsgClientToGCSetItemInventoryCategory::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCSetItemInventoryCategory>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_ids",
                    CMsgClientToGCSetItemInventoryCategory::get_item_ids_for_reflect,
                    CMsgClientToGCSetItemInventoryCategory::mut_item_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "set_to_value",
                    CMsgClientToGCSetItemInventoryCategory::get_set_to_value_for_reflect,
                    CMsgClientToGCSetItemInventoryCategory::mut_set_to_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "remove_categories",
                    CMsgClientToGCSetItemInventoryCategory::get_remove_categories_for_reflect,
                    CMsgClientToGCSetItemInventoryCategory::mut_remove_categories_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "add_categories",
                    CMsgClientToGCSetItemInventoryCategory::get_add_categories_for_reflect,
                    CMsgClientToGCSetItemInventoryCategory::mut_add_categories_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCSetItemInventoryCategory>(
                    "CMsgClientToGCSetItemInventoryCategory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCSetItemInventoryCategory {
    fn clear(&mut self) {
        self.clear_item_ids();
        self.clear_set_to_value();
        self.clear_remove_categories();
        self.clear_add_categories();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCSetItemInventoryCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCSetItemInventoryCategory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCUnlockCrate {
    // message fields
    crate_item_id: ::std::option::Option<u64>,
    key_item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCUnlockCrate {}

impl CMsgClientToGCUnlockCrate {
    pub fn new() -> CMsgClientToGCUnlockCrate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCUnlockCrate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCUnlockCrate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCUnlockCrate,
        };
        unsafe {
            instance.get(CMsgClientToGCUnlockCrate::new)
        }
    }

    // optional uint64 crate_item_id = 1;

    pub fn clear_crate_item_id(&mut self) {
        self.crate_item_id = ::std::option::Option::None;
    }

    pub fn has_crate_item_id(&self) -> bool {
        self.crate_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crate_item_id(&mut self, v: u64) {
        self.crate_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_crate_item_id(&self) -> u64 {
        self.crate_item_id.unwrap_or(0)
    }

    fn get_crate_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.crate_item_id
    }

    fn mut_crate_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.crate_item_id
    }

    // optional uint64 key_item_id = 2;

    pub fn clear_key_item_id(&mut self) {
        self.key_item_id = ::std::option::Option::None;
    }

    pub fn has_key_item_id(&self) -> bool {
        self.key_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_item_id(&mut self, v: u64) {
        self.key_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_key_item_id(&self) -> u64 {
        self.key_item_id.unwrap_or(0)
    }

    fn get_key_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.key_item_id
    }

    fn mut_key_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.key_item_id
    }
}

impl ::protobuf::Message for CMsgClientToGCUnlockCrate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.crate_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.key_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.crate_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.key_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.crate_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.key_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCUnlockCrate {
    fn new() -> CMsgClientToGCUnlockCrate {
        CMsgClientToGCUnlockCrate::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCUnlockCrate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "crate_item_id",
                    CMsgClientToGCUnlockCrate::get_crate_item_id_for_reflect,
                    CMsgClientToGCUnlockCrate::mut_crate_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "key_item_id",
                    CMsgClientToGCUnlockCrate::get_key_item_id_for_reflect,
                    CMsgClientToGCUnlockCrate::mut_key_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCUnlockCrate>(
                    "CMsgClientToGCUnlockCrate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCUnlockCrate {
    fn clear(&mut self) {
        self.clear_crate_item_id();
        self.clear_key_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCUnlockCrate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCUnlockCrate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCUnlockCrateResponse {
    // message fields
    result: ::std::option::Option<super::econ_shared_enums::EGCMsgResponse>,
    granted_items: ::protobuf::RepeatedField<CMsgClientToGCUnlockCrateResponse_Item>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCUnlockCrateResponse {}

impl CMsgClientToGCUnlockCrateResponse {
    pub fn new() -> CMsgClientToGCUnlockCrateResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCUnlockCrateResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCUnlockCrateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCUnlockCrateResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCUnlockCrateResponse::new)
        }
    }

    // optional .EGCMsgResponse result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::econ_shared_enums::EGCMsgResponse) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> super::econ_shared_enums::EGCMsgResponse {
        self.result.unwrap_or(super::econ_shared_enums::EGCMsgResponse::k_EGCMsgResponseOK)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<super::econ_shared_enums::EGCMsgResponse> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<super::econ_shared_enums::EGCMsgResponse> {
        &mut self.result
    }

    // repeated .CMsgClientToGCUnlockCrateResponse.Item granted_items = 2;

    pub fn clear_granted_items(&mut self) {
        self.granted_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_granted_items(&mut self, v: ::protobuf::RepeatedField<CMsgClientToGCUnlockCrateResponse_Item>) {
        self.granted_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_granted_items(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCUnlockCrateResponse_Item> {
        &mut self.granted_items
    }

    // Take field
    pub fn take_granted_items(&mut self) -> ::protobuf::RepeatedField<CMsgClientToGCUnlockCrateResponse_Item> {
        ::std::mem::replace(&mut self.granted_items, ::protobuf::RepeatedField::new())
    }

    pub fn get_granted_items(&self) -> &[CMsgClientToGCUnlockCrateResponse_Item] {
        &self.granted_items
    }

    fn get_granted_items_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientToGCUnlockCrateResponse_Item> {
        &self.granted_items
    }

    fn mut_granted_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCUnlockCrateResponse_Item> {
        &mut self.granted_items
    }
}

impl ::protobuf::Message for CMsgClientToGCUnlockCrateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.granted_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.granted_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.granted_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        for v in &self.granted_items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCUnlockCrateResponse {
    fn new() -> CMsgClientToGCUnlockCrateResponse {
        CMsgClientToGCUnlockCrateResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCUnlockCrateResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::econ_shared_enums::EGCMsgResponse>>(
                    "result",
                    CMsgClientToGCUnlockCrateResponse::get_result_for_reflect,
                    CMsgClientToGCUnlockCrateResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCUnlockCrateResponse_Item>>(
                    "granted_items",
                    CMsgClientToGCUnlockCrateResponse::get_granted_items_for_reflect,
                    CMsgClientToGCUnlockCrateResponse::mut_granted_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCUnlockCrateResponse>(
                    "CMsgClientToGCUnlockCrateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCUnlockCrateResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_granted_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCUnlockCrateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCUnlockCrateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCUnlockCrateResponse_Item {
    // message fields
    item_id: ::std::option::Option<u64>,
    def_index: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCUnlockCrateResponse_Item {}

impl CMsgClientToGCUnlockCrateResponse_Item {
    pub fn new() -> CMsgClientToGCUnlockCrateResponse_Item {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCUnlockCrateResponse_Item {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCUnlockCrateResponse_Item> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCUnlockCrateResponse_Item,
        };
        unsafe {
            instance.get(CMsgClientToGCUnlockCrateResponse_Item::new)
        }
    }

    // optional uint64 item_id = 1;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }

    // optional uint32 def_index = 2;

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    fn get_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.def_index
    }

    fn mut_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.def_index
    }
}

impl ::protobuf::Message for CMsgClientToGCUnlockCrateResponse_Item {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCUnlockCrateResponse_Item {
    fn new() -> CMsgClientToGCUnlockCrateResponse_Item {
        CMsgClientToGCUnlockCrateResponse_Item::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCUnlockCrateResponse_Item>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgClientToGCUnlockCrateResponse_Item::get_item_id_for_reflect,
                    CMsgClientToGCUnlockCrateResponse_Item::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "def_index",
                    CMsgClientToGCUnlockCrateResponse_Item::get_def_index_for_reflect,
                    CMsgClientToGCUnlockCrateResponse_Item::mut_def_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCUnlockCrateResponse_Item>(
                    "CMsgClientToGCUnlockCrateResponse_Item",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCUnlockCrateResponse_Item {
    fn clear(&mut self) {
        self.clear_item_id();
        self.clear_def_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCUnlockCrateResponse_Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCUnlockCrateResponse_Item {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRemoveItemAttribute {
    // message fields
    item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRemoveItemAttribute {}

impl CMsgClientToGCRemoveItemAttribute {
    pub fn new() -> CMsgClientToGCRemoveItemAttribute {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRemoveItemAttribute {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRemoveItemAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRemoveItemAttribute,
        };
        unsafe {
            instance.get(CMsgClientToGCRemoveItemAttribute::new)
        }
    }

    // optional uint64 item_id = 1;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }
}

impl ::protobuf::Message for CMsgClientToGCRemoveItemAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRemoveItemAttribute {
    fn new() -> CMsgClientToGCRemoveItemAttribute {
        CMsgClientToGCRemoveItemAttribute::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRemoveItemAttribute>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgClientToGCRemoveItemAttribute::get_item_id_for_reflect,
                    CMsgClientToGCRemoveItemAttribute::mut_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRemoveItemAttribute>(
                    "CMsgClientToGCRemoveItemAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRemoveItemAttribute {
    fn clear(&mut self) {
        self.clear_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRemoveItemAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRemoveItemAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCRemoveItemAttributeResponse {
    // message fields
    response: ::std::option::Option<CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute>,
    item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCRemoveItemAttributeResponse {}

impl CMsgClientToGCRemoveItemAttributeResponse {
    pub fn new() -> CMsgClientToGCRemoveItemAttributeResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCRemoveItemAttributeResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCRemoveItemAttributeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCRemoveItemAttributeResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCRemoveItemAttributeResponse::new)
        }
    }

    // optional .CMsgClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute response = 1;

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute) {
        self.response = ::std::option::Option::Some(v);
    }

    pub fn get_response(&self) -> CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute {
        self.response.unwrap_or(CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute::k_RemoveItemAttribute_Succeeded)
    }

    fn get_response_for_reflect(&self) -> &::std::option::Option<CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute> {
        &self.response
    }

    fn mut_response_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute> {
        &mut self.response
    }

    // optional uint64 item_id = 2;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }
}

impl ::protobuf::Message for CMsgClientToGCRemoveItemAttributeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.response = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.response {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCRemoveItemAttributeResponse {
    fn new() -> CMsgClientToGCRemoveItemAttributeResponse {
        CMsgClientToGCRemoveItemAttributeResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCRemoveItemAttributeResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute>>(
                    "response",
                    CMsgClientToGCRemoveItemAttributeResponse::get_response_for_reflect,
                    CMsgClientToGCRemoveItemAttributeResponse::mut_response_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgClientToGCRemoveItemAttributeResponse::get_item_id_for_reflect,
                    CMsgClientToGCRemoveItemAttributeResponse::mut_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCRemoveItemAttributeResponse>(
                    "CMsgClientToGCRemoveItemAttributeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCRemoveItemAttributeResponse {
    fn clear(&mut self) {
        self.clear_response();
        self.clear_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCRemoveItemAttributeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRemoveItemAttributeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute {
    k_RemoveItemAttribute_Succeeded = 0,
    k_RemoveItemAttribute_Failed = 1,
    k_RemoveItemAttribute_Failed_ItemIsInvalid = 2,
    k_RemoveItemAttribute_Failed_AttributeCannotBeRemoved = 3,
    k_RemoveItemAttribute_Failed_AttributeDoesntExist = 4,
}

impl ::protobuf::ProtobufEnum for CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute> {
        match value {
            0 => ::std::option::Option::Some(CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute::k_RemoveItemAttribute_Succeeded),
            1 => ::std::option::Option::Some(CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute::k_RemoveItemAttribute_Failed),
            2 => ::std::option::Option::Some(CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute::k_RemoveItemAttribute_Failed_ItemIsInvalid),
            3 => ::std::option::Option::Some(CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute::k_RemoveItemAttribute_Failed_AttributeCannotBeRemoved),
            4 => ::std::option::Option::Some(CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute::k_RemoveItemAttribute_Failed_AttributeDoesntExist),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute] = &[
            CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute::k_RemoveItemAttribute_Succeeded,
            CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute::k_RemoveItemAttribute_Failed,
            CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute::k_RemoveItemAttribute_Failed_ItemIsInvalid,
            CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute::k_RemoveItemAttribute_Failed_AttributeCannotBeRemoved,
            CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute::k_RemoveItemAttribute_Failed_AttributeDoesntExist,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute {
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCRemoveItemAttributeResponse_ERemoveItemAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCNameItem {
    // message fields
    subject_item_id: ::std::option::Option<u64>,
    tool_item_id: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCNameItem {}

impl CMsgClientToGCNameItem {
    pub fn new() -> CMsgClientToGCNameItem {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCNameItem {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCNameItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCNameItem,
        };
        unsafe {
            instance.get(CMsgClientToGCNameItem::new)
        }
    }

    // optional uint64 subject_item_id = 1;

    pub fn clear_subject_item_id(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
    }

    pub fn has_subject_item_id(&self) -> bool {
        self.subject_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_item_id(&mut self, v: u64) {
        self.subject_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_subject_item_id(&self) -> u64 {
        self.subject_item_id.unwrap_or(0)
    }

    fn get_subject_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.subject_item_id
    }

    fn mut_subject_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.subject_item_id
    }

    // optional uint64 tool_item_id = 2;

    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }

    fn get_tool_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.tool_item_id
    }

    fn mut_tool_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.tool_item_id
    }

    // optional string name = 3;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }
}

impl ::protobuf::Message for CMsgClientToGCNameItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.subject_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tool_item_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.subject_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tool_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.subject_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.tool_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCNameItem {
    fn new() -> CMsgClientToGCNameItem {
        CMsgClientToGCNameItem::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCNameItem>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "subject_item_id",
                    CMsgClientToGCNameItem::get_subject_item_id_for_reflect,
                    CMsgClientToGCNameItem::mut_subject_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tool_item_id",
                    CMsgClientToGCNameItem::get_tool_item_id_for_reflect,
                    CMsgClientToGCNameItem::mut_tool_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CMsgClientToGCNameItem::get_name_for_reflect,
                    CMsgClientToGCNameItem::mut_name_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCNameItem>(
                    "CMsgClientToGCNameItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCNameItem {
    fn clear(&mut self) {
        self.clear_subject_item_id();
        self.clear_tool_item_id();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCNameItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCNameItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCNameItemResponse {
    // message fields
    response: ::std::option::Option<CMsgClientToGCNameItemResponse_ENameItem>,
    item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCNameItemResponse {}

impl CMsgClientToGCNameItemResponse {
    pub fn new() -> CMsgClientToGCNameItemResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCNameItemResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCNameItemResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCNameItemResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCNameItemResponse::new)
        }
    }

    // optional .CMsgClientToGCNameItemResponse.ENameItem response = 1;

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: CMsgClientToGCNameItemResponse_ENameItem) {
        self.response = ::std::option::Option::Some(v);
    }

    pub fn get_response(&self) -> CMsgClientToGCNameItemResponse_ENameItem {
        self.response.unwrap_or(CMsgClientToGCNameItemResponse_ENameItem::k_NameItem_Succeeded)
    }

    fn get_response_for_reflect(&self) -> &::std::option::Option<CMsgClientToGCNameItemResponse_ENameItem> {
        &self.response
    }

    fn mut_response_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgClientToGCNameItemResponse_ENameItem> {
        &mut self.response
    }

    // optional uint64 item_id = 2;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }
}

impl ::protobuf::Message for CMsgClientToGCNameItemResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.response = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.response {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCNameItemResponse {
    fn new() -> CMsgClientToGCNameItemResponse {
        CMsgClientToGCNameItemResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCNameItemResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgClientToGCNameItemResponse_ENameItem>>(
                    "response",
                    CMsgClientToGCNameItemResponse::get_response_for_reflect,
                    CMsgClientToGCNameItemResponse::mut_response_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgClientToGCNameItemResponse::get_item_id_for_reflect,
                    CMsgClientToGCNameItemResponse::mut_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCNameItemResponse>(
                    "CMsgClientToGCNameItemResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCNameItemResponse {
    fn clear(&mut self) {
        self.clear_response();
        self.clear_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCNameItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCNameItemResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgClientToGCNameItemResponse_ENameItem {
    k_NameItem_Succeeded = 0,
    k_NameItem_Failed = 1,
    k_NameItem_Failed_ToolIsInvalid = 2,
    k_NameItem_Failed_ItemIsInvalid = 3,
    k_NameItem_Failed_NameIsInvalid = 4,
}

impl ::protobuf::ProtobufEnum for CMsgClientToGCNameItemResponse_ENameItem {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgClientToGCNameItemResponse_ENameItem> {
        match value {
            0 => ::std::option::Option::Some(CMsgClientToGCNameItemResponse_ENameItem::k_NameItem_Succeeded),
            1 => ::std::option::Option::Some(CMsgClientToGCNameItemResponse_ENameItem::k_NameItem_Failed),
            2 => ::std::option::Option::Some(CMsgClientToGCNameItemResponse_ENameItem::k_NameItem_Failed_ToolIsInvalid),
            3 => ::std::option::Option::Some(CMsgClientToGCNameItemResponse_ENameItem::k_NameItem_Failed_ItemIsInvalid),
            4 => ::std::option::Option::Some(CMsgClientToGCNameItemResponse_ENameItem::k_NameItem_Failed_NameIsInvalid),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgClientToGCNameItemResponse_ENameItem] = &[
            CMsgClientToGCNameItemResponse_ENameItem::k_NameItem_Succeeded,
            CMsgClientToGCNameItemResponse_ENameItem::k_NameItem_Failed,
            CMsgClientToGCNameItemResponse_ENameItem::k_NameItem_Failed_ToolIsInvalid,
            CMsgClientToGCNameItemResponse_ENameItem::k_NameItem_Failed_ItemIsInvalid,
            CMsgClientToGCNameItemResponse_ENameItem::k_NameItem_Failed_NameIsInvalid,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgClientToGCNameItemResponse_ENameItem>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgClientToGCNameItemResponse_ENameItem", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgClientToGCNameItemResponse_ENameItem {
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCNameItemResponse_ENameItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCSetItemPosition {
    // message fields
    item_id: ::std::option::Option<u64>,
    new_position: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCSetItemPosition {}

impl CMsgGCSetItemPosition {
    pub fn new() -> CMsgGCSetItemPosition {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCSetItemPosition {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCSetItemPosition> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCSetItemPosition,
        };
        unsafe {
            instance.get(CMsgGCSetItemPosition::new)
        }
    }

    // optional uint64 item_id = 1;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }

    // optional uint32 new_position = 2;

    pub fn clear_new_position(&mut self) {
        self.new_position = ::std::option::Option::None;
    }

    pub fn has_new_position(&self) -> bool {
        self.new_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_position(&mut self, v: u32) {
        self.new_position = ::std::option::Option::Some(v);
    }

    pub fn get_new_position(&self) -> u32 {
        self.new_position.unwrap_or(0)
    }

    fn get_new_position_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.new_position
    }

    fn mut_new_position_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.new_position
    }
}

impl ::protobuf::Message for CMsgGCSetItemPosition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.new_position = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.new_position {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.new_position {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCSetItemPosition {
    fn new() -> CMsgGCSetItemPosition {
        CMsgGCSetItemPosition::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCSetItemPosition>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgGCSetItemPosition::get_item_id_for_reflect,
                    CMsgGCSetItemPosition::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "new_position",
                    CMsgGCSetItemPosition::get_new_position_for_reflect,
                    CMsgGCSetItemPosition::mut_new_position_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCSetItemPosition>(
                    "CMsgGCSetItemPosition",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCSetItemPosition {
    fn clear(&mut self) {
        self.clear_item_id();
        self.clear_new_position();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCSetItemPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCSetItemPosition {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CAttribute_ItemDynamicRecipeComponent {
    // message fields
    item_def: ::std::option::Option<u32>,
    item_quality: ::std::option::Option<u32>,
    item_flags: ::std::option::Option<u32>,
    attributes_string: ::protobuf::SingularField<::std::string::String>,
    item_count: ::std::option::Option<u32>,
    items_fulfilled: ::std::option::Option<u32>,
    item_rarity: ::std::option::Option<u32>,
    lootlist: ::protobuf::SingularField<::std::string::String>,
    fulfilled_item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CAttribute_ItemDynamicRecipeComponent {}

impl CAttribute_ItemDynamicRecipeComponent {
    pub fn new() -> CAttribute_ItemDynamicRecipeComponent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CAttribute_ItemDynamicRecipeComponent {
        static mut instance: ::protobuf::lazy::Lazy<CAttribute_ItemDynamicRecipeComponent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CAttribute_ItemDynamicRecipeComponent,
        };
        unsafe {
            instance.get(CAttribute_ItemDynamicRecipeComponent::new)
        }
    }

    // optional uint32 item_def = 1;

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    pub fn get_item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    fn get_item_def_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_def
    }

    fn mut_item_def_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_def
    }

    // optional uint32 item_quality = 2;

    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: u32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    pub fn get_item_quality(&self) -> u32 {
        self.item_quality.unwrap_or(0)
    }

    fn get_item_quality_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_quality
    }

    fn mut_item_quality_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_quality
    }

    // optional uint32 item_flags = 3;

    pub fn clear_item_flags(&mut self) {
        self.item_flags = ::std::option::Option::None;
    }

    pub fn has_item_flags(&self) -> bool {
        self.item_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_flags(&mut self, v: u32) {
        self.item_flags = ::std::option::Option::Some(v);
    }

    pub fn get_item_flags(&self) -> u32 {
        self.item_flags.unwrap_or(0)
    }

    fn get_item_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_flags
    }

    fn mut_item_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_flags
    }

    // optional string attributes_string = 4;

    pub fn clear_attributes_string(&mut self) {
        self.attributes_string.clear();
    }

    pub fn has_attributes_string(&self) -> bool {
        self.attributes_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes_string(&mut self, v: ::std::string::String) {
        self.attributes_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes_string(&mut self) -> &mut ::std::string::String {
        if self.attributes_string.is_none() {
            self.attributes_string.set_default();
        }
        self.attributes_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes_string(&mut self) -> ::std::string::String {
        self.attributes_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_attributes_string(&self) -> &str {
        match self.attributes_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_attributes_string_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.attributes_string
    }

    fn mut_attributes_string_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.attributes_string
    }

    // optional uint32 item_count = 5;

    pub fn clear_item_count(&mut self) {
        self.item_count = ::std::option::Option::None;
    }

    pub fn has_item_count(&self) -> bool {
        self.item_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_count(&mut self, v: u32) {
        self.item_count = ::std::option::Option::Some(v);
    }

    pub fn get_item_count(&self) -> u32 {
        self.item_count.unwrap_or(0)
    }

    fn get_item_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_count
    }

    fn mut_item_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_count
    }

    // optional uint32 items_fulfilled = 6;

    pub fn clear_items_fulfilled(&mut self) {
        self.items_fulfilled = ::std::option::Option::None;
    }

    pub fn has_items_fulfilled(&self) -> bool {
        self.items_fulfilled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_fulfilled(&mut self, v: u32) {
        self.items_fulfilled = ::std::option::Option::Some(v);
    }

    pub fn get_items_fulfilled(&self) -> u32 {
        self.items_fulfilled.unwrap_or(0)
    }

    fn get_items_fulfilled_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.items_fulfilled
    }

    fn mut_items_fulfilled_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.items_fulfilled
    }

    // optional uint32 item_rarity = 7;

    pub fn clear_item_rarity(&mut self) {
        self.item_rarity = ::std::option::Option::None;
    }

    pub fn has_item_rarity(&self) -> bool {
        self.item_rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_rarity(&mut self, v: u32) {
        self.item_rarity = ::std::option::Option::Some(v);
    }

    pub fn get_item_rarity(&self) -> u32 {
        self.item_rarity.unwrap_or(0)
    }

    fn get_item_rarity_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_rarity
    }

    fn mut_item_rarity_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_rarity
    }

    // optional string lootlist = 8;

    pub fn clear_lootlist(&mut self) {
        self.lootlist.clear();
    }

    pub fn has_lootlist(&self) -> bool {
        self.lootlist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lootlist(&mut self, v: ::std::string::String) {
        self.lootlist = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lootlist(&mut self) -> &mut ::std::string::String {
        if self.lootlist.is_none() {
            self.lootlist.set_default();
        }
        self.lootlist.as_mut().unwrap()
    }

    // Take field
    pub fn take_lootlist(&mut self) -> ::std::string::String {
        self.lootlist.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_lootlist(&self) -> &str {
        match self.lootlist.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_lootlist_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.lootlist
    }

    fn mut_lootlist_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.lootlist
    }

    // optional uint64 fulfilled_item_id = 9;

    pub fn clear_fulfilled_item_id(&mut self) {
        self.fulfilled_item_id = ::std::option::Option::None;
    }

    pub fn has_fulfilled_item_id(&self) -> bool {
        self.fulfilled_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fulfilled_item_id(&mut self, v: u64) {
        self.fulfilled_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_fulfilled_item_id(&self) -> u64 {
        self.fulfilled_item_id.unwrap_or(0)
    }

    fn get_fulfilled_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fulfilled_item_id
    }

    fn mut_fulfilled_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fulfilled_item_id
    }
}

impl ::protobuf::Message for CAttribute_ItemDynamicRecipeComponent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_quality = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_flags = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.attributes_string)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_count = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.items_fulfilled = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_rarity = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.lootlist)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fulfilled_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_quality {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_flags {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.attributes_string.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.item_count {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.items_fulfilled {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_rarity {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.lootlist.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.fulfilled_item_id {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.attributes_string.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.item_count {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.items_fulfilled {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.item_rarity {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.lootlist.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.fulfilled_item_id {
            os.write_uint64(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CAttribute_ItemDynamicRecipeComponent {
    fn new() -> CAttribute_ItemDynamicRecipeComponent {
        CAttribute_ItemDynamicRecipeComponent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CAttribute_ItemDynamicRecipeComponent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_def",
                    CAttribute_ItemDynamicRecipeComponent::get_item_def_for_reflect,
                    CAttribute_ItemDynamicRecipeComponent::mut_item_def_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_quality",
                    CAttribute_ItemDynamicRecipeComponent::get_item_quality_for_reflect,
                    CAttribute_ItemDynamicRecipeComponent::mut_item_quality_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_flags",
                    CAttribute_ItemDynamicRecipeComponent::get_item_flags_for_reflect,
                    CAttribute_ItemDynamicRecipeComponent::mut_item_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "attributes_string",
                    CAttribute_ItemDynamicRecipeComponent::get_attributes_string_for_reflect,
                    CAttribute_ItemDynamicRecipeComponent::mut_attributes_string_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_count",
                    CAttribute_ItemDynamicRecipeComponent::get_item_count_for_reflect,
                    CAttribute_ItemDynamicRecipeComponent::mut_item_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "items_fulfilled",
                    CAttribute_ItemDynamicRecipeComponent::get_items_fulfilled_for_reflect,
                    CAttribute_ItemDynamicRecipeComponent::mut_items_fulfilled_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_rarity",
                    CAttribute_ItemDynamicRecipeComponent::get_item_rarity_for_reflect,
                    CAttribute_ItemDynamicRecipeComponent::mut_item_rarity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "lootlist",
                    CAttribute_ItemDynamicRecipeComponent::get_lootlist_for_reflect,
                    CAttribute_ItemDynamicRecipeComponent::mut_lootlist_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fulfilled_item_id",
                    CAttribute_ItemDynamicRecipeComponent::get_fulfilled_item_id_for_reflect,
                    CAttribute_ItemDynamicRecipeComponent::mut_fulfilled_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CAttribute_ItemDynamicRecipeComponent>(
                    "CAttribute_ItemDynamicRecipeComponent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CAttribute_ItemDynamicRecipeComponent {
    fn clear(&mut self) {
        self.clear_item_def();
        self.clear_item_quality();
        self.clear_item_flags();
        self.clear_attributes_string();
        self.clear_item_count();
        self.clear_items_fulfilled();
        self.clear_item_rarity();
        self.clear_lootlist();
        self.clear_fulfilled_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAttribute_ItemDynamicRecipeComponent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAttribute_ItemDynamicRecipeComponent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CProtoItemSocket {
    // message fields
    item_id: ::std::option::Option<u64>,
    attr_def_index: ::std::option::Option<u32>,
    required_type: ::std::option::Option<u32>,
    required_hero: ::protobuf::SingularField<::std::string::String>,
    gem_def_index: ::std::option::Option<u32>,
    not_tradable: ::std::option::Option<bool>,
    required_item_slot: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CProtoItemSocket {}

impl CProtoItemSocket {
    pub fn new() -> CProtoItemSocket {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CProtoItemSocket {
        static mut instance: ::protobuf::lazy::Lazy<CProtoItemSocket> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CProtoItemSocket,
        };
        unsafe {
            instance.get(CProtoItemSocket::new)
        }
    }

    // optional uint64 item_id = 1;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }

    // optional uint32 attr_def_index = 2;

    pub fn clear_attr_def_index(&mut self) {
        self.attr_def_index = ::std::option::Option::None;
    }

    pub fn has_attr_def_index(&self) -> bool {
        self.attr_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attr_def_index(&mut self, v: u32) {
        self.attr_def_index = ::std::option::Option::Some(v);
    }

    pub fn get_attr_def_index(&self) -> u32 {
        self.attr_def_index.unwrap_or(0)
    }

    fn get_attr_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.attr_def_index
    }

    fn mut_attr_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.attr_def_index
    }

    // optional uint32 required_type = 3;

    pub fn clear_required_type(&mut self) {
        self.required_type = ::std::option::Option::None;
    }

    pub fn has_required_type(&self) -> bool {
        self.required_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_type(&mut self, v: u32) {
        self.required_type = ::std::option::Option::Some(v);
    }

    pub fn get_required_type(&self) -> u32 {
        self.required_type.unwrap_or(0)
    }

    fn get_required_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.required_type
    }

    fn mut_required_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.required_type
    }

    // optional string required_hero = 4;

    pub fn clear_required_hero(&mut self) {
        self.required_hero.clear();
    }

    pub fn has_required_hero(&self) -> bool {
        self.required_hero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_hero(&mut self, v: ::std::string::String) {
        self.required_hero = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_required_hero(&mut self) -> &mut ::std::string::String {
        if self.required_hero.is_none() {
            self.required_hero.set_default();
        }
        self.required_hero.as_mut().unwrap()
    }

    // Take field
    pub fn take_required_hero(&mut self) -> ::std::string::String {
        self.required_hero.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_required_hero(&self) -> &str {
        match self.required_hero.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_required_hero_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.required_hero
    }

    fn mut_required_hero_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.required_hero
    }

    // optional uint32 gem_def_index = 5;

    pub fn clear_gem_def_index(&mut self) {
        self.gem_def_index = ::std::option::Option::None;
    }

    pub fn has_gem_def_index(&self) -> bool {
        self.gem_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gem_def_index(&mut self, v: u32) {
        self.gem_def_index = ::std::option::Option::Some(v);
    }

    pub fn get_gem_def_index(&self) -> u32 {
        self.gem_def_index.unwrap_or(0)
    }

    fn get_gem_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gem_def_index
    }

    fn mut_gem_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gem_def_index
    }

    // optional bool not_tradable = 6;

    pub fn clear_not_tradable(&mut self) {
        self.not_tradable = ::std::option::Option::None;
    }

    pub fn has_not_tradable(&self) -> bool {
        self.not_tradable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_tradable(&mut self, v: bool) {
        self.not_tradable = ::std::option::Option::Some(v);
    }

    pub fn get_not_tradable(&self) -> bool {
        self.not_tradable.unwrap_or(false)
    }

    fn get_not_tradable_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.not_tradable
    }

    fn mut_not_tradable_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.not_tradable
    }

    // optional string required_item_slot = 7;

    pub fn clear_required_item_slot(&mut self) {
        self.required_item_slot.clear();
    }

    pub fn has_required_item_slot(&self) -> bool {
        self.required_item_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_item_slot(&mut self, v: ::std::string::String) {
        self.required_item_slot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_required_item_slot(&mut self) -> &mut ::std::string::String {
        if self.required_item_slot.is_none() {
            self.required_item_slot.set_default();
        }
        self.required_item_slot.as_mut().unwrap()
    }

    // Take field
    pub fn take_required_item_slot(&mut self) -> ::std::string::String {
        self.required_item_slot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_required_item_slot(&self) -> &str {
        match self.required_item_slot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_required_item_slot_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.required_item_slot
    }

    fn mut_required_item_slot_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.required_item_slot
    }
}

impl ::protobuf::Message for CProtoItemSocket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.attr_def_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.required_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.required_hero)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gem_def_index = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.not_tradable = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.required_item_slot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.attr_def_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.required_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.required_hero.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.gem_def_index {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.not_tradable {
            my_size += 2;
        }
        if let Some(ref v) = self.required_item_slot.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.attr_def_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.required_type {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.required_hero.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.gem_def_index {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.not_tradable {
            os.write_bool(6, v)?;
        }
        if let Some(ref v) = self.required_item_slot.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CProtoItemSocket {
    fn new() -> CProtoItemSocket {
        CProtoItemSocket::new()
    }

    fn descriptor_static(_: ::std::option::Option<CProtoItemSocket>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CProtoItemSocket::get_item_id_for_reflect,
                    CProtoItemSocket::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "attr_def_index",
                    CProtoItemSocket::get_attr_def_index_for_reflect,
                    CProtoItemSocket::mut_attr_def_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "required_type",
                    CProtoItemSocket::get_required_type_for_reflect,
                    CProtoItemSocket::mut_required_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "required_hero",
                    CProtoItemSocket::get_required_hero_for_reflect,
                    CProtoItemSocket::mut_required_hero_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gem_def_index",
                    CProtoItemSocket::get_gem_def_index_for_reflect,
                    CProtoItemSocket::mut_gem_def_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "not_tradable",
                    CProtoItemSocket::get_not_tradable_for_reflect,
                    CProtoItemSocket::mut_not_tradable_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "required_item_slot",
                    CProtoItemSocket::get_required_item_slot_for_reflect,
                    CProtoItemSocket::mut_required_item_slot_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CProtoItemSocket>(
                    "CProtoItemSocket",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CProtoItemSocket {
    fn clear(&mut self) {
        self.clear_item_id();
        self.clear_attr_def_index();
        self.clear_required_type();
        self.clear_required_hero();
        self.clear_gem_def_index();
        self.clear_not_tradable();
        self.clear_required_item_slot();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CProtoItemSocket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CProtoItemSocket_Empty {
    // message fields
    socket: ::protobuf::SingularPtrField<CProtoItemSocket>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CProtoItemSocket_Empty {}

impl CProtoItemSocket_Empty {
    pub fn new() -> CProtoItemSocket_Empty {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CProtoItemSocket_Empty {
        static mut instance: ::protobuf::lazy::Lazy<CProtoItemSocket_Empty> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CProtoItemSocket_Empty,
        };
        unsafe {
            instance.get(CProtoItemSocket_Empty::new)
        }
    }

    // optional .CProtoItemSocket socket = 1;

    pub fn clear_socket(&mut self) {
        self.socket.clear();
    }

    pub fn has_socket(&self) -> bool {
        self.socket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socket(&mut self, v: CProtoItemSocket) {
        self.socket = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socket(&mut self) -> &mut CProtoItemSocket {
        if self.socket.is_none() {
            self.socket.set_default();
        }
        self.socket.as_mut().unwrap()
    }

    // Take field
    pub fn take_socket(&mut self) -> CProtoItemSocket {
        self.socket.take().unwrap_or_else(|| CProtoItemSocket::new())
    }

    pub fn get_socket(&self) -> &CProtoItemSocket {
        self.socket.as_ref().unwrap_or_else(|| CProtoItemSocket::default_instance())
    }

    fn get_socket_for_reflect(&self) -> &::protobuf::SingularPtrField<CProtoItemSocket> {
        &self.socket
    }

    fn mut_socket_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CProtoItemSocket> {
        &mut self.socket
    }
}

impl ::protobuf::Message for CProtoItemSocket_Empty {
    fn is_initialized(&self) -> bool {
        for v in &self.socket {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socket)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.socket.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CProtoItemSocket_Empty {
    fn new() -> CProtoItemSocket_Empty {
        CProtoItemSocket_Empty::new()
    }

    fn descriptor_static(_: ::std::option::Option<CProtoItemSocket_Empty>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CProtoItemSocket>>(
                    "socket",
                    CProtoItemSocket_Empty::get_socket_for_reflect,
                    CProtoItemSocket_Empty::mut_socket_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CProtoItemSocket_Empty>(
                    "CProtoItemSocket_Empty",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CProtoItemSocket_Empty {
    fn clear(&mut self) {
        self.clear_socket();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CProtoItemSocket_Empty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_Empty {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CProtoItemSocket_Effect {
    // message fields
    socket: ::protobuf::SingularPtrField<CProtoItemSocket>,
    effect: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CProtoItemSocket_Effect {}

impl CProtoItemSocket_Effect {
    pub fn new() -> CProtoItemSocket_Effect {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CProtoItemSocket_Effect {
        static mut instance: ::protobuf::lazy::Lazy<CProtoItemSocket_Effect> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CProtoItemSocket_Effect,
        };
        unsafe {
            instance.get(CProtoItemSocket_Effect::new)
        }
    }

    // optional .CProtoItemSocket socket = 1;

    pub fn clear_socket(&mut self) {
        self.socket.clear();
    }

    pub fn has_socket(&self) -> bool {
        self.socket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socket(&mut self, v: CProtoItemSocket) {
        self.socket = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socket(&mut self) -> &mut CProtoItemSocket {
        if self.socket.is_none() {
            self.socket.set_default();
        }
        self.socket.as_mut().unwrap()
    }

    // Take field
    pub fn take_socket(&mut self) -> CProtoItemSocket {
        self.socket.take().unwrap_or_else(|| CProtoItemSocket::new())
    }

    pub fn get_socket(&self) -> &CProtoItemSocket {
        self.socket.as_ref().unwrap_or_else(|| CProtoItemSocket::default_instance())
    }

    fn get_socket_for_reflect(&self) -> &::protobuf::SingularPtrField<CProtoItemSocket> {
        &self.socket
    }

    fn mut_socket_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CProtoItemSocket> {
        &mut self.socket
    }

    // optional uint32 effect = 2;

    pub fn clear_effect(&mut self) {
        self.effect = ::std::option::Option::None;
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: u32) {
        self.effect = ::std::option::Option::Some(v);
    }

    pub fn get_effect(&self) -> u32 {
        self.effect.unwrap_or(0)
    }

    fn get_effect_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.effect
    }

    fn mut_effect_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.effect
    }
}

impl ::protobuf::Message for CProtoItemSocket_Effect {
    fn is_initialized(&self) -> bool {
        for v in &self.socket {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socket)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.effect = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.effect {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.socket.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.effect {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CProtoItemSocket_Effect {
    fn new() -> CProtoItemSocket_Effect {
        CProtoItemSocket_Effect::new()
    }

    fn descriptor_static(_: ::std::option::Option<CProtoItemSocket_Effect>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CProtoItemSocket>>(
                    "socket",
                    CProtoItemSocket_Effect::get_socket_for_reflect,
                    CProtoItemSocket_Effect::mut_socket_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "effect",
                    CProtoItemSocket_Effect::get_effect_for_reflect,
                    CProtoItemSocket_Effect::mut_effect_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CProtoItemSocket_Effect>(
                    "CProtoItemSocket_Effect",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CProtoItemSocket_Effect {
    fn clear(&mut self) {
        self.clear_socket();
        self.clear_effect();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CProtoItemSocket_Effect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_Effect {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CProtoItemSocket_Color {
    // message fields
    socket: ::protobuf::SingularPtrField<CProtoItemSocket>,
    red: ::std::option::Option<u32>,
    green: ::std::option::Option<u32>,
    blue: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CProtoItemSocket_Color {}

impl CProtoItemSocket_Color {
    pub fn new() -> CProtoItemSocket_Color {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CProtoItemSocket_Color {
        static mut instance: ::protobuf::lazy::Lazy<CProtoItemSocket_Color> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CProtoItemSocket_Color,
        };
        unsafe {
            instance.get(CProtoItemSocket_Color::new)
        }
    }

    // optional .CProtoItemSocket socket = 1;

    pub fn clear_socket(&mut self) {
        self.socket.clear();
    }

    pub fn has_socket(&self) -> bool {
        self.socket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socket(&mut self, v: CProtoItemSocket) {
        self.socket = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socket(&mut self) -> &mut CProtoItemSocket {
        if self.socket.is_none() {
            self.socket.set_default();
        }
        self.socket.as_mut().unwrap()
    }

    // Take field
    pub fn take_socket(&mut self) -> CProtoItemSocket {
        self.socket.take().unwrap_or_else(|| CProtoItemSocket::new())
    }

    pub fn get_socket(&self) -> &CProtoItemSocket {
        self.socket.as_ref().unwrap_or_else(|| CProtoItemSocket::default_instance())
    }

    fn get_socket_for_reflect(&self) -> &::protobuf::SingularPtrField<CProtoItemSocket> {
        &self.socket
    }

    fn mut_socket_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CProtoItemSocket> {
        &mut self.socket
    }

    // optional uint32 red = 2;

    pub fn clear_red(&mut self) {
        self.red = ::std::option::Option::None;
    }

    pub fn has_red(&self) -> bool {
        self.red.is_some()
    }

    // Param is passed by value, moved
    pub fn set_red(&mut self, v: u32) {
        self.red = ::std::option::Option::Some(v);
    }

    pub fn get_red(&self) -> u32 {
        self.red.unwrap_or(0)
    }

    fn get_red_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.red
    }

    fn mut_red_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.red
    }

    // optional uint32 green = 3;

    pub fn clear_green(&mut self) {
        self.green = ::std::option::Option::None;
    }

    pub fn has_green(&self) -> bool {
        self.green.is_some()
    }

    // Param is passed by value, moved
    pub fn set_green(&mut self, v: u32) {
        self.green = ::std::option::Option::Some(v);
    }

    pub fn get_green(&self) -> u32 {
        self.green.unwrap_or(0)
    }

    fn get_green_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.green
    }

    fn mut_green_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.green
    }

    // optional uint32 blue = 4;

    pub fn clear_blue(&mut self) {
        self.blue = ::std::option::Option::None;
    }

    pub fn has_blue(&self) -> bool {
        self.blue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blue(&mut self, v: u32) {
        self.blue = ::std::option::Option::Some(v);
    }

    pub fn get_blue(&self) -> u32 {
        self.blue.unwrap_or(0)
    }

    fn get_blue_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.blue
    }

    fn mut_blue_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.blue
    }
}

impl ::protobuf::Message for CProtoItemSocket_Color {
    fn is_initialized(&self) -> bool {
        for v in &self.socket {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socket)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.red = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.green = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.blue = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.red {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.green {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blue {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.socket.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.red {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.green {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.blue {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CProtoItemSocket_Color {
    fn new() -> CProtoItemSocket_Color {
        CProtoItemSocket_Color::new()
    }

    fn descriptor_static(_: ::std::option::Option<CProtoItemSocket_Color>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CProtoItemSocket>>(
                    "socket",
                    CProtoItemSocket_Color::get_socket_for_reflect,
                    CProtoItemSocket_Color::mut_socket_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "red",
                    CProtoItemSocket_Color::get_red_for_reflect,
                    CProtoItemSocket_Color::mut_red_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "green",
                    CProtoItemSocket_Color::get_green_for_reflect,
                    CProtoItemSocket_Color::mut_green_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "blue",
                    CProtoItemSocket_Color::get_blue_for_reflect,
                    CProtoItemSocket_Color::mut_blue_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CProtoItemSocket_Color>(
                    "CProtoItemSocket_Color",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CProtoItemSocket_Color {
    fn clear(&mut self) {
        self.clear_socket();
        self.clear_red();
        self.clear_green();
        self.clear_blue();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CProtoItemSocket_Color {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_Color {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CProtoItemSocket_Strange {
    // message fields
    socket: ::protobuf::SingularPtrField<CProtoItemSocket>,
    strange_type: ::std::option::Option<u32>,
    strange_value: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CProtoItemSocket_Strange {}

impl CProtoItemSocket_Strange {
    pub fn new() -> CProtoItemSocket_Strange {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CProtoItemSocket_Strange {
        static mut instance: ::protobuf::lazy::Lazy<CProtoItemSocket_Strange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CProtoItemSocket_Strange,
        };
        unsafe {
            instance.get(CProtoItemSocket_Strange::new)
        }
    }

    // optional .CProtoItemSocket socket = 1;

    pub fn clear_socket(&mut self) {
        self.socket.clear();
    }

    pub fn has_socket(&self) -> bool {
        self.socket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socket(&mut self, v: CProtoItemSocket) {
        self.socket = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socket(&mut self) -> &mut CProtoItemSocket {
        if self.socket.is_none() {
            self.socket.set_default();
        }
        self.socket.as_mut().unwrap()
    }

    // Take field
    pub fn take_socket(&mut self) -> CProtoItemSocket {
        self.socket.take().unwrap_or_else(|| CProtoItemSocket::new())
    }

    pub fn get_socket(&self) -> &CProtoItemSocket {
        self.socket.as_ref().unwrap_or_else(|| CProtoItemSocket::default_instance())
    }

    fn get_socket_for_reflect(&self) -> &::protobuf::SingularPtrField<CProtoItemSocket> {
        &self.socket
    }

    fn mut_socket_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CProtoItemSocket> {
        &mut self.socket
    }

    // optional uint32 strange_type = 2;

    pub fn clear_strange_type(&mut self) {
        self.strange_type = ::std::option::Option::None;
    }

    pub fn has_strange_type(&self) -> bool {
        self.strange_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_type(&mut self, v: u32) {
        self.strange_type = ::std::option::Option::Some(v);
    }

    pub fn get_strange_type(&self) -> u32 {
        self.strange_type.unwrap_or(0)
    }

    fn get_strange_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.strange_type
    }

    fn mut_strange_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.strange_type
    }

    // optional uint32 strange_value = 3;

    pub fn clear_strange_value(&mut self) {
        self.strange_value = ::std::option::Option::None;
    }

    pub fn has_strange_value(&self) -> bool {
        self.strange_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_value(&mut self, v: u32) {
        self.strange_value = ::std::option::Option::Some(v);
    }

    pub fn get_strange_value(&self) -> u32 {
        self.strange_value.unwrap_or(0)
    }

    fn get_strange_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.strange_value
    }

    fn mut_strange_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.strange_value
    }
}

impl ::protobuf::Message for CProtoItemSocket_Strange {
    fn is_initialized(&self) -> bool {
        for v in &self.socket {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socket)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.strange_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.strange_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.strange_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.strange_value {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.socket.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.strange_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.strange_value {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CProtoItemSocket_Strange {
    fn new() -> CProtoItemSocket_Strange {
        CProtoItemSocket_Strange::new()
    }

    fn descriptor_static(_: ::std::option::Option<CProtoItemSocket_Strange>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CProtoItemSocket>>(
                    "socket",
                    CProtoItemSocket_Strange::get_socket_for_reflect,
                    CProtoItemSocket_Strange::mut_socket_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "strange_type",
                    CProtoItemSocket_Strange::get_strange_type_for_reflect,
                    CProtoItemSocket_Strange::mut_strange_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "strange_value",
                    CProtoItemSocket_Strange::get_strange_value_for_reflect,
                    CProtoItemSocket_Strange::mut_strange_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CProtoItemSocket_Strange>(
                    "CProtoItemSocket_Strange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CProtoItemSocket_Strange {
    fn clear(&mut self) {
        self.clear_socket();
        self.clear_strange_type();
        self.clear_strange_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CProtoItemSocket_Strange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_Strange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CProtoItemSocket_Spectator {
    // message fields
    socket: ::protobuf::SingularPtrField<CProtoItemSocket>,
    games_viewed: ::std::option::Option<u32>,
    corporation_id: ::std::option::Option<u32>,
    league_id: ::std::option::Option<u32>,
    team_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CProtoItemSocket_Spectator {}

impl CProtoItemSocket_Spectator {
    pub fn new() -> CProtoItemSocket_Spectator {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CProtoItemSocket_Spectator {
        static mut instance: ::protobuf::lazy::Lazy<CProtoItemSocket_Spectator> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CProtoItemSocket_Spectator,
        };
        unsafe {
            instance.get(CProtoItemSocket_Spectator::new)
        }
    }

    // optional .CProtoItemSocket socket = 1;

    pub fn clear_socket(&mut self) {
        self.socket.clear();
    }

    pub fn has_socket(&self) -> bool {
        self.socket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socket(&mut self, v: CProtoItemSocket) {
        self.socket = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socket(&mut self) -> &mut CProtoItemSocket {
        if self.socket.is_none() {
            self.socket.set_default();
        }
        self.socket.as_mut().unwrap()
    }

    // Take field
    pub fn take_socket(&mut self) -> CProtoItemSocket {
        self.socket.take().unwrap_or_else(|| CProtoItemSocket::new())
    }

    pub fn get_socket(&self) -> &CProtoItemSocket {
        self.socket.as_ref().unwrap_or_else(|| CProtoItemSocket::default_instance())
    }

    fn get_socket_for_reflect(&self) -> &::protobuf::SingularPtrField<CProtoItemSocket> {
        &self.socket
    }

    fn mut_socket_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CProtoItemSocket> {
        &mut self.socket
    }

    // optional uint32 games_viewed = 2;

    pub fn clear_games_viewed(&mut self) {
        self.games_viewed = ::std::option::Option::None;
    }

    pub fn has_games_viewed(&self) -> bool {
        self.games_viewed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games_viewed(&mut self, v: u32) {
        self.games_viewed = ::std::option::Option::Some(v);
    }

    pub fn get_games_viewed(&self) -> u32 {
        self.games_viewed.unwrap_or(0)
    }

    fn get_games_viewed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.games_viewed
    }

    fn mut_games_viewed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.games_viewed
    }

    // optional uint32 corporation_id = 3;

    pub fn clear_corporation_id(&mut self) {
        self.corporation_id = ::std::option::Option::None;
    }

    pub fn has_corporation_id(&self) -> bool {
        self.corporation_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corporation_id(&mut self, v: u32) {
        self.corporation_id = ::std::option::Option::Some(v);
    }

    pub fn get_corporation_id(&self) -> u32 {
        self.corporation_id.unwrap_or(0)
    }

    fn get_corporation_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.corporation_id
    }

    fn mut_corporation_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.corporation_id
    }

    // optional uint32 league_id = 4;

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    pub fn get_league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    fn get_league_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.league_id
    }

    fn mut_league_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.league_id
    }

    // optional uint32 team_id = 5;

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    pub fn get_team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    fn get_team_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team_id
    }

    fn mut_team_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team_id
    }
}

impl ::protobuf::Message for CProtoItemSocket_Spectator {
    fn is_initialized(&self) -> bool {
        for v in &self.socket {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socket)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.games_viewed = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.corporation_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.league_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.games_viewed {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.corporation_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.socket.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.games_viewed {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.corporation_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CProtoItemSocket_Spectator {
    fn new() -> CProtoItemSocket_Spectator {
        CProtoItemSocket_Spectator::new()
    }

    fn descriptor_static(_: ::std::option::Option<CProtoItemSocket_Spectator>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CProtoItemSocket>>(
                    "socket",
                    CProtoItemSocket_Spectator::get_socket_for_reflect,
                    CProtoItemSocket_Spectator::mut_socket_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "games_viewed",
                    CProtoItemSocket_Spectator::get_games_viewed_for_reflect,
                    CProtoItemSocket_Spectator::mut_games_viewed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "corporation_id",
                    CProtoItemSocket_Spectator::get_corporation_id_for_reflect,
                    CProtoItemSocket_Spectator::mut_corporation_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "league_id",
                    CProtoItemSocket_Spectator::get_league_id_for_reflect,
                    CProtoItemSocket_Spectator::mut_league_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team_id",
                    CProtoItemSocket_Spectator::get_team_id_for_reflect,
                    CProtoItemSocket_Spectator::mut_team_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CProtoItemSocket_Spectator>(
                    "CProtoItemSocket_Spectator",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CProtoItemSocket_Spectator {
    fn clear(&mut self) {
        self.clear_socket();
        self.clear_games_viewed();
        self.clear_corporation_id();
        self.clear_league_id();
        self.clear_team_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CProtoItemSocket_Spectator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_Spectator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CProtoItemSocket_AssetModifier {
    // message fields
    socket: ::protobuf::SingularPtrField<CProtoItemSocket>,
    asset_modifier: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CProtoItemSocket_AssetModifier {}

impl CProtoItemSocket_AssetModifier {
    pub fn new() -> CProtoItemSocket_AssetModifier {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CProtoItemSocket_AssetModifier {
        static mut instance: ::protobuf::lazy::Lazy<CProtoItemSocket_AssetModifier> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CProtoItemSocket_AssetModifier,
        };
        unsafe {
            instance.get(CProtoItemSocket_AssetModifier::new)
        }
    }

    // optional .CProtoItemSocket socket = 1;

    pub fn clear_socket(&mut self) {
        self.socket.clear();
    }

    pub fn has_socket(&self) -> bool {
        self.socket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socket(&mut self, v: CProtoItemSocket) {
        self.socket = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socket(&mut self) -> &mut CProtoItemSocket {
        if self.socket.is_none() {
            self.socket.set_default();
        }
        self.socket.as_mut().unwrap()
    }

    // Take field
    pub fn take_socket(&mut self) -> CProtoItemSocket {
        self.socket.take().unwrap_or_else(|| CProtoItemSocket::new())
    }

    pub fn get_socket(&self) -> &CProtoItemSocket {
        self.socket.as_ref().unwrap_or_else(|| CProtoItemSocket::default_instance())
    }

    fn get_socket_for_reflect(&self) -> &::protobuf::SingularPtrField<CProtoItemSocket> {
        &self.socket
    }

    fn mut_socket_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CProtoItemSocket> {
        &mut self.socket
    }

    // optional uint32 asset_modifier = 2;

    pub fn clear_asset_modifier(&mut self) {
        self.asset_modifier = ::std::option::Option::None;
    }

    pub fn has_asset_modifier(&self) -> bool {
        self.asset_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_modifier(&mut self, v: u32) {
        self.asset_modifier = ::std::option::Option::Some(v);
    }

    pub fn get_asset_modifier(&self) -> u32 {
        self.asset_modifier.unwrap_or(0)
    }

    fn get_asset_modifier_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.asset_modifier
    }

    fn mut_asset_modifier_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.asset_modifier
    }
}

impl ::protobuf::Message for CProtoItemSocket_AssetModifier {
    fn is_initialized(&self) -> bool {
        for v in &self.socket {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socket)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.asset_modifier = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.asset_modifier {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.socket.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.asset_modifier {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CProtoItemSocket_AssetModifier {
    fn new() -> CProtoItemSocket_AssetModifier {
        CProtoItemSocket_AssetModifier::new()
    }

    fn descriptor_static(_: ::std::option::Option<CProtoItemSocket_AssetModifier>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CProtoItemSocket>>(
                    "socket",
                    CProtoItemSocket_AssetModifier::get_socket_for_reflect,
                    CProtoItemSocket_AssetModifier::mut_socket_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "asset_modifier",
                    CProtoItemSocket_AssetModifier::get_asset_modifier_for_reflect,
                    CProtoItemSocket_AssetModifier::mut_asset_modifier_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CProtoItemSocket_AssetModifier>(
                    "CProtoItemSocket_AssetModifier",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CProtoItemSocket_AssetModifier {
    fn clear(&mut self) {
        self.clear_socket();
        self.clear_asset_modifier();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CProtoItemSocket_AssetModifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_AssetModifier {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    // message fields
    socket: ::protobuf::SingularPtrField<CProtoItemSocket>,
    asset_modifier: ::std::option::Option<u32>,
    anim_modifier: ::std::option::Option<u32>,
    ability_effect: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {}

impl CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    pub fn new() -> CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
        static mut instance: ::protobuf::lazy::Lazy<CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY,
        };
        unsafe {
            instance.get(CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY::new)
        }
    }

    // optional .CProtoItemSocket socket = 1;

    pub fn clear_socket(&mut self) {
        self.socket.clear();
    }

    pub fn has_socket(&self) -> bool {
        self.socket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socket(&mut self, v: CProtoItemSocket) {
        self.socket = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socket(&mut self) -> &mut CProtoItemSocket {
        if self.socket.is_none() {
            self.socket.set_default();
        }
        self.socket.as_mut().unwrap()
    }

    // Take field
    pub fn take_socket(&mut self) -> CProtoItemSocket {
        self.socket.take().unwrap_or_else(|| CProtoItemSocket::new())
    }

    pub fn get_socket(&self) -> &CProtoItemSocket {
        self.socket.as_ref().unwrap_or_else(|| CProtoItemSocket::default_instance())
    }

    fn get_socket_for_reflect(&self) -> &::protobuf::SingularPtrField<CProtoItemSocket> {
        &self.socket
    }

    fn mut_socket_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CProtoItemSocket> {
        &mut self.socket
    }

    // optional uint32 asset_modifier = 2;

    pub fn clear_asset_modifier(&mut self) {
        self.asset_modifier = ::std::option::Option::None;
    }

    pub fn has_asset_modifier(&self) -> bool {
        self.asset_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_modifier(&mut self, v: u32) {
        self.asset_modifier = ::std::option::Option::Some(v);
    }

    pub fn get_asset_modifier(&self) -> u32 {
        self.asset_modifier.unwrap_or(0)
    }

    fn get_asset_modifier_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.asset_modifier
    }

    fn mut_asset_modifier_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.asset_modifier
    }

    // optional uint32 anim_modifier = 3;

    pub fn clear_anim_modifier(&mut self) {
        self.anim_modifier = ::std::option::Option::None;
    }

    pub fn has_anim_modifier(&self) -> bool {
        self.anim_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_anim_modifier(&mut self, v: u32) {
        self.anim_modifier = ::std::option::Option::Some(v);
    }

    pub fn get_anim_modifier(&self) -> u32 {
        self.anim_modifier.unwrap_or(0)
    }

    fn get_anim_modifier_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.anim_modifier
    }

    fn mut_anim_modifier_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.anim_modifier
    }

    // optional uint32 ability_effect = 4;

    pub fn clear_ability_effect(&mut self) {
        self.ability_effect = ::std::option::Option::None;
    }

    pub fn has_ability_effect(&self) -> bool {
        self.ability_effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_effect(&mut self, v: u32) {
        self.ability_effect = ::std::option::Option::Some(v);
    }

    pub fn get_ability_effect(&self) -> u32 {
        self.ability_effect.unwrap_or(0)
    }

    fn get_ability_effect_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ability_effect
    }

    fn mut_ability_effect_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ability_effect
    }
}

impl ::protobuf::Message for CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    fn is_initialized(&self) -> bool {
        for v in &self.socket {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socket)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.asset_modifier = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.anim_modifier = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ability_effect = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.asset_modifier {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.anim_modifier {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ability_effect {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.socket.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.asset_modifier {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.anim_modifier {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ability_effect {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    fn new() -> CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
        CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY::new()
    }

    fn descriptor_static(_: ::std::option::Option<CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CProtoItemSocket>>(
                    "socket",
                    CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY::get_socket_for_reflect,
                    CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY::mut_socket_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "asset_modifier",
                    CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY::get_asset_modifier_for_reflect,
                    CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY::mut_asset_modifier_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "anim_modifier",
                    CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY::get_anim_modifier_for_reflect,
                    CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY::mut_anim_modifier_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ability_effect",
                    CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY::get_ability_effect_for_reflect,
                    CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY::mut_ability_effect_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY>(
                    "CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    fn clear(&mut self) {
        self.clear_socket();
        self.clear_asset_modifier();
        self.clear_anim_modifier();
        self.clear_ability_effect();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CProtoItemSocket_Autograph {
    // message fields
    socket: ::protobuf::SingularPtrField<CProtoItemSocket>,
    autograph: ::protobuf::SingularField<::std::string::String>,
    autograph_id: ::std::option::Option<u32>,
    autograph_score: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CProtoItemSocket_Autograph {}

impl CProtoItemSocket_Autograph {
    pub fn new() -> CProtoItemSocket_Autograph {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CProtoItemSocket_Autograph {
        static mut instance: ::protobuf::lazy::Lazy<CProtoItemSocket_Autograph> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CProtoItemSocket_Autograph,
        };
        unsafe {
            instance.get(CProtoItemSocket_Autograph::new)
        }
    }

    // optional .CProtoItemSocket socket = 1;

    pub fn clear_socket(&mut self) {
        self.socket.clear();
    }

    pub fn has_socket(&self) -> bool {
        self.socket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socket(&mut self, v: CProtoItemSocket) {
        self.socket = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socket(&mut self) -> &mut CProtoItemSocket {
        if self.socket.is_none() {
            self.socket.set_default();
        }
        self.socket.as_mut().unwrap()
    }

    // Take field
    pub fn take_socket(&mut self) -> CProtoItemSocket {
        self.socket.take().unwrap_or_else(|| CProtoItemSocket::new())
    }

    pub fn get_socket(&self) -> &CProtoItemSocket {
        self.socket.as_ref().unwrap_or_else(|| CProtoItemSocket::default_instance())
    }

    fn get_socket_for_reflect(&self) -> &::protobuf::SingularPtrField<CProtoItemSocket> {
        &self.socket
    }

    fn mut_socket_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CProtoItemSocket> {
        &mut self.socket
    }

    // optional string autograph = 2;

    pub fn clear_autograph(&mut self) {
        self.autograph.clear();
    }

    pub fn has_autograph(&self) -> bool {
        self.autograph.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autograph(&mut self, v: ::std::string::String) {
        self.autograph = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_autograph(&mut self) -> &mut ::std::string::String {
        if self.autograph.is_none() {
            self.autograph.set_default();
        }
        self.autograph.as_mut().unwrap()
    }

    // Take field
    pub fn take_autograph(&mut self) -> ::std::string::String {
        self.autograph.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_autograph(&self) -> &str {
        match self.autograph.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_autograph_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.autograph
    }

    fn mut_autograph_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.autograph
    }

    // optional uint32 autograph_id = 3;

    pub fn clear_autograph_id(&mut self) {
        self.autograph_id = ::std::option::Option::None;
    }

    pub fn has_autograph_id(&self) -> bool {
        self.autograph_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autograph_id(&mut self, v: u32) {
        self.autograph_id = ::std::option::Option::Some(v);
    }

    pub fn get_autograph_id(&self) -> u32 {
        self.autograph_id.unwrap_or(0)
    }

    fn get_autograph_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.autograph_id
    }

    fn mut_autograph_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.autograph_id
    }

    // optional uint32 autograph_score = 4;

    pub fn clear_autograph_score(&mut self) {
        self.autograph_score = ::std::option::Option::None;
    }

    pub fn has_autograph_score(&self) -> bool {
        self.autograph_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autograph_score(&mut self, v: u32) {
        self.autograph_score = ::std::option::Option::Some(v);
    }

    pub fn get_autograph_score(&self) -> u32 {
        self.autograph_score.unwrap_or(0)
    }

    fn get_autograph_score_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.autograph_score
    }

    fn mut_autograph_score_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.autograph_score
    }
}

impl ::protobuf::Message for CProtoItemSocket_Autograph {
    fn is_initialized(&self) -> bool {
        for v in &self.socket {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.autograph)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.autograph_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.autograph_score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.autograph.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.autograph_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.autograph_score {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.socket.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.autograph.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.autograph_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.autograph_score {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CProtoItemSocket_Autograph {
    fn new() -> CProtoItemSocket_Autograph {
        CProtoItemSocket_Autograph::new()
    }

    fn descriptor_static(_: ::std::option::Option<CProtoItemSocket_Autograph>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CProtoItemSocket>>(
                    "socket",
                    CProtoItemSocket_Autograph::get_socket_for_reflect,
                    CProtoItemSocket_Autograph::mut_socket_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "autograph",
                    CProtoItemSocket_Autograph::get_autograph_for_reflect,
                    CProtoItemSocket_Autograph::mut_autograph_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "autograph_id",
                    CProtoItemSocket_Autograph::get_autograph_id_for_reflect,
                    CProtoItemSocket_Autograph::mut_autograph_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "autograph_score",
                    CProtoItemSocket_Autograph::get_autograph_score_for_reflect,
                    CProtoItemSocket_Autograph::mut_autograph_score_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CProtoItemSocket_Autograph>(
                    "CProtoItemSocket_Autograph",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CProtoItemSocket_Autograph {
    fn clear(&mut self) {
        self.clear_socket();
        self.clear_autograph();
        self.clear_autograph_id();
        self.clear_autograph_score();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CProtoItemSocket_Autograph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_Autograph {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CProtoItemSocket_StaticVisuals {
    // message fields
    socket: ::protobuf::SingularPtrField<CProtoItemSocket>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CProtoItemSocket_StaticVisuals {}

impl CProtoItemSocket_StaticVisuals {
    pub fn new() -> CProtoItemSocket_StaticVisuals {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CProtoItemSocket_StaticVisuals {
        static mut instance: ::protobuf::lazy::Lazy<CProtoItemSocket_StaticVisuals> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CProtoItemSocket_StaticVisuals,
        };
        unsafe {
            instance.get(CProtoItemSocket_StaticVisuals::new)
        }
    }

    // optional .CProtoItemSocket socket = 1;

    pub fn clear_socket(&mut self) {
        self.socket.clear();
    }

    pub fn has_socket(&self) -> bool {
        self.socket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socket(&mut self, v: CProtoItemSocket) {
        self.socket = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_socket(&mut self) -> &mut CProtoItemSocket {
        if self.socket.is_none() {
            self.socket.set_default();
        }
        self.socket.as_mut().unwrap()
    }

    // Take field
    pub fn take_socket(&mut self) -> CProtoItemSocket {
        self.socket.take().unwrap_or_else(|| CProtoItemSocket::new())
    }

    pub fn get_socket(&self) -> &CProtoItemSocket {
        self.socket.as_ref().unwrap_or_else(|| CProtoItemSocket::default_instance())
    }

    fn get_socket_for_reflect(&self) -> &::protobuf::SingularPtrField<CProtoItemSocket> {
        &self.socket
    }

    fn mut_socket_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CProtoItemSocket> {
        &mut self.socket
    }
}

impl ::protobuf::Message for CProtoItemSocket_StaticVisuals {
    fn is_initialized(&self) -> bool {
        for v in &self.socket {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.socket)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.socket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.socket.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CProtoItemSocket_StaticVisuals {
    fn new() -> CProtoItemSocket_StaticVisuals {
        CProtoItemSocket_StaticVisuals::new()
    }

    fn descriptor_static(_: ::std::option::Option<CProtoItemSocket_StaticVisuals>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CProtoItemSocket>>(
                    "socket",
                    CProtoItemSocket_StaticVisuals::get_socket_for_reflect,
                    CProtoItemSocket_StaticVisuals::mut_socket_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CProtoItemSocket_StaticVisuals>(
                    "CProtoItemSocket_StaticVisuals",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CProtoItemSocket_StaticVisuals {
    fn clear(&mut self) {
        self.clear_socket();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CProtoItemSocket_StaticVisuals {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProtoItemSocket_StaticVisuals {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CAttribute_String {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CAttribute_String {}

impl CAttribute_String {
    pub fn new() -> CAttribute_String {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CAttribute_String {
        static mut instance: ::protobuf::lazy::Lazy<CAttribute_String> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CAttribute_String,
        };
        unsafe {
            instance.get(CAttribute_String::new)
        }
    }

    // optional string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for CAttribute_String {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CAttribute_String {
    fn new() -> CAttribute_String {
        CAttribute_String::new()
    }

    fn descriptor_static(_: ::std::option::Option<CAttribute_String>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    CAttribute_String::get_value_for_reflect,
                    CAttribute_String::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CAttribute_String>(
                    "CAttribute_String",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CAttribute_String {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAttribute_String {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAttribute_String {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CWorkshop_GetItemDailyRevenue_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u32>,
    date_start: ::std::option::Option<u32>,
    date_end: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CWorkshop_GetItemDailyRevenue_Request {}

impl CWorkshop_GetItemDailyRevenue_Request {
    pub fn new() -> CWorkshop_GetItemDailyRevenue_Request {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CWorkshop_GetItemDailyRevenue_Request {
        static mut instance: ::protobuf::lazy::Lazy<CWorkshop_GetItemDailyRevenue_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CWorkshop_GetItemDailyRevenue_Request,
        };
        unsafe {
            instance.get(CWorkshop_GetItemDailyRevenue_Request::new)
        }
    }

    // optional uint32 appid = 1;

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    fn get_appid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.appid
    }

    fn mut_appid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.appid
    }

    // optional uint32 item_id = 2;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u32) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u32 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_id
    }

    // optional uint32 date_start = 3;

    pub fn clear_date_start(&mut self) {
        self.date_start = ::std::option::Option::None;
    }

    pub fn has_date_start(&self) -> bool {
        self.date_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_start(&mut self, v: u32) {
        self.date_start = ::std::option::Option::Some(v);
    }

    pub fn get_date_start(&self) -> u32 {
        self.date_start.unwrap_or(0)
    }

    fn get_date_start_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.date_start
    }

    fn mut_date_start_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.date_start
    }

    // optional uint32 date_end = 4;

    pub fn clear_date_end(&mut self) {
        self.date_end = ::std::option::Option::None;
    }

    pub fn has_date_end(&self) -> bool {
        self.date_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_end(&mut self, v: u32) {
        self.date_end = ::std::option::Option::Some(v);
    }

    pub fn get_date_end(&self) -> u32 {
        self.date_end.unwrap_or(0)
    }

    fn get_date_end_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.date_end
    }

    fn mut_date_end_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.date_end
    }
}

impl ::protobuf::Message for CWorkshop_GetItemDailyRevenue_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.date_start = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.date_end = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.date_start {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.date_end {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.date_start {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.date_end {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CWorkshop_GetItemDailyRevenue_Request {
    fn new() -> CWorkshop_GetItemDailyRevenue_Request {
        CWorkshop_GetItemDailyRevenue_Request::new()
    }

    fn descriptor_static(_: ::std::option::Option<CWorkshop_GetItemDailyRevenue_Request>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    CWorkshop_GetItemDailyRevenue_Request::get_appid_for_reflect,
                    CWorkshop_GetItemDailyRevenue_Request::mut_appid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_id",
                    CWorkshop_GetItemDailyRevenue_Request::get_item_id_for_reflect,
                    CWorkshop_GetItemDailyRevenue_Request::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "date_start",
                    CWorkshop_GetItemDailyRevenue_Request::get_date_start_for_reflect,
                    CWorkshop_GetItemDailyRevenue_Request::mut_date_start_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "date_end",
                    CWorkshop_GetItemDailyRevenue_Request::get_date_end_for_reflect,
                    CWorkshop_GetItemDailyRevenue_Request::mut_date_end_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CWorkshop_GetItemDailyRevenue_Request>(
                    "CWorkshop_GetItemDailyRevenue_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CWorkshop_GetItemDailyRevenue_Request {
    fn clear(&mut self) {
        self.clear_appid();
        self.clear_item_id();
        self.clear_date_start();
        self.clear_date_end();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CWorkshop_GetItemDailyRevenue_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetItemDailyRevenue_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CWorkshop_GetItemDailyRevenue_Response {
    // message fields
    country_revenue: ::protobuf::RepeatedField<CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CWorkshop_GetItemDailyRevenue_Response {}

impl CWorkshop_GetItemDailyRevenue_Response {
    pub fn new() -> CWorkshop_GetItemDailyRevenue_Response {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CWorkshop_GetItemDailyRevenue_Response {
        static mut instance: ::protobuf::lazy::Lazy<CWorkshop_GetItemDailyRevenue_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CWorkshop_GetItemDailyRevenue_Response,
        };
        unsafe {
            instance.get(CWorkshop_GetItemDailyRevenue_Response::new)
        }
    }

    // repeated .CWorkshop_GetItemDailyRevenue_Response.CountryDailyRevenue country_revenue = 1;

    pub fn clear_country_revenue(&mut self) {
        self.country_revenue.clear();
    }

    // Param is passed by value, moved
    pub fn set_country_revenue(&mut self, v: ::protobuf::RepeatedField<CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue>) {
        self.country_revenue = v;
    }

    // Mutable pointer to the field.
    pub fn mut_country_revenue(&mut self) -> &mut ::protobuf::RepeatedField<CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue> {
        &mut self.country_revenue
    }

    // Take field
    pub fn take_country_revenue(&mut self) -> ::protobuf::RepeatedField<CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue> {
        ::std::mem::replace(&mut self.country_revenue, ::protobuf::RepeatedField::new())
    }

    pub fn get_country_revenue(&self) -> &[CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue] {
        &self.country_revenue
    }

    fn get_country_revenue_for_reflect(&self) -> &::protobuf::RepeatedField<CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue> {
        &self.country_revenue
    }

    fn mut_country_revenue_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue> {
        &mut self.country_revenue
    }
}

impl ::protobuf::Message for CWorkshop_GetItemDailyRevenue_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.country_revenue {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.country_revenue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.country_revenue {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.country_revenue {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CWorkshop_GetItemDailyRevenue_Response {
    fn new() -> CWorkshop_GetItemDailyRevenue_Response {
        CWorkshop_GetItemDailyRevenue_Response::new()
    }

    fn descriptor_static(_: ::std::option::Option<CWorkshop_GetItemDailyRevenue_Response>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue>>(
                    "country_revenue",
                    CWorkshop_GetItemDailyRevenue_Response::get_country_revenue_for_reflect,
                    CWorkshop_GetItemDailyRevenue_Response::mut_country_revenue_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CWorkshop_GetItemDailyRevenue_Response>(
                    "CWorkshop_GetItemDailyRevenue_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CWorkshop_GetItemDailyRevenue_Response {
    fn clear(&mut self) {
        self.clear_country_revenue();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CWorkshop_GetItemDailyRevenue_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetItemDailyRevenue_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue {
    // message fields
    country_code: ::protobuf::SingularField<::std::string::String>,
    date: ::std::option::Option<u32>,
    revenue_usd: ::std::option::Option<i64>,
    units: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue {}

impl CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue {
    pub fn new() -> CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue {
        static mut instance: ::protobuf::lazy::Lazy<CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue,
        };
        unsafe {
            instance.get(CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue::new)
        }
    }

    // optional string country_code = 1;

    pub fn clear_country_code(&mut self) {
        self.country_code.clear();
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code.set_default();
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_country_code_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.country_code
    }

    fn mut_country_code_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.country_code
    }

    // optional uint32 date = 2;

    pub fn clear_date(&mut self) {
        self.date = ::std::option::Option::None;
    }

    pub fn has_date(&self) -> bool {
        self.date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: u32) {
        self.date = ::std::option::Option::Some(v);
    }

    pub fn get_date(&self) -> u32 {
        self.date.unwrap_or(0)
    }

    fn get_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.date
    }

    fn mut_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.date
    }

    // optional int64 revenue_usd = 3;

    pub fn clear_revenue_usd(&mut self) {
        self.revenue_usd = ::std::option::Option::None;
    }

    pub fn has_revenue_usd(&self) -> bool {
        self.revenue_usd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revenue_usd(&mut self, v: i64) {
        self.revenue_usd = ::std::option::Option::Some(v);
    }

    pub fn get_revenue_usd(&self) -> i64 {
        self.revenue_usd.unwrap_or(0)
    }

    fn get_revenue_usd_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.revenue_usd
    }

    fn mut_revenue_usd_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.revenue_usd
    }

    // optional int32 units = 4;

    pub fn clear_units(&mut self) {
        self.units = ::std::option::Option::None;
    }

    pub fn has_units(&self) -> bool {
        self.units.is_some()
    }

    // Param is passed by value, moved
    pub fn set_units(&mut self, v: i32) {
        self.units = ::std::option::Option::Some(v);
    }

    pub fn get_units(&self) -> i32 {
        self.units.unwrap_or(0)
    }

    fn get_units_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.units
    }

    fn mut_units_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.units
    }
}

impl ::protobuf::Message for CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country_code)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.date = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.revenue_usd = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.units = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.date {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.revenue_usd {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.units {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.country_code.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.date {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.revenue_usd {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.units {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue {
    fn new() -> CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue {
        CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue::new()
    }

    fn descriptor_static(_: ::std::option::Option<CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "country_code",
                    CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue::get_country_code_for_reflect,
                    CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue::mut_country_code_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "date",
                    CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue::get_date_for_reflect,
                    CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue::mut_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "revenue_usd",
                    CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue::get_revenue_usd_for_reflect,
                    CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue::mut_revenue_usd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "units",
                    CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue::get_units_for_reflect,
                    CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue::mut_units_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue>(
                    "CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue {
    fn clear(&mut self) {
        self.clear_country_code();
        self.clear_date();
        self.clear_revenue_usd();
        self.clear_units();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetItemDailyRevenue_Response_CountryDailyRevenue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CWorkshop_GetPackageDailyRevenue_Request {
    // message fields
    packageid: ::std::option::Option<u32>,
    date_start: ::std::option::Option<u32>,
    date_end: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CWorkshop_GetPackageDailyRevenue_Request {}

impl CWorkshop_GetPackageDailyRevenue_Request {
    pub fn new() -> CWorkshop_GetPackageDailyRevenue_Request {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CWorkshop_GetPackageDailyRevenue_Request {
        static mut instance: ::protobuf::lazy::Lazy<CWorkshop_GetPackageDailyRevenue_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CWorkshop_GetPackageDailyRevenue_Request,
        };
        unsafe {
            instance.get(CWorkshop_GetPackageDailyRevenue_Request::new)
        }
    }

    // optional uint32 packageid = 1;

    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    pub fn get_packageid(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }

    fn get_packageid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.packageid
    }

    fn mut_packageid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.packageid
    }

    // optional uint32 date_start = 2;

    pub fn clear_date_start(&mut self) {
        self.date_start = ::std::option::Option::None;
    }

    pub fn has_date_start(&self) -> bool {
        self.date_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_start(&mut self, v: u32) {
        self.date_start = ::std::option::Option::Some(v);
    }

    pub fn get_date_start(&self) -> u32 {
        self.date_start.unwrap_or(0)
    }

    fn get_date_start_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.date_start
    }

    fn mut_date_start_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.date_start
    }

    // optional uint32 date_end = 3;

    pub fn clear_date_end(&mut self) {
        self.date_end = ::std::option::Option::None;
    }

    pub fn has_date_end(&self) -> bool {
        self.date_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_end(&mut self, v: u32) {
        self.date_end = ::std::option::Option::Some(v);
    }

    pub fn get_date_end(&self) -> u32 {
        self.date_end.unwrap_or(0)
    }

    fn get_date_end_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.date_end
    }

    fn mut_date_end_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.date_end
    }
}

impl ::protobuf::Message for CWorkshop_GetPackageDailyRevenue_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.packageid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.date_start = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.date_end = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packageid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.date_start {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.date_end {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.date_start {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.date_end {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CWorkshop_GetPackageDailyRevenue_Request {
    fn new() -> CWorkshop_GetPackageDailyRevenue_Request {
        CWorkshop_GetPackageDailyRevenue_Request::new()
    }

    fn descriptor_static(_: ::std::option::Option<CWorkshop_GetPackageDailyRevenue_Request>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "packageid",
                    CWorkshop_GetPackageDailyRevenue_Request::get_packageid_for_reflect,
                    CWorkshop_GetPackageDailyRevenue_Request::mut_packageid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "date_start",
                    CWorkshop_GetPackageDailyRevenue_Request::get_date_start_for_reflect,
                    CWorkshop_GetPackageDailyRevenue_Request::mut_date_start_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "date_end",
                    CWorkshop_GetPackageDailyRevenue_Request::get_date_end_for_reflect,
                    CWorkshop_GetPackageDailyRevenue_Request::mut_date_end_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CWorkshop_GetPackageDailyRevenue_Request>(
                    "CWorkshop_GetPackageDailyRevenue_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CWorkshop_GetPackageDailyRevenue_Request {
    fn clear(&mut self) {
        self.clear_packageid();
        self.clear_date_start();
        self.clear_date_end();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CWorkshop_GetPackageDailyRevenue_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetPackageDailyRevenue_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CWorkshop_GetPackageDailyRevenue_Response {
    // message fields
    country_revenue: ::protobuf::RepeatedField<CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CWorkshop_GetPackageDailyRevenue_Response {}

impl CWorkshop_GetPackageDailyRevenue_Response {
    pub fn new() -> CWorkshop_GetPackageDailyRevenue_Response {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CWorkshop_GetPackageDailyRevenue_Response {
        static mut instance: ::protobuf::lazy::Lazy<CWorkshop_GetPackageDailyRevenue_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CWorkshop_GetPackageDailyRevenue_Response,
        };
        unsafe {
            instance.get(CWorkshop_GetPackageDailyRevenue_Response::new)
        }
    }

    // repeated .CWorkshop_GetPackageDailyRevenue_Response.CountryDailyRevenue country_revenue = 1;

    pub fn clear_country_revenue(&mut self) {
        self.country_revenue.clear();
    }

    // Param is passed by value, moved
    pub fn set_country_revenue(&mut self, v: ::protobuf::RepeatedField<CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue>) {
        self.country_revenue = v;
    }

    // Mutable pointer to the field.
    pub fn mut_country_revenue(&mut self) -> &mut ::protobuf::RepeatedField<CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue> {
        &mut self.country_revenue
    }

    // Take field
    pub fn take_country_revenue(&mut self) -> ::protobuf::RepeatedField<CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue> {
        ::std::mem::replace(&mut self.country_revenue, ::protobuf::RepeatedField::new())
    }

    pub fn get_country_revenue(&self) -> &[CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue] {
        &self.country_revenue
    }

    fn get_country_revenue_for_reflect(&self) -> &::protobuf::RepeatedField<CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue> {
        &self.country_revenue
    }

    fn mut_country_revenue_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue> {
        &mut self.country_revenue
    }
}

impl ::protobuf::Message for CWorkshop_GetPackageDailyRevenue_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.country_revenue {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.country_revenue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.country_revenue {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.country_revenue {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CWorkshop_GetPackageDailyRevenue_Response {
    fn new() -> CWorkshop_GetPackageDailyRevenue_Response {
        CWorkshop_GetPackageDailyRevenue_Response::new()
    }

    fn descriptor_static(_: ::std::option::Option<CWorkshop_GetPackageDailyRevenue_Response>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue>>(
                    "country_revenue",
                    CWorkshop_GetPackageDailyRevenue_Response::get_country_revenue_for_reflect,
                    CWorkshop_GetPackageDailyRevenue_Response::mut_country_revenue_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CWorkshop_GetPackageDailyRevenue_Response>(
                    "CWorkshop_GetPackageDailyRevenue_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CWorkshop_GetPackageDailyRevenue_Response {
    fn clear(&mut self) {
        self.clear_country_revenue();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CWorkshop_GetPackageDailyRevenue_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetPackageDailyRevenue_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue {
    // message fields
    country_code: ::protobuf::SingularField<::std::string::String>,
    date: ::std::option::Option<u32>,
    revenue_usd: ::std::option::Option<i64>,
    units: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue {}

impl CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue {
    pub fn new() -> CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue {
        static mut instance: ::protobuf::lazy::Lazy<CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue,
        };
        unsafe {
            instance.get(CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue::new)
        }
    }

    // optional string country_code = 1;

    pub fn clear_country_code(&mut self) {
        self.country_code.clear();
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code.set_default();
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_country_code_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.country_code
    }

    fn mut_country_code_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.country_code
    }

    // optional uint32 date = 2;

    pub fn clear_date(&mut self) {
        self.date = ::std::option::Option::None;
    }

    pub fn has_date(&self) -> bool {
        self.date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: u32) {
        self.date = ::std::option::Option::Some(v);
    }

    pub fn get_date(&self) -> u32 {
        self.date.unwrap_or(0)
    }

    fn get_date_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.date
    }

    fn mut_date_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.date
    }

    // optional int64 revenue_usd = 3;

    pub fn clear_revenue_usd(&mut self) {
        self.revenue_usd = ::std::option::Option::None;
    }

    pub fn has_revenue_usd(&self) -> bool {
        self.revenue_usd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revenue_usd(&mut self, v: i64) {
        self.revenue_usd = ::std::option::Option::Some(v);
    }

    pub fn get_revenue_usd(&self) -> i64 {
        self.revenue_usd.unwrap_or(0)
    }

    fn get_revenue_usd_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.revenue_usd
    }

    fn mut_revenue_usd_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.revenue_usd
    }

    // optional int32 units = 4;

    pub fn clear_units(&mut self) {
        self.units = ::std::option::Option::None;
    }

    pub fn has_units(&self) -> bool {
        self.units.is_some()
    }

    // Param is passed by value, moved
    pub fn set_units(&mut self, v: i32) {
        self.units = ::std::option::Option::Some(v);
    }

    pub fn get_units(&self) -> i32 {
        self.units.unwrap_or(0)
    }

    fn get_units_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.units
    }

    fn mut_units_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.units
    }
}

impl ::protobuf::Message for CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country_code)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.date = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.revenue_usd = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.units = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.date {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.revenue_usd {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.units {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.country_code.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.date {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.revenue_usd {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.units {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue {
    fn new() -> CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue {
        CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue::new()
    }

    fn descriptor_static(_: ::std::option::Option<CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "country_code",
                    CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue::get_country_code_for_reflect,
                    CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue::mut_country_code_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "date",
                    CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue::get_date_for_reflect,
                    CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue::mut_date_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "revenue_usd",
                    CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue::get_revenue_usd_for_reflect,
                    CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue::mut_revenue_usd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "units",
                    CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue::get_units_for_reflect,
                    CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue::mut_units_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue>(
                    "CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue {
    fn clear(&mut self) {
        self.clear_country_code();
        self.clear_date();
        self.clear_revenue_usd();
        self.clear_units();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetPackageDailyRevenue_Response_CountryDailyRevenue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSQLGCToGCGrantBackpackSlots {
    // message fields
    account_id: ::std::option::Option<u32>,
    add_slots: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgSQLGCToGCGrantBackpackSlots {}

impl CMsgSQLGCToGCGrantBackpackSlots {
    pub fn new() -> CMsgSQLGCToGCGrantBackpackSlots {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgSQLGCToGCGrantBackpackSlots {
        static mut instance: ::protobuf::lazy::Lazy<CMsgSQLGCToGCGrantBackpackSlots> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgSQLGCToGCGrantBackpackSlots,
        };
        unsafe {
            instance.get(CMsgSQLGCToGCGrantBackpackSlots::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 add_slots = 2;

    pub fn clear_add_slots(&mut self) {
        self.add_slots = ::std::option::Option::None;
    }

    pub fn has_add_slots(&self) -> bool {
        self.add_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_slots(&mut self, v: u32) {
        self.add_slots = ::std::option::Option::Some(v);
    }

    pub fn get_add_slots(&self) -> u32 {
        self.add_slots.unwrap_or(0)
    }

    fn get_add_slots_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.add_slots
    }

    fn mut_add_slots_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.add_slots
    }
}

impl ::protobuf::Message for CMsgSQLGCToGCGrantBackpackSlots {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.add_slots = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.add_slots {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.add_slots {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgSQLGCToGCGrantBackpackSlots {
    fn new() -> CMsgSQLGCToGCGrantBackpackSlots {
        CMsgSQLGCToGCGrantBackpackSlots::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgSQLGCToGCGrantBackpackSlots>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgSQLGCToGCGrantBackpackSlots::get_account_id_for_reflect,
                    CMsgSQLGCToGCGrantBackpackSlots::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "add_slots",
                    CMsgSQLGCToGCGrantBackpackSlots::get_add_slots_for_reflect,
                    CMsgSQLGCToGCGrantBackpackSlots::mut_add_slots_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgSQLGCToGCGrantBackpackSlots>(
                    "CMsgSQLGCToGCGrantBackpackSlots",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgSQLGCToGCGrantBackpackSlots {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_add_slots();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSQLGCToGCGrantBackpackSlots {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSQLGCToGCGrantBackpackSlots {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCLookupAccountName {
    // message fields
    account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCLookupAccountName {}

impl CMsgClientToGCLookupAccountName {
    pub fn new() -> CMsgClientToGCLookupAccountName {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCLookupAccountName {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCLookupAccountName> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCLookupAccountName,
        };
        unsafe {
            instance.get(CMsgClientToGCLookupAccountName::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }
}

impl ::protobuf::Message for CMsgClientToGCLookupAccountName {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCLookupAccountName {
    fn new() -> CMsgClientToGCLookupAccountName {
        CMsgClientToGCLookupAccountName::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCLookupAccountName>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgClientToGCLookupAccountName::get_account_id_for_reflect,
                    CMsgClientToGCLookupAccountName::mut_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCLookupAccountName>(
                    "CMsgClientToGCLookupAccountName",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCLookupAccountName {
    fn clear(&mut self) {
        self.clear_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCLookupAccountName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCLookupAccountName {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCLookupAccountNameResponse {
    // message fields
    account_id: ::std::option::Option<u32>,
    account_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCLookupAccountNameResponse {}

impl CMsgClientToGCLookupAccountNameResponse {
    pub fn new() -> CMsgClientToGCLookupAccountNameResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCLookupAccountNameResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCLookupAccountNameResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCLookupAccountNameResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCLookupAccountNameResponse::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional string account_name = 2;

    pub fn clear_account_name(&mut self) {
        self.account_name.clear();
    }

    pub fn has_account_name(&self) -> bool {
        self.account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::string::String) {
        self.account_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::string::String {
        if self.account_name.is_none() {
            self.account_name.set_default();
        }
        self.account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::string::String {
        self.account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_account_name(&self) -> &str {
        match self.account_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_account_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.account_name
    }

    fn mut_account_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.account_name
    }
}

impl ::protobuf::Message for CMsgClientToGCLookupAccountNameResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.account_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.account_name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCLookupAccountNameResponse {
    fn new() -> CMsgClientToGCLookupAccountNameResponse {
        CMsgClientToGCLookupAccountNameResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCLookupAccountNameResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgClientToGCLookupAccountNameResponse::get_account_id_for_reflect,
                    CMsgClientToGCLookupAccountNameResponse::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "account_name",
                    CMsgClientToGCLookupAccountNameResponse::get_account_name_for_reflect,
                    CMsgClientToGCLookupAccountNameResponse::mut_account_name_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCLookupAccountNameResponse>(
                    "CMsgClientToGCLookupAccountNameResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCLookupAccountNameResponse {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_account_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCLookupAccountNameResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCLookupAccountNameResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCCreateStaticRecipe {
    // message fields
    items: ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipe_Item>,
    recipe_def_index: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCCreateStaticRecipe {}

impl CMsgClientToGCCreateStaticRecipe {
    pub fn new() -> CMsgClientToGCCreateStaticRecipe {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCCreateStaticRecipe {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCCreateStaticRecipe> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCCreateStaticRecipe,
        };
        unsafe {
            instance.get(CMsgClientToGCCreateStaticRecipe::new)
        }
    }

    // repeated .CMsgClientToGCCreateStaticRecipe.Item items = 1;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipe_Item>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipe_Item> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipe_Item> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[CMsgClientToGCCreateStaticRecipe_Item] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipe_Item> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipe_Item> {
        &mut self.items
    }

    // optional uint32 recipe_def_index = 2;

    pub fn clear_recipe_def_index(&mut self) {
        self.recipe_def_index = ::std::option::Option::None;
    }

    pub fn has_recipe_def_index(&self) -> bool {
        self.recipe_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipe_def_index(&mut self, v: u32) {
        self.recipe_def_index = ::std::option::Option::Some(v);
    }

    pub fn get_recipe_def_index(&self) -> u32 {
        self.recipe_def_index.unwrap_or(0)
    }

    fn get_recipe_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.recipe_def_index
    }

    fn mut_recipe_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.recipe_def_index
    }
}

impl ::protobuf::Message for CMsgClientToGCCreateStaticRecipe {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recipe_def_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.recipe_def_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.recipe_def_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCCreateStaticRecipe {
    fn new() -> CMsgClientToGCCreateStaticRecipe {
        CMsgClientToGCCreateStaticRecipe::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCCreateStaticRecipe>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCCreateStaticRecipe_Item>>(
                    "items",
                    CMsgClientToGCCreateStaticRecipe::get_items_for_reflect,
                    CMsgClientToGCCreateStaticRecipe::mut_items_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "recipe_def_index",
                    CMsgClientToGCCreateStaticRecipe::get_recipe_def_index_for_reflect,
                    CMsgClientToGCCreateStaticRecipe::mut_recipe_def_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCCreateStaticRecipe>(
                    "CMsgClientToGCCreateStaticRecipe",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCCreateStaticRecipe {
    fn clear(&mut self) {
        self.clear_items();
        self.clear_recipe_def_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCCreateStaticRecipe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCreateStaticRecipe {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCCreateStaticRecipe_Item {
    // message fields
    item_id: ::std::option::Option<u64>,
    slot_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCCreateStaticRecipe_Item {}

impl CMsgClientToGCCreateStaticRecipe_Item {
    pub fn new() -> CMsgClientToGCCreateStaticRecipe_Item {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCCreateStaticRecipe_Item {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCCreateStaticRecipe_Item> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCCreateStaticRecipe_Item,
        };
        unsafe {
            instance.get(CMsgClientToGCCreateStaticRecipe_Item::new)
        }
    }

    // optional uint64 item_id = 1;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }

    // optional uint32 slot_id = 2;

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    pub fn get_slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    fn get_slot_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_id
    }

    fn mut_slot_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_id
    }
}

impl ::protobuf::Message for CMsgClientToGCCreateStaticRecipe_Item {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCCreateStaticRecipe_Item {
    fn new() -> CMsgClientToGCCreateStaticRecipe_Item {
        CMsgClientToGCCreateStaticRecipe_Item::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCCreateStaticRecipe_Item>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgClientToGCCreateStaticRecipe_Item::get_item_id_for_reflect,
                    CMsgClientToGCCreateStaticRecipe_Item::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_id",
                    CMsgClientToGCCreateStaticRecipe_Item::get_slot_id_for_reflect,
                    CMsgClientToGCCreateStaticRecipe_Item::mut_slot_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCCreateStaticRecipe_Item>(
                    "CMsgClientToGCCreateStaticRecipe_Item",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCCreateStaticRecipe_Item {
    fn clear(&mut self) {
        self.clear_item_id();
        self.clear_slot_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCCreateStaticRecipe_Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCreateStaticRecipe_Item {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCCreateStaticRecipeResponse {
    // message fields
    response: ::std::option::Option<CMsgClientToGCCreateStaticRecipeResponse_EResponse>,
    output_items: ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_OutputItem>,
    input_errors: ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_InputError>,
    additional_outputs: ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCCreateStaticRecipeResponse {}

impl CMsgClientToGCCreateStaticRecipeResponse {
    pub fn new() -> CMsgClientToGCCreateStaticRecipeResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCCreateStaticRecipeResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCCreateStaticRecipeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCCreateStaticRecipeResponse,
        };
        unsafe {
            instance.get(CMsgClientToGCCreateStaticRecipeResponse::new)
        }
    }

    // optional .CMsgClientToGCCreateStaticRecipeResponse.EResponse response = 1;

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: CMsgClientToGCCreateStaticRecipeResponse_EResponse) {
        self.response = ::std::option::Option::Some(v);
    }

    pub fn get_response(&self) -> CMsgClientToGCCreateStaticRecipeResponse_EResponse {
        self.response.unwrap_or(CMsgClientToGCCreateStaticRecipeResponse_EResponse::eResponse_Success)
    }

    fn get_response_for_reflect(&self) -> &::std::option::Option<CMsgClientToGCCreateStaticRecipeResponse_EResponse> {
        &self.response
    }

    fn mut_response_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgClientToGCCreateStaticRecipeResponse_EResponse> {
        &mut self.response
    }

    // repeated .CMsgClientToGCCreateStaticRecipeResponse.OutputItem output_items = 2;

    pub fn clear_output_items(&mut self) {
        self.output_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_output_items(&mut self, v: ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_OutputItem>) {
        self.output_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output_items(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_OutputItem> {
        &mut self.output_items
    }

    // Take field
    pub fn take_output_items(&mut self) -> ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_OutputItem> {
        ::std::mem::replace(&mut self.output_items, ::protobuf::RepeatedField::new())
    }

    pub fn get_output_items(&self) -> &[CMsgClientToGCCreateStaticRecipeResponse_OutputItem] {
        &self.output_items
    }

    fn get_output_items_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_OutputItem> {
        &self.output_items
    }

    fn mut_output_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_OutputItem> {
        &mut self.output_items
    }

    // repeated .CMsgClientToGCCreateStaticRecipeResponse.InputError input_errors = 3;

    pub fn clear_input_errors(&mut self) {
        self.input_errors.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_errors(&mut self, v: ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_InputError>) {
        self.input_errors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input_errors(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_InputError> {
        &mut self.input_errors
    }

    // Take field
    pub fn take_input_errors(&mut self) -> ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_InputError> {
        ::std::mem::replace(&mut self.input_errors, ::protobuf::RepeatedField::new())
    }

    pub fn get_input_errors(&self) -> &[CMsgClientToGCCreateStaticRecipeResponse_InputError] {
        &self.input_errors
    }

    fn get_input_errors_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_InputError> {
        &self.input_errors
    }

    fn mut_input_errors_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_InputError> {
        &mut self.input_errors
    }

    // repeated .CMsgClientToGCCreateStaticRecipeResponse.AdditionalOutput additional_outputs = 4;

    pub fn clear_additional_outputs(&mut self) {
        self.additional_outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_outputs(&mut self, v: ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput>) {
        self.additional_outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additional_outputs(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput> {
        &mut self.additional_outputs
    }

    // Take field
    pub fn take_additional_outputs(&mut self) -> ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput> {
        ::std::mem::replace(&mut self.additional_outputs, ::protobuf::RepeatedField::new())
    }

    pub fn get_additional_outputs(&self) -> &[CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput] {
        &self.additional_outputs
    }

    fn get_additional_outputs_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput> {
        &self.additional_outputs
    }

    fn mut_additional_outputs_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput> {
        &mut self.additional_outputs
    }
}

impl ::protobuf::Message for CMsgClientToGCCreateStaticRecipeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.output_items {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.input_errors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.additional_outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.response = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.output_items)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.input_errors)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.additional_outputs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.output_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.input_errors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.additional_outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.response {
            os.write_enum(1, v.value())?;
        }
        for v in &self.output_items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.input_errors {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.additional_outputs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCCreateStaticRecipeResponse {
    fn new() -> CMsgClientToGCCreateStaticRecipeResponse {
        CMsgClientToGCCreateStaticRecipeResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCCreateStaticRecipeResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgClientToGCCreateStaticRecipeResponse_EResponse>>(
                    "response",
                    CMsgClientToGCCreateStaticRecipeResponse::get_response_for_reflect,
                    CMsgClientToGCCreateStaticRecipeResponse::mut_response_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCCreateStaticRecipeResponse_OutputItem>>(
                    "output_items",
                    CMsgClientToGCCreateStaticRecipeResponse::get_output_items_for_reflect,
                    CMsgClientToGCCreateStaticRecipeResponse::mut_output_items_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCCreateStaticRecipeResponse_InputError>>(
                    "input_errors",
                    CMsgClientToGCCreateStaticRecipeResponse::get_input_errors_for_reflect,
                    CMsgClientToGCCreateStaticRecipeResponse::mut_input_errors_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput>>(
                    "additional_outputs",
                    CMsgClientToGCCreateStaticRecipeResponse::get_additional_outputs_for_reflect,
                    CMsgClientToGCCreateStaticRecipeResponse::mut_additional_outputs_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCCreateStaticRecipeResponse>(
                    "CMsgClientToGCCreateStaticRecipeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCCreateStaticRecipeResponse {
    fn clear(&mut self) {
        self.clear_response();
        self.clear_output_items();
        self.clear_input_errors();
        self.clear_additional_outputs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCCreateStaticRecipeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCreateStaticRecipeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCCreateStaticRecipeResponse_OutputItem {
    // message fields
    def_index: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u64>,
    slot_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCCreateStaticRecipeResponse_OutputItem {}

impl CMsgClientToGCCreateStaticRecipeResponse_OutputItem {
    pub fn new() -> CMsgClientToGCCreateStaticRecipeResponse_OutputItem {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCCreateStaticRecipeResponse_OutputItem {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCCreateStaticRecipeResponse_OutputItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCCreateStaticRecipeResponse_OutputItem,
        };
        unsafe {
            instance.get(CMsgClientToGCCreateStaticRecipeResponse_OutputItem::new)
        }
    }

    // optional uint32 def_index = 1;

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    fn get_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.def_index
    }

    fn mut_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.def_index
    }

    // optional uint64 item_id = 2;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.item_id
    }

    // optional uint32 slot_id = 3;

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    pub fn get_slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    fn get_slot_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_id
    }

    fn mut_slot_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_id
    }
}

impl ::protobuf::Message for CMsgClientToGCCreateStaticRecipeResponse_OutputItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCCreateStaticRecipeResponse_OutputItem {
    fn new() -> CMsgClientToGCCreateStaticRecipeResponse_OutputItem {
        CMsgClientToGCCreateStaticRecipeResponse_OutputItem::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCCreateStaticRecipeResponse_OutputItem>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "def_index",
                    CMsgClientToGCCreateStaticRecipeResponse_OutputItem::get_def_index_for_reflect,
                    CMsgClientToGCCreateStaticRecipeResponse_OutputItem::mut_def_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "item_id",
                    CMsgClientToGCCreateStaticRecipeResponse_OutputItem::get_item_id_for_reflect,
                    CMsgClientToGCCreateStaticRecipeResponse_OutputItem::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_id",
                    CMsgClientToGCCreateStaticRecipeResponse_OutputItem::get_slot_id_for_reflect,
                    CMsgClientToGCCreateStaticRecipeResponse_OutputItem::mut_slot_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCCreateStaticRecipeResponse_OutputItem>(
                    "CMsgClientToGCCreateStaticRecipeResponse_OutputItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCCreateStaticRecipeResponse_OutputItem {
    fn clear(&mut self) {
        self.clear_def_index();
        self.clear_item_id();
        self.clear_slot_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCCreateStaticRecipeResponse_OutputItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCreateStaticRecipeResponse_OutputItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCCreateStaticRecipeResponse_InputError {
    // message fields
    slot_id: ::std::option::Option<u32>,
    error: ::std::option::Option<CMsgClientToGCCreateStaticRecipeResponse_EResponse>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCCreateStaticRecipeResponse_InputError {}

impl CMsgClientToGCCreateStaticRecipeResponse_InputError {
    pub fn new() -> CMsgClientToGCCreateStaticRecipeResponse_InputError {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCCreateStaticRecipeResponse_InputError {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCCreateStaticRecipeResponse_InputError> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCCreateStaticRecipeResponse_InputError,
        };
        unsafe {
            instance.get(CMsgClientToGCCreateStaticRecipeResponse_InputError::new)
        }
    }

    // optional uint32 slot_id = 1;

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    pub fn get_slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    fn get_slot_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_id
    }

    fn mut_slot_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_id
    }

    // optional .CMsgClientToGCCreateStaticRecipeResponse.EResponse error = 2;

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CMsgClientToGCCreateStaticRecipeResponse_EResponse) {
        self.error = ::std::option::Option::Some(v);
    }

    pub fn get_error(&self) -> CMsgClientToGCCreateStaticRecipeResponse_EResponse {
        self.error.unwrap_or(CMsgClientToGCCreateStaticRecipeResponse_EResponse::eResponse_Success)
    }

    fn get_error_for_reflect(&self) -> &::std::option::Option<CMsgClientToGCCreateStaticRecipeResponse_EResponse> {
        &self.error
    }

    fn mut_error_for_reflect(&mut self) -> &mut ::std::option::Option<CMsgClientToGCCreateStaticRecipeResponse_EResponse> {
        &mut self.error
    }
}

impl ::protobuf::Message for CMsgClientToGCCreateStaticRecipeResponse_InputError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.error = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.slot_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(2, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCCreateStaticRecipeResponse_InputError {
    fn new() -> CMsgClientToGCCreateStaticRecipeResponse_InputError {
        CMsgClientToGCCreateStaticRecipeResponse_InputError::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCCreateStaticRecipeResponse_InputError>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_id",
                    CMsgClientToGCCreateStaticRecipeResponse_InputError::get_slot_id_for_reflect,
                    CMsgClientToGCCreateStaticRecipeResponse_InputError::mut_slot_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgClientToGCCreateStaticRecipeResponse_EResponse>>(
                    "error",
                    CMsgClientToGCCreateStaticRecipeResponse_InputError::get_error_for_reflect,
                    CMsgClientToGCCreateStaticRecipeResponse_InputError::mut_error_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCCreateStaticRecipeResponse_InputError>(
                    "CMsgClientToGCCreateStaticRecipeResponse_InputError",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCCreateStaticRecipeResponse_InputError {
    fn clear(&mut self) {
        self.clear_slot_id();
        self.clear_error();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCCreateStaticRecipeResponse_InputError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCreateStaticRecipeResponse_InputError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput {
    // message fields
    slot_id: ::std::option::Option<u32>,
    value: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput {}

impl CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput {
    pub fn new() -> CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput,
        };
        unsafe {
            instance.get(CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput::new)
        }
    }

    // optional uint32 slot_id = 1;

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    pub fn get_slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    fn get_slot_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.slot_id
    }

    fn mut_slot_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.slot_id
    }

    // optional uint64 value = 2;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> u64 {
        self.value.unwrap_or(0)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.value
    }
}

impl ::protobuf::Message for CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.slot_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput {
    fn new() -> CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput {
        CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "slot_id",
                    CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput::get_slot_id_for_reflect,
                    CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput::mut_slot_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "value",
                    CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput::get_value_for_reflect,
                    CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput>(
                    "CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput {
    fn clear(&mut self) {
        self.clear_slot_id();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCreateStaticRecipeResponse_AdditionalOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgClientToGCCreateStaticRecipeResponse_EResponse {
    eResponse_Success = 0,
    eResponse_OfferingDisabled = 1,
    eResponse_InvalidItems = 2,
    eResponse_InternalError = 3,
    eResponse_MissingLeague = 4,
}

impl ::protobuf::ProtobufEnum for CMsgClientToGCCreateStaticRecipeResponse_EResponse {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgClientToGCCreateStaticRecipeResponse_EResponse> {
        match value {
            0 => ::std::option::Option::Some(CMsgClientToGCCreateStaticRecipeResponse_EResponse::eResponse_Success),
            1 => ::std::option::Option::Some(CMsgClientToGCCreateStaticRecipeResponse_EResponse::eResponse_OfferingDisabled),
            2 => ::std::option::Option::Some(CMsgClientToGCCreateStaticRecipeResponse_EResponse::eResponse_InvalidItems),
            3 => ::std::option::Option::Some(CMsgClientToGCCreateStaticRecipeResponse_EResponse::eResponse_InternalError),
            4 => ::std::option::Option::Some(CMsgClientToGCCreateStaticRecipeResponse_EResponse::eResponse_MissingLeague),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgClientToGCCreateStaticRecipeResponse_EResponse] = &[
            CMsgClientToGCCreateStaticRecipeResponse_EResponse::eResponse_Success,
            CMsgClientToGCCreateStaticRecipeResponse_EResponse::eResponse_OfferingDisabled,
            CMsgClientToGCCreateStaticRecipeResponse_EResponse::eResponse_InvalidItems,
            CMsgClientToGCCreateStaticRecipeResponse_EResponse::eResponse_InternalError,
            CMsgClientToGCCreateStaticRecipeResponse_EResponse::eResponse_MissingLeague,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CMsgClientToGCCreateStaticRecipeResponse_EResponse>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CMsgClientToGCCreateStaticRecipeResponse_EResponse", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CMsgClientToGCCreateStaticRecipeResponse_EResponse {
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientToGCCreateStaticRecipeResponse_EResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgProcessTransactionOrder {
    // message fields
    txn_id: ::std::option::Option<u64>,
    steam_txn_id: ::std::option::Option<u64>,
    partner_txn_id: ::std::option::Option<u64>,
    steam_id: ::std::option::Option<u64>,
    time_stamp: ::std::option::Option<u32>,
    watermark: ::std::option::Option<u64>,
    purchase_report_status: ::std::option::Option<i32>,
    currency: ::std::option::Option<u32>,
    items: ::protobuf::RepeatedField<CMsgProcessTransactionOrder_Item>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgProcessTransactionOrder {}

impl CMsgProcessTransactionOrder {
    pub fn new() -> CMsgProcessTransactionOrder {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgProcessTransactionOrder {
        static mut instance: ::protobuf::lazy::Lazy<CMsgProcessTransactionOrder> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgProcessTransactionOrder,
        };
        unsafe {
            instance.get(CMsgProcessTransactionOrder::new)
        }
    }

    // optional uint64 txn_id = 1;

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }

    pub fn get_txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    fn get_txn_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.txn_id
    }

    fn mut_txn_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.txn_id
    }

    // optional uint64 steam_txn_id = 2;

    pub fn clear_steam_txn_id(&mut self) {
        self.steam_txn_id = ::std::option::Option::None;
    }

    pub fn has_steam_txn_id(&self) -> bool {
        self.steam_txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_txn_id(&mut self, v: u64) {
        self.steam_txn_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_txn_id(&self) -> u64 {
        self.steam_txn_id.unwrap_or(0)
    }

    fn get_steam_txn_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.steam_txn_id
    }

    fn mut_steam_txn_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.steam_txn_id
    }

    // optional uint64 partner_txn_id = 3;

    pub fn clear_partner_txn_id(&mut self) {
        self.partner_txn_id = ::std::option::Option::None;
    }

    pub fn has_partner_txn_id(&self) -> bool {
        self.partner_txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner_txn_id(&mut self, v: u64) {
        self.partner_txn_id = ::std::option::Option::Some(v);
    }

    pub fn get_partner_txn_id(&self) -> u64 {
        self.partner_txn_id.unwrap_or(0)
    }

    fn get_partner_txn_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.partner_txn_id
    }

    fn mut_partner_txn_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.partner_txn_id
    }

    // optional fixed64 steam_id = 4;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    fn get_steam_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.steam_id
    }

    fn mut_steam_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.steam_id
    }

    // optional uint32 time_stamp = 5;

    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u32) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    pub fn get_time_stamp(&self) -> u32 {
        self.time_stamp.unwrap_or(0)
    }

    fn get_time_stamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.time_stamp
    }

    fn mut_time_stamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.time_stamp
    }

    // optional uint64 watermark = 6;

    pub fn clear_watermark(&mut self) {
        self.watermark = ::std::option::Option::None;
    }

    pub fn has_watermark(&self) -> bool {
        self.watermark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watermark(&mut self, v: u64) {
        self.watermark = ::std::option::Option::Some(v);
    }

    pub fn get_watermark(&self) -> u64 {
        self.watermark.unwrap_or(0)
    }

    fn get_watermark_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.watermark
    }

    fn mut_watermark_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.watermark
    }

    // optional int32 purchase_report_status = 7;

    pub fn clear_purchase_report_status(&mut self) {
        self.purchase_report_status = ::std::option::Option::None;
    }

    pub fn has_purchase_report_status(&self) -> bool {
        self.purchase_report_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_report_status(&mut self, v: i32) {
        self.purchase_report_status = ::std::option::Option::Some(v);
    }

    pub fn get_purchase_report_status(&self) -> i32 {
        self.purchase_report_status.unwrap_or(0)
    }

    fn get_purchase_report_status_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.purchase_report_status
    }

    fn mut_purchase_report_status_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.purchase_report_status
    }

    // optional uint32 currency = 8;

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: u32) {
        self.currency = ::std::option::Option::Some(v);
    }

    pub fn get_currency(&self) -> u32 {
        self.currency.unwrap_or(0)
    }

    fn get_currency_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.currency
    }

    fn mut_currency_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.currency
    }

    // repeated .CMsgProcessTransactionOrder.Item items = 9;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<CMsgProcessTransactionOrder_Item>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<CMsgProcessTransactionOrder_Item> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<CMsgProcessTransactionOrder_Item> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[CMsgProcessTransactionOrder_Item] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgProcessTransactionOrder_Item> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgProcessTransactionOrder_Item> {
        &mut self.items
    }
}

impl ::protobuf::Message for CMsgProcessTransactionOrder {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txn_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.steam_txn_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.partner_txn_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_stamp = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.watermark = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.purchase_report_status = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.currency = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_txn_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.partner_txn_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.time_stamp {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.watermark {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.purchase_report_status {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steam_txn_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.partner_txn_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steam_id {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.time_stamp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.watermark {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.purchase_report_status {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.currency {
            os.write_uint32(8, v)?;
        }
        for v in &self.items {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgProcessTransactionOrder {
    fn new() -> CMsgProcessTransactionOrder {
        CMsgProcessTransactionOrder::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgProcessTransactionOrder>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "txn_id",
                    CMsgProcessTransactionOrder::get_txn_id_for_reflect,
                    CMsgProcessTransactionOrder::mut_txn_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "steam_txn_id",
                    CMsgProcessTransactionOrder::get_steam_txn_id_for_reflect,
                    CMsgProcessTransactionOrder::mut_steam_txn_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "partner_txn_id",
                    CMsgProcessTransactionOrder::get_partner_txn_id_for_reflect,
                    CMsgProcessTransactionOrder::mut_partner_txn_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steam_id",
                    CMsgProcessTransactionOrder::get_steam_id_for_reflect,
                    CMsgProcessTransactionOrder::mut_steam_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_stamp",
                    CMsgProcessTransactionOrder::get_time_stamp_for_reflect,
                    CMsgProcessTransactionOrder::mut_time_stamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "watermark",
                    CMsgProcessTransactionOrder::get_watermark_for_reflect,
                    CMsgProcessTransactionOrder::mut_watermark_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "purchase_report_status",
                    CMsgProcessTransactionOrder::get_purchase_report_status_for_reflect,
                    CMsgProcessTransactionOrder::mut_purchase_report_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "currency",
                    CMsgProcessTransactionOrder::get_currency_for_reflect,
                    CMsgProcessTransactionOrder::mut_currency_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProcessTransactionOrder_Item>>(
                    "items",
                    CMsgProcessTransactionOrder::get_items_for_reflect,
                    CMsgProcessTransactionOrder::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgProcessTransactionOrder>(
                    "CMsgProcessTransactionOrder",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgProcessTransactionOrder {
    fn clear(&mut self) {
        self.clear_txn_id();
        self.clear_steam_txn_id();
        self.clear_partner_txn_id();
        self.clear_steam_id();
        self.clear_time_stamp();
        self.clear_watermark();
        self.clear_purchase_report_status();
        self.clear_currency();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgProcessTransactionOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgProcessTransactionOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgProcessTransactionOrder_Item {
    // message fields
    item_def_index: ::std::option::Option<u32>,
    item_price: ::std::option::Option<u32>,
    quantity: ::std::option::Option<u32>,
    category_desc: ::protobuf::SingularField<::std::string::String>,
    store_purchase_type: ::std::option::Option<u32>,
    source_reference_id: ::std::option::Option<u64>,
    parent_stack_index: ::std::option::Option<i32>,
    default_price: ::std::option::Option<bool>,
    is_user_facing: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgProcessTransactionOrder_Item {}

impl CMsgProcessTransactionOrder_Item {
    pub fn new() -> CMsgProcessTransactionOrder_Item {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgProcessTransactionOrder_Item {
        static mut instance: ::protobuf::lazy::Lazy<CMsgProcessTransactionOrder_Item> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgProcessTransactionOrder_Item,
        };
        unsafe {
            instance.get(CMsgProcessTransactionOrder_Item::new)
        }
    }

    // optional uint32 item_def_index = 1;

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    pub fn get_item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    fn get_item_def_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_def_index
    }

    fn mut_item_def_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_def_index
    }

    // optional uint32 item_price = 2;

    pub fn clear_item_price(&mut self) {
        self.item_price = ::std::option::Option::None;
    }

    pub fn has_item_price(&self) -> bool {
        self.item_price.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_price(&mut self, v: u32) {
        self.item_price = ::std::option::Option::Some(v);
    }

    pub fn get_item_price(&self) -> u32 {
        self.item_price.unwrap_or(0)
    }

    fn get_item_price_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_price
    }

    fn mut_item_price_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_price
    }

    // optional uint32 quantity = 3;

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    pub fn get_quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    fn get_quantity_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.quantity
    }

    fn mut_quantity_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.quantity
    }

    // optional string category_desc = 4;

    pub fn clear_category_desc(&mut self) {
        self.category_desc.clear();
    }

    pub fn has_category_desc(&self) -> bool {
        self.category_desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category_desc(&mut self, v: ::std::string::String) {
        self.category_desc = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_category_desc(&mut self) -> &mut ::std::string::String {
        if self.category_desc.is_none() {
            self.category_desc.set_default();
        }
        self.category_desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_category_desc(&mut self) -> ::std::string::String {
        self.category_desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_category_desc(&self) -> &str {
        match self.category_desc.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_category_desc_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.category_desc
    }

    fn mut_category_desc_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.category_desc
    }

    // optional uint32 store_purchase_type = 5;

    pub fn clear_store_purchase_type(&mut self) {
        self.store_purchase_type = ::std::option::Option::None;
    }

    pub fn has_store_purchase_type(&self) -> bool {
        self.store_purchase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_purchase_type(&mut self, v: u32) {
        self.store_purchase_type = ::std::option::Option::Some(v);
    }

    pub fn get_store_purchase_type(&self) -> u32 {
        self.store_purchase_type.unwrap_or(0)
    }

    fn get_store_purchase_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.store_purchase_type
    }

    fn mut_store_purchase_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.store_purchase_type
    }

    // optional uint64 source_reference_id = 6;

    pub fn clear_source_reference_id(&mut self) {
        self.source_reference_id = ::std::option::Option::None;
    }

    pub fn has_source_reference_id(&self) -> bool {
        self.source_reference_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_reference_id(&mut self, v: u64) {
        self.source_reference_id = ::std::option::Option::Some(v);
    }

    pub fn get_source_reference_id(&self) -> u64 {
        self.source_reference_id.unwrap_or(0)
    }

    fn get_source_reference_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.source_reference_id
    }

    fn mut_source_reference_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.source_reference_id
    }

    // optional int32 parent_stack_index = 7;

    pub fn clear_parent_stack_index(&mut self) {
        self.parent_stack_index = ::std::option::Option::None;
    }

    pub fn has_parent_stack_index(&self) -> bool {
        self.parent_stack_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_stack_index(&mut self, v: i32) {
        self.parent_stack_index = ::std::option::Option::Some(v);
    }

    pub fn get_parent_stack_index(&self) -> i32 {
        self.parent_stack_index.unwrap_or(0)
    }

    fn get_parent_stack_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.parent_stack_index
    }

    fn mut_parent_stack_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.parent_stack_index
    }

    // optional bool default_price = 8;

    pub fn clear_default_price(&mut self) {
        self.default_price = ::std::option::Option::None;
    }

    pub fn has_default_price(&self) -> bool {
        self.default_price.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_price(&mut self, v: bool) {
        self.default_price = ::std::option::Option::Some(v);
    }

    pub fn get_default_price(&self) -> bool {
        self.default_price.unwrap_or(false)
    }

    fn get_default_price_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.default_price
    }

    fn mut_default_price_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.default_price
    }

    // optional bool is_user_facing = 9;

    pub fn clear_is_user_facing(&mut self) {
        self.is_user_facing = ::std::option::Option::None;
    }

    pub fn has_is_user_facing(&self) -> bool {
        self.is_user_facing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_user_facing(&mut self, v: bool) {
        self.is_user_facing = ::std::option::Option::Some(v);
    }

    pub fn get_is_user_facing(&self) -> bool {
        self.is_user_facing.unwrap_or(false)
    }

    fn get_is_user_facing_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_user_facing
    }

    fn mut_is_user_facing_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_user_facing
    }
}

impl ::protobuf::Message for CMsgProcessTransactionOrder_Item {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_price = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quantity = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.category_desc)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.store_purchase_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.source_reference_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.parent_stack_index = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.default_price = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_user_facing = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_price {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.category_desc.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.store_purchase_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.source_reference_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.parent_stack_index {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.default_price {
            my_size += 2;
        }
        if let Some(v) = self.is_user_facing {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_price {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.category_desc.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.store_purchase_type {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.source_reference_id {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.parent_stack_index {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.default_price {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.is_user_facing {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgProcessTransactionOrder_Item {
    fn new() -> CMsgProcessTransactionOrder_Item {
        CMsgProcessTransactionOrder_Item::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgProcessTransactionOrder_Item>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_def_index",
                    CMsgProcessTransactionOrder_Item::get_item_def_index_for_reflect,
                    CMsgProcessTransactionOrder_Item::mut_item_def_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_price",
                    CMsgProcessTransactionOrder_Item::get_item_price_for_reflect,
                    CMsgProcessTransactionOrder_Item::mut_item_price_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quantity",
                    CMsgProcessTransactionOrder_Item::get_quantity_for_reflect,
                    CMsgProcessTransactionOrder_Item::mut_quantity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "category_desc",
                    CMsgProcessTransactionOrder_Item::get_category_desc_for_reflect,
                    CMsgProcessTransactionOrder_Item::mut_category_desc_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "store_purchase_type",
                    CMsgProcessTransactionOrder_Item::get_store_purchase_type_for_reflect,
                    CMsgProcessTransactionOrder_Item::mut_store_purchase_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "source_reference_id",
                    CMsgProcessTransactionOrder_Item::get_source_reference_id_for_reflect,
                    CMsgProcessTransactionOrder_Item::mut_source_reference_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "parent_stack_index",
                    CMsgProcessTransactionOrder_Item::get_parent_stack_index_for_reflect,
                    CMsgProcessTransactionOrder_Item::mut_parent_stack_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "default_price",
                    CMsgProcessTransactionOrder_Item::get_default_price_for_reflect,
                    CMsgProcessTransactionOrder_Item::mut_default_price_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_user_facing",
                    CMsgProcessTransactionOrder_Item::get_is_user_facing_for_reflect,
                    CMsgProcessTransactionOrder_Item::mut_is_user_facing_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgProcessTransactionOrder_Item>(
                    "CMsgProcessTransactionOrder_Item",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgProcessTransactionOrder_Item {
    fn clear(&mut self) {
        self.clear_item_def_index();
        self.clear_item_price();
        self.clear_quantity();
        self.clear_category_desc();
        self.clear_store_purchase_type();
        self.clear_source_reference_id();
        self.clear_parent_stack_index();
        self.clear_default_price();
        self.clear_is_user_facing();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgProcessTransactionOrder_Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgProcessTransactionOrder_Item {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCStoreProcessCDKeyTransaction {
    // message fields
    order: ::protobuf::SingularPtrField<CMsgProcessTransactionOrder>,
    reason_code: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCStoreProcessCDKeyTransaction {}

impl CMsgGCToGCStoreProcessCDKeyTransaction {
    pub fn new() -> CMsgGCToGCStoreProcessCDKeyTransaction {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCStoreProcessCDKeyTransaction {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCStoreProcessCDKeyTransaction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCStoreProcessCDKeyTransaction,
        };
        unsafe {
            instance.get(CMsgGCToGCStoreProcessCDKeyTransaction::new)
        }
    }

    // optional .CMsgProcessTransactionOrder order = 1;

    pub fn clear_order(&mut self) {
        self.order.clear();
    }

    pub fn has_order(&self) -> bool {
        self.order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: CMsgProcessTransactionOrder) {
        self.order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order(&mut self) -> &mut CMsgProcessTransactionOrder {
        if self.order.is_none() {
            self.order.set_default();
        }
        self.order.as_mut().unwrap()
    }

    // Take field
    pub fn take_order(&mut self) -> CMsgProcessTransactionOrder {
        self.order.take().unwrap_or_else(|| CMsgProcessTransactionOrder::new())
    }

    pub fn get_order(&self) -> &CMsgProcessTransactionOrder {
        self.order.as_ref().unwrap_or_else(|| CMsgProcessTransactionOrder::default_instance())
    }

    fn get_order_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgProcessTransactionOrder> {
        &self.order
    }

    fn mut_order_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgProcessTransactionOrder> {
        &mut self.order
    }

    // optional uint32 reason_code = 2;

    pub fn clear_reason_code(&mut self) {
        self.reason_code = ::std::option::Option::None;
    }

    pub fn has_reason_code(&self) -> bool {
        self.reason_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason_code(&mut self, v: u32) {
        self.reason_code = ::std::option::Option::Some(v);
    }

    pub fn get_reason_code(&self) -> u32 {
        self.reason_code.unwrap_or(0)
    }

    fn get_reason_code_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.reason_code
    }

    fn mut_reason_code_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.reason_code
    }
}

impl ::protobuf::Message for CMsgGCToGCStoreProcessCDKeyTransaction {
    fn is_initialized(&self) -> bool {
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reason_code = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.reason_code {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.order.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.reason_code {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCStoreProcessCDKeyTransaction {
    fn new() -> CMsgGCToGCStoreProcessCDKeyTransaction {
        CMsgGCToGCStoreProcessCDKeyTransaction::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCStoreProcessCDKeyTransaction>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProcessTransactionOrder>>(
                    "order",
                    CMsgGCToGCStoreProcessCDKeyTransaction::get_order_for_reflect,
                    CMsgGCToGCStoreProcessCDKeyTransaction::mut_order_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reason_code",
                    CMsgGCToGCStoreProcessCDKeyTransaction::get_reason_code_for_reflect,
                    CMsgGCToGCStoreProcessCDKeyTransaction::mut_reason_code_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCStoreProcessCDKeyTransaction>(
                    "CMsgGCToGCStoreProcessCDKeyTransaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCStoreProcessCDKeyTransaction {
    fn clear(&mut self) {
        self.clear_order();
        self.clear_reason_code();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCStoreProcessCDKeyTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCStoreProcessCDKeyTransaction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    // message fields
    success: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCStoreProcessCDKeyTransactionResponse {}

impl CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    pub fn new() -> CMsgGCToGCStoreProcessCDKeyTransactionResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCStoreProcessCDKeyTransactionResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCStoreProcessCDKeyTransactionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCStoreProcessCDKeyTransactionResponse,
        };
        unsafe {
            instance.get(CMsgGCToGCStoreProcessCDKeyTransactionResponse::new)
        }
    }

    // optional bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    fn get_success_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.success
    }

    fn mut_success_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.success
    }
}

impl ::protobuf::Message for CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    fn new() -> CMsgGCToGCStoreProcessCDKeyTransactionResponse {
        CMsgGCToGCStoreProcessCDKeyTransactionResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCStoreProcessCDKeyTransactionResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    CMsgGCToGCStoreProcessCDKeyTransactionResponse::get_success_for_reflect,
                    CMsgGCToGCStoreProcessCDKeyTransactionResponse::mut_success_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCStoreProcessCDKeyTransactionResponse>(
                    "CMsgGCToGCStoreProcessCDKeyTransactionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    fn clear(&mut self) {
        self.clear_success();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCStoreProcessCDKeyTransactionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCStoreProcessSettlement {
    // message fields
    order: ::protobuf::SingularPtrField<CMsgProcessTransactionOrder>,
    partner: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCStoreProcessSettlement {}

impl CMsgGCToGCStoreProcessSettlement {
    pub fn new() -> CMsgGCToGCStoreProcessSettlement {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCStoreProcessSettlement {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCStoreProcessSettlement> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCStoreProcessSettlement,
        };
        unsafe {
            instance.get(CMsgGCToGCStoreProcessSettlement::new)
        }
    }

    // optional .CMsgProcessTransactionOrder order = 1;

    pub fn clear_order(&mut self) {
        self.order.clear();
    }

    pub fn has_order(&self) -> bool {
        self.order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: CMsgProcessTransactionOrder) {
        self.order = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order(&mut self) -> &mut CMsgProcessTransactionOrder {
        if self.order.is_none() {
            self.order.set_default();
        }
        self.order.as_mut().unwrap()
    }

    // Take field
    pub fn take_order(&mut self) -> CMsgProcessTransactionOrder {
        self.order.take().unwrap_or_else(|| CMsgProcessTransactionOrder::new())
    }

    pub fn get_order(&self) -> &CMsgProcessTransactionOrder {
        self.order.as_ref().unwrap_or_else(|| CMsgProcessTransactionOrder::default_instance())
    }

    fn get_order_for_reflect(&self) -> &::protobuf::SingularPtrField<CMsgProcessTransactionOrder> {
        &self.order
    }

    fn mut_order_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CMsgProcessTransactionOrder> {
        &mut self.order
    }

    // optional uint32 partner = 2;

    pub fn clear_partner(&mut self) {
        self.partner = ::std::option::Option::None;
    }

    pub fn has_partner(&self) -> bool {
        self.partner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner(&mut self, v: u32) {
        self.partner = ::std::option::Option::Some(v);
    }

    pub fn get_partner(&self) -> u32 {
        self.partner.unwrap_or(0)
    }

    fn get_partner_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.partner
    }

    fn mut_partner_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.partner
    }
}

impl ::protobuf::Message for CMsgGCToGCStoreProcessSettlement {
    fn is_initialized(&self) -> bool {
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.order)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.partner = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.partner {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.order.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.partner {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCStoreProcessSettlement {
    fn new() -> CMsgGCToGCStoreProcessSettlement {
        CMsgGCToGCStoreProcessSettlement::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCStoreProcessSettlement>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProcessTransactionOrder>>(
                    "order",
                    CMsgGCToGCStoreProcessSettlement::get_order_for_reflect,
                    CMsgGCToGCStoreProcessSettlement::mut_order_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "partner",
                    CMsgGCToGCStoreProcessSettlement::get_partner_for_reflect,
                    CMsgGCToGCStoreProcessSettlement::mut_partner_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCStoreProcessSettlement>(
                    "CMsgGCToGCStoreProcessSettlement",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCStoreProcessSettlement {
    fn clear(&mut self) {
        self.clear_order();
        self.clear_partner();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCStoreProcessSettlement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCStoreProcessSettlement {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCStoreProcessSettlementResponse {
    // message fields
    success: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCStoreProcessSettlementResponse {}

impl CMsgGCToGCStoreProcessSettlementResponse {
    pub fn new() -> CMsgGCToGCStoreProcessSettlementResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCStoreProcessSettlementResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCStoreProcessSettlementResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCStoreProcessSettlementResponse,
        };
        unsafe {
            instance.get(CMsgGCToGCStoreProcessSettlementResponse::new)
        }
    }

    // optional bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    fn get_success_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.success
    }

    fn mut_success_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.success
    }
}

impl ::protobuf::Message for CMsgGCToGCStoreProcessSettlementResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCStoreProcessSettlementResponse {
    fn new() -> CMsgGCToGCStoreProcessSettlementResponse {
        CMsgGCToGCStoreProcessSettlementResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCStoreProcessSettlementResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    CMsgGCToGCStoreProcessSettlementResponse::get_success_for_reflect,
                    CMsgGCToGCStoreProcessSettlementResponse::mut_success_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCStoreProcessSettlementResponse>(
                    "CMsgGCToGCStoreProcessSettlementResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCStoreProcessSettlementResponse {
    fn clear(&mut self) {
        self.clear_success();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCStoreProcessSettlementResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCStoreProcessSettlementResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCBroadcastConsoleCommand {
    // message fields
    con_command: ::protobuf::SingularField<::std::string::String>,
    report_output: ::std::option::Option<bool>,
    sending_gc: ::std::option::Option<u32>,
    output_initiator: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCBroadcastConsoleCommand {}

impl CMsgGCToGCBroadcastConsoleCommand {
    pub fn new() -> CMsgGCToGCBroadcastConsoleCommand {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCBroadcastConsoleCommand {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCBroadcastConsoleCommand> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCBroadcastConsoleCommand,
        };
        unsafe {
            instance.get(CMsgGCToGCBroadcastConsoleCommand::new)
        }
    }

    // optional string con_command = 1;

    pub fn clear_con_command(&mut self) {
        self.con_command.clear();
    }

    pub fn has_con_command(&self) -> bool {
        self.con_command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_con_command(&mut self, v: ::std::string::String) {
        self.con_command = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_con_command(&mut self) -> &mut ::std::string::String {
        if self.con_command.is_none() {
            self.con_command.set_default();
        }
        self.con_command.as_mut().unwrap()
    }

    // Take field
    pub fn take_con_command(&mut self) -> ::std::string::String {
        self.con_command.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_con_command(&self) -> &str {
        match self.con_command.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_con_command_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.con_command
    }

    fn mut_con_command_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.con_command
    }

    // optional bool report_output = 2;

    pub fn clear_report_output(&mut self) {
        self.report_output = ::std::option::Option::None;
    }

    pub fn has_report_output(&self) -> bool {
        self.report_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_output(&mut self, v: bool) {
        self.report_output = ::std::option::Option::Some(v);
    }

    pub fn get_report_output(&self) -> bool {
        self.report_output.unwrap_or(false)
    }

    fn get_report_output_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.report_output
    }

    fn mut_report_output_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.report_output
    }

    // optional uint32 sending_gc = 3;

    pub fn clear_sending_gc(&mut self) {
        self.sending_gc = ::std::option::Option::None;
    }

    pub fn has_sending_gc(&self) -> bool {
        self.sending_gc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sending_gc(&mut self, v: u32) {
        self.sending_gc = ::std::option::Option::Some(v);
    }

    pub fn get_sending_gc(&self) -> u32 {
        self.sending_gc.unwrap_or(0)
    }

    fn get_sending_gc_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.sending_gc
    }

    fn mut_sending_gc_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.sending_gc
    }

    // optional string output_initiator = 4;

    pub fn clear_output_initiator(&mut self) {
        self.output_initiator.clear();
    }

    pub fn has_output_initiator(&self) -> bool {
        self.output_initiator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_initiator(&mut self, v: ::std::string::String) {
        self.output_initiator = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_initiator(&mut self) -> &mut ::std::string::String {
        if self.output_initiator.is_none() {
            self.output_initiator.set_default();
        }
        self.output_initiator.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_initiator(&mut self) -> ::std::string::String {
        self.output_initiator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_output_initiator(&self) -> &str {
        match self.output_initiator.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_output_initiator_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.output_initiator
    }

    fn mut_output_initiator_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.output_initiator
    }
}

impl ::protobuf::Message for CMsgGCToGCBroadcastConsoleCommand {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.con_command)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.report_output = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sending_gc = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.output_initiator)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.con_command.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.report_output {
            my_size += 2;
        }
        if let Some(v) = self.sending_gc {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.output_initiator.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.con_command.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.report_output {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.sending_gc {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.output_initiator.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCBroadcastConsoleCommand {
    fn new() -> CMsgGCToGCBroadcastConsoleCommand {
        CMsgGCToGCBroadcastConsoleCommand::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCBroadcastConsoleCommand>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "con_command",
                    CMsgGCToGCBroadcastConsoleCommand::get_con_command_for_reflect,
                    CMsgGCToGCBroadcastConsoleCommand::mut_con_command_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "report_output",
                    CMsgGCToGCBroadcastConsoleCommand::get_report_output_for_reflect,
                    CMsgGCToGCBroadcastConsoleCommand::mut_report_output_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sending_gc",
                    CMsgGCToGCBroadcastConsoleCommand::get_sending_gc_for_reflect,
                    CMsgGCToGCBroadcastConsoleCommand::mut_sending_gc_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "output_initiator",
                    CMsgGCToGCBroadcastConsoleCommand::get_output_initiator_for_reflect,
                    CMsgGCToGCBroadcastConsoleCommand::mut_output_initiator_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCBroadcastConsoleCommand>(
                    "CMsgGCToGCBroadcastConsoleCommand",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCBroadcastConsoleCommand {
    fn clear(&mut self) {
        self.clear_con_command();
        self.clear_report_output();
        self.clear_sending_gc();
        self.clear_output_initiator();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCBroadcastConsoleCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCBroadcastConsoleCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCConsoleOutput {
    // message fields
    initiator: ::protobuf::SingularField<::std::string::String>,
    sending_gc: ::std::option::Option<u32>,
    msgs: ::protobuf::RepeatedField<CMsgGCToGCConsoleOutput_OutputLine>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCConsoleOutput {}

impl CMsgGCToGCConsoleOutput {
    pub fn new() -> CMsgGCToGCConsoleOutput {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCConsoleOutput {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCConsoleOutput> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCConsoleOutput,
        };
        unsafe {
            instance.get(CMsgGCToGCConsoleOutput::new)
        }
    }

    // optional string initiator = 1;

    pub fn clear_initiator(&mut self) {
        self.initiator.clear();
    }

    pub fn has_initiator(&self) -> bool {
        self.initiator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator(&mut self, v: ::std::string::String) {
        self.initiator = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initiator(&mut self) -> &mut ::std::string::String {
        if self.initiator.is_none() {
            self.initiator.set_default();
        }
        self.initiator.as_mut().unwrap()
    }

    // Take field
    pub fn take_initiator(&mut self) -> ::std::string::String {
        self.initiator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_initiator(&self) -> &str {
        match self.initiator.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_initiator_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.initiator
    }

    fn mut_initiator_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.initiator
    }

    // optional uint32 sending_gc = 2;

    pub fn clear_sending_gc(&mut self) {
        self.sending_gc = ::std::option::Option::None;
    }

    pub fn has_sending_gc(&self) -> bool {
        self.sending_gc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sending_gc(&mut self, v: u32) {
        self.sending_gc = ::std::option::Option::Some(v);
    }

    pub fn get_sending_gc(&self) -> u32 {
        self.sending_gc.unwrap_or(0)
    }

    fn get_sending_gc_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.sending_gc
    }

    fn mut_sending_gc_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.sending_gc
    }

    // repeated .CMsgGCToGCConsoleOutput.OutputLine msgs = 3;

    pub fn clear_msgs(&mut self) {
        self.msgs.clear();
    }

    // Param is passed by value, moved
    pub fn set_msgs(&mut self, v: ::protobuf::RepeatedField<CMsgGCToGCConsoleOutput_OutputLine>) {
        self.msgs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_msgs(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToGCConsoleOutput_OutputLine> {
        &mut self.msgs
    }

    // Take field
    pub fn take_msgs(&mut self) -> ::protobuf::RepeatedField<CMsgGCToGCConsoleOutput_OutputLine> {
        ::std::mem::replace(&mut self.msgs, ::protobuf::RepeatedField::new())
    }

    pub fn get_msgs(&self) -> &[CMsgGCToGCConsoleOutput_OutputLine] {
        &self.msgs
    }

    fn get_msgs_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgGCToGCConsoleOutput_OutputLine> {
        &self.msgs
    }

    fn mut_msgs_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToGCConsoleOutput_OutputLine> {
        &mut self.msgs
    }
}

impl ::protobuf::Message for CMsgGCToGCConsoleOutput {
    fn is_initialized(&self) -> bool {
        for v in &self.msgs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.initiator)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sending_gc = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.msgs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.initiator.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.sending_gc {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.msgs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.initiator.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.sending_gc {
            os.write_uint32(2, v)?;
        }
        for v in &self.msgs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCConsoleOutput {
    fn new() -> CMsgGCToGCConsoleOutput {
        CMsgGCToGCConsoleOutput::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCConsoleOutput>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "initiator",
                    CMsgGCToGCConsoleOutput::get_initiator_for_reflect,
                    CMsgGCToGCConsoleOutput::mut_initiator_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sending_gc",
                    CMsgGCToGCConsoleOutput::get_sending_gc_for_reflect,
                    CMsgGCToGCConsoleOutput::mut_sending_gc_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToGCConsoleOutput_OutputLine>>(
                    "msgs",
                    CMsgGCToGCConsoleOutput::get_msgs_for_reflect,
                    CMsgGCToGCConsoleOutput::mut_msgs_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCConsoleOutput>(
                    "CMsgGCToGCConsoleOutput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCConsoleOutput {
    fn clear(&mut self) {
        self.clear_initiator();
        self.clear_sending_gc();
        self.clear_msgs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCConsoleOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCConsoleOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCConsoleOutput_OutputLine {
    // message fields
    text: ::protobuf::SingularField<::std::string::String>,
    spew_level: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCConsoleOutput_OutputLine {}

impl CMsgGCToGCConsoleOutput_OutputLine {
    pub fn new() -> CMsgGCToGCConsoleOutput_OutputLine {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCConsoleOutput_OutputLine {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCConsoleOutput_OutputLine> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCConsoleOutput_OutputLine,
        };
        unsafe {
            instance.get(CMsgGCToGCConsoleOutput_OutputLine::new)
        }
    }

    // optional string text = 1;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_text_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.text
    }

    fn mut_text_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.text
    }

    // optional uint32 spew_level = 2;

    pub fn clear_spew_level(&mut self) {
        self.spew_level = ::std::option::Option::None;
    }

    pub fn has_spew_level(&self) -> bool {
        self.spew_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spew_level(&mut self, v: u32) {
        self.spew_level = ::std::option::Option::Some(v);
    }

    pub fn get_spew_level(&self) -> u32 {
        self.spew_level.unwrap_or(0)
    }

    fn get_spew_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.spew_level
    }

    fn mut_spew_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.spew_level
    }
}

impl ::protobuf::Message for CMsgGCToGCConsoleOutput_OutputLine {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.spew_level = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.spew_level {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.spew_level {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCConsoleOutput_OutputLine {
    fn new() -> CMsgGCToGCConsoleOutput_OutputLine {
        CMsgGCToGCConsoleOutput_OutputLine::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCConsoleOutput_OutputLine>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    CMsgGCToGCConsoleOutput_OutputLine::get_text_for_reflect,
                    CMsgGCToGCConsoleOutput_OutputLine::mut_text_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "spew_level",
                    CMsgGCToGCConsoleOutput_OutputLine::get_spew_level_for_reflect,
                    CMsgGCToGCConsoleOutput_OutputLine::mut_spew_level_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCConsoleOutput_OutputLine>(
                    "CMsgGCToGCConsoleOutput_OutputLine",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCConsoleOutput_OutputLine {
    fn clear(&mut self) {
        self.clear_text();
        self.clear_spew_level();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCConsoleOutput_OutputLine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCConsoleOutput_OutputLine {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgItemAges {
    // message fields
    max_item_id_timestamps: ::protobuf::RepeatedField<CMsgItemAges_MaxItemIDTimestamp>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgItemAges {}

impl CMsgItemAges {
    pub fn new() -> CMsgItemAges {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgItemAges {
        static mut instance: ::protobuf::lazy::Lazy<CMsgItemAges> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgItemAges,
        };
        unsafe {
            instance.get(CMsgItemAges::new)
        }
    }

    // repeated .CMsgItemAges.MaxItemIDTimestamp max_item_id_timestamps = 1;

    pub fn clear_max_item_id_timestamps(&mut self) {
        self.max_item_id_timestamps.clear();
    }

    // Param is passed by value, moved
    pub fn set_max_item_id_timestamps(&mut self, v: ::protobuf::RepeatedField<CMsgItemAges_MaxItemIDTimestamp>) {
        self.max_item_id_timestamps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_max_item_id_timestamps(&mut self) -> &mut ::protobuf::RepeatedField<CMsgItemAges_MaxItemIDTimestamp> {
        &mut self.max_item_id_timestamps
    }

    // Take field
    pub fn take_max_item_id_timestamps(&mut self) -> ::protobuf::RepeatedField<CMsgItemAges_MaxItemIDTimestamp> {
        ::std::mem::replace(&mut self.max_item_id_timestamps, ::protobuf::RepeatedField::new())
    }

    pub fn get_max_item_id_timestamps(&self) -> &[CMsgItemAges_MaxItemIDTimestamp] {
        &self.max_item_id_timestamps
    }

    fn get_max_item_id_timestamps_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgItemAges_MaxItemIDTimestamp> {
        &self.max_item_id_timestamps
    }

    fn mut_max_item_id_timestamps_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgItemAges_MaxItemIDTimestamp> {
        &mut self.max_item_id_timestamps
    }
}

impl ::protobuf::Message for CMsgItemAges {
    fn is_initialized(&self) -> bool {
        for v in &self.max_item_id_timestamps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.max_item_id_timestamps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.max_item_id_timestamps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.max_item_id_timestamps {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgItemAges {
    fn new() -> CMsgItemAges {
        CMsgItemAges::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgItemAges>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgItemAges_MaxItemIDTimestamp>>(
                    "max_item_id_timestamps",
                    CMsgItemAges::get_max_item_id_timestamps_for_reflect,
                    CMsgItemAges::mut_max_item_id_timestamps_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgItemAges>(
                    "CMsgItemAges",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgItemAges {
    fn clear(&mut self) {
        self.clear_max_item_id_timestamps();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgItemAges {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgItemAges {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgItemAges_MaxItemIDTimestamp {
    // message fields
    timestamp: ::std::option::Option<u32>,
    max_item_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgItemAges_MaxItemIDTimestamp {}

impl CMsgItemAges_MaxItemIDTimestamp {
    pub fn new() -> CMsgItemAges_MaxItemIDTimestamp {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgItemAges_MaxItemIDTimestamp {
        static mut instance: ::protobuf::lazy::Lazy<CMsgItemAges_MaxItemIDTimestamp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgItemAges_MaxItemIDTimestamp,
        };
        unsafe {
            instance.get(CMsgItemAges_MaxItemIDTimestamp::new)
        }
    }

    // optional uint32 timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.timestamp
    }

    // optional uint64 max_item_id = 2;

    pub fn clear_max_item_id(&mut self) {
        self.max_item_id = ::std::option::Option::None;
    }

    pub fn has_max_item_id(&self) -> bool {
        self.max_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_item_id(&mut self, v: u64) {
        self.max_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_max_item_id(&self) -> u64 {
        self.max_item_id.unwrap_or(0)
    }

    fn get_max_item_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.max_item_id
    }

    fn mut_max_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.max_item_id
    }
}

impl ::protobuf::Message for CMsgItemAges_MaxItemIDTimestamp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.max_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgItemAges_MaxItemIDTimestamp {
    fn new() -> CMsgItemAges_MaxItemIDTimestamp {
        CMsgItemAges_MaxItemIDTimestamp::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgItemAges_MaxItemIDTimestamp>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    CMsgItemAges_MaxItemIDTimestamp::get_timestamp_for_reflect,
                    CMsgItemAges_MaxItemIDTimestamp::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "max_item_id",
                    CMsgItemAges_MaxItemIDTimestamp::get_max_item_id_for_reflect,
                    CMsgItemAges_MaxItemIDTimestamp::mut_max_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgItemAges_MaxItemIDTimestamp>(
                    "CMsgItemAges_MaxItemIDTimestamp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgItemAges_MaxItemIDTimestamp {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_max_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgItemAges_MaxItemIDTimestamp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgItemAges_MaxItemIDTimestamp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCInternalTestMsg {
    // message fields
    sending_gc: ::std::option::Option<u32>,
    sender_id: ::std::option::Option<u64>,
    context: ::std::option::Option<u32>,
    message_id: ::std::option::Option<u32>,
    message_body: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    job_id_source: ::std::option::Option<u64>,
    job_id_target: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCInternalTestMsg {}

impl CMsgGCToGCInternalTestMsg {
    pub fn new() -> CMsgGCToGCInternalTestMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCInternalTestMsg {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCInternalTestMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCInternalTestMsg,
        };
        unsafe {
            instance.get(CMsgGCToGCInternalTestMsg::new)
        }
    }

    // optional uint32 sending_gc = 1;

    pub fn clear_sending_gc(&mut self) {
        self.sending_gc = ::std::option::Option::None;
    }

    pub fn has_sending_gc(&self) -> bool {
        self.sending_gc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sending_gc(&mut self, v: u32) {
        self.sending_gc = ::std::option::Option::Some(v);
    }

    pub fn get_sending_gc(&self) -> u32 {
        self.sending_gc.unwrap_or(0)
    }

    fn get_sending_gc_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.sending_gc
    }

    fn mut_sending_gc_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.sending_gc
    }

    // optional fixed64 sender_id = 2;

    pub fn clear_sender_id(&mut self) {
        self.sender_id = ::std::option::Option::None;
    }

    pub fn has_sender_id(&self) -> bool {
        self.sender_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: u64) {
        self.sender_id = ::std::option::Option::Some(v);
    }

    pub fn get_sender_id(&self) -> u64 {
        self.sender_id.unwrap_or(0)
    }

    fn get_sender_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.sender_id
    }

    fn mut_sender_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.sender_id
    }

    // optional uint32 context = 3;

    pub fn clear_context(&mut self) {
        self.context = ::std::option::Option::None;
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: u32) {
        self.context = ::std::option::Option::Some(v);
    }

    pub fn get_context(&self) -> u32 {
        self.context.unwrap_or(0)
    }

    fn get_context_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.context
    }

    fn mut_context_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.context
    }

    // optional uint32 message_id = 4;

    pub fn clear_message_id(&mut self) {
        self.message_id = ::std::option::Option::None;
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: u32) {
        self.message_id = ::std::option::Option::Some(v);
    }

    pub fn get_message_id(&self) -> u32 {
        self.message_id.unwrap_or(0)
    }

    fn get_message_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.message_id
    }

    fn mut_message_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.message_id
    }

    // optional bytes message_body = 5;

    pub fn clear_message_body(&mut self) {
        self.message_body.clear();
    }

    pub fn has_message_body(&self) -> bool {
        self.message_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.message_body = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message_body.is_none() {
            self.message_body.set_default();
        }
        self.message_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_body(&mut self) -> ::std::vec::Vec<u8> {
        self.message_body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_message_body(&self) -> &[u8] {
        match self.message_body.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_message_body_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.message_body
    }

    fn mut_message_body_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.message_body
    }

    // optional fixed64 job_id_source = 6;

    pub fn clear_job_id_source(&mut self) {
        self.job_id_source = ::std::option::Option::None;
    }

    pub fn has_job_id_source(&self) -> bool {
        self.job_id_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_id_source(&mut self, v: u64) {
        self.job_id_source = ::std::option::Option::Some(v);
    }

    pub fn get_job_id_source(&self) -> u64 {
        self.job_id_source.unwrap_or(0)
    }

    fn get_job_id_source_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.job_id_source
    }

    fn mut_job_id_source_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.job_id_source
    }

    // optional fixed64 job_id_target = 7;

    pub fn clear_job_id_target(&mut self) {
        self.job_id_target = ::std::option::Option::None;
    }

    pub fn has_job_id_target(&self) -> bool {
        self.job_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_id_target(&mut self, v: u64) {
        self.job_id_target = ::std::option::Option::Some(v);
    }

    pub fn get_job_id_target(&self) -> u64 {
        self.job_id_target.unwrap_or(0)
    }

    fn get_job_id_target_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.job_id_target
    }

    fn mut_job_id_target_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.job_id_target
    }
}

impl ::protobuf::Message for CMsgGCToGCInternalTestMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sending_gc = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.sender_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.context = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.message_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.message_body)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.job_id_source = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.job_id_target = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sending_gc {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sender_id {
            my_size += 9;
        }
        if let Some(v) = self.context {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.message_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message_body.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.job_id_source {
            my_size += 9;
        }
        if let Some(v) = self.job_id_target {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sending_gc {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sender_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.context {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.message_id {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.message_body.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(v) = self.job_id_source {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.job_id_target {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCInternalTestMsg {
    fn new() -> CMsgGCToGCInternalTestMsg {
        CMsgGCToGCInternalTestMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCInternalTestMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sending_gc",
                    CMsgGCToGCInternalTestMsg::get_sending_gc_for_reflect,
                    CMsgGCToGCInternalTestMsg::mut_sending_gc_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "sender_id",
                    CMsgGCToGCInternalTestMsg::get_sender_id_for_reflect,
                    CMsgGCToGCInternalTestMsg::mut_sender_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "context",
                    CMsgGCToGCInternalTestMsg::get_context_for_reflect,
                    CMsgGCToGCInternalTestMsg::mut_context_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "message_id",
                    CMsgGCToGCInternalTestMsg::get_message_id_for_reflect,
                    CMsgGCToGCInternalTestMsg::mut_message_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "message_body",
                    CMsgGCToGCInternalTestMsg::get_message_body_for_reflect,
                    CMsgGCToGCInternalTestMsg::mut_message_body_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "job_id_source",
                    CMsgGCToGCInternalTestMsg::get_job_id_source_for_reflect,
                    CMsgGCToGCInternalTestMsg::mut_job_id_source_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "job_id_target",
                    CMsgGCToGCInternalTestMsg::get_job_id_target_for_reflect,
                    CMsgGCToGCInternalTestMsg::mut_job_id_target_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCInternalTestMsg>(
                    "CMsgGCToGCInternalTestMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCInternalTestMsg {
    fn clear(&mut self) {
        self.clear_sending_gc();
        self.clear_sender_id();
        self.clear_context();
        self.clear_message_id();
        self.clear_message_body();
        self.clear_job_id_source();
        self.clear_job_id_target();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCInternalTestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCInternalTestMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCClientServerVersionsUpdated {
    // message fields
    client_min_allowed_version: ::std::option::Option<u32>,
    client_active_version: ::std::option::Option<u32>,
    server_active_version: ::std::option::Option<u32>,
    server_deployed_version: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGCToGCClientServerVersionsUpdated {}

impl CMsgGCToGCClientServerVersionsUpdated {
    pub fn new() -> CMsgGCToGCClientServerVersionsUpdated {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGCToGCClientServerVersionsUpdated {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGCToGCClientServerVersionsUpdated> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGCToGCClientServerVersionsUpdated,
        };
        unsafe {
            instance.get(CMsgGCToGCClientServerVersionsUpdated::new)
        }
    }

    // optional uint32 client_min_allowed_version = 1;

    pub fn clear_client_min_allowed_version(&mut self) {
        self.client_min_allowed_version = ::std::option::Option::None;
    }

    pub fn has_client_min_allowed_version(&self) -> bool {
        self.client_min_allowed_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_min_allowed_version(&mut self, v: u32) {
        self.client_min_allowed_version = ::std::option::Option::Some(v);
    }

    pub fn get_client_min_allowed_version(&self) -> u32 {
        self.client_min_allowed_version.unwrap_or(0)
    }

    fn get_client_min_allowed_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.client_min_allowed_version
    }

    fn mut_client_min_allowed_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.client_min_allowed_version
    }

    // optional uint32 client_active_version = 2;

    pub fn clear_client_active_version(&mut self) {
        self.client_active_version = ::std::option::Option::None;
    }

    pub fn has_client_active_version(&self) -> bool {
        self.client_active_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_active_version(&mut self, v: u32) {
        self.client_active_version = ::std::option::Option::Some(v);
    }

    pub fn get_client_active_version(&self) -> u32 {
        self.client_active_version.unwrap_or(0)
    }

    fn get_client_active_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.client_active_version
    }

    fn mut_client_active_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.client_active_version
    }

    // optional uint32 server_active_version = 3;

    pub fn clear_server_active_version(&mut self) {
        self.server_active_version = ::std::option::Option::None;
    }

    pub fn has_server_active_version(&self) -> bool {
        self.server_active_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_active_version(&mut self, v: u32) {
        self.server_active_version = ::std::option::Option::Some(v);
    }

    pub fn get_server_active_version(&self) -> u32 {
        self.server_active_version.unwrap_or(0)
    }

    fn get_server_active_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_active_version
    }

    fn mut_server_active_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_active_version
    }

    // optional uint32 server_deployed_version = 4;

    pub fn clear_server_deployed_version(&mut self) {
        self.server_deployed_version = ::std::option::Option::None;
    }

    pub fn has_server_deployed_version(&self) -> bool {
        self.server_deployed_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_deployed_version(&mut self, v: u32) {
        self.server_deployed_version = ::std::option::Option::Some(v);
    }

    pub fn get_server_deployed_version(&self) -> u32 {
        self.server_deployed_version.unwrap_or(0)
    }

    fn get_server_deployed_version_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.server_deployed_version
    }

    fn mut_server_deployed_version_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.server_deployed_version
    }
}

impl ::protobuf::Message for CMsgGCToGCClientServerVersionsUpdated {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_min_allowed_version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_active_version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_active_version = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_deployed_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.client_min_allowed_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_active_version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_active_version {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_deployed_version {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.client_min_allowed_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.client_active_version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.server_active_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.server_deployed_version {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGCToGCClientServerVersionsUpdated {
    fn new() -> CMsgGCToGCClientServerVersionsUpdated {
        CMsgGCToGCClientServerVersionsUpdated::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGCToGCClientServerVersionsUpdated>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "client_min_allowed_version",
                    CMsgGCToGCClientServerVersionsUpdated::get_client_min_allowed_version_for_reflect,
                    CMsgGCToGCClientServerVersionsUpdated::mut_client_min_allowed_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "client_active_version",
                    CMsgGCToGCClientServerVersionsUpdated::get_client_active_version_for_reflect,
                    CMsgGCToGCClientServerVersionsUpdated::mut_client_active_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_active_version",
                    CMsgGCToGCClientServerVersionsUpdated::get_server_active_version_for_reflect,
                    CMsgGCToGCClientServerVersionsUpdated::mut_server_active_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_deployed_version",
                    CMsgGCToGCClientServerVersionsUpdated::get_server_deployed_version_for_reflect,
                    CMsgGCToGCClientServerVersionsUpdated::mut_server_deployed_version_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGCToGCClientServerVersionsUpdated>(
                    "CMsgGCToGCClientServerVersionsUpdated",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGCToGCClientServerVersionsUpdated {
    fn clear(&mut self) {
        self.clear_client_min_allowed_version();
        self.clear_client_active_version();
        self.clear_server_active_version();
        self.clear_server_deployed_version();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCClientServerVersionsUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCClientServerVersionsUpdated {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EGCItemMsg {
    k_EMsgGCBase = 1000,
    k_EMsgGCSetItemPosition = 1001,
    k_EMsgGCDelete = 1004,
    k_EMsgGCVerifyCacheSubscription = 1005,
    k_EMsgClientToGCNameItem = 1006,
    k_EMsgGCPaintItem = 1009,
    k_EMsgGCPaintItemResponse = 1010,
    k_EMsgGCGoldenWrenchBroadcast = 1011,
    k_EMsgGCMOTDRequest = 1012,
    k_EMsgGCMOTDRequestResponse = 1013,
    k_EMsgGCAddItemToSocket_DEPRECATED = 1014,
    k_EMsgGCAddItemToSocketResponse_DEPRECATED = 1015,
    k_EMsgGCAddSocketToBaseItem_DEPRECATED = 1016,
    k_EMsgGCAddSocketToItem_DEPRECATED = 1017,
    k_EMsgGCAddSocketToItemResponse_DEPRECATED = 1018,
    k_EMsgGCNameBaseItem = 1019,
    k_EMsgGCNameBaseItemResponse = 1020,
    k_EMsgGCRemoveSocketItem_DEPRECATED = 1021,
    k_EMsgGCRemoveSocketItemResponse_DEPRECATED = 1022,
    k_EMsgGCCustomizeItemTexture = 1023,
    k_EMsgGCCustomizeItemTextureResponse = 1024,
    k_EMsgGCUseItemRequest = 1025,
    k_EMsgGCUseItemResponse = 1026,
    k_EMsgGCGiftedItems = 1027,
    k_EMsgGCRemoveItemName = 1030,
    k_EMsgGCRemoveItemPaint = 1031,
    k_EMsgGCUnwrapGiftRequest = 1037,
    k_EMsgGCUnwrapGiftResponse = 1038,
    k_EMsgGCSetItemStyle_DEPRECATED = 1039,
    k_EMsgGCUsedClaimCodeItem = 1040,
    k_EMsgGCSortItems = 1041,
    k_EMsgGC_RevolvingLootList_DEPRECATED = 1042,
    k_EMsgGCUpdateItemSchema = 1049,
    k_EMsgGCRemoveCustomTexture = 1051,
    k_EMsgGCRemoveCustomTextureResponse = 1052,
    k_EMsgGCRemoveMakersMark = 1053,
    k_EMsgGCRemoveMakersMarkResponse = 1054,
    k_EMsgGCRemoveUniqueCraftIndex = 1055,
    k_EMsgGCRemoveUniqueCraftIndexResponse = 1056,
    k_EMsgGCSaxxyBroadcast = 1057,
    k_EMsgGCBackpackSortFinished = 1058,
    k_EMsgGCAdjustItemEquippedState = 1059,
    k_EMsgGCCollectItem = 1061,
    k_EMsgGCItemAcknowledged = 1062,
    k_EMsgGCPresets_SelectPresetForClass = 1063,
    k_EMsgGCPresets_SetItemPosition = 1064,
    k_EMsgGCPresets_SelectPresetForClassReply = 1067,
    k_EMsgClientToGCNameItemResponse = 1068,
    k_EMsgGCApplyConsumableEffects = 1069,
    k_EMsgGCConsumableExhausted = 1070,
    k_EMsgGCShowItemsPickedUp = 1071,
    k_EMsgGCClientDisplayNotification = 1072,
    k_EMsgGCApplyStrangePart = 1073,
    k_EMsgGC_IncrementKillCountResponse = 1075,
    k_EMsgGCApplyPennantUpgrade = 1076,
    k_EMsgGCSetItemPositions = 1077,
    k_EMsgGCSetItemPositions_RateLimited = 1096,
    k_EMsgGCApplyEggEssence = 1078,
    k_EMsgGCNameEggEssenceResponse = 1079,
    k_EMsgGCFulfillDynamicRecipeComponent = 1082,
    k_EMsgGCFulfillDynamicRecipeComponentResponse = 1083,
    k_EMsgGCClientRequestMarketData = 1084,
    k_EMsgGCClientRequestMarketDataResponse = 1085,
    k_EMsgGCExtractGems = 1086,
    k_EMsgGCAddSocket = 1087,
    k_EMsgGCAddItemToSocket = 1088,
    k_EMsgGCAddItemToSocketResponse = 1089,
    k_EMsgGCAddSocketResponse = 1090,
    k_EMsgGCResetStrangeGemCount = 1091,
    k_EMsgGCRequestCrateItems = 1092,
    k_EMsgGCRequestCrateItemsResponse = 1093,
    k_EMsgGCExtractGemsResponse = 1094,
    k_EMsgGCResetStrangeGemCountResponse = 1095,
    k_EMsgGCServerUseItemRequest = 1103,
    k_EMsgGCAddGiftItem = 1104,
    k_EMsgGCRemoveItemGiftMessage = 1105,
    k_EMsgGCRemoveItemGiftMessageResponse = 1106,
    k_EMsgGCRemoveItemGifterAccountId = 1107,
    k_EMsgGCRemoveItemGifterAccountIdResponse = 1108,
    k_EMsgClientToGCRemoveItemGifterAttributes = 1109,
    k_EMsgClientToGCRemoveItemName = 1110,
    k_EMsgClientToGCRemoveItemDescription = 1111,
    k_EMsgClientToGCRemoveItemAttributeResponse = 1112,
    k_EMsgGCTradingBase = 1500,
    k_EMsgGCTrading_InitiateTradeRequest = 1501,
    k_EMsgGCTrading_InitiateTradeResponse = 1502,
    k_EMsgGCTrading_StartSession = 1503,
    k_EMsgGCTrading_SessionClosed = 1509,
    k_EMsgGCTrading_InitiateTradeRequestResponse = 1514,
    k_EMsgGCServerBrowser_FavoriteServer = 1601,
    k_EMsgGCServerBrowser_BlacklistServer = 1602,
    k_EMsgGCServerRentalsBase = 1700,
    k_EMsgGCDev_NewItemRequest = 2001,
    k_EMsgGCDev_NewItemRequestResponse = 2002,
    k_EMsgGCStoreGetUserData = 2500,
    k_EMsgGCStoreGetUserDataResponse = 2501,
    k_EMsgGCStorePurchaseFinalize = 2504,
    k_EMsgGCStorePurchaseFinalizeResponse = 2505,
    k_EMsgGCStorePurchaseCancel = 2506,
    k_EMsgGCStorePurchaseCancelResponse = 2507,
    k_EMsgGCStorePurchaseInit = 2510,
    k_EMsgGCStorePurchaseInitResponse = 2511,
    k_EMsgGCBannedWordListRequest = 2512,
    k_EMsgGCBannedWordListResponse = 2513,
    k_EMsgGCToGCBannedWordListBroadcast = 2514,
    k_EMsgGCToGCBannedWordListUpdated = 2515,
    k_EMsgGCToGCDirtySDOCache = 2516,
    k_EMsgGCToGCDirtyMultipleSDOCache = 2517,
    k_EMsgGCToGCUpdateSQLKeyValue = 2518,
    k_EMsgGCToGCBroadcastConsoleCommand = 2521,
    k_EMsgGCServerVersionUpdated = 2522,
    k_EMsgGCApplyAutograph = 2523,
    k_EMsgGCToGCWebAPIAccountChanged = 2524,
    k_EMsgGCClientVersionUpdated = 2528,
    k_EMsgGCItemPurgatory_FinalizePurchase = 2531,
    k_EMsgGCItemPurgatory_FinalizePurchaseResponse = 2532,
    k_EMsgGCItemPurgatory_RefundPurchase = 2533,
    k_EMsgGCItemPurgatory_RefundPurchaseResponse = 2534,
    k_EMsgGCToGCPlayerStrangeCountAdjustments = 2535,
    k_EMsgGCRequestStoreSalesData = 2536,
    k_EMsgGCRequestStoreSalesDataResponse = 2537,
    k_EMsgGCRequestStoreSalesDataUpToDateResponse = 2538,
    k_EMsgGCToGCPingRequest = 2539,
    k_EMsgGCToGCPingResponse = 2540,
    k_EMsgGCToGCGetUserSessionServer = 2541,
    k_EMsgGCToGCGetUserSessionServerResponse = 2542,
    k_EMsgGCToGCGetUserServerMembers = 2543,
    k_EMsgGCToGCGetUserServerMembersResponse = 2544,
    k_EMsgGCToGCGetUserPCBangNo = 2545,
    k_EMsgGCToGCGetUserPCBangNoResponse = 2546,
    k_EMsgGCToGCCanUseDropRateBonus = 2547,
    k_EMsgSQLAddDropRateBonus = 2548,
    k_EMsgGCToGCRefreshSOCache = 2549,
    k_EMsgGCToGCApplyLocalizationDiff = 2550,
    k_EMsgGCToGCApplyLocalizationDiffResponse = 2551,
    k_EMsgGCToGCCheckAccountTradeStatus = 2552,
    k_EMsgGCToGCCheckAccountTradeStatusResponse = 2553,
    k_EMsgGCToGCGrantAccountRolledItems = 2554,
    k_EMsgGCToGCGrantSelfMadeItemToAccount = 2555,
    k_EMsgGCPartnerBalanceRequest = 2557,
    k_EMsgGCPartnerBalanceResponse = 2558,
    k_EMsgGCPartnerRechargeRedirectURLRequest = 2559,
    k_EMsgGCPartnerRechargeRedirectURLResponse = 2560,
    k_EMsgGCStatueCraft = 2561,
    k_EMsgGCRedeemCode = 2562,
    k_EMsgGCRedeemCodeResponse = 2563,
    k_EMsgGCToGCItemConsumptionRollback = 2564,
    k_EMsgClientToGCWrapAndDeliverGift = 2565,
    k_EMsgClientToGCWrapAndDeliverGiftResponse = 2566,
    k_EMsgClientToGCUnpackBundleResponse = 2567,
    k_EMsgGCToClientStoreTransactionCompleted = 2568,
    k_EMsgClientToGCEquipItems = 2569,
    k_EMsgClientToGCEquipItemsResponse = 2570,
    k_EMsgClientToGCUnlockItemStyle = 2571,
    k_EMsgClientToGCUnlockItemStyleResponse = 2572,
    k_EMsgClientToGCSetItemInventoryCategory = 2573,
    k_EMsgClientToGCUnlockCrate = 2574,
    k_EMsgClientToGCUnlockCrateResponse = 2575,
    k_EMsgClientToGCUnpackBundle = 2576,
    k_EMsgClientToGCSetItemStyle = 2577,
    k_EMsgClientToGCSetItemStyleResponse = 2578,
    k_EMsgSQLGCToGCGrantBackpackSlots = 2580,
    k_EMsgClientToGCLookupAccountName = 2581,
    k_EMsgClientToGCLookupAccountNameResponse = 2582,
    k_EMsgGCToGCDevRevokeUserItems = 2583,
    k_EMsgClientToGCCreateStaticRecipe = 2584,
    k_EMsgClientToGCCreateStaticRecipeResponse = 2585,
    k_EMsgGCToGCStoreProcessCDKeyTransaction = 2586,
    k_EMsgGCToGCStoreProcessCDKeyTransactionResponse = 2587,
    k_EMsgGCToGCStoreProcessSettlement = 2588,
    k_EMsgGCToGCStoreProcessSettlementResponse = 2589,
    k_EMsgGCToGCConsoleOutput = 2590,
    k_EMsgGCToClientItemAges = 2591,
    k_EMsgGCToGCInternalTestMsg = 2592,
    k_EMsgGCToGCClientServerVersionsUpdated = 2593,
    k_EMsgGCUseMultipleItemsRequest = 2594,
    k_EMsgGCCheckAccountSubscription = 2595,
    k_EMsgGCCheckAccountSubscriptionResponse = 2596,
}

impl ::protobuf::ProtobufEnum for EGCItemMsg {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCItemMsg> {
        match value {
            1000 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBase),
            1001 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemPosition),
            1004 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDelete),
            1005 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCVerifyCacheSubscription),
            1006 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCNameItem),
            1009 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItem),
            1010 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItemResponse),
            1011 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGoldenWrenchBroadcast),
            1012 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCMOTDRequest),
            1013 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCMOTDRequestResponse),
            1014 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddItemToSocket_DEPRECATED),
            1015 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddItemToSocketResponse_DEPRECATED),
            1016 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddSocketToBaseItem_DEPRECATED),
            1017 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddSocketToItem_DEPRECATED),
            1018 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddSocketToItemResponse_DEPRECATED),
            1019 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItem),
            1020 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItemResponse),
            1021 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveSocketItem_DEPRECATED),
            1022 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveSocketItemResponse_DEPRECATED),
            1023 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCustomizeItemTexture),
            1024 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCustomizeItemTextureResponse),
            1025 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemRequest),
            1026 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemResponse),
            1027 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGiftedItems),
            1030 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveItemName),
            1031 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveItemPaint),
            1037 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftRequest),
            1038 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftResponse),
            1039 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemStyle_DEPRECATED),
            1040 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUsedClaimCodeItem),
            1041 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSortItems),
            1042 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_RevolvingLootList_DEPRECATED),
            1049 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUpdateItemSchema),
            1051 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveCustomTexture),
            1052 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveCustomTextureResponse),
            1053 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveMakersMark),
            1054 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveMakersMarkResponse),
            1055 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndex),
            1056 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndexResponse),
            1057 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSaxxyBroadcast),
            1058 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBackpackSortFinished),
            1059 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAdjustItemEquippedState),
            1061 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCollectItem),
            1062 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemAcknowledged),
            1063 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPresets_SelectPresetForClass),
            1064 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPresets_SetItemPosition),
            1067 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPresets_SelectPresetForClassReply),
            1068 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCNameItemResponse),
            1069 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyConsumableEffects),
            1070 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCConsumableExhausted),
            1071 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCShowItemsPickedUp),
            1072 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientDisplayNotification),
            1073 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyStrangePart),
            1075 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_IncrementKillCountResponse),
            1076 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyPennantUpgrade),
            1077 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemPositions),
            1096 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemPositions_RateLimited),
            1078 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyEggEssence),
            1079 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameEggEssenceResponse),
            1082 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponent),
            1083 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponentResponse),
            1084 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientRequestMarketData),
            1085 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientRequestMarketDataResponse),
            1086 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCExtractGems),
            1087 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddSocket),
            1088 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddItemToSocket),
            1089 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddItemToSocketResponse),
            1090 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddSocketResponse),
            1091 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCResetStrangeGemCount),
            1092 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateItems),
            1093 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestCrateItemsResponse),
            1094 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCExtractGemsResponse),
            1095 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCResetStrangeGemCountResponse),
            1103 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerUseItemRequest),
            1104 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAddGiftItem),
            1105 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveItemGiftMessage),
            1106 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveItemGiftMessageResponse),
            1107 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveItemGifterAccountId),
            1108 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveItemGifterAccountIdResponse),
            1109 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemGifterAttributes),
            1110 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemName),
            1111 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemDescription),
            1112 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCRemoveItemAttributeResponse),
            1500 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTradingBase),
            1501 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequest),
            1502 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_InitiateTradeResponse),
            1503 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_StartSession),
            1509 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_SessionClosed),
            1514 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequestResponse),
            1601 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerBrowser_FavoriteServer),
            1602 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerBrowser_BlacklistServer),
            1700 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerRentalsBase),
            2001 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequest),
            2002 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequestResponse),
            2500 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStoreGetUserData),
            2501 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStoreGetUserDataResponse),
            2504 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalize),
            2505 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse),
            2506 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancel),
            2507 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse),
            2510 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInit),
            2511 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInitResponse),
            2512 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBannedWordListRequest),
            2513 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBannedWordListResponse),
            2514 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBannedWordListBroadcast),
            2515 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBannedWordListUpdated),
            2516 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCDirtySDOCache),
            2517 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCDirtyMultipleSDOCache),
            2518 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue),
            2521 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand),
            2522 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerVersionUpdated),
            2523 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyAutograph),
            2524 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged),
            2528 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientVersionUpdated),
            2531 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchase),
            2532 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchaseResponse),
            2533 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchase),
            2534 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchaseResponse),
            2535 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPlayerStrangeCountAdjustments),
            2536 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesData),
            2537 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse),
            2538 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse),
            2539 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingRequest),
            2540 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingResponse),
            2541 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServer),
            2542 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse),
            2543 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembers),
            2544 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse),
            2545 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserPCBangNo),
            2546 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserPCBangNoResponse),
            2547 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCCanUseDropRateBonus),
            2548 => ::std::option::Option::Some(EGCItemMsg::k_EMsgSQLAddDropRateBonus),
            2549 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCRefreshSOCache),
            2550 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCApplyLocalizationDiff),
            2551 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCApplyLocalizationDiffResponse),
            2552 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCCheckAccountTradeStatus),
            2553 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCCheckAccountTradeStatusResponse),
            2554 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGrantAccountRolledItems),
            2555 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount),
            2557 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPartnerBalanceRequest),
            2558 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPartnerBalanceResponse),
            2559 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPartnerRechargeRedirectURLRequest),
            2560 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPartnerRechargeRedirectURLResponse),
            2561 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStatueCraft),
            2562 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRedeemCode),
            2563 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRedeemCodeResponse),
            2564 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCItemConsumptionRollback),
            2565 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGift),
            2566 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGiftResponse),
            2567 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnpackBundleResponse),
            2568 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToClientStoreTransactionCompleted),
            2569 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCEquipItems),
            2570 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCEquipItemsResponse),
            2571 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockItemStyle),
            2572 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockItemStyleResponse),
            2573 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCSetItemInventoryCategory),
            2574 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockCrate),
            2575 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnlockCrateResponse),
            2576 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCUnpackBundle),
            2577 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCSetItemStyle),
            2578 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCSetItemStyleResponse),
            2580 => ::std::option::Option::Some(EGCItemMsg::k_EMsgSQLGCToGCGrantBackpackSlots),
            2581 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCLookupAccountName),
            2582 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCLookupAccountNameResponse),
            2583 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCDevRevokeUserItems),
            2584 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCCreateStaticRecipe),
            2585 => ::std::option::Option::Some(EGCItemMsg::k_EMsgClientToGCCreateStaticRecipeResponse),
            2586 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransaction),
            2587 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransactionResponse),
            2588 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessSettlement),
            2589 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCStoreProcessSettlementResponse),
            2590 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCConsoleOutput),
            2591 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToClientItemAges),
            2592 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCInternalTestMsg),
            2593 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCClientServerVersionsUpdated),
            2594 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseMultipleItemsRequest),
            2595 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCheckAccountSubscription),
            2596 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCheckAccountSubscriptionResponse),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EGCItemMsg] = &[
            EGCItemMsg::k_EMsgGCBase,
            EGCItemMsg::k_EMsgGCSetItemPosition,
            EGCItemMsg::k_EMsgGCDelete,
            EGCItemMsg::k_EMsgGCVerifyCacheSubscription,
            EGCItemMsg::k_EMsgClientToGCNameItem,
            EGCItemMsg::k_EMsgGCPaintItem,
            EGCItemMsg::k_EMsgGCPaintItemResponse,
            EGCItemMsg::k_EMsgGCGoldenWrenchBroadcast,
            EGCItemMsg::k_EMsgGCMOTDRequest,
            EGCItemMsg::k_EMsgGCMOTDRequestResponse,
            EGCItemMsg::k_EMsgGCAddItemToSocket_DEPRECATED,
            EGCItemMsg::k_EMsgGCAddItemToSocketResponse_DEPRECATED,
            EGCItemMsg::k_EMsgGCAddSocketToBaseItem_DEPRECATED,
            EGCItemMsg::k_EMsgGCAddSocketToItem_DEPRECATED,
            EGCItemMsg::k_EMsgGCAddSocketToItemResponse_DEPRECATED,
            EGCItemMsg::k_EMsgGCNameBaseItem,
            EGCItemMsg::k_EMsgGCNameBaseItemResponse,
            EGCItemMsg::k_EMsgGCRemoveSocketItem_DEPRECATED,
            EGCItemMsg::k_EMsgGCRemoveSocketItemResponse_DEPRECATED,
            EGCItemMsg::k_EMsgGCCustomizeItemTexture,
            EGCItemMsg::k_EMsgGCCustomizeItemTextureResponse,
            EGCItemMsg::k_EMsgGCUseItemRequest,
            EGCItemMsg::k_EMsgGCUseItemResponse,
            EGCItemMsg::k_EMsgGCGiftedItems,
            EGCItemMsg::k_EMsgGCRemoveItemName,
            EGCItemMsg::k_EMsgGCRemoveItemPaint,
            EGCItemMsg::k_EMsgGCUnwrapGiftRequest,
            EGCItemMsg::k_EMsgGCUnwrapGiftResponse,
            EGCItemMsg::k_EMsgGCSetItemStyle_DEPRECATED,
            EGCItemMsg::k_EMsgGCUsedClaimCodeItem,
            EGCItemMsg::k_EMsgGCSortItems,
            EGCItemMsg::k_EMsgGC_RevolvingLootList_DEPRECATED,
            EGCItemMsg::k_EMsgGCUpdateItemSchema,
            EGCItemMsg::k_EMsgGCRemoveCustomTexture,
            EGCItemMsg::k_EMsgGCRemoveCustomTextureResponse,
            EGCItemMsg::k_EMsgGCRemoveMakersMark,
            EGCItemMsg::k_EMsgGCRemoveMakersMarkResponse,
            EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndex,
            EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndexResponse,
            EGCItemMsg::k_EMsgGCSaxxyBroadcast,
            EGCItemMsg::k_EMsgGCBackpackSortFinished,
            EGCItemMsg::k_EMsgGCAdjustItemEquippedState,
            EGCItemMsg::k_EMsgGCCollectItem,
            EGCItemMsg::k_EMsgGCItemAcknowledged,
            EGCItemMsg::k_EMsgGCPresets_SelectPresetForClass,
            EGCItemMsg::k_EMsgGCPresets_SetItemPosition,
            EGCItemMsg::k_EMsgGCPresets_SelectPresetForClassReply,
            EGCItemMsg::k_EMsgClientToGCNameItemResponse,
            EGCItemMsg::k_EMsgGCApplyConsumableEffects,
            EGCItemMsg::k_EMsgGCConsumableExhausted,
            EGCItemMsg::k_EMsgGCShowItemsPickedUp,
            EGCItemMsg::k_EMsgGCClientDisplayNotification,
            EGCItemMsg::k_EMsgGCApplyStrangePart,
            EGCItemMsg::k_EMsgGC_IncrementKillCountResponse,
            EGCItemMsg::k_EMsgGCApplyPennantUpgrade,
            EGCItemMsg::k_EMsgGCSetItemPositions,
            EGCItemMsg::k_EMsgGCSetItemPositions_RateLimited,
            EGCItemMsg::k_EMsgGCApplyEggEssence,
            EGCItemMsg::k_EMsgGCNameEggEssenceResponse,
            EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponent,
            EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponentResponse,
            EGCItemMsg::k_EMsgGCClientRequestMarketData,
            EGCItemMsg::k_EMsgGCClientRequestMarketDataResponse,
            EGCItemMsg::k_EMsgGCExtractGems,
            EGCItemMsg::k_EMsgGCAddSocket,
            EGCItemMsg::k_EMsgGCAddItemToSocket,
            EGCItemMsg::k_EMsgGCAddItemToSocketResponse,
            EGCItemMsg::k_EMsgGCAddSocketResponse,
            EGCItemMsg::k_EMsgGCResetStrangeGemCount,
            EGCItemMsg::k_EMsgGCRequestCrateItems,
            EGCItemMsg::k_EMsgGCRequestCrateItemsResponse,
            EGCItemMsg::k_EMsgGCExtractGemsResponse,
            EGCItemMsg::k_EMsgGCResetStrangeGemCountResponse,
            EGCItemMsg::k_EMsgGCServerUseItemRequest,
            EGCItemMsg::k_EMsgGCAddGiftItem,
            EGCItemMsg::k_EMsgGCRemoveItemGiftMessage,
            EGCItemMsg::k_EMsgGCRemoveItemGiftMessageResponse,
            EGCItemMsg::k_EMsgGCRemoveItemGifterAccountId,
            EGCItemMsg::k_EMsgGCRemoveItemGifterAccountIdResponse,
            EGCItemMsg::k_EMsgClientToGCRemoveItemGifterAttributes,
            EGCItemMsg::k_EMsgClientToGCRemoveItemName,
            EGCItemMsg::k_EMsgClientToGCRemoveItemDescription,
            EGCItemMsg::k_EMsgClientToGCRemoveItemAttributeResponse,
            EGCItemMsg::k_EMsgGCTradingBase,
            EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequest,
            EGCItemMsg::k_EMsgGCTrading_InitiateTradeResponse,
            EGCItemMsg::k_EMsgGCTrading_StartSession,
            EGCItemMsg::k_EMsgGCTrading_SessionClosed,
            EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequestResponse,
            EGCItemMsg::k_EMsgGCServerBrowser_FavoriteServer,
            EGCItemMsg::k_EMsgGCServerBrowser_BlacklistServer,
            EGCItemMsg::k_EMsgGCServerRentalsBase,
            EGCItemMsg::k_EMsgGCDev_NewItemRequest,
            EGCItemMsg::k_EMsgGCDev_NewItemRequestResponse,
            EGCItemMsg::k_EMsgGCStoreGetUserData,
            EGCItemMsg::k_EMsgGCStoreGetUserDataResponse,
            EGCItemMsg::k_EMsgGCStorePurchaseFinalize,
            EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse,
            EGCItemMsg::k_EMsgGCStorePurchaseCancel,
            EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse,
            EGCItemMsg::k_EMsgGCStorePurchaseInit,
            EGCItemMsg::k_EMsgGCStorePurchaseInitResponse,
            EGCItemMsg::k_EMsgGCBannedWordListRequest,
            EGCItemMsg::k_EMsgGCBannedWordListResponse,
            EGCItemMsg::k_EMsgGCToGCBannedWordListBroadcast,
            EGCItemMsg::k_EMsgGCToGCBannedWordListUpdated,
            EGCItemMsg::k_EMsgGCToGCDirtySDOCache,
            EGCItemMsg::k_EMsgGCToGCDirtyMultipleSDOCache,
            EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue,
            EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand,
            EGCItemMsg::k_EMsgGCServerVersionUpdated,
            EGCItemMsg::k_EMsgGCApplyAutograph,
            EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged,
            EGCItemMsg::k_EMsgGCClientVersionUpdated,
            EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchase,
            EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchaseResponse,
            EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchase,
            EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchaseResponse,
            EGCItemMsg::k_EMsgGCToGCPlayerStrangeCountAdjustments,
            EGCItemMsg::k_EMsgGCRequestStoreSalesData,
            EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse,
            EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse,
            EGCItemMsg::k_EMsgGCToGCPingRequest,
            EGCItemMsg::k_EMsgGCToGCPingResponse,
            EGCItemMsg::k_EMsgGCToGCGetUserSessionServer,
            EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse,
            EGCItemMsg::k_EMsgGCToGCGetUserServerMembers,
            EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse,
            EGCItemMsg::k_EMsgGCToGCGetUserPCBangNo,
            EGCItemMsg::k_EMsgGCToGCGetUserPCBangNoResponse,
            EGCItemMsg::k_EMsgGCToGCCanUseDropRateBonus,
            EGCItemMsg::k_EMsgSQLAddDropRateBonus,
            EGCItemMsg::k_EMsgGCToGCRefreshSOCache,
            EGCItemMsg::k_EMsgGCToGCApplyLocalizationDiff,
            EGCItemMsg::k_EMsgGCToGCApplyLocalizationDiffResponse,
            EGCItemMsg::k_EMsgGCToGCCheckAccountTradeStatus,
            EGCItemMsg::k_EMsgGCToGCCheckAccountTradeStatusResponse,
            EGCItemMsg::k_EMsgGCToGCGrantAccountRolledItems,
            EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount,
            EGCItemMsg::k_EMsgGCPartnerBalanceRequest,
            EGCItemMsg::k_EMsgGCPartnerBalanceResponse,
            EGCItemMsg::k_EMsgGCPartnerRechargeRedirectURLRequest,
            EGCItemMsg::k_EMsgGCPartnerRechargeRedirectURLResponse,
            EGCItemMsg::k_EMsgGCStatueCraft,
            EGCItemMsg::k_EMsgGCRedeemCode,
            EGCItemMsg::k_EMsgGCRedeemCodeResponse,
            EGCItemMsg::k_EMsgGCToGCItemConsumptionRollback,
            EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGift,
            EGCItemMsg::k_EMsgClientToGCWrapAndDeliverGiftResponse,
            EGCItemMsg::k_EMsgClientToGCUnpackBundleResponse,
            EGCItemMsg::k_EMsgGCToClientStoreTransactionCompleted,
            EGCItemMsg::k_EMsgClientToGCEquipItems,
            EGCItemMsg::k_EMsgClientToGCEquipItemsResponse,
            EGCItemMsg::k_EMsgClientToGCUnlockItemStyle,
            EGCItemMsg::k_EMsgClientToGCUnlockItemStyleResponse,
            EGCItemMsg::k_EMsgClientToGCSetItemInventoryCategory,
            EGCItemMsg::k_EMsgClientToGCUnlockCrate,
            EGCItemMsg::k_EMsgClientToGCUnlockCrateResponse,
            EGCItemMsg::k_EMsgClientToGCUnpackBundle,
            EGCItemMsg::k_EMsgClientToGCSetItemStyle,
            EGCItemMsg::k_EMsgClientToGCSetItemStyleResponse,
            EGCItemMsg::k_EMsgSQLGCToGCGrantBackpackSlots,
            EGCItemMsg::k_EMsgClientToGCLookupAccountName,
            EGCItemMsg::k_EMsgClientToGCLookupAccountNameResponse,
            EGCItemMsg::k_EMsgGCToGCDevRevokeUserItems,
            EGCItemMsg::k_EMsgClientToGCCreateStaticRecipe,
            EGCItemMsg::k_EMsgClientToGCCreateStaticRecipeResponse,
            EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransaction,
            EGCItemMsg::k_EMsgGCToGCStoreProcessCDKeyTransactionResponse,
            EGCItemMsg::k_EMsgGCToGCStoreProcessSettlement,
            EGCItemMsg::k_EMsgGCToGCStoreProcessSettlementResponse,
            EGCItemMsg::k_EMsgGCToGCConsoleOutput,
            EGCItemMsg::k_EMsgGCToClientItemAges,
            EGCItemMsg::k_EMsgGCToGCInternalTestMsg,
            EGCItemMsg::k_EMsgGCToGCClientServerVersionsUpdated,
            EGCItemMsg::k_EMsgGCUseMultipleItemsRequest,
            EGCItemMsg::k_EMsgGCCheckAccountSubscription,
            EGCItemMsg::k_EMsgGCCheckAccountSubscriptionResponse,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EGCItemMsg>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EGCItemMsg", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EGCItemMsg {
}

impl ::protobuf::reflect::ProtobufValue for EGCItemMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EItemPurgatoryResponse_Finalize {
    k_ItemPurgatoryResponse_Finalize_Succeeded = 0,
    k_ItemPurgatoryResponse_Finalize_Failed_Incomplete = 1,
    k_ItemPurgatoryResponse_Finalize_Failed_ItemsNotInPurgatory = 2,
    k_ItemPurgatoryResponse_Finalize_Failed_CouldNotFindItems = 3,
    k_ItemPurgatoryResponse_Finalize_Failed_NoSOCache = 4,
    k_ItemPurgatoryResponse_Finalize_BackpackFull = 5,
}

impl ::protobuf::ProtobufEnum for EItemPurgatoryResponse_Finalize {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EItemPurgatoryResponse_Finalize> {
        match value {
            0 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Succeeded),
            1 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_Incomplete),
            2 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_ItemsNotInPurgatory),
            3 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_CouldNotFindItems),
            4 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_NoSOCache),
            5 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_BackpackFull),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EItemPurgatoryResponse_Finalize] = &[
            EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Succeeded,
            EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_Incomplete,
            EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_ItemsNotInPurgatory,
            EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_CouldNotFindItems,
            EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_NoSOCache,
            EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_BackpackFull,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EItemPurgatoryResponse_Finalize>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EItemPurgatoryResponse_Finalize", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EItemPurgatoryResponse_Finalize {
}

impl ::protobuf::reflect::ProtobufValue for EItemPurgatoryResponse_Finalize {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EItemPurgatoryResponse_Refund {
    k_ItemPurgatoryResponse_Refund_Succeeded = 0,
    k_ItemPurgatoryResponse_Refund_Failed_ItemNotInPurgatory = 1,
    k_ItemPurgatoryResponse_Refund_Failed_CouldNotFindItem = 2,
    k_ItemPurgatoryResponse_Refund_Failed_NoSOCache = 3,
    k_ItemPurgatoryResponse_Refund_Failed_NoDetail = 4,
    k_ItemPurgatoryResponse_Refund_Failed_NexonWebAPI = 5,
}

impl ::protobuf::ProtobufEnum for EItemPurgatoryResponse_Refund {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EItemPurgatoryResponse_Refund> {
        match value {
            0 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Succeeded),
            1 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_ItemNotInPurgatory),
            2 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_CouldNotFindItem),
            3 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoSOCache),
            4 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoDetail),
            5 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NexonWebAPI),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EItemPurgatoryResponse_Refund] = &[
            EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Succeeded,
            EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_ItemNotInPurgatory,
            EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_CouldNotFindItem,
            EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoSOCache,
            EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoDetail,
            EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NexonWebAPI,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EItemPurgatoryResponse_Refund>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EItemPurgatoryResponse_Refund", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EItemPurgatoryResponse_Refund {
}

impl ::protobuf::reflect::ProtobufValue for EItemPurgatoryResponse_Refund {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EGCMsgInitiateTradeResponse {
    k_EGCMsgInitiateTradeResponse_Accepted = 0,
    k_EGCMsgInitiateTradeResponse_Declined = 1,
    k_EGCMsgInitiateTradeResponse_VAC_Banned_Initiator = 2,
    k_EGCMsgInitiateTradeResponse_VAC_Banned_Target = 3,
    k_EGCMsgInitiateTradeResponse_Target_Already_Trading = 4,
    k_EGCMsgInitiateTradeResponse_Disabled = 5,
    k_EGCMsgInitiateTradeResponse_NotLoggedIn = 6,
    k_EGCMsgInitiateTradeResponse_Cancel = 7,
    k_EGCMsgInitiateTradeResponse_TooSoon = 8,
    k_EGCMsgInitiateTradeResponse_TooSoonPenalty = 9,
    k_EGCMsgInitiateTradeResponse_Trade_Banned_Initiator = 10,
    k_EGCMsgInitiateTradeResponse_Trade_Banned_Target = 11,
    k_EGCMsgInitiateTradeResponse_Free_Account_Initiator_DEPRECATED = 12,
    k_EGCMsgInitiateTradeResponse_Shared_Account_Initiator = 13,
    k_EGCMsgInitiateTradeResponse_Service_Unavailable = 14,
    k_EGCMsgInitiateTradeResponse_Target_Blocked = 15,
    k_EGCMsgInitiateTradeResponse_NeedVerifiedEmail = 16,
    k_EGCMsgInitiateTradeResponse_NeedSteamGuard = 17,
    k_EGCMsgInitiateTradeResponse_SteamGuardDuration = 18,
    k_EGCMsgInitiateTradeResponse_TheyCannotTrade = 19,
    k_EGCMsgInitiateTradeResponse_Recent_Password_Reset = 20,
    k_EGCMsgInitiateTradeResponse_Using_New_Device = 21,
    k_EGCMsgInitiateTradeResponse_Sent_Invalid_Cookie = 22,
    k_EGCMsgInitiateTradeResponse_TooRecentFriend = 23,
    k_EGCMsgInitiateTradeResponse_WalledFundsNotTrusted = 24,
}

impl ::protobuf::ProtobufEnum for EGCMsgInitiateTradeResponse {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCMsgInitiateTradeResponse> {
        match value {
            0 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted),
            1 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Declined),
            2 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_VAC_Banned_Initiator),
            3 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_VAC_Banned_Target),
            4 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Target_Already_Trading),
            5 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Disabled),
            6 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NotLoggedIn),
            7 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Cancel),
            8 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooSoon),
            9 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooSoonPenalty),
            10 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Trade_Banned_Initiator),
            11 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Trade_Banned_Target),
            12 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Free_Account_Initiator_DEPRECATED),
            13 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Shared_Account_Initiator),
            14 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Service_Unavailable),
            15 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Target_Blocked),
            16 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NeedVerifiedEmail),
            17 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NeedSteamGuard),
            18 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_SteamGuardDuration),
            19 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TheyCannotTrade),
            20 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Recent_Password_Reset),
            21 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Using_New_Device),
            22 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Sent_Invalid_Cookie),
            23 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooRecentFriend),
            24 => ::std::option::Option::Some(EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_WalledFundsNotTrusted),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EGCMsgInitiateTradeResponse] = &[
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Accepted,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Declined,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_VAC_Banned_Initiator,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_VAC_Banned_Target,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Target_Already_Trading,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Disabled,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NotLoggedIn,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Cancel,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooSoon,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooSoonPenalty,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Trade_Banned_Initiator,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Trade_Banned_Target,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Free_Account_Initiator_DEPRECATED,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Shared_Account_Initiator,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Service_Unavailable,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Target_Blocked,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NeedVerifiedEmail,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_NeedSteamGuard,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_SteamGuardDuration,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TheyCannotTrade,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Recent_Password_Reset,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Using_New_Device,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_Sent_Invalid_Cookie,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_TooRecentFriend,
            EGCMsgInitiateTradeResponse::k_EGCMsgInitiateTradeResponse_WalledFundsNotTrusted,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EGCMsgInitiateTradeResponse>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EGCMsgInitiateTradeResponse", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EGCMsgInitiateTradeResponse {
}

impl ::protobuf::reflect::ProtobufValue for EGCMsgInitiateTradeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15econ_gcmessages.proto\x1a\x13steammessages.proto\x1a\x17econ_share\
    d_enums.proto\"b\n\x12CMsgApplyAutograph\x12*\n\x11autograph_item_id\x18\
    \x01\x20\x01(\x04R\x0fautographItemId\x12\x20\n\x0citem_item_id\x18\x02\
    \x20\x01(\x04R\nitemItemId\"\x8f\x01\n\x1bCMsgAdjustItemEquippedState\
    \x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06itemId\x12\x1b\n\tnew_cla\
    ss\x18\x02\x20\x01(\rR\x08newClass\x12\x19\n\x08new_slot\x18\x03\x20\x01\
    (\rR\x07newSlot\x12\x1f\n\x0bstyle_index\x18\x04\x20\x01(\rR\nstyleIndex\
    \"\xb3\x02\n$CMsgEconPlayerStrangeCountAdjustment\x12\x1d\n\naccount_id\
    \x18\x01\x20\x01(\rR\taccountId\x12y\n\x19strange_count_adjustments\x18\
    \x02\x20\x03(\x0b2=.CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAd\
    justmentR\x17strangeCountAdjustments\x1aq\n\x17CStrangeCountAdjustment\
    \x12\x1d\n\nevent_type\x18\x01\x20\x01(\rR\teventType\x12\x17\n\x07item_\
    id\x18\x02\x20\x01(\x04R\x06itemId\x12\x1e\n\nadjustment\x18\x03\x20\x01\
    (\rR\nadjustment\"F\n)CMsgRequestItemPurgatory_FinalizePurchase\x12\x19\
    \n\x08item_ids\x18\x01\x20\x03(\x04R\x07itemIds\"f\n1CMsgRequestItemPurg\
    atory_FinalizePurchaseResponse\x12\x16\n\x06result\x18\x01\x20\x01(\rR\
    \x06result\x12\x19\n\x08item_ids\x18\x02\x20\x03(\x04R\x07itemIds\"D\n'C\
    MsgRequestItemPurgatory_RefundPurchase\x12\x19\n\x08item_ids\x18\x01\x20\
    \x03(\x04R\x07itemIds\"I\n/CMsgRequestItemPurgatory_RefundPurchaseRespon\
    se\x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06result\"1\n\x14CMsgCraftin\
    gResponse\x12\x19\n\x08item_ids\x18\x01\x20\x03(\x04R\x07itemIds\"S\n\
    \x1bCMsgGCRequestStoreSalesData\x12\x18\n\x07version\x18\x01\x20\x01(\rR\
    \x07version\x12\x1a\n\x08currency\x18\x02\x20\x01(\rR\x08currency\"\xed\
    \x01\n#CMsgGCRequestStoreSalesDataResponse\x12I\n\nsale_price\x18\x01\
    \x20\x03(\x0b2*.CMsgGCRequestStoreSalesDataResponse.PriceR\tsalePrice\
    \x12\x18\n\x07version\x18\x02\x20\x01(\rR\x07version\x12'\n\x0fexpiratio\
    n_time\x18\x03\x20\x01(\rR\x0eexpirationTime\x1a8\n\x05Price\x12\x19\n\
    \x08item_def\x18\x01\x20\x01(\rR\x07itemDef\x12\x14\n\x05price\x18\x02\
    \x20\x01(\rR\x05price\"p\n+CMsgGCRequestStoreSalesDataUpToDateResponse\
    \x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12'\n\x0fexpiratio\
    n_time\x18\x02\x20\x01(\rR\x0eexpirationTime\"\x17\n\x15CMsgGCToGCPingRe\
    quest\"\x18\n\x16CMsgGCToGCPingResponse\"?\n\x1eCMsgGCToGCGetUserSession\
    Server\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\"m\n&CMsgGCT\
    oGCGetUserSessionServerResponse\x12&\n\x0fserver_steam_id\x18\x01\x20\
    \x01(\x06R\rserverSteamId\x12\x1b\n\tis_online\x18\x02\x20\x01(\x08R\x08\
    isOnline\"f\n\x1eCMsgGCToGCGetUserServerMembers\x12\x1d\n\naccount_id\
    \x18\x01\x20\x01(\rR\taccountId\x12%\n\x0emax_spectators\x18\x02\x20\x01\
    (\rR\rmaxSpectators\"T\n&CMsgGCToGCGetUserServerMembersResponse\x12*\n\
    \x11member_account_id\x18\x01\x20\x03(\rR\x0fmemberAccountId\"D\n\x1eCMs\
    gLookupMultipleAccountNames\x12\"\n\naccountids\x18\x01\x20\x03(\rR\nacc\
    ountidsB\x02\x10\x01\"\xb8\x01\n&CMsgLookupMultipleAccountNamesResponse\
    \x12K\n\x08accounts\x18\x01\x20\x03(\x0b2/.CMsgLookupMultipleAccountName\
    sResponse.AccountR\x08accounts\x1aA\n\x07Account\x12\x1c\n\taccountid\
    \x18\x01\x20\x01(\rR\taccountid\x12\x18\n\x07persona\x18\x02\x20\x01(\tR\
    \x07persona\":\n\x19CMsgGCToGCGetUserPCBangNo\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\"A\n!CMsgGCToGCGetUserPCBangNoResponse\x12\
    \x1c\n\npc_bang_no\x18\x01\x20\x01(\rR\x08pcBangNo\"=\n\x15CMsgRequestCr\
    ateItems\x12$\n\x0ecrate_item_def\x18\x01\x20\x01(\rR\x0ccrateItemDef\"\
    \xa6\x01\n\x1dCMsgRequestCrateItemsResponse\x12\x1a\n\x08response\x18\
    \x01\x20\x01(\rR\x08response\x12\x1b\n\titem_defs\x18\x02\x20\x03(\rR\
    \x08itemDefs\x12\"\n\rpeek_item_def\x18\x03\x20\x01(\rR\x0bpeekItemDef\"\
    (\n\x07EResult\x12\x0f\n\x0bk_Succeeded\x10\0\x12\x0c\n\x08k_Failed\x10\
    \x01\"\xe1\x01\n\x1dCMsgGCToGCCanUseDropRateBonus\x12\x1d\n\naccount_id\
    \x18\x01\x20\x01(\rR\taccountId\x12&\n\x0fdrop_rate_bonus\x18\x02\x20\
    \x01(\x02R\rdropRateBonus\x12!\n\x0cbooster_type\x18\x03\x20\x01(\rR\x0b\
    boosterType\x12,\n\x12exclusive_item_def\x18\x04\x20\x01(\rR\x10exclusiv\
    eItemDef\x12(\n\x10allow_equal_rate\x18\x05\x20\x01(\x08R\x0eallowEqualR\
    ate\"\x88\x02\n\x17CMsgSQLAddDropRateBonus\x12\x1d\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountId\x12\x17\n\x07item_id\x18\x02\x20\x01(\x04R\x06it\
    emId\x12\x19\n\x08item_def\x18\x03\x20\x01(\rR\x07itemDef\x12&\n\x0fdrop\
    _rate_bonus\x18\x04\x20\x01(\x02R\rdropRateBonus\x12!\n\x0cbooster_type\
    \x18\x05\x20\x01(\rR\x0bboosterType\x12)\n\x10seconds_duration\x18\x06\
    \x20\x01(\rR\x0fsecondsDuration\x12$\n\x0eend_time_stamp\x18\x07\x20\x01\
    (\rR\x0cendTimeStamp\"\x9c\x01\n\x1bCMsgSQLUpgradeBattleBooster\x12\x1d\
    \n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x19\n\x08item_def\x18\
    \x02\x20\x01(\rR\x07itemDef\x12\x20\n\x0cbonus_to_add\x18\x03\x20\x01(\
    \x02R\nbonusToAdd\x12!\n\x0cbooster_type\x18\x04\x20\x01(\rR\x0bboosterT\
    ype\"Q\n\x18CMsgGCToGCRefreshSOCache\x12\x1d\n\naccount_id\x18\x01\x20\
    \x01(\rR\taccountId\x12\x16\n\x06reload\x18\x02\x20\x01(\x08R\x06reload\
    \"`\n!CMsgGCToGCCheckAccountTradeStatus\x12\x1d\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountId\x12\x1c\n\tinitiator\x18\x02\x20\x01(\x08R\tinit\
    iator\"g\n)CMsgGCToGCCheckAccountTradeStatusResponse\x12\x1b\n\tcan_trad\
    e\x18\x01\x20\x01(\x08R\x08canTrade\x12\x1d\n\nerror_code\x18\x02\x20\
    \x01(\rR\terrorCode\"\xbc\x06\n!CMsgGCToGCGrantAccountRolledItems\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12=\n\x05items\x18\
    \x02\x20\x03(\x0b2'.CMsgGCToGCGrantAccountRolledItems.ItemR\x05items\x12\
    !\n\x0caudit_action\x18\x03\x20\x01(\rR\x0bauditAction\x12\x1d\n\naudit_\
    data\x18\x04\x20\x01(\x04R\tauditData\x1a\xf6\x04\n\x04Item\x12\x19\n\
    \x08item_def\x18\x01\x20\x01(\rR\x07itemDef\x12\x1d\n\nloot_lists\x18\
    \x02\x20\x03(\tR\tlootLists\x12!\n\x0cignore_limit\x18\x03\x20\x01(\x08R\
    \x0bignoreLimit\x12\x16\n\x06origin\x18\x04\x20\x01(\rR\x06origin\x12g\n\
    \x12dynamic_attributes\x18\x05\x20\x03(\x0b28.CMsgGCToGCGrantAccountRoll\
    edItems.Item.DynamicAttributeR\x11dynamicAttributes\x12v\n\x18additional\
    _audit_entries\x18\x06\x20\x03(\x0b2<.CMsgGCToGCGrantAccountRolledItems.\
    Item.AdditionalAuditEntryR\x16additionalAuditEntries\x12'\n\x0finventory\
    _token\x18\x07\x20\x01(\rR\x0einventoryToken\x1aj\n\x10DynamicAttribute\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12!\n\x0cvalue_uint32\
    \x18\x02\x20\x01(\rR\x0bvalueUint32\x12\x1f\n\x0bvalue_float\x18\x03\x20\
    \x01(\x02R\nvalueFloat\x1a\x82\x01\n\x14AdditionalAuditEntry\x12(\n\x10o\
    wner_account_id\x18\x01\x20\x01(\rR\x0eownerAccountId\x12!\n\x0caudit_ac\
    tion\x18\x02\x20\x01(\rR\x0bauditAction\x12\x1d\n\naudit_data\x18\x03\
    \x20\x01(\x04R\tauditData\"j\n$CMsgGCToGCGrantSelfMadeItemToAccount\x12$\
    \n\x0eitem_def_index\x18\x01\x20\x01(\rR\x0citemDefIndex\x12\x1c\n\tacco\
    untid\x18\x02\x20\x01(\rR\taccountid\"\x97\x02\n\x0bCMsgUseItem\x12\x17\
    \n\x07item_id\x18\x01\x20\x01(\x04R\x06itemId\x12&\n\x0ftarget_steam_id\
    \x18\x02\x20\x01(\x06R\rtargetSteamId\x125\n\x17gift__potential_targets\
    \x18\x03\x20\x03(\rR\x14giftPotentialTargets\x12'\n\x10duel__class_lock\
    \x18\x04\x20\x01(\rR\rduelClassLock\x12,\n\x12initiator_steam_id\x18\x05\
    \x20\x01(\x04R\x10initiatorSteamId\x129\n\x19itempack__ack_immediately\
    \x18\x06\x20\x01(\x08R\x16itempackAckImmediately\"u\n\x11CMsgServerUseIt\
    em\x120\n\x14initiator_account_id\x18\x01\x20\x01(\rR\x12initiatorAccoun\
    tId\x12.\n\x0cuse_item_msg\x18\x02\x20\x01(\x0b2\x0c.CMsgUseItemR\nuseIt\
    emMsg\"1\n\x14CMsgUseMultipleItems\x12\x19\n\x08item_ids\x18\x01\x20\x03\
    (\x04R\x07itemIds\"\x1d\n\x1bCMsgGCPartnerBalanceRequest\"\x81\x01\n\x1c\
    CMsgGCPartnerBalanceResponse\x12G\n\x06result\x18\x01\x20\x01(\x0e2\x1a.\
    EGCPartnerRequestResponse:\x13k_EPartnerRequestOKR\x06result\x12\x18\n\
    \x07balance\x18\x02\x20\x01(\rR\x07balance\"_\n!CGCStoreRechargeRedirect\
    _LineItem\x12\x1e\n\x0bitem_def_id\x18\x01\x20\x01(\rR\titemDefId\x12\
    \x1a\n\x08quantity\x18\x02\x20\x01(\rR\x08quantity\"l\n'CMsgGCPartnerRec\
    hargeRedirectURLRequest\x12A\n\nline_items\x18\x01\x20\x03(\x0b2\".CGCSt\
    oreRechargeRedirect_LineItemR\tlineItems\"\x85\x01\n(CMsgGCPartnerRechar\
    geRedirectURLResponse\x12G\n\x06result\x18\x01\x20\x01(\x0e2\x1a.EGCPart\
    nerRequestResponse:\x13k_EPartnerRequestOKR\x06result\x12\x10\n\x03url\
    \x18\x02\x20\x01(\tR\x03url\"r\n)CMsgGCEconSQLWorkItemEmbeddedRollbackDa\
    ta\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12&\n\x0fdelete\
    d_item_id\x18\x02\x20\x01(\x04R\rdeletedItemId\"\xc8\x01\n\x0fCMsgCraftS\
    tatue\x12\x16\n\x06heroid\x18\x01\x20\x01(\rR\x06heroid\x12\"\n\x0cseque\
    ncename\x18\x02\x20\x01(\tR\x0csequencename\x12\x14\n\x05cycle\x18\x03\
    \x20\x01(\x02R\x05cycle\x12\x20\n\x0bdescription\x18\x04\x20\x01(\tR\x0b\
    description\x12)\n\x10pedestal_itemdef\x18\x05\x20\x01(\rR\x0fpedestalIt\
    emdef\x12\x16\n\x06toolid\x18\x06\x20\x01(\x04R\x06toolid\"$\n\x0eCMsgRe\
    deemCode\x12\x12\n\x04code\x18\x01\x20\x01(\tR\x04code\"\xbf\x01\n\x16CM\
    sgRedeemCodeResponse\x12\x1a\n\x08response\x18\x01\x20\x01(\rR\x08respon\
    se\x12\x17\n\x07item_id\x18\x02\x20\x01(\x04R\x06itemId\"p\n\x0bEResultC\
    ode\x12\x0f\n\x0bk_Succeeded\x10\0\x12\x19\n\x15k_Failed_CodeNotFound\
    \x10\x01\x12\x1c\n\x18k_Failed_CodeAlreadyUsed\x10\x02\x12\x17\n\x13k_Fa\
    iled_OtherError\x10\x03\"\xa4\x01\n\x15CMsgDevNewItemRequest\x12\"\n\rit\
    em_def_name\x18\x03\x20\x01(\tR\x0bitemDefName\x12$\n\x0eloot_list_name\
    \x18\x04\x20\x01(\tR\x0clootListName\x12\"\n\rattr_def_name\x18\x05\x20\
    \x03(\tR\x0battrDefName\x12\x1d\n\nattr_value\x18\x06\x20\x03(\tR\tattrV\
    alue\"9\n\x1dCMsgDevNewItemRequestResponse\x12\x18\n\x07success\x18\x01\
    \x20\x01(\x08R\x07success\"\\\n\x1eCMsgGCCheckAccountSubscription\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1b\n\tdef_index\
    \x18\x02\x20\x01(\rR\x08defIndex\"\xf9\x01\n&CMsgGCCheckAccountSubscript\
    ionResponse\x12_\n\x05state\x18\x01\x20\x01(\x0e2:.CMsgGCCheckAccountSub\
    scriptionResponse.ESubscriptionState:\rSTATE_UNKNOWNR\x05state\x12\x1f\n\
    \x0bcache_until\x18\x02\x20\x01(\rR\ncacheUntil\"M\n\x12ESubscriptionSta\
    te\x12\x11\n\rSTATE_UNKNOWN\x10\0\x12\x12\n\x0eSTATE_INACTIVE\x10\x01\
    \x12\x10\n\x0cSTATE_ACTIVE\x10\x02\"K\n\x11CMsgGCAddGiftItem\x12\x1d\n\n\
    account_id\x18\x01\x20\x01(\rR\taccountId\x12\x17\n\x07item_id\x18\x02\
    \x20\x01(\x04R\x06itemId\"\x8b\x01\n\x20CMsgClientToGCWrapAndDeliverGift\
    \x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06itemId\x12+\n\x12give_to_\
    account_id\x18\x02\x20\x01(\rR\x0fgiveToAccountId\x12!\n\x0cgift_message\
    \x18\x03\x20\x01(\tR\x0bgiftMessage\"\xb2\x03\n(CMsgClientToGCWrapAndDel\
    iverGiftResponse\x12?\n\x08response\x18\x01\x20\x01(\x0e2\x0f.EGCMsgResp\
    onse:\x12k_EGCMsgResponseOKR\x08response\x12.\n\x13gifting_charge_uses\
    \x18\x02\x20\x01(\rR\x11giftingChargeUses\x12,\n\x12gifting_charge_max\
    \x18\x03\x20\x01(\x05R\x10giftingChargeMax\x12!\n\x0cgifting_uses\x18\
    \x04\x20\x01(\rR\x0bgiftingUses\x12\x1f\n\x0bgifting_max\x18\x05\x20\x01\
    (\x05R\ngiftingMax\x120\n\x14gifting_window_hours\x18\x06\x20\x01(\rR\
    \x12giftingWindowHours\x12q\n\x11trade_restriction\x18\x07\x20\x01(\x0e2\
    \x1c.EGCMsgInitiateTradeResponse:&k_EGCMsgInitiateTradeResponse_Accepted\
    R\x10tradeRestriction\"3\n\x18CMsgClientToGCUnwrapGift\x12\x17\n\x07item\
    _id\x18\x01\x20\x01(\x04R\x06itemId\"\"\n\x20CMsgClientToGCGetGiftPermis\
    sions\"\xfb\x04\n(CMsgClientToGCGetGiftPermissionsResponse\x12!\n\x0cis_\
    unlimited\x18\x01\x20\x01(\x08R\x0bisUnlimited\x12$\n\x0ehas_two_factor\
    \x18\x03\x20\x01(\x08R\x0chasTwoFactor\x12q\n\x11sender_permission\x18\
    \x06\x20\x01(\x0e2\x1c.EGCMsgInitiateTradeResponse:&k_EGCMsgInitiateTrad\
    eResponse_AcceptedR\x10senderPermission\x12<\n\x1afriendship_age_require\
    ment\x18\x07\x20\x01(\rR\x18friendshipAgeRequirement\x12P\n%friendship_a\
    ge_requirement_two_factor\x18\x08\x20\x01(\rR!friendshipAgeRequirementTw\
    oFactor\x12i\n\x12friend_permissions\x18\t\x20\x03(\x0b2:.CMsgClientToGC\
    GetGiftPermissionsResponse.FriendPermissionR\x11friendPermissions\x1a\
    \x97\x01\n\x10FriendPermission\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\
    \taccountId\x12d\n\npermission\x18\x02\x20\x01(\x0e2\x1c.EGCMsgInitiateT\
    radeResponse:&k_EGCMsgInitiateTradeResponse_AcceptedR\npermission\"5\n\
    \x1aCMsgClientToGCUnpackBundle\x12\x17\n\x07item_id\x18\x01\x20\x01(\x04\
    R\x06itemId\"\xf5\x03\n\"CMsgClientToGCUnpackBundleResponse\x12*\n\x11un\
    packed_item_ids\x18\x01\x20\x03(\x04R\x0funpackedItemIds\x12g\n\x08respo\
    nse\x18\x02\x20\x01(\x0e21.CMsgClientToGCUnpackBundleResponse.EUnpackBun\
    dle:\x18k_UnpackBundle_SucceededR\x08response\"\xb9\x02\n\rEUnpackBundle\
    \x12\x1c\n\x18k_UnpackBundle_Succeeded\x10\0\x12)\n%k_UnpackBundle_Faile\
    d_ItemIsNotBundle\x10\x01\x125\n1k_UnpackBundle_Failed_UnableToCreateCon\
    tainedItem\x10\x02\x12&\n\"k_UnpackBundle_Failed_SOCacheError\x10\x03\
    \x12'\n#k_UnpackBundle_Failed_ItemIsInvalid\x10\x04\x12)\n%k_UnpackBundl\
    e_Failed_BadItemQuantity\x10\x05\x12,\n(k_UnpackBundle_Failed_UnableToDe\
    leteItem\x10\x06\"[\n'CMsgGCToClientStoreTransactionCompleted\x12\x15\n\
    \x06txn_id\x18\x01\x20\x01(\x04R\x05txnId\x12\x19\n\x08item_ids\x18\x02\
    \x20\x03(\x04R\x07itemIds\"P\n\x18CMsgClientToGCEquipItems\x124\n\x06equ\
    ips\x18\x01\x20\x03(\x0b2\x1c.CMsgAdjustItemEquippedStateR\x06equips\"Q\
    \n\x20CMsgClientToGCEquipItemsResponse\x12-\n\x13so_cache_version_id\x18\
    \x01\x20\x01(\x06R\x10soCacheVersionId\"V\n\x1aCMsgClientToGCSetItemStyl\
    e\x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06itemId\x12\x1f\n\x0bstyl\
    e_index\x18\x02\x20\x01(\rR\nstyleIndex\"\xe8\x01\n\"CMsgClientToGCSetIt\
    emStyleResponse\x12_\n\x08response\x18\x01\x20\x01(\x0e2-.CMsgClientToGC\
    SetItemStyleResponse.ESetStyle:\x14k_SetStyle_SucceededR\x08response\"a\
    \n\tESetStyle\x12\x18\n\x14k_SetStyle_Succeeded\x10\0\x12\x15\n\x11k_Set\
    Style_Failed\x10\x01\x12#\n\x1fk_SetStyle_Failed_StyleIsLocked\x10\x02\"\
    \x96\x01\n\x1dCMsgClientToGCUnlockItemStyle\x12$\n\x0eitem_to_unlock\x18\
    \x01\x20\x01(\x04R\x0citemToUnlock\x12\x1f\n\x0bstyle_index\x18\x02\x20\
    \x01(\rR\nstyleIndex\x12.\n\x13consumable_item_ids\x18\x03\x20\x03(\x04R\
    \x11consumableItemIds\"\xcd\x05\n%CMsgClientToGCUnlockItemStyleResponse\
    \x12h\n\x08response\x18\x01\x20\x01(\x0e23.CMsgClientToGCUnlockItemStyle\
    Response.EUnlockStyle:\x17k_UnlockStyle_SucceededR\x08response\x12\x17\n\
    \x07item_id\x18\x02\x20\x01(\x04R\x06itemId\x12\x1f\n\x0bstyle_index\x18\
    \x03\x20\x01(\rR\nstyleIndex\x12!\n\x0cstyle_prereq\x18\x04\x20\x01(\rR\
    \x0bstylePrereq\"\xdc\x03\n\x0cEUnlockStyle\x12\x1b\n\x17k_UnlockStyle_S\
    ucceeded\x10\0\x12\x1f\n\x1bk_UnlockStyle_Failed_PreReq\x10\x01\x12#\n\
    \x1fk_UnlockStyle_Failed_CantAfford\x10\x02\x12#\n\x1fk_UnlockStyle_Fail\
    ed_CantCommit\x10\x03\x12&\n\"k_UnlockStyle_Failed_CantLockCache\x10\x04\
    \x12)\n%k_UnlockStyle_Failed_CantAffordAttrib\x10\x05\x12&\n\"k_UnlockSt\
    yle_Failed_CantAffordGem\x10\x06\x12*\n&k_UnlockStyle_Failed_NoCompendiu\
    mLevel\x10\x07\x12(\n$k_UnlockStyle_Failed_AlreadyUnlocked\x10\x08\x12#\
    \n\x1fk_UnlockStyle_Failed_OtherError\x10\t\x12&\n\"k_UnlockStyle_Failed\
    _ItemIsInvalid\x10\n\x12&\n\"k_UnlockStyle_Failed_ToolIsInvalid\x10\x0b\
    \"\xb9\x01\n&CMsgClientToGCSetItemInventoryCategory\x12\x19\n\x08item_id\
    s\x18\x01\x20\x03(\x04R\x07itemIds\x12\x20\n\x0cset_to_value\x18\x02\x20\
    \x01(\rR\nsetToValue\x12+\n\x11remove_categories\x18\x03\x20\x01(\rR\x10\
    removeCategories\x12%\n\x0eadd_categories\x18\x04\x20\x01(\rR\raddCatego\
    ries\"_\n\x19CMsgClientToGCUnlockCrate\x12\"\n\rcrate_item_id\x18\x01\
    \x20\x01(\x04R\x0bcrateItemId\x12\x1e\n\x0bkey_item_id\x18\x02\x20\x01(\
    \x04R\tkeyItemId\"\xec\x01\n!CMsgClientToGCUnlockCrateResponse\x12;\n\
    \x06result\x18\x01\x20\x01(\x0e2\x0f.EGCMsgResponse:\x12k_EGCMsgResponse\
    OKR\x06result\x12L\n\rgranted_items\x18\x02\x20\x03(\x0b2'.CMsgClientToG\
    CUnlockCrateResponse.ItemR\x0cgrantedItems\x1a<\n\x04Item\x12\x17\n\x07i\
    tem_id\x18\x01\x20\x01(\x04R\x06itemId\x12\x1b\n\tdef_index\x18\x02\x20\
    \x01(\rR\x08defIndex\"<\n!CMsgClientToGCRemoveItemAttribute\x12\x17\n\
    \x07item_id\x18\x01\x20\x01(\x04R\x06itemId\"\xc4\x03\n)CMsgClientToGCRe\
    moveItemAttributeResponse\x12|\n\x08response\x18\x01\x20\x01(\x0e2?.CMsg\
    ClientToGCRemoveItemAttributeResponse.ERemoveItemAttribute:\x1fk_RemoveI\
    temAttribute_SucceededR\x08response\x12\x17\n\x07item_id\x18\x02\x20\x01\
    (\x04R\x06itemId\"\xff\x01\n\x14ERemoveItemAttribute\x12#\n\x1fk_RemoveI\
    temAttribute_Succeeded\x10\0\x12\x20\n\x1ck_RemoveItemAttribute_Failed\
    \x10\x01\x12.\n*k_RemoveItemAttribute_Failed_ItemIsInvalid\x10\x02\x129\
    \n5k_RemoveItemAttribute_Failed_AttributeCannotBeRemoved\x10\x03\x125\n1\
    k_RemoveItemAttribute_Failed_AttributeDoesntExist\x10\x04\"v\n\x16CMsgCl\
    ientToGCNameItem\x12&\n\x0fsubject_item_id\x18\x01\x20\x01(\x04R\rsubjec\
    tItemId\x12\x20\n\x0ctool_item_id\x18\x02\x20\x01(\x04R\ntoolItemId\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\"\xc4\x02\n\x1eCMsgClientToGC\
    NameItemResponse\x12[\n\x08response\x18\x01\x20\x01(\x0e2).CMsgClientToG\
    CNameItemResponse.ENameItem:\x14k_NameItem_SucceededR\x08response\x12\
    \x17\n\x07item_id\x18\x02\x20\x01(\x04R\x06itemId\"\xab\x01\n\tENameItem\
    \x12\x18\n\x14k_NameItem_Succeeded\x10\0\x12\x15\n\x11k_NameItem_Failed\
    \x10\x01\x12#\n\x1fk_NameItem_Failed_ToolIsInvalid\x10\x02\x12#\n\x1fk_N\
    ameItem_Failed_ItemIsInvalid\x10\x03\x12#\n\x1fk_NameItem_Failed_NameIsI\
    nvalid\x10\x04\"S\n\x15CMsgGCSetItemPosition\x12\x17\n\x07item_id\x18\
    \x01\x20\x01(\x04R\x06itemId\x12!\n\x0cnew_position\x18\x02\x20\x01(\rR\
    \x0bnewPosition\"\xe2\x02\n%CAttribute_ItemDynamicRecipeComponent\x12\
    \x19\n\x08item_def\x18\x01\x20\x01(\rR\x07itemDef\x12!\n\x0citem_quality\
    \x18\x02\x20\x01(\rR\x0bitemQuality\x12\x1d\n\nitem_flags\x18\x03\x20\
    \x01(\rR\titemFlags\x12+\n\x11attributes_string\x18\x04\x20\x01(\tR\x10a\
    ttributesString\x12\x1d\n\nitem_count\x18\x05\x20\x01(\rR\titemCount\x12\
    '\n\x0fitems_fulfilled\x18\x06\x20\x01(\rR\x0eitemsFulfilled\x12\x1f\n\
    \x0bitem_rarity\x18\x07\x20\x01(\rR\nitemRarity\x12\x1a\n\x08lootlist\
    \x18\x08\x20\x01(\tR\x08lootlist\x12*\n\x11fulfilled_item_id\x18\t\x20\
    \x01(\x04R\x0ffulfilledItemId\"\x90\x02\n\x10CProtoItemSocket\x12\x17\n\
    \x07item_id\x18\x01\x20\x01(\x04R\x06itemId\x12$\n\x0eattr_def_index\x18\
    \x02\x20\x01(\rR\x0cattrDefIndex\x12#\n\rrequired_type\x18\x03\x20\x01(\
    \rR\x0crequiredType\x12#\n\rrequired_hero\x18\x04\x20\x01(\tR\x0crequire\
    dHero\x12\"\n\rgem_def_index\x18\x05\x20\x01(\rR\x0bgemDefIndex\x12!\n\
    \x0cnot_tradable\x18\x06\x20\x01(\x08R\x0bnotTradable\x12,\n\x12required\
    _item_slot\x18\x07\x20\x01(\tR\x10requiredItemSlot\"C\n\x16CProtoItemSoc\
    ket_Empty\x12)\n\x06socket\x18\x01\x20\x01(\x0b2\x11.CProtoItemSocketR\
    \x06socket\"\\\n\x17CProtoItemSocket_Effect\x12)\n\x06socket\x18\x01\x20\
    \x01(\x0b2\x11.CProtoItemSocketR\x06socket\x12\x16\n\x06effect\x18\x02\
    \x20\x01(\rR\x06effect\"\x7f\n\x16CProtoItemSocket_Color\x12)\n\x06socke\
    t\x18\x01\x20\x01(\x0b2\x11.CProtoItemSocketR\x06socket\x12\x10\n\x03red\
    \x18\x02\x20\x01(\rR\x03red\x12\x14\n\x05green\x18\x03\x20\x01(\rR\x05gr\
    een\x12\x12\n\x04blue\x18\x04\x20\x01(\rR\x04blue\"\x8d\x01\n\x18CProtoI\
    temSocket_Strange\x12)\n\x06socket\x18\x01\x20\x01(\x0b2\x11.CProtoItemS\
    ocketR\x06socket\x12!\n\x0cstrange_type\x18\x02\x20\x01(\rR\x0bstrangeTy\
    pe\x12#\n\rstrange_value\x18\x03\x20\x01(\rR\x0cstrangeValue\"\xc7\x01\n\
    \x1aCProtoItemSocket_Spectator\x12)\n\x06socket\x18\x01\x20\x01(\x0b2\
    \x11.CProtoItemSocketR\x06socket\x12!\n\x0cgames_viewed\x18\x02\x20\x01(\
    \rR\x0bgamesViewed\x12%\n\x0ecorporation_id\x18\x03\x20\x01(\rR\rcorpora\
    tionId\x12\x1b\n\tleague_id\x18\x04\x20\x01(\rR\x08leagueId\x12\x17\n\
    \x07team_id\x18\x05\x20\x01(\rR\x06teamId\"r\n\x1eCProtoItemSocket_Asset\
    Modifier\x12)\n\x06socket\x18\x01\x20\x01(\x0b2\x11.CProtoItemSocketR\
    \x06socket\x12%\n\x0easset_modifier\x18\x02\x20\x01(\rR\rassetModifier\"\
    \xdb\x01\n;CProtoItemSocket_AssetModifier_DESERIALIZE_FROM_STRING_ONLY\
    \x12)\n\x06socket\x18\x01\x20\x01(\x0b2\x11.CProtoItemSocketR\x06socket\
    \x12%\n\x0easset_modifier\x18\x02\x20\x01(\rR\rassetModifier\x12#\n\rani\
    m_modifier\x18\x03\x20\x01(\rR\x0canimModifier\x12%\n\x0eability_effect\
    \x18\x04\x20\x01(\rR\rabilityEffect\"\xb1\x01\n\x1aCProtoItemSocket_Auto\
    graph\x12)\n\x06socket\x18\x01\x20\x01(\x0b2\x11.CProtoItemSocketR\x06so\
    cket\x12\x1c\n\tautograph\x18\x02\x20\x01(\tR\tautograph\x12!\n\x0cautog\
    raph_id\x18\x03\x20\x01(\rR\x0bautographId\x12'\n\x0fautograph_score\x18\
    \x04\x20\x01(\rR\x0eautographScore\"K\n\x1eCProtoItemSocket_StaticVisual\
    s\x12)\n\x06socket\x18\x01\x20\x01(\x0b2\x11.CProtoItemSocketR\x06socket\
    \")\n\x11CAttribute_String\x12\x14\n\x05value\x18\x01\x20\x01(\tR\x05val\
    ue\"\x90\x01\n%CWorkshop_GetItemDailyRevenue_Request\x12\x14\n\x05appid\
    \x18\x01\x20\x01(\rR\x05appid\x12\x17\n\x07item_id\x18\x02\x20\x01(\rR\
    \x06itemId\x12\x1d\n\ndate_start\x18\x03\x20\x01(\rR\tdateStart\x12\x19\
    \n\x08date_end\x18\x04\x20\x01(\rR\x07dateEnd\"\x94\x02\n&CWorkshop_GetI\
    temDailyRevenue_Response\x12d\n\x0fcountry_revenue\x18\x01\x20\x03(\x0b2\
    ;.CWorkshop_GetItemDailyRevenue_Response.CountryDailyRevenueR\x0ecountry\
    Revenue\x1a\x83\x01\n\x13CountryDailyRevenue\x12!\n\x0ccountry_code\x18\
    \x01\x20\x01(\tR\x0bcountryCode\x12\x12\n\x04date\x18\x02\x20\x01(\rR\
    \x04date\x12\x1f\n\x0brevenue_usd\x18\x03\x20\x01(\x03R\nrevenueUsd\x12\
    \x14\n\x05units\x18\x04\x20\x01(\x05R\x05units\"\x82\x01\n(CWorkshop_Get\
    PackageDailyRevenue_Request\x12\x1c\n\tpackageid\x18\x01\x20\x01(\rR\tpa\
    ckageid\x12\x1d\n\ndate_start\x18\x02\x20\x01(\rR\tdateStart\x12\x19\n\
    \x08date_end\x18\x03\x20\x01(\rR\x07dateEnd\"\x9a\x02\n)CWorkshop_GetPac\
    kageDailyRevenue_Response\x12g\n\x0fcountry_revenue\x18\x01\x20\x03(\x0b\
    2>.CWorkshop_GetPackageDailyRevenue_Response.CountryDailyRevenueR\x0ecou\
    ntryRevenue\x1a\x83\x01\n\x13CountryDailyRevenue\x12!\n\x0ccountry_code\
    \x18\x01\x20\x01(\tR\x0bcountryCode\x12\x12\n\x04date\x18\x02\x20\x01(\r\
    R\x04date\x12\x1f\n\x0brevenue_usd\x18\x03\x20\x01(\x03R\nrevenueUsd\x12\
    \x14\n\x05units\x18\x04\x20\x01(\x05R\x05units\"]\n\x1fCMsgSQLGCToGCGran\
    tBackpackSlots\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\
    \x1b\n\tadd_slots\x18\x02\x20\x01(\rR\x08addSlots\"@\n\x1fCMsgClientToGC\
    LookupAccountName\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\"\
    k\n'CMsgClientToGCLookupAccountNameResponse\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12!\n\x0caccount_name\x18\x02\x20\x01(\tR\
    \x0baccountName\"\xc4\x01\n\x20CMsgClientToGCCreateStaticRecipe\x12<\n\
    \x05items\x18\x01\x20\x03(\x0b2&.CMsgClientToGCCreateStaticRecipe.ItemR\
    \x05items\x12(\n\x10recipe_def_index\x18\x02\x20\x01(\rR\x0erecipeDefInd\
    ex\x1a8\n\x04Item\x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06itemId\
    \x12\x17\n\x07slot_id\x18\x02\x20\x01(\rR\x06slotId\"\xec\x06\n(CMsgClie\
    ntToGCCreateStaticRecipeResponse\x12b\n\x08response\x18\x01\x20\x01(\x0e\
    23.CMsgClientToGCCreateStaticRecipeResponse.EResponse:\x11eResponse_Succ\
    essR\x08response\x12W\n\x0coutput_items\x18\x02\x20\x03(\x0b24.CMsgClien\
    tToGCCreateStaticRecipeResponse.OutputItemR\x0boutputItems\x12W\n\x0cinp\
    ut_errors\x18\x03\x20\x03(\x0b24.CMsgClientToGCCreateStaticRecipeRespons\
    e.InputErrorR\x0binputErrors\x12i\n\x12additional_outputs\x18\x04\x20\
    \x03(\x0b2:.CMsgClientToGCCreateStaticRecipeResponse.AdditionalOutputR\
    \x11additionalOutputs\x1a[\n\nOutputItem\x12\x1b\n\tdef_index\x18\x01\
    \x20\x01(\rR\x08defIndex\x12\x17\n\x07item_id\x18\x02\x20\x01(\x04R\x06i\
    temId\x12\x17\n\x07slot_id\x18\x03\x20\x01(\rR\x06slotId\x1a\x83\x01\n\n\
    InputError\x12\x17\n\x07slot_id\x18\x01\x20\x01(\rR\x06slotId\x12\\\n\
    \x05error\x18\x02\x20\x01(\x0e23.CMsgClientToGCCreateStaticRecipeRespons\
    e.EResponse:\x11eResponse_SuccessR\x05error\x1aA\n\x10AdditionalOutput\
    \x12\x17\n\x07slot_id\x18\x01\x20\x01(\rR\x06slotId\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x04R\x05value\"\x98\x01\n\tEResponse\x12\x15\n\x11eRes\
    ponse_Success\x10\0\x12\x1e\n\x1aeResponse_OfferingDisabled\x10\x01\x12\
    \x1a\n\x16eResponse_InvalidItems\x10\x02\x12\x1b\n\x17eResponse_Internal\
    Error\x10\x03\x12\x1b\n\x17eResponse_MissingLeague\x10\x04\"\xc7\x05\n\
    \x1bCMsgProcessTransactionOrder\x12\x15\n\x06txn_id\x18\x01\x20\x01(\x04\
    R\x05txnId\x12\x20\n\x0csteam_txn_id\x18\x02\x20\x01(\x04R\nsteamTxnId\
    \x12$\n\x0epartner_txn_id\x18\x03\x20\x01(\x04R\x0cpartnerTxnId\x12\x19\
    \n\x08steam_id\x18\x04\x20\x01(\x06R\x07steamId\x12\x1d\n\ntime_stamp\
    \x18\x05\x20\x01(\rR\ttimeStamp\x12\x1c\n\twatermark\x18\x06\x20\x01(\
    \x04R\twatermark\x124\n\x16purchase_report_status\x18\x07\x20\x01(\x05R\
    \x14purchaseReportStatus\x12\x1a\n\x08currency\x18\x08\x20\x01(\rR\x08cu\
    rrency\x127\n\x05items\x18\t\x20\x03(\x0b2!.CMsgProcessTransactionOrder.\
    ItemR\x05items\x1a\xe5\x02\n\x04Item\x12$\n\x0eitem_def_index\x18\x01\
    \x20\x01(\rR\x0citemDefIndex\x12\x1d\n\nitem_price\x18\x02\x20\x01(\rR\t\
    itemPrice\x12\x1a\n\x08quantity\x18\x03\x20\x01(\rR\x08quantity\x12#\n\r\
    category_desc\x18\x04\x20\x01(\tR\x0ccategoryDesc\x12.\n\x13store_purcha\
    se_type\x18\x05\x20\x01(\rR\x11storePurchaseType\x12.\n\x13source_refere\
    nce_id\x18\x06\x20\x01(\x04R\x11sourceReferenceId\x12,\n\x12parent_stack\
    _index\x18\x07\x20\x01(\x05R\x10parentStackIndex\x12#\n\rdefault_price\
    \x18\x08\x20\x01(\x08R\x0cdefaultPrice\x12$\n\x0eis_user_facing\x18\t\
    \x20\x01(\x08R\x0cisUserFacing\"}\n&CMsgGCToGCStoreProcessCDKeyTransacti\
    on\x122\n\x05order\x18\x01\x20\x01(\x0b2\x1c.CMsgProcessTransactionOrder\
    R\x05order\x12\x1f\n\x0breason_code\x18\x02\x20\x01(\rR\nreasonCode\"J\n\
    .CMsgGCToGCStoreProcessCDKeyTransactionResponse\x12\x18\n\x07success\x18\
    \x01\x20\x01(\x08R\x07success\"p\n\x20CMsgGCToGCStoreProcessSettlement\
    \x122\n\x05order\x18\x01\x20\x01(\x0b2\x1c.CMsgProcessTransactionOrderR\
    \x05order\x12\x18\n\x07partner\x18\x02\x20\x01(\rR\x07partner\"D\n(CMsgG\
    CToGCStoreProcessSettlementResponse\x12\x18\n\x07success\x18\x01\x20\x01\
    (\x08R\x07success\"\xb3\x01\n!CMsgGCToGCBroadcastConsoleCommand\x12\x1f\
    \n\x0bcon_command\x18\x01\x20\x01(\tR\nconCommand\x12#\n\rreport_output\
    \x18\x02\x20\x01(\x08R\x0creportOutput\x12\x1d\n\nsending_gc\x18\x03\x20\
    \x01(\rR\tsendingGc\x12)\n\x10output_initiator\x18\x04\x20\x01(\tR\x0fou\
    tputInitiator\"\xd0\x01\n\x17CMsgGCToGCConsoleOutput\x12\x1c\n\tinitiato\
    r\x18\x01\x20\x01(\tR\tinitiator\x12\x1d\n\nsending_gc\x18\x02\x20\x01(\
    \rR\tsendingGc\x127\n\x04msgs\x18\x03\x20\x03(\x0b2#.CMsgGCToGCConsoleOu\
    tput.OutputLineR\x04msgs\x1a?\n\nOutputLine\x12\x12\n\x04text\x18\x01\
    \x20\x01(\tR\x04text\x12\x1d\n\nspew_level\x18\x02\x20\x01(\rR\tspewLeve\
    l\"\xb9\x01\n\x0cCMsgItemAges\x12U\n\x16max_item_id_timestamps\x18\x01\
    \x20\x03(\x0b2\x20.CMsgItemAges.MaxItemIDTimestampR\x13maxItemIdTimestam\
    ps\x1aR\n\x12MaxItemIDTimestamp\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\rR\
    \ttimestamp\x12\x1e\n\x0bmax_item_id\x18\x02\x20\x01(\x04R\tmaxItemId\"\
    \xfb\x01\n\x19CMsgGCToGCInternalTestMsg\x12\x1d\n\nsending_gc\x18\x01\
    \x20\x01(\rR\tsendingGc\x12\x1b\n\tsender_id\x18\x02\x20\x01(\x06R\x08se\
    nderId\x12\x18\n\x07context\x18\x03\x20\x01(\rR\x07context\x12\x1d\n\nme\
    ssage_id\x18\x04\x20\x01(\rR\tmessageId\x12!\n\x0cmessage_body\x18\x05\
    \x20\x01(\x0cR\x0bmessageBody\x12\"\n\rjob_id_source\x18\x06\x20\x01(\
    \x06R\x0bjobIdSource\x12\"\n\rjob_id_target\x18\x07\x20\x01(\x06R\x0bjob\
    IdTarget\"\x84\x02\n%CMsgGCToGCClientServerVersionsUpdated\x12;\n\x1acli\
    ent_min_allowed_version\x18\x01\x20\x01(\rR\x17clientMinAllowedVersion\
    \x122\n\x15client_active_version\x18\x02\x20\x01(\rR\x13clientActiveVers\
    ion\x122\n\x15server_active_version\x18\x03\x20\x01(\rR\x13serverActiveV\
    ersion\x126\n\x17server_deployed_version\x18\x04\x20\x01(\rR\x15serverDe\
    ployedVersion*\x9c5\n\nEGCItemMsg\x12\x11\n\x0ck_EMsgGCBase\x10\xe8\x07\
    \x12\x1c\n\x17k_EMsgGCSetItemPosition\x10\xe9\x07\x12\x13\n\x0ek_EMsgGCD\
    elete\x10\xec\x07\x12$\n\x1fk_EMsgGCVerifyCacheSubscription\x10\xed\x07\
    \x12\x1d\n\x18k_EMsgClientToGCNameItem\x10\xee\x07\x12\x16\n\x11k_EMsgGC\
    PaintItem\x10\xf1\x07\x12\x1e\n\x19k_EMsgGCPaintItemResponse\x10\xf2\x07\
    \x12\"\n\x1dk_EMsgGCGoldenWrenchBroadcast\x10\xf3\x07\x12\x18\n\x13k_EMs\
    gGCMOTDRequest\x10\xf4\x07\x12\x20\n\x1bk_EMsgGCMOTDRequestResponse\x10\
    \xf5\x07\x12'\n\"k_EMsgGCAddItemToSocket_DEPRECATED\x10\xf6\x07\x12/\n*k\
    _EMsgGCAddItemToSocketResponse_DEPRECATED\x10\xf7\x07\x12+\n&k_EMsgGCAdd\
    SocketToBaseItem_DEPRECATED\x10\xf8\x07\x12'\n\"k_EMsgGCAddSocketToItem_\
    DEPRECATED\x10\xf9\x07\x12/\n*k_EMsgGCAddSocketToItemResponse_DEPRECATED\
    \x10\xfa\x07\x12\x19\n\x14k_EMsgGCNameBaseItem\x10\xfb\x07\x12!\n\x1ck_E\
    MsgGCNameBaseItemResponse\x10\xfc\x07\x12(\n#k_EMsgGCRemoveSocketItem_DE\
    PRECATED\x10\xfd\x07\x120\n+k_EMsgGCRemoveSocketItemResponse_DEPRECATED\
    \x10\xfe\x07\x12!\n\x1ck_EMsgGCCustomizeItemTexture\x10\xff\x07\x12)\n$k\
    _EMsgGCCustomizeItemTextureResponse\x10\x80\x08\x12\x1b\n\x16k_EMsgGCUse\
    ItemRequest\x10\x81\x08\x12\x1c\n\x17k_EMsgGCUseItemResponse\x10\x82\x08\
    \x12\x18\n\x13k_EMsgGCGiftedItems\x10\x83\x08\x12\x1b\n\x16k_EMsgGCRemov\
    eItemName\x10\x86\x08\x12\x1c\n\x17k_EMsgGCRemoveItemPaint\x10\x87\x08\
    \x12\x1e\n\x19k_EMsgGCUnwrapGiftRequest\x10\x8d\x08\x12\x1f\n\x1ak_EMsgG\
    CUnwrapGiftResponse\x10\x8e\x08\x12$\n\x1fk_EMsgGCSetItemStyle_DEPRECATE\
    D\x10\x8f\x08\x12\x1e\n\x19k_EMsgGCUsedClaimCodeItem\x10\x90\x08\x12\x16\
    \n\x11k_EMsgGCSortItems\x10\x91\x08\x12*\n%k_EMsgGC_RevolvingLootList_DE\
    PRECATED\x10\x92\x08\x12\x1d\n\x18k_EMsgGCUpdateItemSchema\x10\x99\x08\
    \x12\x20\n\x1bk_EMsgGCRemoveCustomTexture\x10\x9b\x08\x12(\n#k_EMsgGCRem\
    oveCustomTextureResponse\x10\x9c\x08\x12\x1d\n\x18k_EMsgGCRemoveMakersMa\
    rk\x10\x9d\x08\x12%\n\x20k_EMsgGCRemoveMakersMarkResponse\x10\x9e\x08\
    \x12#\n\x1ek_EMsgGCRemoveUniqueCraftIndex\x10\x9f\x08\x12+\n&k_EMsgGCRem\
    oveUniqueCraftIndexResponse\x10\xa0\x08\x12\x1b\n\x16k_EMsgGCSaxxyBroadc\
    ast\x10\xa1\x08\x12!\n\x1ck_EMsgGCBackpackSortFinished\x10\xa2\x08\x12$\
    \n\x1fk_EMsgGCAdjustItemEquippedState\x10\xa3\x08\x12\x18\n\x13k_EMsgGCC\
    ollectItem\x10\xa5\x08\x12\x1d\n\x18k_EMsgGCItemAcknowledged\x10\xa6\x08\
    \x12)\n$k_EMsgGCPresets_SelectPresetForClass\x10\xa7\x08\x12$\n\x1fk_EMs\
    gGCPresets_SetItemPosition\x10\xa8\x08\x12.\n)k_EMsgGCPresets_SelectPres\
    etForClassReply\x10\xab\x08\x12%\n\x20k_EMsgClientToGCNameItemResponse\
    \x10\xac\x08\x12#\n\x1ek_EMsgGCApplyConsumableEffects\x10\xad\x08\x12\
    \x20\n\x1bk_EMsgGCConsumableExhausted\x10\xae\x08\x12\x1e\n\x19k_EMsgGCS\
    howItemsPickedUp\x10\xaf\x08\x12&\n!k_EMsgGCClientDisplayNotification\
    \x10\xb0\x08\x12\x1d\n\x18k_EMsgGCApplyStrangePart\x10\xb1\x08\x12(\n#k_\
    EMsgGC_IncrementKillCountResponse\x10\xb3\x08\x12\x20\n\x1bk_EMsgGCApply\
    PennantUpgrade\x10\xb4\x08\x12\x1d\n\x18k_EMsgGCSetItemPositions\x10\xb5\
    \x08\x12)\n$k_EMsgGCSetItemPositions_RateLimited\x10\xc8\x08\x12\x1c\n\
    \x17k_EMsgGCApplyEggEssence\x10\xb6\x08\x12#\n\x1ek_EMsgGCNameEggEssence\
    Response\x10\xb7\x08\x12*\n%k_EMsgGCFulfillDynamicRecipeComponent\x10\
    \xba\x08\x122\n-k_EMsgGCFulfillDynamicRecipeComponentResponse\x10\xbb\
    \x08\x12$\n\x1fk_EMsgGCClientRequestMarketData\x10\xbc\x08\x12,\n'k_EMsg\
    GCClientRequestMarketDataResponse\x10\xbd\x08\x12\x18\n\x13k_EMsgGCExtra\
    ctGems\x10\xbe\x08\x12\x16\n\x11k_EMsgGCAddSocket\x10\xbf\x08\x12\x1c\n\
    \x17k_EMsgGCAddItemToSocket\x10\xc0\x08\x12$\n\x1fk_EMsgGCAddItemToSocke\
    tResponse\x10\xc1\x08\x12\x1e\n\x19k_EMsgGCAddSocketResponse\x10\xc2\x08\
    \x12!\n\x1ck_EMsgGCResetStrangeGemCount\x10\xc3\x08\x12\x1e\n\x19k_EMsgG\
    CRequestCrateItems\x10\xc4\x08\x12&\n!k_EMsgGCRequestCrateItemsResponse\
    \x10\xc5\x08\x12\x20\n\x1bk_EMsgGCExtractGemsResponse\x10\xc6\x08\x12)\n\
    $k_EMsgGCResetStrangeGemCountResponse\x10\xc7\x08\x12!\n\x1ck_EMsgGCServ\
    erUseItemRequest\x10\xcf\x08\x12\x18\n\x13k_EMsgGCAddGiftItem\x10\xd0\
    \x08\x12\"\n\x1dk_EMsgGCRemoveItemGiftMessage\x10\xd1\x08\x12*\n%k_EMsgG\
    CRemoveItemGiftMessageResponse\x10\xd2\x08\x12&\n!k_EMsgGCRemoveItemGift\
    erAccountId\x10\xd3\x08\x12.\n)k_EMsgGCRemoveItemGifterAccountIdResponse\
    \x10\xd4\x08\x12/\n*k_EMsgClientToGCRemoveItemGifterAttributes\x10\xd5\
    \x08\x12#\n\x1ek_EMsgClientToGCRemoveItemName\x10\xd6\x08\x12*\n%k_EMsgC\
    lientToGCRemoveItemDescription\x10\xd7\x08\x120\n+k_EMsgClientToGCRemove\
    ItemAttributeResponse\x10\xd8\x08\x12\x18\n\x13k_EMsgGCTradingBase\x10\
    \xdc\x0b\x12)\n$k_EMsgGCTrading_InitiateTradeRequest\x10\xdd\x0b\x12*\n%\
    k_EMsgGCTrading_InitiateTradeResponse\x10\xde\x0b\x12!\n\x1ck_EMsgGCTrad\
    ing_StartSession\x10\xdf\x0b\x12\"\n\x1dk_EMsgGCTrading_SessionClosed\
    \x10\xe5\x0b\x121\n,k_EMsgGCTrading_InitiateTradeRequestResponse\x10\xea\
    \x0b\x12)\n$k_EMsgGCServerBrowser_FavoriteServer\x10\xc1\x0c\x12*\n%k_EM\
    sgGCServerBrowser_BlacklistServer\x10\xc2\x0c\x12\x1e\n\x19k_EMsgGCServe\
    rRentalsBase\x10\xa4\r\x12\x1f\n\x1ak_EMsgGCDev_NewItemRequest\x10\xd1\
    \x0f\x12'\n\"k_EMsgGCDev_NewItemRequestResponse\x10\xd2\x0f\x12\x1d\n\
    \x18k_EMsgGCStoreGetUserData\x10\xc4\x13\x12%\n\x20k_EMsgGCStoreGetUserD\
    ataResponse\x10\xc5\x13\x12\"\n\x1dk_EMsgGCStorePurchaseFinalize\x10\xc8\
    \x13\x12*\n%k_EMsgGCStorePurchaseFinalizeResponse\x10\xc9\x13\x12\x20\n\
    \x1bk_EMsgGCStorePurchaseCancel\x10\xca\x13\x12(\n#k_EMsgGCStorePurchase\
    CancelResponse\x10\xcb\x13\x12\x1e\n\x19k_EMsgGCStorePurchaseInit\x10\
    \xce\x13\x12&\n!k_EMsgGCStorePurchaseInitResponse\x10\xcf\x13\x12\"\n\
    \x1dk_EMsgGCBannedWordListRequest\x10\xd0\x13\x12#\n\x1ek_EMsgGCBannedWo\
    rdListResponse\x10\xd1\x13\x12(\n#k_EMsgGCToGCBannedWordListBroadcast\
    \x10\xd2\x13\x12&\n!k_EMsgGCToGCBannedWordListUpdated\x10\xd3\x13\x12\
    \x1e\n\x19k_EMsgGCToGCDirtySDOCache\x10\xd4\x13\x12&\n!k_EMsgGCToGCDirty\
    MultipleSDOCache\x10\xd5\x13\x12\"\n\x1dk_EMsgGCToGCUpdateSQLKeyValue\
    \x10\xd6\x13\x12(\n#k_EMsgGCToGCBroadcastConsoleCommand\x10\xd9\x13\x12!\
    \n\x1ck_EMsgGCServerVersionUpdated\x10\xda\x13\x12\x1b\n\x16k_EMsgGCAppl\
    yAutograph\x10\xdb\x13\x12%\n\x20k_EMsgGCToGCWebAPIAccountChanged\x10\
    \xdc\x13\x12!\n\x1ck_EMsgGCClientVersionUpdated\x10\xe0\x13\x12+\n&k_EMs\
    gGCItemPurgatory_FinalizePurchase\x10\xe3\x13\x123\n.k_EMsgGCItemPurgato\
    ry_FinalizePurchaseResponse\x10\xe4\x13\x12)\n$k_EMsgGCItemPurgatory_Ref\
    undPurchase\x10\xe5\x13\x121\n,k_EMsgGCItemPurgatory_RefundPurchaseRespo\
    nse\x10\xe6\x13\x12.\n)k_EMsgGCToGCPlayerStrangeCountAdjustments\x10\xe7\
    \x13\x12\"\n\x1dk_EMsgGCRequestStoreSalesData\x10\xe8\x13\x12*\n%k_EMsgG\
    CRequestStoreSalesDataResponse\x10\xe9\x13\x122\n-k_EMsgGCRequestStoreSa\
    lesDataUpToDateResponse\x10\xea\x13\x12\x1c\n\x17k_EMsgGCToGCPingRequest\
    \x10\xeb\x13\x12\x1d\n\x18k_EMsgGCToGCPingResponse\x10\xec\x13\x12%\n\
    \x20k_EMsgGCToGCGetUserSessionServer\x10\xed\x13\x12-\n(k_EMsgGCToGCGetU\
    serSessionServerResponse\x10\xee\x13\x12%\n\x20k_EMsgGCToGCGetUserServer\
    Members\x10\xef\x13\x12-\n(k_EMsgGCToGCGetUserServerMembersResponse\x10\
    \xf0\x13\x12\x20\n\x1bk_EMsgGCToGCGetUserPCBangNo\x10\xf1\x13\x12(\n#k_E\
    MsgGCToGCGetUserPCBangNoResponse\x10\xf2\x13\x12$\n\x1fk_EMsgGCToGCCanUs\
    eDropRateBonus\x10\xf3\x13\x12\x1e\n\x19k_EMsgSQLAddDropRateBonus\x10\
    \xf4\x13\x12\x1f\n\x1ak_EMsgGCToGCRefreshSOCache\x10\xf5\x13\x12&\n!k_EM\
    sgGCToGCApplyLocalizationDiff\x10\xf6\x13\x12.\n)k_EMsgGCToGCApplyLocali\
    zationDiffResponse\x10\xf7\x13\x12(\n#k_EMsgGCToGCCheckAccountTradeStatu\
    s\x10\xf8\x13\x120\n+k_EMsgGCToGCCheckAccountTradeStatusResponse\x10\xf9\
    \x13\x12(\n#k_EMsgGCToGCGrantAccountRolledItems\x10\xfa\x13\x12+\n&k_EMs\
    gGCToGCGrantSelfMadeItemToAccount\x10\xfb\x13\x12\"\n\x1dk_EMsgGCPartner\
    BalanceRequest\x10\xfd\x13\x12#\n\x1ek_EMsgGCPartnerBalanceResponse\x10\
    \xfe\x13\x12.\n)k_EMsgGCPartnerRechargeRedirectURLRequest\x10\xff\x13\
    \x12/\n*k_EMsgGCPartnerRechargeRedirectURLResponse\x10\x80\x14\x12\x18\n\
    \x13k_EMsgGCStatueCraft\x10\x81\x14\x12\x17\n\x12k_EMsgGCRedeemCode\x10\
    \x82\x14\x12\x1f\n\x1ak_EMsgGCRedeemCodeResponse\x10\x83\x14\x12(\n#k_EM\
    sgGCToGCItemConsumptionRollback\x10\x84\x14\x12'\n\"k_EMsgClientToGCWrap\
    AndDeliverGift\x10\x85\x14\x12/\n*k_EMsgClientToGCWrapAndDeliverGiftResp\
    onse\x10\x86\x14\x12)\n$k_EMsgClientToGCUnpackBundleResponse\x10\x87\x14\
    \x12.\n)k_EMsgGCToClientStoreTransactionCompleted\x10\x88\x14\x12\x1f\n\
    \x1ak_EMsgClientToGCEquipItems\x10\x89\x14\x12'\n\"k_EMsgClientToGCEquip\
    ItemsResponse\x10\x8a\x14\x12$\n\x1fk_EMsgClientToGCUnlockItemStyle\x10\
    \x8b\x14\x12,\n'k_EMsgClientToGCUnlockItemStyleResponse\x10\x8c\x14\x12-\
    \n(k_EMsgClientToGCSetItemInventoryCategory\x10\x8d\x14\x12\x20\n\x1bk_E\
    MsgClientToGCUnlockCrate\x10\x8e\x14\x12(\n#k_EMsgClientToGCUnlockCrateR\
    esponse\x10\x8f\x14\x12!\n\x1ck_EMsgClientToGCUnpackBundle\x10\x90\x14\
    \x12!\n\x1ck_EMsgClientToGCSetItemStyle\x10\x91\x14\x12)\n$k_EMsgClientT\
    oGCSetItemStyleResponse\x10\x92\x14\x12&\n!k_EMsgSQLGCToGCGrantBackpackS\
    lots\x10\x94\x14\x12&\n!k_EMsgClientToGCLookupAccountName\x10\x95\x14\
    \x12.\n)k_EMsgClientToGCLookupAccountNameResponse\x10\x96\x14\x12#\n\x1e\
    k_EMsgGCToGCDevRevokeUserItems\x10\x97\x14\x12'\n\"k_EMsgClientToGCCreat\
    eStaticRecipe\x10\x98\x14\x12/\n*k_EMsgClientToGCCreateStaticRecipeRespo\
    nse\x10\x99\x14\x12-\n(k_EMsgGCToGCStoreProcessCDKeyTransaction\x10\x9a\
    \x14\x125\n0k_EMsgGCToGCStoreProcessCDKeyTransactionResponse\x10\x9b\x14\
    \x12'\n\"k_EMsgGCToGCStoreProcessSettlement\x10\x9c\x14\x12/\n*k_EMsgGCT\
    oGCStoreProcessSettlementResponse\x10\x9d\x14\x12\x1e\n\x19k_EMsgGCToGCC\
    onsoleOutput\x10\x9e\x14\x12\x1d\n\x18k_EMsgGCToClientItemAges\x10\x9f\
    \x14\x12\x20\n\x1bk_EMsgGCToGCInternalTestMsg\x10\xa0\x14\x12,\n'k_EMsgG\
    CToGCClientServerVersionsUpdated\x10\xa1\x14\x12$\n\x1fk_EMsgGCUseMultip\
    leItemsRequest\x10\xa2\x14\x12%\n\x20k_EMsgGCCheckAccountSubscription\
    \x10\xa3\x14\x12-\n(k_EMsgGCCheckAccountSubscriptionResponse\x10\xa4\x14\
    *\xf3\x02\n\x1fEItemPurgatoryResponse_Finalize\x12.\n*k_ItemPurgatoryRes\
    ponse_Finalize_Succeeded\x10\0\x126\n2k_ItemPurgatoryResponse_Finalize_F\
    ailed_Incomplete\x10\x01\x12?\n;k_ItemPurgatoryResponse_Finalize_Failed_\
    ItemsNotInPurgatory\x10\x02\x12=\n9k_ItemPurgatoryResponse_Finalize_Fail\
    ed_CouldNotFindItems\x10\x03\x125\n1k_ItemPurgatoryResponse_Finalize_Fai\
    led_NoSOCache\x10\x04\x121\n-k_ItemPurgatoryResponse_Finalize_BackpackFu\
    ll\x10\x05*\xe7\x02\n\x1dEItemPurgatoryResponse_Refund\x12,\n(k_ItemPurg\
    atoryResponse_Refund_Succeeded\x10\0\x12<\n8k_ItemPurgatoryResponse_Refu\
    nd_Failed_ItemNotInPurgatory\x10\x01\x12:\n6k_ItemPurgatoryResponse_Refu\
    nd_Failed_CouldNotFindItem\x10\x02\x123\n/k_ItemPurgatoryResponse_Refund\
    _Failed_NoSOCache\x10\x03\x122\n.k_ItemPurgatoryResponse_Refund_Failed_N\
    oDetail\x10\x04\x125\n1k_ItemPurgatoryResponse_Refund_Failed_NexonWebAPI\
    \x10\x05*\xb9\n\n\x1bEGCMsgInitiateTradeResponse\x12*\n&k_EGCMsgInitiate\
    TradeResponse_Accepted\x10\0\x12*\n&k_EGCMsgInitiateTradeResponse_Declin\
    ed\x10\x01\x126\n2k_EGCMsgInitiateTradeResponse_VAC_Banned_Initiator\x10\
    \x02\x123\n/k_EGCMsgInitiateTradeResponse_VAC_Banned_Target\x10\x03\x128\
    \n4k_EGCMsgInitiateTradeResponse_Target_Already_Trading\x10\x04\x12*\n&k\
    _EGCMsgInitiateTradeResponse_Disabled\x10\x05\x12-\n)k_EGCMsgInitiateTra\
    deResponse_NotLoggedIn\x10\x06\x12(\n$k_EGCMsgInitiateTradeResponse_Canc\
    el\x10\x07\x12)\n%k_EGCMsgInitiateTradeResponse_TooSoon\x10\x08\x120\n,k\
    _EGCMsgInitiateTradeResponse_TooSoonPenalty\x10\t\x128\n4k_EGCMsgInitiat\
    eTradeResponse_Trade_Banned_Initiator\x10\n\x125\n1k_EGCMsgInitiateTrade\
    Response_Trade_Banned_Target\x10\x0b\x12C\n?k_EGCMsgInitiateTradeRespons\
    e_Free_Account_Initiator_DEPRECATED\x10\x0c\x12:\n6k_EGCMsgInitiateTrade\
    Response_Shared_Account_Initiator\x10\r\x125\n1k_EGCMsgInitiateTradeResp\
    onse_Service_Unavailable\x10\x0e\x120\n,k_EGCMsgInitiateTradeResponse_Ta\
    rget_Blocked\x10\x0f\x123\n/k_EGCMsgInitiateTradeResponse_NeedVerifiedEm\
    ail\x10\x10\x120\n,k_EGCMsgInitiateTradeResponse_NeedSteamGuard\x10\x11\
    \x124\n0k_EGCMsgInitiateTradeResponse_SteamGuardDuration\x10\x12\x121\n-\
    k_EGCMsgInitiateTradeResponse_TheyCannotTrade\x10\x13\x127\n3k_EGCMsgIni\
    tiateTradeResponse_Recent_Password_Reset\x10\x14\x122\n.k_EGCMsgInitiate\
    TradeResponse_Using_New_Device\x10\x15\x125\n1k_EGCMsgInitiateTradeRespo\
    nse_Sent_Invalid_Cookie\x10\x16\x121\n-k_EGCMsgInitiateTradeResponse_Too\
    RecentFriend\x10\x17\x127\n3k_EGCMsgInitiateTradeResponse_WalledFundsNot\
    Trusted\x10\x18B\x05H\x01\x80\x01\0\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
