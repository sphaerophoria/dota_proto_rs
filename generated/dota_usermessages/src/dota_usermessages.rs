// This file is generated. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_AIDebugLine {
    // message fields
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_AIDebugLine {}

impl CDOTAUserMsg_AIDebugLine {
    pub fn new() -> CDOTAUserMsg_AIDebugLine {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_AIDebugLine {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_AIDebugLine> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_AIDebugLine,
        };
        unsafe {
            instance.get(CDOTAUserMsg_AIDebugLine::new)
        }
    }

    // optional string message = 1;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }
}

impl ::protobuf::Message for CDOTAUserMsg_AIDebugLine {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_AIDebugLine {
    fn new() -> CDOTAUserMsg_AIDebugLine {
        CDOTAUserMsg_AIDebugLine::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_AIDebugLine>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    CDOTAUserMsg_AIDebugLine::get_message_for_reflect,
                    CDOTAUserMsg_AIDebugLine::mut_message_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_AIDebugLine>(
                    "CDOTAUserMsg_AIDebugLine",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_AIDebugLine {
    fn clear(&mut self) {
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_AIDebugLine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_AIDebugLine {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_Ping {
    // message fields
    ping: ::std::option::Option<u32>,
    loss: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_Ping {}

impl CDOTAUserMsg_Ping {
    pub fn new() -> CDOTAUserMsg_Ping {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_Ping {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_Ping> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_Ping,
        };
        unsafe {
            instance.get(CDOTAUserMsg_Ping::new)
        }
    }

    // optional uint32 ping = 2;

    pub fn clear_ping(&mut self) {
        self.ping = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        self.ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: u32) {
        self.ping = ::std::option::Option::Some(v);
    }

    pub fn get_ping(&self) -> u32 {
        self.ping.unwrap_or(0)
    }

    fn get_ping_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ping
    }

    fn mut_ping_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ping
    }

    // optional uint32 loss = 3;

    pub fn clear_loss(&mut self) {
        self.loss = ::std::option::Option::None;
    }

    pub fn has_loss(&self) -> bool {
        self.loss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loss(&mut self, v: u32) {
        self.loss = ::std::option::Option::Some(v);
    }

    pub fn get_loss(&self) -> u32 {
        self.loss.unwrap_or(0)
    }

    fn get_loss_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.loss
    }

    fn mut_loss_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.loss
    }
}

impl ::protobuf::Message for CDOTAUserMsg_Ping {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.loss = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ping {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.loss {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ping {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.loss {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_Ping {
    fn new() -> CDOTAUserMsg_Ping {
        CDOTAUserMsg_Ping::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_Ping>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ping",
                    CDOTAUserMsg_Ping::get_ping_for_reflect,
                    CDOTAUserMsg_Ping::mut_ping_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "loss",
                    CDOTAUserMsg_Ping::get_loss_for_reflect,
                    CDOTAUserMsg_Ping::mut_loss_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_Ping>(
                    "CDOTAUserMsg_Ping",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_Ping {
    fn clear(&mut self) {
        self.clear_ping();
        self.clear_loss();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_Ping {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_SwapVerify {
    // message fields
    player_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_SwapVerify {}

impl CDOTAUserMsg_SwapVerify {
    pub fn new() -> CDOTAUserMsg_SwapVerify {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_SwapVerify {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_SwapVerify> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_SwapVerify,
        };
        unsafe {
            instance.get(CDOTAUserMsg_SwapVerify::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SwapVerify {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_SwapVerify {
    fn new() -> CDOTAUserMsg_SwapVerify {
        CDOTAUserMsg_SwapVerify::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_SwapVerify>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_SwapVerify::get_player_id_for_reflect,
                    CDOTAUserMsg_SwapVerify::mut_player_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_SwapVerify>(
                    "CDOTAUserMsg_SwapVerify",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_SwapVerify {
    fn clear(&mut self) {
        self.clear_player_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_SwapVerify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SwapVerify {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ChatEvent {
    // message fields
    field_type: ::std::option::Option<DOTA_CHAT_MESSAGE>,
    value: ::std::option::Option<u32>,
    playerid_1: ::std::option::Option<i32>,
    playerid_2: ::std::option::Option<i32>,
    playerid_3: ::std::option::Option<i32>,
    playerid_4: ::std::option::Option<i32>,
    playerid_5: ::std::option::Option<i32>,
    playerid_6: ::std::option::Option<i32>,
    value2: ::std::option::Option<u32>,
    value3: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ChatEvent {}

impl CDOTAUserMsg_ChatEvent {
    pub fn new() -> CDOTAUserMsg_ChatEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ChatEvent {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ChatEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ChatEvent,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ChatEvent::new)
        }
    }

    // required .DOTA_CHAT_MESSAGE type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DOTA_CHAT_MESSAGE) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> DOTA_CHAT_MESSAGE {
        self.field_type.unwrap_or(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INVALID)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<DOTA_CHAT_MESSAGE> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<DOTA_CHAT_MESSAGE> {
        &mut self.field_type
    }

    // optional uint32 value = 2;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.value
    }

    // optional sint32 playerid_1 = 3;

    pub fn clear_playerid_1(&mut self) {
        self.playerid_1 = ::std::option::Option::None;
    }

    pub fn has_playerid_1(&self) -> bool {
        self.playerid_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_1(&mut self, v: i32) {
        self.playerid_1 = ::std::option::Option::Some(v);
    }

    pub fn get_playerid_1(&self) -> i32 {
        self.playerid_1.unwrap_or(-1i32)
    }

    fn get_playerid_1_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.playerid_1
    }

    fn mut_playerid_1_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.playerid_1
    }

    // optional sint32 playerid_2 = 4;

    pub fn clear_playerid_2(&mut self) {
        self.playerid_2 = ::std::option::Option::None;
    }

    pub fn has_playerid_2(&self) -> bool {
        self.playerid_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_2(&mut self, v: i32) {
        self.playerid_2 = ::std::option::Option::Some(v);
    }

    pub fn get_playerid_2(&self) -> i32 {
        self.playerid_2.unwrap_or(-1i32)
    }

    fn get_playerid_2_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.playerid_2
    }

    fn mut_playerid_2_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.playerid_2
    }

    // optional sint32 playerid_3 = 5;

    pub fn clear_playerid_3(&mut self) {
        self.playerid_3 = ::std::option::Option::None;
    }

    pub fn has_playerid_3(&self) -> bool {
        self.playerid_3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_3(&mut self, v: i32) {
        self.playerid_3 = ::std::option::Option::Some(v);
    }

    pub fn get_playerid_3(&self) -> i32 {
        self.playerid_3.unwrap_or(-1i32)
    }

    fn get_playerid_3_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.playerid_3
    }

    fn mut_playerid_3_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.playerid_3
    }

    // optional sint32 playerid_4 = 6;

    pub fn clear_playerid_4(&mut self) {
        self.playerid_4 = ::std::option::Option::None;
    }

    pub fn has_playerid_4(&self) -> bool {
        self.playerid_4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_4(&mut self, v: i32) {
        self.playerid_4 = ::std::option::Option::Some(v);
    }

    pub fn get_playerid_4(&self) -> i32 {
        self.playerid_4.unwrap_or(-1i32)
    }

    fn get_playerid_4_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.playerid_4
    }

    fn mut_playerid_4_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.playerid_4
    }

    // optional sint32 playerid_5 = 7;

    pub fn clear_playerid_5(&mut self) {
        self.playerid_5 = ::std::option::Option::None;
    }

    pub fn has_playerid_5(&self) -> bool {
        self.playerid_5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_5(&mut self, v: i32) {
        self.playerid_5 = ::std::option::Option::Some(v);
    }

    pub fn get_playerid_5(&self) -> i32 {
        self.playerid_5.unwrap_or(-1i32)
    }

    fn get_playerid_5_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.playerid_5
    }

    fn mut_playerid_5_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.playerid_5
    }

    // optional sint32 playerid_6 = 8;

    pub fn clear_playerid_6(&mut self) {
        self.playerid_6 = ::std::option::Option::None;
    }

    pub fn has_playerid_6(&self) -> bool {
        self.playerid_6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerid_6(&mut self, v: i32) {
        self.playerid_6 = ::std::option::Option::Some(v);
    }

    pub fn get_playerid_6(&self) -> i32 {
        self.playerid_6.unwrap_or(-1i32)
    }

    fn get_playerid_6_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.playerid_6
    }

    fn mut_playerid_6_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.playerid_6
    }

    // optional uint32 value2 = 9;

    pub fn clear_value2(&mut self) {
        self.value2 = ::std::option::Option::None;
    }

    pub fn has_value2(&self) -> bool {
        self.value2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value2(&mut self, v: u32) {
        self.value2 = ::std::option::Option::Some(v);
    }

    pub fn get_value2(&self) -> u32 {
        self.value2.unwrap_or(0)
    }

    fn get_value2_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.value2
    }

    fn mut_value2_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.value2
    }

    // optional uint32 value3 = 10;

    pub fn clear_value3(&mut self) {
        self.value3 = ::std::option::Option::None;
    }

    pub fn has_value3(&self) -> bool {
        self.value3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value3(&mut self, v: u32) {
        self.value3 = ::std::option::Option::Some(v);
    }

    pub fn get_value3(&self) -> u32 {
        self.value3.unwrap_or(0)
    }

    fn get_value3_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.value3
    }

    fn mut_value3_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.value3
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ChatEvent {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.playerid_1 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.playerid_2 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.playerid_3 = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.playerid_4 = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.playerid_5 = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.playerid_6 = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value2 = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value3 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.playerid_1 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        if let Some(v) = self.playerid_2 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(4, v);
        }
        if let Some(v) = self.playerid_3 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, v);
        }
        if let Some(v) = self.playerid_4 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(6, v);
        }
        if let Some(v) = self.playerid_5 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, v);
        }
        if let Some(v) = self.playerid_6 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(8, v);
        }
        if let Some(v) = self.value2 {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value3 {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.playerid_1 {
            os.write_sint32(3, v)?;
        }
        if let Some(v) = self.playerid_2 {
            os.write_sint32(4, v)?;
        }
        if let Some(v) = self.playerid_3 {
            os.write_sint32(5, v)?;
        }
        if let Some(v) = self.playerid_4 {
            os.write_sint32(6, v)?;
        }
        if let Some(v) = self.playerid_5 {
            os.write_sint32(7, v)?;
        }
        if let Some(v) = self.playerid_6 {
            os.write_sint32(8, v)?;
        }
        if let Some(v) = self.value2 {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.value3 {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ChatEvent {
    fn new() -> CDOTAUserMsg_ChatEvent {
        CDOTAUserMsg_ChatEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ChatEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DOTA_CHAT_MESSAGE>>(
                    "type",
                    CDOTAUserMsg_ChatEvent::get_field_type_for_reflect,
                    CDOTAUserMsg_ChatEvent::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "value",
                    CDOTAUserMsg_ChatEvent::get_value_for_reflect,
                    CDOTAUserMsg_ChatEvent::mut_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "playerid_1",
                    CDOTAUserMsg_ChatEvent::get_playerid_1_for_reflect,
                    CDOTAUserMsg_ChatEvent::mut_playerid_1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "playerid_2",
                    CDOTAUserMsg_ChatEvent::get_playerid_2_for_reflect,
                    CDOTAUserMsg_ChatEvent::mut_playerid_2_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "playerid_3",
                    CDOTAUserMsg_ChatEvent::get_playerid_3_for_reflect,
                    CDOTAUserMsg_ChatEvent::mut_playerid_3_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "playerid_4",
                    CDOTAUserMsg_ChatEvent::get_playerid_4_for_reflect,
                    CDOTAUserMsg_ChatEvent::mut_playerid_4_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "playerid_5",
                    CDOTAUserMsg_ChatEvent::get_playerid_5_for_reflect,
                    CDOTAUserMsg_ChatEvent::mut_playerid_5_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "playerid_6",
                    CDOTAUserMsg_ChatEvent::get_playerid_6_for_reflect,
                    CDOTAUserMsg_ChatEvent::mut_playerid_6_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "value2",
                    CDOTAUserMsg_ChatEvent::get_value2_for_reflect,
                    CDOTAUserMsg_ChatEvent::mut_value2_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "value3",
                    CDOTAUserMsg_ChatEvent::get_value3_for_reflect,
                    CDOTAUserMsg_ChatEvent::mut_value3_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ChatEvent>(
                    "CDOTAUserMsg_ChatEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ChatEvent {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_value();
        self.clear_playerid_1();
        self.clear_playerid_2();
        self.clear_playerid_3();
        self.clear_playerid_4();
        self.clear_playerid_5();
        self.clear_playerid_6();
        self.clear_value2();
        self.clear_value3();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ChatEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ChatEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_CombatLogShowDeath {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_CombatLogShowDeath {}

impl CDOTAUserMsg_CombatLogShowDeath {
    pub fn new() -> CDOTAUserMsg_CombatLogShowDeath {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_CombatLogShowDeath {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_CombatLogShowDeath> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_CombatLogShowDeath,
        };
        unsafe {
            instance.get(CDOTAUserMsg_CombatLogShowDeath::new)
        }
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CombatLogShowDeath {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_CombatLogShowDeath {
    fn new() -> CDOTAUserMsg_CombatLogShowDeath {
        CDOTAUserMsg_CombatLogShowDeath::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_CombatLogShowDeath>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_CombatLogShowDeath>(
                    "CDOTAUserMsg_CombatLogShowDeath",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_CombatLogShowDeath {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_CombatLogShowDeath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CombatLogShowDeath {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_BotChat {
    // message fields
    player_id: ::std::option::Option<u32>,
    message: ::protobuf::SingularField<::std::string::String>,
    target: ::protobuf::SingularField<::std::string::String>,
    team_only: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_BotChat {}

impl CDOTAUserMsg_BotChat {
    pub fn new() -> CDOTAUserMsg_BotChat {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_BotChat {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_BotChat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_BotChat,
        };
        unsafe {
            instance.get(CDOTAUserMsg_BotChat::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional string message = 3;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }

    // optional string target = 4;

    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::string::String) {
        self.target = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ::std::string::String {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::string::String {
        self.target.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_target(&self) -> &str {
        match self.target.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_target_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.target
    }

    fn mut_target_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.target
    }

    // optional bool team_only = 5;

    pub fn clear_team_only(&mut self) {
        self.team_only = ::std::option::Option::None;
    }

    pub fn has_team_only(&self) -> bool {
        self.team_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_only(&mut self, v: bool) {
        self.team_only = ::std::option::Option::Some(v);
    }

    pub fn get_team_only(&self) -> bool {
        self.team_only.unwrap_or(false)
    }

    fn get_team_only_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.team_only
    }

    fn mut_team_only_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.team_only
    }
}

impl ::protobuf::Message for CDOTAUserMsg_BotChat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.target)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.team_only = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.target.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.team_only {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.target.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.team_only {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_BotChat {
    fn new() -> CDOTAUserMsg_BotChat {
        CDOTAUserMsg_BotChat::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_BotChat>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_BotChat::get_player_id_for_reflect,
                    CDOTAUserMsg_BotChat::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    CDOTAUserMsg_BotChat::get_message_for_reflect,
                    CDOTAUserMsg_BotChat::mut_message_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "target",
                    CDOTAUserMsg_BotChat::get_target_for_reflect,
                    CDOTAUserMsg_BotChat::mut_target_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "team_only",
                    CDOTAUserMsg_BotChat::get_team_only_for_reflect,
                    CDOTAUserMsg_BotChat::mut_team_only_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_BotChat>(
                    "CDOTAUserMsg_BotChat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_BotChat {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_message();
        self.clear_target();
        self.clear_team_only();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_BotChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_BotChat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_CombatHeroPositions {
    // message fields
    index: ::std::option::Option<u32>,
    time: ::std::option::Option<i32>,
    world_pos: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector2D>,
    health: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_CombatHeroPositions {}

impl CDOTAUserMsg_CombatHeroPositions {
    pub fn new() -> CDOTAUserMsg_CombatHeroPositions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_CombatHeroPositions {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_CombatHeroPositions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_CombatHeroPositions,
        };
        unsafe {
            instance.get(CDOTAUserMsg_CombatHeroPositions::new)
        }
    }

    // optional uint32 index = 1;

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    pub fn get_index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    fn get_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.index
    }

    fn mut_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.index
    }

    // optional int32 time = 2;

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i32) {
        self.time = ::std::option::Option::Some(v);
    }

    pub fn get_time(&self) -> i32 {
        self.time.unwrap_or(0)
    }

    fn get_time_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.time
    }

    fn mut_time_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.time
    }

    // optional .CMsgVector2D world_pos = 3;

    pub fn clear_world_pos(&mut self) {
        self.world_pos.clear();
    }

    pub fn has_world_pos(&self) -> bool {
        self.world_pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_world_pos(&mut self, v: super::networkbasetypes::CMsgVector2D) {
        self.world_pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_world_pos(&mut self) -> &mut super::networkbasetypes::CMsgVector2D {
        if self.world_pos.is_none() {
            self.world_pos.set_default();
        }
        self.world_pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_world_pos(&mut self) -> super::networkbasetypes::CMsgVector2D {
        self.world_pos.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector2D::new())
    }

    pub fn get_world_pos(&self) -> &super::networkbasetypes::CMsgVector2D {
        self.world_pos.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector2D::default_instance())
    }

    fn get_world_pos_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector2D> {
        &self.world_pos
    }

    fn mut_world_pos_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector2D> {
        &mut self.world_pos
    }

    // optional int32 health = 4;

    pub fn clear_health(&mut self) {
        self.health = ::std::option::Option::None;
    }

    pub fn has_health(&self) -> bool {
        self.health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: i32) {
        self.health = ::std::option::Option::Some(v);
    }

    pub fn get_health(&self) -> i32 {
        self.health.unwrap_or(0)
    }

    fn get_health_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.health
    }

    fn mut_health_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.health
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CombatHeroPositions {
    fn is_initialized(&self) -> bool {
        for v in &self.world_pos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.world_pos)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.health = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.world_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.health {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.world_pos.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.health {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_CombatHeroPositions {
    fn new() -> CDOTAUserMsg_CombatHeroPositions {
        CDOTAUserMsg_CombatHeroPositions::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_CombatHeroPositions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "index",
                    CDOTAUserMsg_CombatHeroPositions::get_index_for_reflect,
                    CDOTAUserMsg_CombatHeroPositions::mut_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "time",
                    CDOTAUserMsg_CombatHeroPositions::get_time_for_reflect,
                    CDOTAUserMsg_CombatHeroPositions::mut_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector2D>>(
                    "world_pos",
                    CDOTAUserMsg_CombatHeroPositions::get_world_pos_for_reflect,
                    CDOTAUserMsg_CombatHeroPositions::mut_world_pos_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "health",
                    CDOTAUserMsg_CombatHeroPositions::get_health_for_reflect,
                    CDOTAUserMsg_CombatHeroPositions::mut_health_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_CombatHeroPositions>(
                    "CDOTAUserMsg_CombatHeroPositions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_CombatHeroPositions {
    fn clear(&mut self) {
        self.clear_index();
        self.clear_time();
        self.clear_world_pos();
        self.clear_health();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_CombatHeroPositions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CombatHeroPositions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_MiniKillCamInfo {
    // message fields
    attackers: ::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_MiniKillCamInfo {}

impl CDOTAUserMsg_MiniKillCamInfo {
    pub fn new() -> CDOTAUserMsg_MiniKillCamInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_MiniKillCamInfo {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_MiniKillCamInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_MiniKillCamInfo,
        };
        unsafe {
            instance.get(CDOTAUserMsg_MiniKillCamInfo::new)
        }
    }

    // repeated .CDOTAUserMsg_MiniKillCamInfo.Attacker attackers = 1;

    pub fn clear_attackers(&mut self) {
        self.attackers.clear();
    }

    // Param is passed by value, moved
    pub fn set_attackers(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker>) {
        self.attackers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attackers(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker> {
        &mut self.attackers
    }

    // Take field
    pub fn take_attackers(&mut self) -> ::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker> {
        ::std::mem::replace(&mut self.attackers, ::protobuf::RepeatedField::new())
    }

    pub fn get_attackers(&self) -> &[CDOTAUserMsg_MiniKillCamInfo_Attacker] {
        &self.attackers
    }

    fn get_attackers_for_reflect(&self) -> &::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker> {
        &self.attackers
    }

    fn mut_attackers_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker> {
        &mut self.attackers
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MiniKillCamInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.attackers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attackers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.attackers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.attackers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_MiniKillCamInfo {
    fn new() -> CDOTAUserMsg_MiniKillCamInfo {
        CDOTAUserMsg_MiniKillCamInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_MiniKillCamInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_MiniKillCamInfo_Attacker>>(
                    "attackers",
                    CDOTAUserMsg_MiniKillCamInfo::get_attackers_for_reflect,
                    CDOTAUserMsg_MiniKillCamInfo::mut_attackers_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_MiniKillCamInfo>(
                    "CDOTAUserMsg_MiniKillCamInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_MiniKillCamInfo {
    fn clear(&mut self) {
        self.clear_attackers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_MiniKillCamInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_MiniKillCamInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_MiniKillCamInfo_Attacker {
    // message fields
    attacker: ::std::option::Option<u32>,
    total_damage: ::std::option::Option<i32>,
    abilities: ::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability>,
    attacker_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_MiniKillCamInfo_Attacker {}

impl CDOTAUserMsg_MiniKillCamInfo_Attacker {
    pub fn new() -> CDOTAUserMsg_MiniKillCamInfo_Attacker {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_MiniKillCamInfo_Attacker {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_MiniKillCamInfo_Attacker> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_MiniKillCamInfo_Attacker,
        };
        unsafe {
            instance.get(CDOTAUserMsg_MiniKillCamInfo_Attacker::new)
        }
    }

    // optional uint32 attacker = 1;

    pub fn clear_attacker(&mut self) {
        self.attacker = ::std::option::Option::None;
    }

    pub fn has_attacker(&self) -> bool {
        self.attacker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacker(&mut self, v: u32) {
        self.attacker = ::std::option::Option::Some(v);
    }

    pub fn get_attacker(&self) -> u32 {
        self.attacker.unwrap_or(0)
    }

    fn get_attacker_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.attacker
    }

    fn mut_attacker_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.attacker
    }

    // optional int32 total_damage = 2;

    pub fn clear_total_damage(&mut self) {
        self.total_damage = ::std::option::Option::None;
    }

    pub fn has_total_damage(&self) -> bool {
        self.total_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_damage(&mut self, v: i32) {
        self.total_damage = ::std::option::Option::Some(v);
    }

    pub fn get_total_damage(&self) -> i32 {
        self.total_damage.unwrap_or(0)
    }

    fn get_total_damage_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.total_damage
    }

    fn mut_total_damage_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.total_damage
    }

    // repeated .CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability abilities = 3;

    pub fn clear_abilities(&mut self) {
        self.abilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_abilities(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability>) {
        self.abilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_abilities(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability> {
        &mut self.abilities
    }

    // Take field
    pub fn take_abilities(&mut self) -> ::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability> {
        ::std::mem::replace(&mut self.abilities, ::protobuf::RepeatedField::new())
    }

    pub fn get_abilities(&self) -> &[CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability] {
        &self.abilities
    }

    fn get_abilities_for_reflect(&self) -> &::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability> {
        &self.abilities
    }

    fn mut_abilities_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability> {
        &mut self.abilities
    }

    // optional string attacker_name = 4;

    pub fn clear_attacker_name(&mut self) {
        self.attacker_name.clear();
    }

    pub fn has_attacker_name(&self) -> bool {
        self.attacker_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacker_name(&mut self, v: ::std::string::String) {
        self.attacker_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attacker_name(&mut self) -> &mut ::std::string::String {
        if self.attacker_name.is_none() {
            self.attacker_name.set_default();
        }
        self.attacker_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_attacker_name(&mut self) -> ::std::string::String {
        self.attacker_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_attacker_name(&self) -> &str {
        match self.attacker_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_attacker_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.attacker_name
    }

    fn mut_attacker_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.attacker_name
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MiniKillCamInfo_Attacker {
    fn is_initialized(&self) -> bool {
        for v in &self.abilities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.attacker = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total_damage = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.abilities)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.attacker_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.attacker {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_damage {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.abilities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.attacker_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.attacker {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.total_damage {
            os.write_int32(2, v)?;
        }
        for v in &self.abilities {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.attacker_name.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_MiniKillCamInfo_Attacker {
    fn new() -> CDOTAUserMsg_MiniKillCamInfo_Attacker {
        CDOTAUserMsg_MiniKillCamInfo_Attacker::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_MiniKillCamInfo_Attacker>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "attacker",
                    CDOTAUserMsg_MiniKillCamInfo_Attacker::get_attacker_for_reflect,
                    CDOTAUserMsg_MiniKillCamInfo_Attacker::mut_attacker_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "total_damage",
                    CDOTAUserMsg_MiniKillCamInfo_Attacker::get_total_damage_for_reflect,
                    CDOTAUserMsg_MiniKillCamInfo_Attacker::mut_total_damage_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability>>(
                    "abilities",
                    CDOTAUserMsg_MiniKillCamInfo_Attacker::get_abilities_for_reflect,
                    CDOTAUserMsg_MiniKillCamInfo_Attacker::mut_abilities_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "attacker_name",
                    CDOTAUserMsg_MiniKillCamInfo_Attacker::get_attacker_name_for_reflect,
                    CDOTAUserMsg_MiniKillCamInfo_Attacker::mut_attacker_name_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_MiniKillCamInfo_Attacker>(
                    "CDOTAUserMsg_MiniKillCamInfo_Attacker",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_MiniKillCamInfo_Attacker {
    fn clear(&mut self) {
        self.clear_attacker();
        self.clear_total_damage();
        self.clear_abilities();
        self.clear_attacker_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_MiniKillCamInfo_Attacker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_MiniKillCamInfo_Attacker {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
    // message fields
    ability: ::std::option::Option<u32>,
    damage: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {}

impl CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
    pub fn new() -> CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability,
        };
        unsafe {
            instance.get(CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability::new)
        }
    }

    // optional uint32 ability = 1;

    pub fn clear_ability(&mut self) {
        self.ability = ::std::option::Option::None;
    }

    pub fn has_ability(&self) -> bool {
        self.ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability(&mut self, v: u32) {
        self.ability = ::std::option::Option::Some(v);
    }

    pub fn get_ability(&self) -> u32 {
        self.ability.unwrap_or(0)
    }

    fn get_ability_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ability
    }

    fn mut_ability_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ability
    }

    // optional int32 damage = 2;

    pub fn clear_damage(&mut self) {
        self.damage = ::std::option::Option::None;
    }

    pub fn has_damage(&self) -> bool {
        self.damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage(&mut self, v: i32) {
        self.damage = ::std::option::Option::Some(v);
    }

    pub fn get_damage(&self) -> i32 {
        self.damage.unwrap_or(0)
    }

    fn get_damage_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.damage
    }

    fn mut_damage_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.damage
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ability = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.damage = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ability {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.damage {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ability {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.damage {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
    fn new() -> CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
        CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ability",
                    CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability::get_ability_for_reflect,
                    CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability::mut_ability_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "damage",
                    CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability::get_damage_for_reflect,
                    CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability::mut_damage_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability>(
                    "CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
    fn clear(&mut self) {
        self.clear_ability();
        self.clear_damage();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_MiniKillCamInfo_Attacker_Ability {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_GlobalLightColor {
    // message fields
    color: ::std::option::Option<u32>,
    duration: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_GlobalLightColor {}

impl CDOTAUserMsg_GlobalLightColor {
    pub fn new() -> CDOTAUserMsg_GlobalLightColor {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_GlobalLightColor {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_GlobalLightColor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_GlobalLightColor,
        };
        unsafe {
            instance.get(CDOTAUserMsg_GlobalLightColor::new)
        }
    }

    // optional uint32 color = 1;

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    pub fn get_color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    fn get_color_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.color
    }

    fn mut_color_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.color
    }

    // optional float duration = 2;

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    fn get_duration_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.duration
    }

    fn mut_duration_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.duration
    }
}

impl ::protobuf::Message for CDOTAUserMsg_GlobalLightColor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.color = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.duration {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.color {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_GlobalLightColor {
    fn new() -> CDOTAUserMsg_GlobalLightColor {
        CDOTAUserMsg_GlobalLightColor::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_GlobalLightColor>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "color",
                    CDOTAUserMsg_GlobalLightColor::get_color_for_reflect,
                    CDOTAUserMsg_GlobalLightColor::mut_color_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "duration",
                    CDOTAUserMsg_GlobalLightColor::get_duration_for_reflect,
                    CDOTAUserMsg_GlobalLightColor::mut_duration_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_GlobalLightColor>(
                    "CDOTAUserMsg_GlobalLightColor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_GlobalLightColor {
    fn clear(&mut self) {
        self.clear_color();
        self.clear_duration();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_GlobalLightColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_GlobalLightColor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_GlobalLightDirection {
    // message fields
    direction: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector>,
    duration: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_GlobalLightDirection {}

impl CDOTAUserMsg_GlobalLightDirection {
    pub fn new() -> CDOTAUserMsg_GlobalLightDirection {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_GlobalLightDirection {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_GlobalLightDirection> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_GlobalLightDirection,
        };
        unsafe {
            instance.get(CDOTAUserMsg_GlobalLightDirection::new)
        }
    }

    // optional .CMsgVector direction = 1;

    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: super::networkbasetypes::CMsgVector) {
        self.direction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut super::networkbasetypes::CMsgVector {
        if self.direction.is_none() {
            self.direction.set_default();
        }
        self.direction.as_mut().unwrap()
    }

    // Take field
    pub fn take_direction(&mut self) -> super::networkbasetypes::CMsgVector {
        self.direction.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector::new())
    }

    pub fn get_direction(&self) -> &super::networkbasetypes::CMsgVector {
        self.direction.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector::default_instance())
    }

    fn get_direction_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &self.direction
    }

    fn mut_direction_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &mut self.direction
    }

    // optional float duration = 2;

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    fn get_duration_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.duration
    }

    fn mut_duration_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.duration
    }
}

impl ::protobuf::Message for CDOTAUserMsg_GlobalLightDirection {
    fn is_initialized(&self) -> bool {
        for v in &self.direction {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.direction)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.direction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.duration {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.direction.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_GlobalLightDirection {
    fn new() -> CDOTAUserMsg_GlobalLightDirection {
        CDOTAUserMsg_GlobalLightDirection::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_GlobalLightDirection>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector>>(
                    "direction",
                    CDOTAUserMsg_GlobalLightDirection::get_direction_for_reflect,
                    CDOTAUserMsg_GlobalLightDirection::mut_direction_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "duration",
                    CDOTAUserMsg_GlobalLightDirection::get_duration_for_reflect,
                    CDOTAUserMsg_GlobalLightDirection::mut_duration_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_GlobalLightDirection>(
                    "CDOTAUserMsg_GlobalLightDirection",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_GlobalLightDirection {
    fn clear(&mut self) {
        self.clear_direction();
        self.clear_duration();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_GlobalLightDirection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_GlobalLightDirection {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_LocationPing {
    // message fields
    player_id: ::std::option::Option<u32>,
    location_ping: ::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_LocationPing>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_LocationPing {}

impl CDOTAUserMsg_LocationPing {
    pub fn new() -> CDOTAUserMsg_LocationPing {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_LocationPing {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_LocationPing> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_LocationPing,
        };
        unsafe {
            instance.get(CDOTAUserMsg_LocationPing::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional .CDOTAMsg_LocationPing location_ping = 2;

    pub fn clear_location_ping(&mut self) {
        self.location_ping.clear();
    }

    pub fn has_location_ping(&self) -> bool {
        self.location_ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location_ping(&mut self, v: super::dota_commonmessages::CDOTAMsg_LocationPing) {
        self.location_ping = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location_ping(&mut self) -> &mut super::dota_commonmessages::CDOTAMsg_LocationPing {
        if self.location_ping.is_none() {
            self.location_ping.set_default();
        }
        self.location_ping.as_mut().unwrap()
    }

    // Take field
    pub fn take_location_ping(&mut self) -> super::dota_commonmessages::CDOTAMsg_LocationPing {
        self.location_ping.take().unwrap_or_else(|| super::dota_commonmessages::CDOTAMsg_LocationPing::new())
    }

    pub fn get_location_ping(&self) -> &super::dota_commonmessages::CDOTAMsg_LocationPing {
        self.location_ping.as_ref().unwrap_or_else(|| super::dota_commonmessages::CDOTAMsg_LocationPing::default_instance())
    }

    fn get_location_ping_for_reflect(&self) -> &::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_LocationPing> {
        &self.location_ping
    }

    fn mut_location_ping_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_LocationPing> {
        &mut self.location_ping
    }
}

impl ::protobuf::Message for CDOTAUserMsg_LocationPing {
    fn is_initialized(&self) -> bool {
        for v in &self.location_ping {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location_ping)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.location_ping.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.location_ping.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_LocationPing {
    fn new() -> CDOTAUserMsg_LocationPing {
        CDOTAUserMsg_LocationPing::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_LocationPing>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_LocationPing::get_player_id_for_reflect,
                    CDOTAUserMsg_LocationPing::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_commonmessages::CDOTAMsg_LocationPing>>(
                    "location_ping",
                    CDOTAUserMsg_LocationPing::get_location_ping_for_reflect,
                    CDOTAUserMsg_LocationPing::mut_location_ping_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_LocationPing>(
                    "CDOTAUserMsg_LocationPing",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_LocationPing {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_location_ping();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_LocationPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_LocationPing {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ItemAlert {
    // message fields
    player_id: ::std::option::Option<u32>,
    item_alert: ::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_ItemAlert>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ItemAlert {}

impl CDOTAUserMsg_ItemAlert {
    pub fn new() -> CDOTAUserMsg_ItemAlert {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ItemAlert {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ItemAlert> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ItemAlert,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ItemAlert::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional .CDOTAMsg_ItemAlert item_alert = 2;

    pub fn clear_item_alert(&mut self) {
        self.item_alert.clear();
    }

    pub fn has_item_alert(&self) -> bool {
        self.item_alert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_alert(&mut self, v: super::dota_commonmessages::CDOTAMsg_ItemAlert) {
        self.item_alert = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_alert(&mut self) -> &mut super::dota_commonmessages::CDOTAMsg_ItemAlert {
        if self.item_alert.is_none() {
            self.item_alert.set_default();
        }
        self.item_alert.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_alert(&mut self) -> super::dota_commonmessages::CDOTAMsg_ItemAlert {
        self.item_alert.take().unwrap_or_else(|| super::dota_commonmessages::CDOTAMsg_ItemAlert::new())
    }

    pub fn get_item_alert(&self) -> &super::dota_commonmessages::CDOTAMsg_ItemAlert {
        self.item_alert.as_ref().unwrap_or_else(|| super::dota_commonmessages::CDOTAMsg_ItemAlert::default_instance())
    }

    fn get_item_alert_for_reflect(&self) -> &::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_ItemAlert> {
        &self.item_alert
    }

    fn mut_item_alert_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_ItemAlert> {
        &mut self.item_alert
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ItemAlert {
    fn is_initialized(&self) -> bool {
        for v in &self.item_alert {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.item_alert)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.item_alert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.item_alert.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ItemAlert {
    fn new() -> CDOTAUserMsg_ItemAlert {
        CDOTAUserMsg_ItemAlert::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ItemAlert>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_ItemAlert::get_player_id_for_reflect,
                    CDOTAUserMsg_ItemAlert::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_commonmessages::CDOTAMsg_ItemAlert>>(
                    "item_alert",
                    CDOTAUserMsg_ItemAlert::get_item_alert_for_reflect,
                    CDOTAUserMsg_ItemAlert::mut_item_alert_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ItemAlert>(
                    "CDOTAUserMsg_ItemAlert",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ItemAlert {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_item_alert();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ItemAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ItemAlert {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_EnemyItemAlert {
    // message fields
    player_id: ::std::option::Option<u32>,
    target_player_id: ::std::option::Option<u32>,
    itemid: ::std::option::Option<i32>,
    rune_type: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_EnemyItemAlert {}

impl CDOTAUserMsg_EnemyItemAlert {
    pub fn new() -> CDOTAUserMsg_EnemyItemAlert {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_EnemyItemAlert {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_EnemyItemAlert> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_EnemyItemAlert,
        };
        unsafe {
            instance.get(CDOTAUserMsg_EnemyItemAlert::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional uint32 target_player_id = 2;

    pub fn clear_target_player_id(&mut self) {
        self.target_player_id = ::std::option::Option::None;
    }

    pub fn has_target_player_id(&self) -> bool {
        self.target_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_id(&mut self, v: u32) {
        self.target_player_id = ::std::option::Option::Some(v);
    }

    pub fn get_target_player_id(&self) -> u32 {
        self.target_player_id.unwrap_or(0)
    }

    fn get_target_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_player_id
    }

    fn mut_target_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_player_id
    }

    // optional int32 itemid = 3;

    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: i32) {
        self.itemid = ::std::option::Option::Some(v);
    }

    pub fn get_itemid(&self) -> i32 {
        self.itemid.unwrap_or(0)
    }

    fn get_itemid_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.itemid
    }

    fn mut_itemid_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.itemid
    }

    // optional uint32 rune_type = 4;

    pub fn clear_rune_type(&mut self) {
        self.rune_type = ::std::option::Option::None;
    }

    pub fn has_rune_type(&self) -> bool {
        self.rune_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rune_type(&mut self, v: u32) {
        self.rune_type = ::std::option::Option::Some(v);
    }

    pub fn get_rune_type(&self) -> u32 {
        self.rune_type.unwrap_or(0)
    }

    fn get_rune_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.rune_type
    }

    fn mut_rune_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.rune_type
    }
}

impl ::protobuf::Message for CDOTAUserMsg_EnemyItemAlert {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_player_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.itemid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rune_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_player_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rune_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_player_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.itemid {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.rune_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_EnemyItemAlert {
    fn new() -> CDOTAUserMsg_EnemyItemAlert {
        CDOTAUserMsg_EnemyItemAlert::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_EnemyItemAlert>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_EnemyItemAlert::get_player_id_for_reflect,
                    CDOTAUserMsg_EnemyItemAlert::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_player_id",
                    CDOTAUserMsg_EnemyItemAlert::get_target_player_id_for_reflect,
                    CDOTAUserMsg_EnemyItemAlert::mut_target_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "itemid",
                    CDOTAUserMsg_EnemyItemAlert::get_itemid_for_reflect,
                    CDOTAUserMsg_EnemyItemAlert::mut_itemid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rune_type",
                    CDOTAUserMsg_EnemyItemAlert::get_rune_type_for_reflect,
                    CDOTAUserMsg_EnemyItemAlert::mut_rune_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_EnemyItemAlert>(
                    "CDOTAUserMsg_EnemyItemAlert",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_EnemyItemAlert {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_target_player_id();
        self.clear_itemid();
        self.clear_rune_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_EnemyItemAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_EnemyItemAlert {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ModifierAlert {
    // message fields
    player_id: ::std::option::Option<u32>,
    class_name: ::protobuf::SingularField<::std::string::String>,
    stack_count: ::std::option::Option<u32>,
    is_debuff: ::std::option::Option<bool>,
    target_entindex: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ModifierAlert {}

impl CDOTAUserMsg_ModifierAlert {
    pub fn new() -> CDOTAUserMsg_ModifierAlert {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ModifierAlert {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ModifierAlert> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ModifierAlert,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ModifierAlert::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional string class_name = 2;

    pub fn clear_class_name(&mut self) {
        self.class_name.clear();
    }

    pub fn has_class_name(&self) -> bool {
        self.class_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_name(&mut self, v: ::std::string::String) {
        self.class_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class_name(&mut self) -> &mut ::std::string::String {
        if self.class_name.is_none() {
            self.class_name.set_default();
        }
        self.class_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_class_name(&mut self) -> ::std::string::String {
        self.class_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_class_name(&self) -> &str {
        match self.class_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_class_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.class_name
    }

    fn mut_class_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.class_name
    }

    // optional uint32 stack_count = 3;

    pub fn clear_stack_count(&mut self) {
        self.stack_count = ::std::option::Option::None;
    }

    pub fn has_stack_count(&self) -> bool {
        self.stack_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_count(&mut self, v: u32) {
        self.stack_count = ::std::option::Option::Some(v);
    }

    pub fn get_stack_count(&self) -> u32 {
        self.stack_count.unwrap_or(0)
    }

    fn get_stack_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.stack_count
    }

    fn mut_stack_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.stack_count
    }

    // optional bool is_debuff = 4;

    pub fn clear_is_debuff(&mut self) {
        self.is_debuff = ::std::option::Option::None;
    }

    pub fn has_is_debuff(&self) -> bool {
        self.is_debuff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_debuff(&mut self, v: bool) {
        self.is_debuff = ::std::option::Option::Some(v);
    }

    pub fn get_is_debuff(&self) -> bool {
        self.is_debuff.unwrap_or(false)
    }

    fn get_is_debuff_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.is_debuff
    }

    fn mut_is_debuff_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.is_debuff
    }

    // optional uint32 target_entindex = 5;

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: u32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    pub fn get_target_entindex(&self) -> u32 {
        self.target_entindex.unwrap_or(0)
    }

    fn get_target_entindex_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_entindex
    }

    fn mut_target_entindex_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_entindex
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ModifierAlert {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.class_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stack_count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_debuff = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_entindex = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.class_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.stack_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_debuff {
            my_size += 2;
        }
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.class_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.stack_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.is_debuff {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ModifierAlert {
    fn new() -> CDOTAUserMsg_ModifierAlert {
        CDOTAUserMsg_ModifierAlert::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ModifierAlert>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_ModifierAlert::get_player_id_for_reflect,
                    CDOTAUserMsg_ModifierAlert::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "class_name",
                    CDOTAUserMsg_ModifierAlert::get_class_name_for_reflect,
                    CDOTAUserMsg_ModifierAlert::mut_class_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stack_count",
                    CDOTAUserMsg_ModifierAlert::get_stack_count_for_reflect,
                    CDOTAUserMsg_ModifierAlert::mut_stack_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_debuff",
                    CDOTAUserMsg_ModifierAlert::get_is_debuff_for_reflect,
                    CDOTAUserMsg_ModifierAlert::mut_is_debuff_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_entindex",
                    CDOTAUserMsg_ModifierAlert::get_target_entindex_for_reflect,
                    CDOTAUserMsg_ModifierAlert::mut_target_entindex_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ModifierAlert>(
                    "CDOTAUserMsg_ModifierAlert",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ModifierAlert {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_class_name();
        self.clear_stack_count();
        self.clear_is_debuff();
        self.clear_target_entindex();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ModifierAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ModifierAlert {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_HPManaAlert {
    // message fields
    player_id: ::std::option::Option<u32>,
    target_entindex: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_HPManaAlert {}

impl CDOTAUserMsg_HPManaAlert {
    pub fn new() -> CDOTAUserMsg_HPManaAlert {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_HPManaAlert {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_HPManaAlert> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_HPManaAlert,
        };
        unsafe {
            instance.get(CDOTAUserMsg_HPManaAlert::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional uint32 target_entindex = 2;

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: u32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    pub fn get_target_entindex(&self) -> u32 {
        self.target_entindex.unwrap_or(0)
    }

    fn get_target_entindex_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_entindex
    }

    fn mut_target_entindex_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_entindex
    }
}

impl ::protobuf::Message for CDOTAUserMsg_HPManaAlert {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_entindex = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_HPManaAlert {
    fn new() -> CDOTAUserMsg_HPManaAlert {
        CDOTAUserMsg_HPManaAlert::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_HPManaAlert>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_HPManaAlert::get_player_id_for_reflect,
                    CDOTAUserMsg_HPManaAlert::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_entindex",
                    CDOTAUserMsg_HPManaAlert::get_target_entindex_for_reflect,
                    CDOTAUserMsg_HPManaAlert::mut_target_entindex_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_HPManaAlert>(
                    "CDOTAUserMsg_HPManaAlert",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_HPManaAlert {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_target_entindex();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_HPManaAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_HPManaAlert {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_GlyphAlert {
    // message fields
    player_id: ::std::option::Option<u32>,
    negative: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_GlyphAlert {}

impl CDOTAUserMsg_GlyphAlert {
    pub fn new() -> CDOTAUserMsg_GlyphAlert {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_GlyphAlert {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_GlyphAlert> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_GlyphAlert,
        };
        unsafe {
            instance.get(CDOTAUserMsg_GlyphAlert::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional bool negative = 2;

    pub fn clear_negative(&mut self) {
        self.negative = ::std::option::Option::None;
    }

    pub fn has_negative(&self) -> bool {
        self.negative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative(&mut self, v: bool) {
        self.negative = ::std::option::Option::Some(v);
    }

    pub fn get_negative(&self) -> bool {
        self.negative.unwrap_or(false)
    }

    fn get_negative_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.negative
    }

    fn mut_negative_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.negative
    }
}

impl ::protobuf::Message for CDOTAUserMsg_GlyphAlert {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.negative = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.negative {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.negative {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_GlyphAlert {
    fn new() -> CDOTAUserMsg_GlyphAlert {
        CDOTAUserMsg_GlyphAlert::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_GlyphAlert>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_GlyphAlert::get_player_id_for_reflect,
                    CDOTAUserMsg_GlyphAlert::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "negative",
                    CDOTAUserMsg_GlyphAlert::get_negative_for_reflect,
                    CDOTAUserMsg_GlyphAlert::mut_negative_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_GlyphAlert>(
                    "CDOTAUserMsg_GlyphAlert",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_GlyphAlert {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_negative();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_GlyphAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_GlyphAlert {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_WillPurchaseAlert {
    // message fields
    itemid: ::std::option::Option<i32>,
    player_id: ::std::option::Option<i32>,
    gold_remaining: ::std::option::Option<u32>,
    suggestion_player_id: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_WillPurchaseAlert {}

impl CDOTAUserMsg_WillPurchaseAlert {
    pub fn new() -> CDOTAUserMsg_WillPurchaseAlert {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_WillPurchaseAlert {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_WillPurchaseAlert> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_WillPurchaseAlert,
        };
        unsafe {
            instance.get(CDOTAUserMsg_WillPurchaseAlert::new)
        }
    }

    // optional int32 itemid = 1;

    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: i32) {
        self.itemid = ::std::option::Option::Some(v);
    }

    pub fn get_itemid(&self) -> i32 {
        self.itemid.unwrap_or(0)
    }

    fn get_itemid_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.itemid
    }

    fn mut_itemid_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.itemid
    }

    // optional int32 player_id = 2;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.player_id
    }

    // optional uint32 gold_remaining = 3;

    pub fn clear_gold_remaining(&mut self) {
        self.gold_remaining = ::std::option::Option::None;
    }

    pub fn has_gold_remaining(&self) -> bool {
        self.gold_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_remaining(&mut self, v: u32) {
        self.gold_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_gold_remaining(&self) -> u32 {
        self.gold_remaining.unwrap_or(0)
    }

    fn get_gold_remaining_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gold_remaining
    }

    fn mut_gold_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gold_remaining
    }

    // optional int32 suggestion_player_id = 4;

    pub fn clear_suggestion_player_id(&mut self) {
        self.suggestion_player_id = ::std::option::Option::None;
    }

    pub fn has_suggestion_player_id(&self) -> bool {
        self.suggestion_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suggestion_player_id(&mut self, v: i32) {
        self.suggestion_player_id = ::std::option::Option::Some(v);
    }

    pub fn get_suggestion_player_id(&self) -> i32 {
        self.suggestion_player_id.unwrap_or(0)
    }

    fn get_suggestion_player_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.suggestion_player_id
    }

    fn mut_suggestion_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.suggestion_player_id
    }
}

impl ::protobuf::Message for CDOTAUserMsg_WillPurchaseAlert {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.itemid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gold_remaining = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.suggestion_player_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gold_remaining {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.suggestion_player_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.itemid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.gold_remaining {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.suggestion_player_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_WillPurchaseAlert {
    fn new() -> CDOTAUserMsg_WillPurchaseAlert {
        CDOTAUserMsg_WillPurchaseAlert::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_WillPurchaseAlert>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "itemid",
                    CDOTAUserMsg_WillPurchaseAlert::get_itemid_for_reflect,
                    CDOTAUserMsg_WillPurchaseAlert::mut_itemid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_id",
                    CDOTAUserMsg_WillPurchaseAlert::get_player_id_for_reflect,
                    CDOTAUserMsg_WillPurchaseAlert::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gold_remaining",
                    CDOTAUserMsg_WillPurchaseAlert::get_gold_remaining_for_reflect,
                    CDOTAUserMsg_WillPurchaseAlert::mut_gold_remaining_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "suggestion_player_id",
                    CDOTAUserMsg_WillPurchaseAlert::get_suggestion_player_id_for_reflect,
                    CDOTAUserMsg_WillPurchaseAlert::mut_suggestion_player_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_WillPurchaseAlert>(
                    "CDOTAUserMsg_WillPurchaseAlert",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_WillPurchaseAlert {
    fn clear(&mut self) {
        self.clear_itemid();
        self.clear_player_id();
        self.clear_gold_remaining();
        self.clear_suggestion_player_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_WillPurchaseAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_WillPurchaseAlert {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_BuyBackStateAlert {
    // message fields
    player_id: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_BuyBackStateAlert {}

impl CDOTAUserMsg_BuyBackStateAlert {
    pub fn new() -> CDOTAUserMsg_BuyBackStateAlert {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_BuyBackStateAlert {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_BuyBackStateAlert> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_BuyBackStateAlert,
        };
        unsafe {
            instance.get(CDOTAUserMsg_BuyBackStateAlert::new)
        }
    }

    // optional int32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.player_id
    }
}

impl ::protobuf::Message for CDOTAUserMsg_BuyBackStateAlert {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_BuyBackStateAlert {
    fn new() -> CDOTAUserMsg_BuyBackStateAlert {
        CDOTAUserMsg_BuyBackStateAlert::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_BuyBackStateAlert>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_id",
                    CDOTAUserMsg_BuyBackStateAlert::get_player_id_for_reflect,
                    CDOTAUserMsg_BuyBackStateAlert::mut_player_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_BuyBackStateAlert>(
                    "CDOTAUserMsg_BuyBackStateAlert",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_BuyBackStateAlert {
    fn clear(&mut self) {
        self.clear_player_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_BuyBackStateAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_BuyBackStateAlert {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_QuickBuyAlert {
    // message fields
    player_id: ::std::option::Option<i32>,
    itemid: ::std::option::Option<i32>,
    gold_required: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_QuickBuyAlert {}

impl CDOTAUserMsg_QuickBuyAlert {
    pub fn new() -> CDOTAUserMsg_QuickBuyAlert {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_QuickBuyAlert {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_QuickBuyAlert> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_QuickBuyAlert,
        };
        unsafe {
            instance.get(CDOTAUserMsg_QuickBuyAlert::new)
        }
    }

    // optional int32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.player_id
    }

    // optional int32 itemid = 2;

    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: i32) {
        self.itemid = ::std::option::Option::Some(v);
    }

    pub fn get_itemid(&self) -> i32 {
        self.itemid.unwrap_or(0)
    }

    fn get_itemid_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.itemid
    }

    fn mut_itemid_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.itemid
    }

    // optional int32 gold_required = 3;

    pub fn clear_gold_required(&mut self) {
        self.gold_required = ::std::option::Option::None;
    }

    pub fn has_gold_required(&self) -> bool {
        self.gold_required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_required(&mut self, v: i32) {
        self.gold_required = ::std::option::Option::Some(v);
    }

    pub fn get_gold_required(&self) -> i32 {
        self.gold_required.unwrap_or(0)
    }

    fn get_gold_required_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.gold_required
    }

    fn mut_gold_required_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.gold_required
    }
}

impl ::protobuf::Message for CDOTAUserMsg_QuickBuyAlert {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.itemid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.gold_required = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gold_required {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.itemid {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.gold_required {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_QuickBuyAlert {
    fn new() -> CDOTAUserMsg_QuickBuyAlert {
        CDOTAUserMsg_QuickBuyAlert::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_QuickBuyAlert>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_id",
                    CDOTAUserMsg_QuickBuyAlert::get_player_id_for_reflect,
                    CDOTAUserMsg_QuickBuyAlert::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "itemid",
                    CDOTAUserMsg_QuickBuyAlert::get_itemid_for_reflect,
                    CDOTAUserMsg_QuickBuyAlert::mut_itemid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "gold_required",
                    CDOTAUserMsg_QuickBuyAlert::get_gold_required_for_reflect,
                    CDOTAUserMsg_QuickBuyAlert::mut_gold_required_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_QuickBuyAlert>(
                    "CDOTAUserMsg_QuickBuyAlert",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_QuickBuyAlert {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_itemid();
        self.clear_gold_required();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_QuickBuyAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_QuickBuyAlert {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_CourierKilledAlert {
    // message fields
    team: ::std::option::Option<u32>,
    gold_value: ::std::option::Option<u32>,
    entity_handle: ::std::option::Option<i32>,
    timestamp: ::std::option::Option<i32>,
    lost_items: ::protobuf::RepeatedField<CDOTAUserMsg_CourierKilledAlert_LostItem>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_CourierKilledAlert {}

impl CDOTAUserMsg_CourierKilledAlert {
    pub fn new() -> CDOTAUserMsg_CourierKilledAlert {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_CourierKilledAlert {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_CourierKilledAlert> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_CourierKilledAlert,
        };
        unsafe {
            instance.get(CDOTAUserMsg_CourierKilledAlert::new)
        }
    }

    // optional uint32 team = 1;

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    pub fn get_team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    fn get_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team
    }

    fn mut_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team
    }

    // optional uint32 gold_value = 2;

    pub fn clear_gold_value(&mut self) {
        self.gold_value = ::std::option::Option::None;
    }

    pub fn has_gold_value(&self) -> bool {
        self.gold_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_value(&mut self, v: u32) {
        self.gold_value = ::std::option::Option::Some(v);
    }

    pub fn get_gold_value(&self) -> u32 {
        self.gold_value.unwrap_or(0)
    }

    fn get_gold_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gold_value
    }

    fn mut_gold_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gold_value
    }

    // optional int32 entity_handle = 3;

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = ::std::option::Option::None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: i32) {
        self.entity_handle = ::std::option::Option::Some(v);
    }

    pub fn get_entity_handle(&self) -> i32 {
        self.entity_handle.unwrap_or(0)
    }

    fn get_entity_handle_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entity_handle
    }

    fn mut_entity_handle_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entity_handle
    }

    // optional int32 timestamp = 4;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp(&self) -> i32 {
        self.timestamp.unwrap_or(0)
    }

    fn get_timestamp_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.timestamp
    }

    fn mut_timestamp_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.timestamp
    }

    // repeated .CDOTAUserMsg_CourierKilledAlert.LostItem lost_items = 5;

    pub fn clear_lost_items(&mut self) {
        self.lost_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_lost_items(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_CourierKilledAlert_LostItem>) {
        self.lost_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lost_items(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_CourierKilledAlert_LostItem> {
        &mut self.lost_items
    }

    // Take field
    pub fn take_lost_items(&mut self) -> ::protobuf::RepeatedField<CDOTAUserMsg_CourierKilledAlert_LostItem> {
        ::std::mem::replace(&mut self.lost_items, ::protobuf::RepeatedField::new())
    }

    pub fn get_lost_items(&self) -> &[CDOTAUserMsg_CourierKilledAlert_LostItem] {
        &self.lost_items
    }

    fn get_lost_items_for_reflect(&self) -> &::protobuf::RepeatedField<CDOTAUserMsg_CourierKilledAlert_LostItem> {
        &self.lost_items
    }

    fn mut_lost_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_CourierKilledAlert_LostItem> {
        &mut self.lost_items
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CourierKilledAlert {
    fn is_initialized(&self) -> bool {
        for v in &self.lost_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gold_value = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entity_handle = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.lost_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gold_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entity_handle {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.lost_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gold_value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.entity_handle {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int32(4, v)?;
        }
        for v in &self.lost_items {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_CourierKilledAlert {
    fn new() -> CDOTAUserMsg_CourierKilledAlert {
        CDOTAUserMsg_CourierKilledAlert::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_CourierKilledAlert>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team",
                    CDOTAUserMsg_CourierKilledAlert::get_team_for_reflect,
                    CDOTAUserMsg_CourierKilledAlert::mut_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gold_value",
                    CDOTAUserMsg_CourierKilledAlert::get_gold_value_for_reflect,
                    CDOTAUserMsg_CourierKilledAlert::mut_gold_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entity_handle",
                    CDOTAUserMsg_CourierKilledAlert::get_entity_handle_for_reflect,
                    CDOTAUserMsg_CourierKilledAlert::mut_entity_handle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "timestamp",
                    CDOTAUserMsg_CourierKilledAlert::get_timestamp_for_reflect,
                    CDOTAUserMsg_CourierKilledAlert::mut_timestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_CourierKilledAlert_LostItem>>(
                    "lost_items",
                    CDOTAUserMsg_CourierKilledAlert::get_lost_items_for_reflect,
                    CDOTAUserMsg_CourierKilledAlert::mut_lost_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_CourierKilledAlert>(
                    "CDOTAUserMsg_CourierKilledAlert",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_CourierKilledAlert {
    fn clear(&mut self) {
        self.clear_team();
        self.clear_gold_value();
        self.clear_entity_handle();
        self.clear_timestamp();
        self.clear_lost_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_CourierKilledAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CourierKilledAlert {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_CourierKilledAlert_LostItem {
    // message fields
    item: ::std::option::Option<i32>,
    quantity: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_CourierKilledAlert_LostItem {}

impl CDOTAUserMsg_CourierKilledAlert_LostItem {
    pub fn new() -> CDOTAUserMsg_CourierKilledAlert_LostItem {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_CourierKilledAlert_LostItem {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_CourierKilledAlert_LostItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_CourierKilledAlert_LostItem,
        };
        unsafe {
            instance.get(CDOTAUserMsg_CourierKilledAlert_LostItem::new)
        }
    }

    // optional int32 item = 1;

    pub fn clear_item(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: i32) {
        self.item = ::std::option::Option::Some(v);
    }

    pub fn get_item(&self) -> i32 {
        self.item.unwrap_or(0)
    }

    fn get_item_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.item
    }

    fn mut_item_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.item
    }

    // optional uint32 quantity = 2;

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    pub fn get_quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    fn get_quantity_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.quantity
    }

    fn mut_quantity_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.quantity
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CourierKilledAlert_LostItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.item = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quantity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_CourierKilledAlert_LostItem {
    fn new() -> CDOTAUserMsg_CourierKilledAlert_LostItem {
        CDOTAUserMsg_CourierKilledAlert_LostItem::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_CourierKilledAlert_LostItem>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "item",
                    CDOTAUserMsg_CourierKilledAlert_LostItem::get_item_for_reflect,
                    CDOTAUserMsg_CourierKilledAlert_LostItem::mut_item_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quantity",
                    CDOTAUserMsg_CourierKilledAlert_LostItem::get_quantity_for_reflect,
                    CDOTAUserMsg_CourierKilledAlert_LostItem::mut_quantity_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_CourierKilledAlert_LostItem>(
                    "CDOTAUserMsg_CourierKilledAlert_LostItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_CourierKilledAlert_LostItem {
    fn clear(&mut self) {
        self.clear_item();
        self.clear_quantity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_CourierKilledAlert_LostItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CourierKilledAlert_LostItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_MinimapEvent {
    // message fields
    event_type: ::std::option::Option<i32>,
    entity_handle: ::std::option::Option<i32>,
    x: ::std::option::Option<i32>,
    y: ::std::option::Option<i32>,
    duration: ::std::option::Option<i32>,
    target_entity_handle: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_MinimapEvent {}

impl CDOTAUserMsg_MinimapEvent {
    pub fn new() -> CDOTAUserMsg_MinimapEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_MinimapEvent {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_MinimapEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_MinimapEvent,
        };
        unsafe {
            instance.get(CDOTAUserMsg_MinimapEvent::new)
        }
    }

    // optional int32 event_type = 1;

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: i32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    pub fn get_event_type(&self) -> i32 {
        self.event_type.unwrap_or(0)
    }

    fn get_event_type_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.event_type
    }

    fn mut_event_type_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.event_type
    }

    // optional int32 entity_handle = 2;

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = ::std::option::Option::None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: i32) {
        self.entity_handle = ::std::option::Option::Some(v);
    }

    pub fn get_entity_handle(&self) -> i32 {
        self.entity_handle.unwrap_or(0)
    }

    fn get_entity_handle_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entity_handle
    }

    fn mut_entity_handle_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entity_handle
    }

    // optional int32 x = 3;

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = ::std::option::Option::Some(v);
    }

    pub fn get_x(&self) -> i32 {
        self.x.unwrap_or(0)
    }

    fn get_x_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.x
    }

    fn mut_x_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.x
    }

    // optional int32 y = 4;

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = ::std::option::Option::Some(v);
    }

    pub fn get_y(&self) -> i32 {
        self.y.unwrap_or(0)
    }

    fn get_y_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.y
    }

    fn mut_y_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.y
    }

    // optional int32 duration = 5;

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    pub fn get_duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    fn get_duration_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.duration
    }

    fn mut_duration_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.duration
    }

    // optional int32 target_entity_handle = 6;

    pub fn clear_target_entity_handle(&mut self) {
        self.target_entity_handle = ::std::option::Option::None;
    }

    pub fn has_target_entity_handle(&self) -> bool {
        self.target_entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entity_handle(&mut self, v: i32) {
        self.target_entity_handle = ::std::option::Option::Some(v);
    }

    pub fn get_target_entity_handle(&self) -> i32 {
        self.target_entity_handle.unwrap_or(0)
    }

    fn get_target_entity_handle_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.target_entity_handle
    }

    fn mut_target_entity_handle_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.target_entity_handle
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MinimapEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.event_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entity_handle = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.x = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.y = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_entity_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entity_handle {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.y {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_entity_handle {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.entity_handle {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.x {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.y {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.target_entity_handle {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_MinimapEvent {
    fn new() -> CDOTAUserMsg_MinimapEvent {
        CDOTAUserMsg_MinimapEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_MinimapEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "event_type",
                    CDOTAUserMsg_MinimapEvent::get_event_type_for_reflect,
                    CDOTAUserMsg_MinimapEvent::mut_event_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entity_handle",
                    CDOTAUserMsg_MinimapEvent::get_entity_handle_for_reflect,
                    CDOTAUserMsg_MinimapEvent::mut_entity_handle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "x",
                    CDOTAUserMsg_MinimapEvent::get_x_for_reflect,
                    CDOTAUserMsg_MinimapEvent::mut_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "y",
                    CDOTAUserMsg_MinimapEvent::get_y_for_reflect,
                    CDOTAUserMsg_MinimapEvent::mut_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "duration",
                    CDOTAUserMsg_MinimapEvent::get_duration_for_reflect,
                    CDOTAUserMsg_MinimapEvent::mut_duration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_entity_handle",
                    CDOTAUserMsg_MinimapEvent::get_target_entity_handle_for_reflect,
                    CDOTAUserMsg_MinimapEvent::mut_target_entity_handle_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_MinimapEvent>(
                    "CDOTAUserMsg_MinimapEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_MinimapEvent {
    fn clear(&mut self) {
        self.clear_event_type();
        self.clear_entity_handle();
        self.clear_x();
        self.clear_y();
        self.clear_duration();
        self.clear_target_entity_handle();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_MinimapEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_MinimapEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_MapLine {
    // message fields
    player_id: ::std::option::Option<i32>,
    mapline: ::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_MapLine>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_MapLine {}

impl CDOTAUserMsg_MapLine {
    pub fn new() -> CDOTAUserMsg_MapLine {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_MapLine {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_MapLine> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_MapLine,
        };
        unsafe {
            instance.get(CDOTAUserMsg_MapLine::new)
        }
    }

    // optional int32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.player_id
    }

    // optional .CDOTAMsg_MapLine mapline = 2;

    pub fn clear_mapline(&mut self) {
        self.mapline.clear();
    }

    pub fn has_mapline(&self) -> bool {
        self.mapline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mapline(&mut self, v: super::dota_commonmessages::CDOTAMsg_MapLine) {
        self.mapline = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mapline(&mut self) -> &mut super::dota_commonmessages::CDOTAMsg_MapLine {
        if self.mapline.is_none() {
            self.mapline.set_default();
        }
        self.mapline.as_mut().unwrap()
    }

    // Take field
    pub fn take_mapline(&mut self) -> super::dota_commonmessages::CDOTAMsg_MapLine {
        self.mapline.take().unwrap_or_else(|| super::dota_commonmessages::CDOTAMsg_MapLine::new())
    }

    pub fn get_mapline(&self) -> &super::dota_commonmessages::CDOTAMsg_MapLine {
        self.mapline.as_ref().unwrap_or_else(|| super::dota_commonmessages::CDOTAMsg_MapLine::default_instance())
    }

    fn get_mapline_for_reflect(&self) -> &::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_MapLine> {
        &self.mapline
    }

    fn mut_mapline_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_MapLine> {
        &mut self.mapline
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MapLine {
    fn is_initialized(&self) -> bool {
        for v in &self.mapline {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mapline)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.mapline.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.mapline.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_MapLine {
    fn new() -> CDOTAUserMsg_MapLine {
        CDOTAUserMsg_MapLine::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_MapLine>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_id",
                    CDOTAUserMsg_MapLine::get_player_id_for_reflect,
                    CDOTAUserMsg_MapLine::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_commonmessages::CDOTAMsg_MapLine>>(
                    "mapline",
                    CDOTAUserMsg_MapLine::get_mapline_for_reflect,
                    CDOTAUserMsg_MapLine::mut_mapline_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_MapLine>(
                    "CDOTAUserMsg_MapLine",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_MapLine {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_mapline();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_MapLine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_MapLine {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_MinimapDebugPoint {
    // message fields
    location: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector>,
    color: ::std::option::Option<u32>,
    size: ::std::option::Option<i32>,
    duration: ::std::option::Option<f32>,
    index: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_MinimapDebugPoint {}

impl CDOTAUserMsg_MinimapDebugPoint {
    pub fn new() -> CDOTAUserMsg_MinimapDebugPoint {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_MinimapDebugPoint {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_MinimapDebugPoint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_MinimapDebugPoint,
        };
        unsafe {
            instance.get(CDOTAUserMsg_MinimapDebugPoint::new)
        }
    }

    // optional .CMsgVector location = 1;

    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: super::networkbasetypes::CMsgVector) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut super::networkbasetypes::CMsgVector {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> super::networkbasetypes::CMsgVector {
        self.location.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector::new())
    }

    pub fn get_location(&self) -> &super::networkbasetypes::CMsgVector {
        self.location.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector::default_instance())
    }

    fn get_location_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &self.location
    }

    fn mut_location_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &mut self.location
    }

    // optional uint32 color = 2;

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    pub fn get_color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    fn get_color_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.color
    }

    fn mut_color_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.color
    }

    // optional int32 size = 3;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i32) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> i32 {
        self.size.unwrap_or(0)
    }

    fn get_size_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.size
    }

    fn mut_size_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.size
    }

    // optional float duration = 4;

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    fn get_duration_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.duration
    }

    fn mut_duration_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.duration
    }

    // optional int32 index = 5;

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    fn get_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.index
    }

    fn mut_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.index
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MinimapDebugPoint {
    fn is_initialized(&self) -> bool {
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.color = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.duration {
            my_size += 5;
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.location.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.color {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.size {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.index {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_MinimapDebugPoint {
    fn new() -> CDOTAUserMsg_MinimapDebugPoint {
        CDOTAUserMsg_MinimapDebugPoint::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_MinimapDebugPoint>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector>>(
                    "location",
                    CDOTAUserMsg_MinimapDebugPoint::get_location_for_reflect,
                    CDOTAUserMsg_MinimapDebugPoint::mut_location_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "color",
                    CDOTAUserMsg_MinimapDebugPoint::get_color_for_reflect,
                    CDOTAUserMsg_MinimapDebugPoint::mut_color_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "size",
                    CDOTAUserMsg_MinimapDebugPoint::get_size_for_reflect,
                    CDOTAUserMsg_MinimapDebugPoint::mut_size_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "duration",
                    CDOTAUserMsg_MinimapDebugPoint::get_duration_for_reflect,
                    CDOTAUserMsg_MinimapDebugPoint::mut_duration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "index",
                    CDOTAUserMsg_MinimapDebugPoint::get_index_for_reflect,
                    CDOTAUserMsg_MinimapDebugPoint::mut_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_MinimapDebugPoint>(
                    "CDOTAUserMsg_MinimapDebugPoint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_MinimapDebugPoint {
    fn clear(&mut self) {
        self.clear_location();
        self.clear_color();
        self.clear_size();
        self.clear_duration();
        self.clear_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_MinimapDebugPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_MinimapDebugPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_CreateLinearProjectile {
    // message fields
    origin: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector>,
    velocity: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector2D>,
    entindex: ::std::option::Option<i32>,
    particle_index: ::std::option::Option<u64>,
    handle: ::std::option::Option<i32>,
    acceleration: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector2D>,
    max_speed: ::std::option::Option<f32>,
    fow_radius: ::std::option::Option<f32>,
    sticky_fow_reveal: ::std::option::Option<bool>,
    distance: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_CreateLinearProjectile {}

impl CDOTAUserMsg_CreateLinearProjectile {
    pub fn new() -> CDOTAUserMsg_CreateLinearProjectile {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_CreateLinearProjectile {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_CreateLinearProjectile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_CreateLinearProjectile,
        };
        unsafe {
            instance.get(CDOTAUserMsg_CreateLinearProjectile::new)
        }
    }

    // optional .CMsgVector origin = 1;

    pub fn clear_origin(&mut self) {
        self.origin.clear();
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: super::networkbasetypes::CMsgVector) {
        self.origin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin(&mut self) -> &mut super::networkbasetypes::CMsgVector {
        if self.origin.is_none() {
            self.origin.set_default();
        }
        self.origin.as_mut().unwrap()
    }

    // Take field
    pub fn take_origin(&mut self) -> super::networkbasetypes::CMsgVector {
        self.origin.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector::new())
    }

    pub fn get_origin(&self) -> &super::networkbasetypes::CMsgVector {
        self.origin.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector::default_instance())
    }

    fn get_origin_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &self.origin
    }

    fn mut_origin_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &mut self.origin
    }

    // optional .CMsgVector2D velocity = 2;

    pub fn clear_velocity(&mut self) {
        self.velocity.clear();
    }

    pub fn has_velocity(&self) -> bool {
        self.velocity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_velocity(&mut self, v: super::networkbasetypes::CMsgVector2D) {
        self.velocity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_velocity(&mut self) -> &mut super::networkbasetypes::CMsgVector2D {
        if self.velocity.is_none() {
            self.velocity.set_default();
        }
        self.velocity.as_mut().unwrap()
    }

    // Take field
    pub fn take_velocity(&mut self) -> super::networkbasetypes::CMsgVector2D {
        self.velocity.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector2D::new())
    }

    pub fn get_velocity(&self) -> &super::networkbasetypes::CMsgVector2D {
        self.velocity.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector2D::default_instance())
    }

    fn get_velocity_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector2D> {
        &self.velocity
    }

    fn mut_velocity_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector2D> {
        &mut self.velocity
    }

    // optional int32 entindex = 4;

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    pub fn get_entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    fn get_entindex_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entindex
    }

    fn mut_entindex_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entindex
    }

    // optional uint64 particle_index = 5;

    pub fn clear_particle_index(&mut self) {
        self.particle_index = ::std::option::Option::None;
    }

    pub fn has_particle_index(&self) -> bool {
        self.particle_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_index(&mut self, v: u64) {
        self.particle_index = ::std::option::Option::Some(v);
    }

    pub fn get_particle_index(&self) -> u64 {
        self.particle_index.unwrap_or(0)
    }

    fn get_particle_index_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.particle_index
    }

    fn mut_particle_index_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.particle_index
    }

    // optional int32 handle = 6;

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i32) {
        self.handle = ::std::option::Option::Some(v);
    }

    pub fn get_handle(&self) -> i32 {
        self.handle.unwrap_or(0)
    }

    fn get_handle_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.handle
    }

    fn mut_handle_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.handle
    }

    // optional .CMsgVector2D acceleration = 7;

    pub fn clear_acceleration(&mut self) {
        self.acceleration.clear();
    }

    pub fn has_acceleration(&self) -> bool {
        self.acceleration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acceleration(&mut self, v: super::networkbasetypes::CMsgVector2D) {
        self.acceleration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_acceleration(&mut self) -> &mut super::networkbasetypes::CMsgVector2D {
        if self.acceleration.is_none() {
            self.acceleration.set_default();
        }
        self.acceleration.as_mut().unwrap()
    }

    // Take field
    pub fn take_acceleration(&mut self) -> super::networkbasetypes::CMsgVector2D {
        self.acceleration.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector2D::new())
    }

    pub fn get_acceleration(&self) -> &super::networkbasetypes::CMsgVector2D {
        self.acceleration.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector2D::default_instance())
    }

    fn get_acceleration_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector2D> {
        &self.acceleration
    }

    fn mut_acceleration_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector2D> {
        &mut self.acceleration
    }

    // optional float max_speed = 8;

    pub fn clear_max_speed(&mut self) {
        self.max_speed = ::std::option::Option::None;
    }

    pub fn has_max_speed(&self) -> bool {
        self.max_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_speed(&mut self, v: f32) {
        self.max_speed = ::std::option::Option::Some(v);
    }

    pub fn get_max_speed(&self) -> f32 {
        self.max_speed.unwrap_or(0.)
    }

    fn get_max_speed_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.max_speed
    }

    fn mut_max_speed_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.max_speed
    }

    // optional float fow_radius = 9;

    pub fn clear_fow_radius(&mut self) {
        self.fow_radius = ::std::option::Option::None;
    }

    pub fn has_fow_radius(&self) -> bool {
        self.fow_radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fow_radius(&mut self, v: f32) {
        self.fow_radius = ::std::option::Option::Some(v);
    }

    pub fn get_fow_radius(&self) -> f32 {
        self.fow_radius.unwrap_or(0.)
    }

    fn get_fow_radius_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.fow_radius
    }

    fn mut_fow_radius_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.fow_radius
    }

    // optional bool sticky_fow_reveal = 10;

    pub fn clear_sticky_fow_reveal(&mut self) {
        self.sticky_fow_reveal = ::std::option::Option::None;
    }

    pub fn has_sticky_fow_reveal(&self) -> bool {
        self.sticky_fow_reveal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sticky_fow_reveal(&mut self, v: bool) {
        self.sticky_fow_reveal = ::std::option::Option::Some(v);
    }

    pub fn get_sticky_fow_reveal(&self) -> bool {
        self.sticky_fow_reveal.unwrap_or(false)
    }

    fn get_sticky_fow_reveal_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.sticky_fow_reveal
    }

    fn mut_sticky_fow_reveal_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.sticky_fow_reveal
    }

    // optional float distance = 11;

    pub fn clear_distance(&mut self) {
        self.distance = ::std::option::Option::None;
    }

    pub fn has_distance(&self) -> bool {
        self.distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f32) {
        self.distance = ::std::option::Option::Some(v);
    }

    pub fn get_distance(&self) -> f32 {
        self.distance.unwrap_or(0.)
    }

    fn get_distance_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.distance
    }

    fn mut_distance_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.distance
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CreateLinearProjectile {
    fn is_initialized(&self) -> bool {
        for v in &self.origin {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.velocity {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.acceleration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.origin)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.velocity)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entindex = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.particle_index = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.handle = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.acceleration)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.max_speed = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.fow_radius = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sticky_fow_reveal = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.distance = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.velocity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.particle_index {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.handle {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.acceleration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.max_speed {
            my_size += 5;
        }
        if let Some(v) = self.fow_radius {
            my_size += 5;
        }
        if let Some(v) = self.sticky_fow_reveal {
            my_size += 2;
        }
        if let Some(v) = self.distance {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.origin.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.velocity.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.entindex {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.particle_index {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.handle {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.acceleration.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.max_speed {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.fow_radius {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.sticky_fow_reveal {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.distance {
            os.write_float(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_CreateLinearProjectile {
    fn new() -> CDOTAUserMsg_CreateLinearProjectile {
        CDOTAUserMsg_CreateLinearProjectile::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_CreateLinearProjectile>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector>>(
                    "origin",
                    CDOTAUserMsg_CreateLinearProjectile::get_origin_for_reflect,
                    CDOTAUserMsg_CreateLinearProjectile::mut_origin_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector2D>>(
                    "velocity",
                    CDOTAUserMsg_CreateLinearProjectile::get_velocity_for_reflect,
                    CDOTAUserMsg_CreateLinearProjectile::mut_velocity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entindex",
                    CDOTAUserMsg_CreateLinearProjectile::get_entindex_for_reflect,
                    CDOTAUserMsg_CreateLinearProjectile::mut_entindex_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "particle_index",
                    CDOTAUserMsg_CreateLinearProjectile::get_particle_index_for_reflect,
                    CDOTAUserMsg_CreateLinearProjectile::mut_particle_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "handle",
                    CDOTAUserMsg_CreateLinearProjectile::get_handle_for_reflect,
                    CDOTAUserMsg_CreateLinearProjectile::mut_handle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector2D>>(
                    "acceleration",
                    CDOTAUserMsg_CreateLinearProjectile::get_acceleration_for_reflect,
                    CDOTAUserMsg_CreateLinearProjectile::mut_acceleration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "max_speed",
                    CDOTAUserMsg_CreateLinearProjectile::get_max_speed_for_reflect,
                    CDOTAUserMsg_CreateLinearProjectile::mut_max_speed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "fow_radius",
                    CDOTAUserMsg_CreateLinearProjectile::get_fow_radius_for_reflect,
                    CDOTAUserMsg_CreateLinearProjectile::mut_fow_radius_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "sticky_fow_reveal",
                    CDOTAUserMsg_CreateLinearProjectile::get_sticky_fow_reveal_for_reflect,
                    CDOTAUserMsg_CreateLinearProjectile::mut_sticky_fow_reveal_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "distance",
                    CDOTAUserMsg_CreateLinearProjectile::get_distance_for_reflect,
                    CDOTAUserMsg_CreateLinearProjectile::mut_distance_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_CreateLinearProjectile>(
                    "CDOTAUserMsg_CreateLinearProjectile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_CreateLinearProjectile {
    fn clear(&mut self) {
        self.clear_origin();
        self.clear_velocity();
        self.clear_entindex();
        self.clear_particle_index();
        self.clear_handle();
        self.clear_acceleration();
        self.clear_max_speed();
        self.clear_fow_radius();
        self.clear_sticky_fow_reveal();
        self.clear_distance();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_CreateLinearProjectile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CreateLinearProjectile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_DestroyLinearProjectile {
    // message fields
    handle: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_DestroyLinearProjectile {}

impl CDOTAUserMsg_DestroyLinearProjectile {
    pub fn new() -> CDOTAUserMsg_DestroyLinearProjectile {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_DestroyLinearProjectile {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_DestroyLinearProjectile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_DestroyLinearProjectile,
        };
        unsafe {
            instance.get(CDOTAUserMsg_DestroyLinearProjectile::new)
        }
    }

    // optional int32 handle = 1;

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i32) {
        self.handle = ::std::option::Option::Some(v);
    }

    pub fn get_handle(&self) -> i32 {
        self.handle.unwrap_or(0)
    }

    fn get_handle_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.handle
    }

    fn mut_handle_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.handle
    }
}

impl ::protobuf::Message for CDOTAUserMsg_DestroyLinearProjectile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.handle {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_DestroyLinearProjectile {
    fn new() -> CDOTAUserMsg_DestroyLinearProjectile {
        CDOTAUserMsg_DestroyLinearProjectile::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_DestroyLinearProjectile>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "handle",
                    CDOTAUserMsg_DestroyLinearProjectile::get_handle_for_reflect,
                    CDOTAUserMsg_DestroyLinearProjectile::mut_handle_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_DestroyLinearProjectile>(
                    "CDOTAUserMsg_DestroyLinearProjectile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_DestroyLinearProjectile {
    fn clear(&mut self) {
        self.clear_handle();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_DestroyLinearProjectile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_DestroyLinearProjectile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_DodgeTrackingProjectiles {
    // message fields
    entindex: ::std::option::Option<i32>,
    attacks_only: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_DodgeTrackingProjectiles {}

impl CDOTAUserMsg_DodgeTrackingProjectiles {
    pub fn new() -> CDOTAUserMsg_DodgeTrackingProjectiles {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_DodgeTrackingProjectiles {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_DodgeTrackingProjectiles> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_DodgeTrackingProjectiles,
        };
        unsafe {
            instance.get(CDOTAUserMsg_DodgeTrackingProjectiles::new)
        }
    }

    // required int32 entindex = 1;

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    pub fn get_entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    fn get_entindex_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entindex
    }

    fn mut_entindex_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entindex
    }

    // optional bool attacks_only = 2;

    pub fn clear_attacks_only(&mut self) {
        self.attacks_only = ::std::option::Option::None;
    }

    pub fn has_attacks_only(&self) -> bool {
        self.attacks_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attacks_only(&mut self, v: bool) {
        self.attacks_only = ::std::option::Option::Some(v);
    }

    pub fn get_attacks_only(&self) -> bool {
        self.attacks_only.unwrap_or(false)
    }

    fn get_attacks_only_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.attacks_only
    }

    fn mut_attacks_only_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.attacks_only
    }
}

impl ::protobuf::Message for CDOTAUserMsg_DodgeTrackingProjectiles {
    fn is_initialized(&self) -> bool {
        if self.entindex.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entindex = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.attacks_only = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.attacks_only {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.attacks_only {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_DodgeTrackingProjectiles {
    fn new() -> CDOTAUserMsg_DodgeTrackingProjectiles {
        CDOTAUserMsg_DodgeTrackingProjectiles::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_DodgeTrackingProjectiles>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entindex",
                    CDOTAUserMsg_DodgeTrackingProjectiles::get_entindex_for_reflect,
                    CDOTAUserMsg_DodgeTrackingProjectiles::mut_entindex_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "attacks_only",
                    CDOTAUserMsg_DodgeTrackingProjectiles::get_attacks_only_for_reflect,
                    CDOTAUserMsg_DodgeTrackingProjectiles::mut_attacks_only_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_DodgeTrackingProjectiles>(
                    "CDOTAUserMsg_DodgeTrackingProjectiles",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_DodgeTrackingProjectiles {
    fn clear(&mut self) {
        self.clear_entindex();
        self.clear_attacks_only();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_DodgeTrackingProjectiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_DodgeTrackingProjectiles {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_SpectatorPlayerClick {
    // message fields
    entindex: ::std::option::Option<i32>,
    order_type: ::std::option::Option<i32>,
    target_index: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_SpectatorPlayerClick {}

impl CDOTAUserMsg_SpectatorPlayerClick {
    pub fn new() -> CDOTAUserMsg_SpectatorPlayerClick {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_SpectatorPlayerClick {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_SpectatorPlayerClick> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_SpectatorPlayerClick,
        };
        unsafe {
            instance.get(CDOTAUserMsg_SpectatorPlayerClick::new)
        }
    }

    // required int32 entindex = 1;

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    pub fn get_entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    fn get_entindex_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entindex
    }

    fn mut_entindex_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entindex
    }

    // optional int32 order_type = 2;

    pub fn clear_order_type(&mut self) {
        self.order_type = ::std::option::Option::None;
    }

    pub fn has_order_type(&self) -> bool {
        self.order_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: i32) {
        self.order_type = ::std::option::Option::Some(v);
    }

    pub fn get_order_type(&self) -> i32 {
        self.order_type.unwrap_or(0)
    }

    fn get_order_type_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.order_type
    }

    fn mut_order_type_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.order_type
    }

    // optional int32 target_index = 3;

    pub fn clear_target_index(&mut self) {
        self.target_index = ::std::option::Option::None;
    }

    pub fn has_target_index(&self) -> bool {
        self.target_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_index(&mut self, v: i32) {
        self.target_index = ::std::option::Option::Some(v);
    }

    pub fn get_target_index(&self) -> i32 {
        self.target_index.unwrap_or(0)
    }

    fn get_target_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.target_index
    }

    fn mut_target_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.target_index
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SpectatorPlayerClick {
    fn is_initialized(&self) -> bool {
        if self.entindex.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entindex = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.order_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.order_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_index {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.order_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.target_index {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_SpectatorPlayerClick {
    fn new() -> CDOTAUserMsg_SpectatorPlayerClick {
        CDOTAUserMsg_SpectatorPlayerClick::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_SpectatorPlayerClick>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entindex",
                    CDOTAUserMsg_SpectatorPlayerClick::get_entindex_for_reflect,
                    CDOTAUserMsg_SpectatorPlayerClick::mut_entindex_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "order_type",
                    CDOTAUserMsg_SpectatorPlayerClick::get_order_type_for_reflect,
                    CDOTAUserMsg_SpectatorPlayerClick::mut_order_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_index",
                    CDOTAUserMsg_SpectatorPlayerClick::get_target_index_for_reflect,
                    CDOTAUserMsg_SpectatorPlayerClick::mut_target_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_SpectatorPlayerClick>(
                    "CDOTAUserMsg_SpectatorPlayerClick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_SpectatorPlayerClick {
    fn clear(&mut self) {
        self.clear_entindex();
        self.clear_order_type();
        self.clear_target_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_SpectatorPlayerClick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SpectatorPlayerClick {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_SpectatorPlayerUnitOrders {
    // message fields
    entindex: ::std::option::Option<i32>,
    order_type: ::std::option::Option<i32>,
    units: ::std::vec::Vec<i32>,
    target_index: ::std::option::Option<i32>,
    ability_index: ::std::option::Option<i32>,
    position: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector>,
    queue: ::std::option::Option<bool>,
    sequence_number: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_SpectatorPlayerUnitOrders {}

impl CDOTAUserMsg_SpectatorPlayerUnitOrders {
    pub fn new() -> CDOTAUserMsg_SpectatorPlayerUnitOrders {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_SpectatorPlayerUnitOrders {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_SpectatorPlayerUnitOrders> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_SpectatorPlayerUnitOrders,
        };
        unsafe {
            instance.get(CDOTAUserMsg_SpectatorPlayerUnitOrders::new)
        }
    }

    // optional int32 entindex = 1;

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    pub fn get_entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    fn get_entindex_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entindex
    }

    fn mut_entindex_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entindex
    }

    // optional int32 order_type = 2;

    pub fn clear_order_type(&mut self) {
        self.order_type = ::std::option::Option::None;
    }

    pub fn has_order_type(&self) -> bool {
        self.order_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: i32) {
        self.order_type = ::std::option::Option::Some(v);
    }

    pub fn get_order_type(&self) -> i32 {
        self.order_type.unwrap_or(0)
    }

    fn get_order_type_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.order_type
    }

    fn mut_order_type_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.order_type
    }

    // repeated int32 units = 3;

    pub fn clear_units(&mut self) {
        self.units.clear();
    }

    // Param is passed by value, moved
    pub fn set_units(&mut self, v: ::std::vec::Vec<i32>) {
        self.units = v;
    }

    // Mutable pointer to the field.
    pub fn mut_units(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.units
    }

    // Take field
    pub fn take_units(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.units, ::std::vec::Vec::new())
    }

    pub fn get_units(&self) -> &[i32] {
        &self.units
    }

    fn get_units_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.units
    }

    fn mut_units_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.units
    }

    // optional int32 target_index = 4;

    pub fn clear_target_index(&mut self) {
        self.target_index = ::std::option::Option::None;
    }

    pub fn has_target_index(&self) -> bool {
        self.target_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_index(&mut self, v: i32) {
        self.target_index = ::std::option::Option::Some(v);
    }

    pub fn get_target_index(&self) -> i32 {
        self.target_index.unwrap_or(0)
    }

    fn get_target_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.target_index
    }

    fn mut_target_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.target_index
    }

    // optional int32 ability_index = 5;

    pub fn clear_ability_index(&mut self) {
        self.ability_index = ::std::option::Option::None;
    }

    pub fn has_ability_index(&self) -> bool {
        self.ability_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_index(&mut self, v: i32) {
        self.ability_index = ::std::option::Option::Some(v);
    }

    pub fn get_ability_index(&self) -> i32 {
        self.ability_index.unwrap_or(0)
    }

    fn get_ability_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.ability_index
    }

    fn mut_ability_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.ability_index
    }

    // optional .CMsgVector position = 6;

    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: super::networkbasetypes::CMsgVector) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut super::networkbasetypes::CMsgVector {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> super::networkbasetypes::CMsgVector {
        self.position.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector::new())
    }

    pub fn get_position(&self) -> &super::networkbasetypes::CMsgVector {
        self.position.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector::default_instance())
    }

    fn get_position_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &self.position
    }

    fn mut_position_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &mut self.position
    }

    // optional bool queue = 7;

    pub fn clear_queue(&mut self) {
        self.queue = ::std::option::Option::None;
    }

    pub fn has_queue(&self) -> bool {
        self.queue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue(&mut self, v: bool) {
        self.queue = ::std::option::Option::Some(v);
    }

    pub fn get_queue(&self) -> bool {
        self.queue.unwrap_or(false)
    }

    fn get_queue_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.queue
    }

    fn mut_queue_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.queue
    }

    // optional int32 sequence_number = 8;

    pub fn clear_sequence_number(&mut self) {
        self.sequence_number = ::std::option::Option::None;
    }

    pub fn has_sequence_number(&self) -> bool {
        self.sequence_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_number(&mut self, v: i32) {
        self.sequence_number = ::std::option::Option::Some(v);
    }

    pub fn get_sequence_number(&self) -> i32 {
        self.sequence_number.unwrap_or(0)
    }

    fn get_sequence_number_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.sequence_number
    }

    fn mut_sequence_number_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.sequence_number
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SpectatorPlayerUnitOrders {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entindex = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.order_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.units)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_index = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ability_index = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.queue = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sequence_number = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.order_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.units {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.target_index {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ability_index {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.queue {
            my_size += 2;
        }
        if let Some(v) = self.sequence_number {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.order_type {
            os.write_int32(2, v)?;
        }
        for v in &self.units {
            os.write_int32(3, *v)?;
        };
        if let Some(v) = self.target_index {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.ability_index {
            os.write_int32(5, v)?;
        }
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.queue {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.sequence_number {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_SpectatorPlayerUnitOrders {
    fn new() -> CDOTAUserMsg_SpectatorPlayerUnitOrders {
        CDOTAUserMsg_SpectatorPlayerUnitOrders::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_SpectatorPlayerUnitOrders>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entindex",
                    CDOTAUserMsg_SpectatorPlayerUnitOrders::get_entindex_for_reflect,
                    CDOTAUserMsg_SpectatorPlayerUnitOrders::mut_entindex_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "order_type",
                    CDOTAUserMsg_SpectatorPlayerUnitOrders::get_order_type_for_reflect,
                    CDOTAUserMsg_SpectatorPlayerUnitOrders::mut_order_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "units",
                    CDOTAUserMsg_SpectatorPlayerUnitOrders::get_units_for_reflect,
                    CDOTAUserMsg_SpectatorPlayerUnitOrders::mut_units_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_index",
                    CDOTAUserMsg_SpectatorPlayerUnitOrders::get_target_index_for_reflect,
                    CDOTAUserMsg_SpectatorPlayerUnitOrders::mut_target_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ability_index",
                    CDOTAUserMsg_SpectatorPlayerUnitOrders::get_ability_index_for_reflect,
                    CDOTAUserMsg_SpectatorPlayerUnitOrders::mut_ability_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector>>(
                    "position",
                    CDOTAUserMsg_SpectatorPlayerUnitOrders::get_position_for_reflect,
                    CDOTAUserMsg_SpectatorPlayerUnitOrders::mut_position_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "queue",
                    CDOTAUserMsg_SpectatorPlayerUnitOrders::get_queue_for_reflect,
                    CDOTAUserMsg_SpectatorPlayerUnitOrders::mut_queue_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "sequence_number",
                    CDOTAUserMsg_SpectatorPlayerUnitOrders::get_sequence_number_for_reflect,
                    CDOTAUserMsg_SpectatorPlayerUnitOrders::mut_sequence_number_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_SpectatorPlayerUnitOrders>(
                    "CDOTAUserMsg_SpectatorPlayerUnitOrders",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_SpectatorPlayerUnitOrders {
    fn clear(&mut self) {
        self.clear_entindex();
        self.clear_order_type();
        self.clear_units();
        self.clear_target_index();
        self.clear_ability_index();
        self.clear_position();
        self.clear_queue();
        self.clear_sequence_number();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_SpectatorPlayerUnitOrders {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SpectatorPlayerUnitOrders {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_NevermoreRequiem {
    // message fields
    entity_handle: ::std::option::Option<i32>,
    lines: ::std::option::Option<i32>,
    origin: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector>,
    reverse: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_NevermoreRequiem {}

impl CDOTAUserMsg_NevermoreRequiem {
    pub fn new() -> CDOTAUserMsg_NevermoreRequiem {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_NevermoreRequiem {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_NevermoreRequiem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_NevermoreRequiem,
        };
        unsafe {
            instance.get(CDOTAUserMsg_NevermoreRequiem::new)
        }
    }

    // optional int32 entity_handle = 1;

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = ::std::option::Option::None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: i32) {
        self.entity_handle = ::std::option::Option::Some(v);
    }

    pub fn get_entity_handle(&self) -> i32 {
        self.entity_handle.unwrap_or(0)
    }

    fn get_entity_handle_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entity_handle
    }

    fn mut_entity_handle_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entity_handle
    }

    // optional int32 lines = 2;

    pub fn clear_lines(&mut self) {
        self.lines = ::std::option::Option::None;
    }

    pub fn has_lines(&self) -> bool {
        self.lines.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lines(&mut self, v: i32) {
        self.lines = ::std::option::Option::Some(v);
    }

    pub fn get_lines(&self) -> i32 {
        self.lines.unwrap_or(0)
    }

    fn get_lines_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.lines
    }

    fn mut_lines_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.lines
    }

    // optional .CMsgVector origin = 3;

    pub fn clear_origin(&mut self) {
        self.origin.clear();
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: super::networkbasetypes::CMsgVector) {
        self.origin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin(&mut self) -> &mut super::networkbasetypes::CMsgVector {
        if self.origin.is_none() {
            self.origin.set_default();
        }
        self.origin.as_mut().unwrap()
    }

    // Take field
    pub fn take_origin(&mut self) -> super::networkbasetypes::CMsgVector {
        self.origin.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector::new())
    }

    pub fn get_origin(&self) -> &super::networkbasetypes::CMsgVector {
        self.origin.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector::default_instance())
    }

    fn get_origin_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &self.origin
    }

    fn mut_origin_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &mut self.origin
    }

    // optional bool reverse = 4;

    pub fn clear_reverse(&mut self) {
        self.reverse = ::std::option::Option::None;
    }

    pub fn has_reverse(&self) -> bool {
        self.reverse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = ::std::option::Option::Some(v);
    }

    pub fn get_reverse(&self) -> bool {
        self.reverse.unwrap_or(false)
    }

    fn get_reverse_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.reverse
    }

    fn mut_reverse_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.reverse
    }
}

impl ::protobuf::Message for CDOTAUserMsg_NevermoreRequiem {
    fn is_initialized(&self) -> bool {
        for v in &self.origin {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entity_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lines = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.origin)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entity_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lines {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.reverse {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entity_handle {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.lines {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.origin.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.reverse {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_NevermoreRequiem {
    fn new() -> CDOTAUserMsg_NevermoreRequiem {
        CDOTAUserMsg_NevermoreRequiem::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_NevermoreRequiem>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entity_handle",
                    CDOTAUserMsg_NevermoreRequiem::get_entity_handle_for_reflect,
                    CDOTAUserMsg_NevermoreRequiem::mut_entity_handle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "lines",
                    CDOTAUserMsg_NevermoreRequiem::get_lines_for_reflect,
                    CDOTAUserMsg_NevermoreRequiem::mut_lines_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector>>(
                    "origin",
                    CDOTAUserMsg_NevermoreRequiem::get_origin_for_reflect,
                    CDOTAUserMsg_NevermoreRequiem::mut_origin_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "reverse",
                    CDOTAUserMsg_NevermoreRequiem::get_reverse_for_reflect,
                    CDOTAUserMsg_NevermoreRequiem::mut_reverse_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_NevermoreRequiem>(
                    "CDOTAUserMsg_NevermoreRequiem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_NevermoreRequiem {
    fn clear(&mut self) {
        self.clear_entity_handle();
        self.clear_lines();
        self.clear_origin();
        self.clear_reverse();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_NevermoreRequiem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_NevermoreRequiem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_InvalidCommand {
    // message fields
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_InvalidCommand {}

impl CDOTAUserMsg_InvalidCommand {
    pub fn new() -> CDOTAUserMsg_InvalidCommand {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_InvalidCommand {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_InvalidCommand> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_InvalidCommand,
        };
        unsafe {
            instance.get(CDOTAUserMsg_InvalidCommand::new)
        }
    }

    // optional string message = 1;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }
}

impl ::protobuf::Message for CDOTAUserMsg_InvalidCommand {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_InvalidCommand {
    fn new() -> CDOTAUserMsg_InvalidCommand {
        CDOTAUserMsg_InvalidCommand::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_InvalidCommand>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    CDOTAUserMsg_InvalidCommand::get_message_for_reflect,
                    CDOTAUserMsg_InvalidCommand::mut_message_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_InvalidCommand>(
                    "CDOTAUserMsg_InvalidCommand",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_InvalidCommand {
    fn clear(&mut self) {
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_InvalidCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_InvalidCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_HudError {
    // message fields
    order_id: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_HudError {}

impl CDOTAUserMsg_HudError {
    pub fn new() -> CDOTAUserMsg_HudError {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_HudError {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_HudError> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_HudError,
        };
        unsafe {
            instance.get(CDOTAUserMsg_HudError::new)
        }
    }

    // optional int32 order_id = 1;

    pub fn clear_order_id(&mut self) {
        self.order_id = ::std::option::Option::None;
    }

    pub fn has_order_id(&self) -> bool {
        self.order_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_id(&mut self, v: i32) {
        self.order_id = ::std::option::Option::Some(v);
    }

    pub fn get_order_id(&self) -> i32 {
        self.order_id.unwrap_or(0)
    }

    fn get_order_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.order_id
    }

    fn mut_order_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.order_id
    }
}

impl ::protobuf::Message for CDOTAUserMsg_HudError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.order_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.order_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.order_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_HudError {
    fn new() -> CDOTAUserMsg_HudError {
        CDOTAUserMsg_HudError::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_HudError>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "order_id",
                    CDOTAUserMsg_HudError::get_order_id_for_reflect,
                    CDOTAUserMsg_HudError::mut_order_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_HudError>(
                    "CDOTAUserMsg_HudError",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_HudError {
    fn clear(&mut self) {
        self.clear_order_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_HudError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_HudError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_SharedCooldown {
    // message fields
    entindex: ::std::option::Option<i32>,
    name: ::protobuf::SingularField<::std::string::String>,
    cooldown: ::std::option::Option<f32>,
    name_index: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_SharedCooldown {}

impl CDOTAUserMsg_SharedCooldown {
    pub fn new() -> CDOTAUserMsg_SharedCooldown {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_SharedCooldown {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_SharedCooldown> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_SharedCooldown,
        };
        unsafe {
            instance.get(CDOTAUserMsg_SharedCooldown::new)
        }
    }

    // optional int32 entindex = 1;

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    pub fn get_entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    fn get_entindex_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entindex
    }

    fn mut_entindex_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entindex
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional float cooldown = 3;

    pub fn clear_cooldown(&mut self) {
        self.cooldown = ::std::option::Option::None;
    }

    pub fn has_cooldown(&self) -> bool {
        self.cooldown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown(&mut self, v: f32) {
        self.cooldown = ::std::option::Option::Some(v);
    }

    pub fn get_cooldown(&self) -> f32 {
        self.cooldown.unwrap_or(0.)
    }

    fn get_cooldown_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.cooldown
    }

    fn mut_cooldown_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.cooldown
    }

    // optional int32 name_index = 4;

    pub fn clear_name_index(&mut self) {
        self.name_index = ::std::option::Option::None;
    }

    pub fn has_name_index(&self) -> bool {
        self.name_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_index(&mut self, v: i32) {
        self.name_index = ::std::option::Option::Some(v);
    }

    pub fn get_name_index(&self) -> i32 {
        self.name_index.unwrap_or(0)
    }

    fn get_name_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.name_index
    }

    fn mut_name_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.name_index
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SharedCooldown {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entindex = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cooldown = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.name_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.cooldown {
            my_size += 5;
        }
        if let Some(v) = self.name_index {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entindex {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.cooldown {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.name_index {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_SharedCooldown {
    fn new() -> CDOTAUserMsg_SharedCooldown {
        CDOTAUserMsg_SharedCooldown::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_SharedCooldown>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entindex",
                    CDOTAUserMsg_SharedCooldown::get_entindex_for_reflect,
                    CDOTAUserMsg_SharedCooldown::mut_entindex_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CDOTAUserMsg_SharedCooldown::get_name_for_reflect,
                    CDOTAUserMsg_SharedCooldown::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "cooldown",
                    CDOTAUserMsg_SharedCooldown::get_cooldown_for_reflect,
                    CDOTAUserMsg_SharedCooldown::mut_cooldown_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "name_index",
                    CDOTAUserMsg_SharedCooldown::get_name_index_for_reflect,
                    CDOTAUserMsg_SharedCooldown::mut_name_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_SharedCooldown>(
                    "CDOTAUserMsg_SharedCooldown",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_SharedCooldown {
    fn clear(&mut self) {
        self.clear_entindex();
        self.clear_name();
        self.clear_cooldown();
        self.clear_name_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_SharedCooldown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SharedCooldown {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_SetNextAutobuyItem {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_SetNextAutobuyItem {}

impl CDOTAUserMsg_SetNextAutobuyItem {
    pub fn new() -> CDOTAUserMsg_SetNextAutobuyItem {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_SetNextAutobuyItem {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_SetNextAutobuyItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_SetNextAutobuyItem,
        };
        unsafe {
            instance.get(CDOTAUserMsg_SetNextAutobuyItem::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SetNextAutobuyItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_SetNextAutobuyItem {
    fn new() -> CDOTAUserMsg_SetNextAutobuyItem {
        CDOTAUserMsg_SetNextAutobuyItem::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_SetNextAutobuyItem>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CDOTAUserMsg_SetNextAutobuyItem::get_name_for_reflect,
                    CDOTAUserMsg_SetNextAutobuyItem::mut_name_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_SetNextAutobuyItem>(
                    "CDOTAUserMsg_SetNextAutobuyItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_SetNextAutobuyItem {
    fn clear(&mut self) {
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_SetNextAutobuyItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SetNextAutobuyItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_HalloweenDrops {
    // message fields
    item_defs: ::std::vec::Vec<u32>,
    player_ids: ::std::vec::Vec<u32>,
    prize_list: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_HalloweenDrops {}

impl CDOTAUserMsg_HalloweenDrops {
    pub fn new() -> CDOTAUserMsg_HalloweenDrops {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_HalloweenDrops {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_HalloweenDrops> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_HalloweenDrops,
        };
        unsafe {
            instance.get(CDOTAUserMsg_HalloweenDrops::new)
        }
    }

    // repeated uint32 item_defs = 1;

    pub fn clear_item_defs(&mut self) {
        self.item_defs.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_defs(&mut self, v: ::std::vec::Vec<u32>) {
        self.item_defs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_defs(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.item_defs
    }

    // Take field
    pub fn take_item_defs(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.item_defs, ::std::vec::Vec::new())
    }

    pub fn get_item_defs(&self) -> &[u32] {
        &self.item_defs
    }

    fn get_item_defs_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.item_defs
    }

    fn mut_item_defs_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.item_defs
    }

    // repeated uint32 player_ids = 2;

    pub fn clear_player_ids(&mut self) {
        self.player_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.player_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.player_ids
    }

    // Take field
    pub fn take_player_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.player_ids, ::std::vec::Vec::new())
    }

    pub fn get_player_ids(&self) -> &[u32] {
        &self.player_ids
    }

    fn get_player_ids_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.player_ids
    }

    fn mut_player_ids_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.player_ids
    }

    // optional uint32 prize_list = 3;

    pub fn clear_prize_list(&mut self) {
        self.prize_list = ::std::option::Option::None;
    }

    pub fn has_prize_list(&self) -> bool {
        self.prize_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prize_list(&mut self, v: u32) {
        self.prize_list = ::std::option::Option::Some(v);
    }

    pub fn get_prize_list(&self) -> u32 {
        self.prize_list.unwrap_or(0)
    }

    fn get_prize_list_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.prize_list
    }

    fn mut_prize_list_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.prize_list
    }
}

impl ::protobuf::Message for CDOTAUserMsg_HalloweenDrops {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.item_defs)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.player_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prize_list = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item_defs {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.player_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.prize_list {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item_defs {
            os.write_uint32(1, *v)?;
        };
        for v in &self.player_ids {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.prize_list {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_HalloweenDrops {
    fn new() -> CDOTAUserMsg_HalloweenDrops {
        CDOTAUserMsg_HalloweenDrops::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_HalloweenDrops>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_defs",
                    CDOTAUserMsg_HalloweenDrops::get_item_defs_for_reflect,
                    CDOTAUserMsg_HalloweenDrops::mut_item_defs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_ids",
                    CDOTAUserMsg_HalloweenDrops::get_player_ids_for_reflect,
                    CDOTAUserMsg_HalloweenDrops::mut_player_ids_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prize_list",
                    CDOTAUserMsg_HalloweenDrops::get_prize_list_for_reflect,
                    CDOTAUserMsg_HalloweenDrops::mut_prize_list_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_HalloweenDrops>(
                    "CDOTAUserMsg_HalloweenDrops",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_HalloweenDrops {
    fn clear(&mut self) {
        self.clear_item_defs();
        self.clear_player_ids();
        self.clear_prize_list();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_HalloweenDrops {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_HalloweenDrops {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_PredictionResult {
    // message fields
    account_id: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    correct: ::std::option::Option<bool>,
    predictions: ::protobuf::RepeatedField<CDOTAUserMsg_PredictionResult_Prediction>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_PredictionResult {}

impl CDOTAUserMsg_PredictionResult {
    pub fn new() -> CDOTAUserMsg_PredictionResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_PredictionResult {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_PredictionResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_PredictionResult,
        };
        unsafe {
            instance.get(CDOTAUserMsg_PredictionResult::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint64 match_id = 2;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional bool correct = 3;

    pub fn clear_correct(&mut self) {
        self.correct = ::std::option::Option::None;
    }

    pub fn has_correct(&self) -> bool {
        self.correct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correct(&mut self, v: bool) {
        self.correct = ::std::option::Option::Some(v);
    }

    pub fn get_correct(&self) -> bool {
        self.correct.unwrap_or(false)
    }

    fn get_correct_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.correct
    }

    fn mut_correct_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.correct
    }

    // repeated .CDOTAUserMsg_PredictionResult.Prediction predictions = 4;

    pub fn clear_predictions(&mut self) {
        self.predictions.clear();
    }

    // Param is passed by value, moved
    pub fn set_predictions(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_PredictionResult_Prediction>) {
        self.predictions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_predictions(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_PredictionResult_Prediction> {
        &mut self.predictions
    }

    // Take field
    pub fn take_predictions(&mut self) -> ::protobuf::RepeatedField<CDOTAUserMsg_PredictionResult_Prediction> {
        ::std::mem::replace(&mut self.predictions, ::protobuf::RepeatedField::new())
    }

    pub fn get_predictions(&self) -> &[CDOTAUserMsg_PredictionResult_Prediction] {
        &self.predictions
    }

    fn get_predictions_for_reflect(&self) -> &::protobuf::RepeatedField<CDOTAUserMsg_PredictionResult_Prediction> {
        &self.predictions
    }

    fn mut_predictions_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_PredictionResult_Prediction> {
        &mut self.predictions
    }
}

impl ::protobuf::Message for CDOTAUserMsg_PredictionResult {
    fn is_initialized(&self) -> bool {
        for v in &self.predictions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.correct = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.predictions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.correct {
            my_size += 2;
        }
        for value in &self.predictions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.correct {
            os.write_bool(3, v)?;
        }
        for v in &self.predictions {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_PredictionResult {
    fn new() -> CDOTAUserMsg_PredictionResult {
        CDOTAUserMsg_PredictionResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_PredictionResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CDOTAUserMsg_PredictionResult::get_account_id_for_reflect,
                    CDOTAUserMsg_PredictionResult::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CDOTAUserMsg_PredictionResult::get_match_id_for_reflect,
                    CDOTAUserMsg_PredictionResult::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "correct",
                    CDOTAUserMsg_PredictionResult::get_correct_for_reflect,
                    CDOTAUserMsg_PredictionResult::mut_correct_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_PredictionResult_Prediction>>(
                    "predictions",
                    CDOTAUserMsg_PredictionResult::get_predictions_for_reflect,
                    CDOTAUserMsg_PredictionResult::mut_predictions_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_PredictionResult>(
                    "CDOTAUserMsg_PredictionResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_PredictionResult {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_match_id();
        self.clear_correct();
        self.clear_predictions();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_PredictionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_PredictionResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_PredictionResult_Prediction {
    // message fields
    item_def: ::std::option::Option<u32>,
    num_correct: ::std::option::Option<u32>,
    num_fails: ::std::option::Option<u32>,
    result: ::std::option::Option<CDOTAUserMsg_PredictionResult_Prediction_EResult>,
    granted_item_defs: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_PredictionResult_Prediction {}

impl CDOTAUserMsg_PredictionResult_Prediction {
    pub fn new() -> CDOTAUserMsg_PredictionResult_Prediction {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_PredictionResult_Prediction {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_PredictionResult_Prediction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_PredictionResult_Prediction,
        };
        unsafe {
            instance.get(CDOTAUserMsg_PredictionResult_Prediction::new)
        }
    }

    // optional uint32 item_def = 1;

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    pub fn get_item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    fn get_item_def_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_def
    }

    fn mut_item_def_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_def
    }

    // optional uint32 num_correct = 2;

    pub fn clear_num_correct(&mut self) {
        self.num_correct = ::std::option::Option::None;
    }

    pub fn has_num_correct(&self) -> bool {
        self.num_correct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_correct(&mut self, v: u32) {
        self.num_correct = ::std::option::Option::Some(v);
    }

    pub fn get_num_correct(&self) -> u32 {
        self.num_correct.unwrap_or(0)
    }

    fn get_num_correct_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.num_correct
    }

    fn mut_num_correct_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.num_correct
    }

    // optional uint32 num_fails = 3;

    pub fn clear_num_fails(&mut self) {
        self.num_fails = ::std::option::Option::None;
    }

    pub fn has_num_fails(&self) -> bool {
        self.num_fails.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_fails(&mut self, v: u32) {
        self.num_fails = ::std::option::Option::Some(v);
    }

    pub fn get_num_fails(&self) -> u32 {
        self.num_fails.unwrap_or(0)
    }

    fn get_num_fails_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.num_fails
    }

    fn mut_num_fails_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.num_fails
    }

    // optional .CDOTAUserMsg_PredictionResult.Prediction.EResult result = 4;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CDOTAUserMsg_PredictionResult_Prediction_EResult) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> CDOTAUserMsg_PredictionResult_Prediction_EResult {
        self.result.unwrap_or(CDOTAUserMsg_PredictionResult_Prediction_EResult::k_eResult_ItemGranted)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<CDOTAUserMsg_PredictionResult_Prediction_EResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<CDOTAUserMsg_PredictionResult_Prediction_EResult> {
        &mut self.result
    }

    // repeated uint32 granted_item_defs = 6;

    pub fn clear_granted_item_defs(&mut self) {
        self.granted_item_defs.clear();
    }

    // Param is passed by value, moved
    pub fn set_granted_item_defs(&mut self, v: ::std::vec::Vec<u32>) {
        self.granted_item_defs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_granted_item_defs(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.granted_item_defs
    }

    // Take field
    pub fn take_granted_item_defs(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.granted_item_defs, ::std::vec::Vec::new())
    }

    pub fn get_granted_item_defs(&self) -> &[u32] {
        &self.granted_item_defs
    }

    fn get_granted_item_defs_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.granted_item_defs
    }

    fn mut_granted_item_defs_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.granted_item_defs
    }
}

impl ::protobuf::Message for CDOTAUserMsg_PredictionResult_Prediction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_correct = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_fails = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.granted_item_defs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_correct {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_fails {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        for value in &self.granted_item_defs {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_correct {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_fails {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(4, v.value())?;
        }
        for v in &self.granted_item_defs {
            os.write_uint32(6, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_PredictionResult_Prediction {
    fn new() -> CDOTAUserMsg_PredictionResult_Prediction {
        CDOTAUserMsg_PredictionResult_Prediction::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_PredictionResult_Prediction>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_def",
                    CDOTAUserMsg_PredictionResult_Prediction::get_item_def_for_reflect,
                    CDOTAUserMsg_PredictionResult_Prediction::mut_item_def_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_correct",
                    CDOTAUserMsg_PredictionResult_Prediction::get_num_correct_for_reflect,
                    CDOTAUserMsg_PredictionResult_Prediction::mut_num_correct_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_fails",
                    CDOTAUserMsg_PredictionResult_Prediction::get_num_fails_for_reflect,
                    CDOTAUserMsg_PredictionResult_Prediction::mut_num_fails_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CDOTAUserMsg_PredictionResult_Prediction_EResult>>(
                    "result",
                    CDOTAUserMsg_PredictionResult_Prediction::get_result_for_reflect,
                    CDOTAUserMsg_PredictionResult_Prediction::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "granted_item_defs",
                    CDOTAUserMsg_PredictionResult_Prediction::get_granted_item_defs_for_reflect,
                    CDOTAUserMsg_PredictionResult_Prediction::mut_granted_item_defs_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_PredictionResult_Prediction>(
                    "CDOTAUserMsg_PredictionResult_Prediction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_PredictionResult_Prediction {
    fn clear(&mut self) {
        self.clear_item_def();
        self.clear_num_correct();
        self.clear_num_fails();
        self.clear_result();
        self.clear_granted_item_defs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_PredictionResult_Prediction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_PredictionResult_Prediction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CDOTAUserMsg_PredictionResult_Prediction_EResult {
    k_eResult_ItemGranted = 1,
    k_eResult_Destroyed = 2,
}

impl ::protobuf::ProtobufEnum for CDOTAUserMsg_PredictionResult_Prediction_EResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CDOTAUserMsg_PredictionResult_Prediction_EResult> {
        match value {
            1 => ::std::option::Option::Some(CDOTAUserMsg_PredictionResult_Prediction_EResult::k_eResult_ItemGranted),
            2 => ::std::option::Option::Some(CDOTAUserMsg_PredictionResult_Prediction_EResult::k_eResult_Destroyed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CDOTAUserMsg_PredictionResult_Prediction_EResult] = &[
            CDOTAUserMsg_PredictionResult_Prediction_EResult::k_eResult_ItemGranted,
            CDOTAUserMsg_PredictionResult_Prediction_EResult::k_eResult_Destroyed,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CDOTAUserMsg_PredictionResult_Prediction_EResult>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CDOTAUserMsg_PredictionResult_Prediction_EResult", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CDOTAUserMsg_PredictionResult_Prediction_EResult {
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_PredictionResult_Prediction_EResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAResponseQuerySerialized {
    // message fields
    facts: ::protobuf::RepeatedField<CDOTAResponseQuerySerialized_Fact>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAResponseQuerySerialized {}

impl CDOTAResponseQuerySerialized {
    pub fn new() -> CDOTAResponseQuerySerialized {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAResponseQuerySerialized {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAResponseQuerySerialized> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAResponseQuerySerialized,
        };
        unsafe {
            instance.get(CDOTAResponseQuerySerialized::new)
        }
    }

    // repeated .CDOTAResponseQuerySerialized.Fact facts = 1;

    pub fn clear_facts(&mut self) {
        self.facts.clear();
    }

    // Param is passed by value, moved
    pub fn set_facts(&mut self, v: ::protobuf::RepeatedField<CDOTAResponseQuerySerialized_Fact>) {
        self.facts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_facts(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAResponseQuerySerialized_Fact> {
        &mut self.facts
    }

    // Take field
    pub fn take_facts(&mut self) -> ::protobuf::RepeatedField<CDOTAResponseQuerySerialized_Fact> {
        ::std::mem::replace(&mut self.facts, ::protobuf::RepeatedField::new())
    }

    pub fn get_facts(&self) -> &[CDOTAResponseQuerySerialized_Fact] {
        &self.facts
    }

    fn get_facts_for_reflect(&self) -> &::protobuf::RepeatedField<CDOTAResponseQuerySerialized_Fact> {
        &self.facts
    }

    fn mut_facts_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAResponseQuerySerialized_Fact> {
        &mut self.facts
    }
}

impl ::protobuf::Message for CDOTAResponseQuerySerialized {
    fn is_initialized(&self) -> bool {
        for v in &self.facts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.facts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.facts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.facts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAResponseQuerySerialized {
    fn new() -> CDOTAResponseQuerySerialized {
        CDOTAResponseQuerySerialized::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAResponseQuerySerialized>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAResponseQuerySerialized_Fact>>(
                    "facts",
                    CDOTAResponseQuerySerialized::get_facts_for_reflect,
                    CDOTAResponseQuerySerialized::mut_facts_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAResponseQuerySerialized>(
                    "CDOTAResponseQuerySerialized",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAResponseQuerySerialized {
    fn clear(&mut self) {
        self.clear_facts();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAResponseQuerySerialized {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAResponseQuerySerialized {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAResponseQuerySerialized_Fact {
    // message fields
    key: ::std::option::Option<i32>,
    valtype: ::std::option::Option<CDOTAResponseQuerySerialized_Fact_ValueType>,
    val_numeric: ::std::option::Option<f32>,
    val_string: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAResponseQuerySerialized_Fact {}

impl CDOTAResponseQuerySerialized_Fact {
    pub fn new() -> CDOTAResponseQuerySerialized_Fact {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAResponseQuerySerialized_Fact {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAResponseQuerySerialized_Fact> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAResponseQuerySerialized_Fact,
        };
        unsafe {
            instance.get(CDOTAResponseQuerySerialized_Fact::new)
        }
    }

    // required int32 key = 1;

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: i32) {
        self.key = ::std::option::Option::Some(v);
    }

    pub fn get_key(&self) -> i32 {
        self.key.unwrap_or(0)
    }

    fn get_key_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.key
    }

    fn mut_key_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.key
    }

    // required .CDOTAResponseQuerySerialized.Fact.ValueType valtype = 2;

    pub fn clear_valtype(&mut self) {
        self.valtype = ::std::option::Option::None;
    }

    pub fn has_valtype(&self) -> bool {
        self.valtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_valtype(&mut self, v: CDOTAResponseQuerySerialized_Fact_ValueType) {
        self.valtype = ::std::option::Option::Some(v);
    }

    pub fn get_valtype(&self) -> CDOTAResponseQuerySerialized_Fact_ValueType {
        self.valtype.unwrap_or(CDOTAResponseQuerySerialized_Fact_ValueType::NUMERIC)
    }

    fn get_valtype_for_reflect(&self) -> &::std::option::Option<CDOTAResponseQuerySerialized_Fact_ValueType> {
        &self.valtype
    }

    fn mut_valtype_for_reflect(&mut self) -> &mut ::std::option::Option<CDOTAResponseQuerySerialized_Fact_ValueType> {
        &mut self.valtype
    }

    // optional float val_numeric = 3;

    pub fn clear_val_numeric(&mut self) {
        self.val_numeric = ::std::option::Option::None;
    }

    pub fn has_val_numeric(&self) -> bool {
        self.val_numeric.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_numeric(&mut self, v: f32) {
        self.val_numeric = ::std::option::Option::Some(v);
    }

    pub fn get_val_numeric(&self) -> f32 {
        self.val_numeric.unwrap_or(0.)
    }

    fn get_val_numeric_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.val_numeric
    }

    fn mut_val_numeric_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.val_numeric
    }

    // optional string val_string = 4;

    pub fn clear_val_string(&mut self) {
        self.val_string.clear();
    }

    pub fn has_val_string(&self) -> bool {
        self.val_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_string(&mut self, v: ::std::string::String) {
        self.val_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val_string(&mut self) -> &mut ::std::string::String {
        if self.val_string.is_none() {
            self.val_string.set_default();
        }
        self.val_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_val_string(&mut self) -> ::std::string::String {
        self.val_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_val_string(&self) -> &str {
        match self.val_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_val_string_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.val_string
    }

    fn mut_val_string_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.val_string
    }
}

impl ::protobuf::Message for CDOTAResponseQuerySerialized_Fact {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.valtype.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.key = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.valtype = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.val_numeric = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.val_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.key {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.valtype {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.val_numeric {
            my_size += 5;
        }
        if let Some(ref v) = self.val_string.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.valtype {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.val_numeric {
            os.write_float(3, v)?;
        }
        if let Some(ref v) = self.val_string.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAResponseQuerySerialized_Fact {
    fn new() -> CDOTAResponseQuerySerialized_Fact {
        CDOTAResponseQuerySerialized_Fact::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAResponseQuerySerialized_Fact>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "key",
                    CDOTAResponseQuerySerialized_Fact::get_key_for_reflect,
                    CDOTAResponseQuerySerialized_Fact::mut_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CDOTAResponseQuerySerialized_Fact_ValueType>>(
                    "valtype",
                    CDOTAResponseQuerySerialized_Fact::get_valtype_for_reflect,
                    CDOTAResponseQuerySerialized_Fact::mut_valtype_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "val_numeric",
                    CDOTAResponseQuerySerialized_Fact::get_val_numeric_for_reflect,
                    CDOTAResponseQuerySerialized_Fact::mut_val_numeric_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "val_string",
                    CDOTAResponseQuerySerialized_Fact::get_val_string_for_reflect,
                    CDOTAResponseQuerySerialized_Fact::mut_val_string_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAResponseQuerySerialized_Fact>(
                    "CDOTAResponseQuerySerialized_Fact",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAResponseQuerySerialized_Fact {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_valtype();
        self.clear_val_numeric();
        self.clear_val_string();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAResponseQuerySerialized_Fact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAResponseQuerySerialized_Fact {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CDOTAResponseQuerySerialized_Fact_ValueType {
    NUMERIC = 1,
    STRING = 2,
}

impl ::protobuf::ProtobufEnum for CDOTAResponseQuerySerialized_Fact_ValueType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CDOTAResponseQuerySerialized_Fact_ValueType> {
        match value {
            1 => ::std::option::Option::Some(CDOTAResponseQuerySerialized_Fact_ValueType::NUMERIC),
            2 => ::std::option::Option::Some(CDOTAResponseQuerySerialized_Fact_ValueType::STRING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CDOTAResponseQuerySerialized_Fact_ValueType] = &[
            CDOTAResponseQuerySerialized_Fact_ValueType::NUMERIC,
            CDOTAResponseQuerySerialized_Fact_ValueType::STRING,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CDOTAResponseQuerySerialized_Fact_ValueType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CDOTAResponseQuerySerialized_Fact_ValueType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CDOTAResponseQuerySerialized_Fact_ValueType {
}

impl ::protobuf::reflect::ProtobufValue for CDOTAResponseQuerySerialized_Fact_ValueType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTASpeechMatchOnClient {
    // message fields
    concept: ::std::option::Option<i32>,
    recipient_type: ::std::option::Option<i32>,
    responsequery: ::protobuf::SingularPtrField<CDOTAResponseQuerySerialized>,
    randomseed: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTASpeechMatchOnClient {}

impl CDOTASpeechMatchOnClient {
    pub fn new() -> CDOTASpeechMatchOnClient {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTASpeechMatchOnClient {
        static mut instance: ::protobuf::lazy::Lazy<CDOTASpeechMatchOnClient> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTASpeechMatchOnClient,
        };
        unsafe {
            instance.get(CDOTASpeechMatchOnClient::new)
        }
    }

    // optional int32 concept = 1;

    pub fn clear_concept(&mut self) {
        self.concept = ::std::option::Option::None;
    }

    pub fn has_concept(&self) -> bool {
        self.concept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_concept(&mut self, v: i32) {
        self.concept = ::std::option::Option::Some(v);
    }

    pub fn get_concept(&self) -> i32 {
        self.concept.unwrap_or(0)
    }

    fn get_concept_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.concept
    }

    fn mut_concept_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.concept
    }

    // optional int32 recipient_type = 2;

    pub fn clear_recipient_type(&mut self) {
        self.recipient_type = ::std::option::Option::None;
    }

    pub fn has_recipient_type(&self) -> bool {
        self.recipient_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_type(&mut self, v: i32) {
        self.recipient_type = ::std::option::Option::Some(v);
    }

    pub fn get_recipient_type(&self) -> i32 {
        self.recipient_type.unwrap_or(0)
    }

    fn get_recipient_type_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.recipient_type
    }

    fn mut_recipient_type_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.recipient_type
    }

    // optional .CDOTAResponseQuerySerialized responsequery = 3;

    pub fn clear_responsequery(&mut self) {
        self.responsequery.clear();
    }

    pub fn has_responsequery(&self) -> bool {
        self.responsequery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_responsequery(&mut self, v: CDOTAResponseQuerySerialized) {
        self.responsequery = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_responsequery(&mut self) -> &mut CDOTAResponseQuerySerialized {
        if self.responsequery.is_none() {
            self.responsequery.set_default();
        }
        self.responsequery.as_mut().unwrap()
    }

    // Take field
    pub fn take_responsequery(&mut self) -> CDOTAResponseQuerySerialized {
        self.responsequery.take().unwrap_or_else(|| CDOTAResponseQuerySerialized::new())
    }

    pub fn get_responsequery(&self) -> &CDOTAResponseQuerySerialized {
        self.responsequery.as_ref().unwrap_or_else(|| CDOTAResponseQuerySerialized::default_instance())
    }

    fn get_responsequery_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAResponseQuerySerialized> {
        &self.responsequery
    }

    fn mut_responsequery_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAResponseQuerySerialized> {
        &mut self.responsequery
    }

    // optional sfixed32 randomseed = 4;

    pub fn clear_randomseed(&mut self) {
        self.randomseed = ::std::option::Option::None;
    }

    pub fn has_randomseed(&self) -> bool {
        self.randomseed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_randomseed(&mut self, v: i32) {
        self.randomseed = ::std::option::Option::Some(v);
    }

    pub fn get_randomseed(&self) -> i32 {
        self.randomseed.unwrap_or(0i32)
    }

    fn get_randomseed_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.randomseed
    }

    fn mut_randomseed_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.randomseed
    }
}

impl ::protobuf::Message for CDOTASpeechMatchOnClient {
    fn is_initialized(&self) -> bool {
        for v in &self.responsequery {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.concept = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.recipient_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.responsequery)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sfixed32()?;
                    self.randomseed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.concept {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.recipient_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.responsequery.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.randomseed {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.concept {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.recipient_type {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.responsequery.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.randomseed {
            os.write_sfixed32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTASpeechMatchOnClient {
    fn new() -> CDOTASpeechMatchOnClient {
        CDOTASpeechMatchOnClient::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTASpeechMatchOnClient>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "concept",
                    CDOTASpeechMatchOnClient::get_concept_for_reflect,
                    CDOTASpeechMatchOnClient::mut_concept_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "recipient_type",
                    CDOTASpeechMatchOnClient::get_recipient_type_for_reflect,
                    CDOTASpeechMatchOnClient::mut_recipient_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAResponseQuerySerialized>>(
                    "responsequery",
                    CDOTASpeechMatchOnClient::get_responsequery_for_reflect,
                    CDOTASpeechMatchOnClient::mut_responsequery_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSfixed32>(
                    "randomseed",
                    CDOTASpeechMatchOnClient::get_randomseed_for_reflect,
                    CDOTASpeechMatchOnClient::mut_randomseed_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTASpeechMatchOnClient>(
                    "CDOTASpeechMatchOnClient",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTASpeechMatchOnClient {
    fn clear(&mut self) {
        self.clear_concept();
        self.clear_recipient_type();
        self.clear_responsequery();
        self.clear_randomseed();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTASpeechMatchOnClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTASpeechMatchOnClient {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_UnitEvent {
    // message fields
    msg_type: ::std::option::Option<EDotaEntityMessages>,
    entity_index: ::std::option::Option<i32>,
    speech: ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_Speech>,
    speech_mute: ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_SpeechMute>,
    add_gesture: ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_AddGesture>,
    remove_gesture: ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_RemoveGesture>,
    blood_impact: ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_BloodImpact>,
    fade_gesture: ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_FadeGesture>,
    speech_match_on_client: ::protobuf::SingularPtrField<CDOTASpeechMatchOnClient>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_UnitEvent {}

impl CDOTAUserMsg_UnitEvent {
    pub fn new() -> CDOTAUserMsg_UnitEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_UnitEvent {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_UnitEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_UnitEvent,
        };
        unsafe {
            instance.get(CDOTAUserMsg_UnitEvent::new)
        }
    }

    // required .EDotaEntityMessages msg_type = 1;

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: EDotaEntityMessages) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    pub fn get_msg_type(&self) -> EDotaEntityMessages {
        self.msg_type.unwrap_or(EDotaEntityMessages::DOTA_UNIT_SPEECH)
    }

    fn get_msg_type_for_reflect(&self) -> &::std::option::Option<EDotaEntityMessages> {
        &self.msg_type
    }

    fn mut_msg_type_for_reflect(&mut self) -> &mut ::std::option::Option<EDotaEntityMessages> {
        &mut self.msg_type
    }

    // required int32 entity_index = 2;

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = ::std::option::Option::Some(v);
    }

    pub fn get_entity_index(&self) -> i32 {
        self.entity_index.unwrap_or(0)
    }

    fn get_entity_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entity_index
    }

    fn mut_entity_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entity_index
    }

    // optional .CDOTAUserMsg_UnitEvent.Speech speech = 3;

    pub fn clear_speech(&mut self) {
        self.speech.clear();
    }

    pub fn has_speech(&self) -> bool {
        self.speech.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speech(&mut self, v: CDOTAUserMsg_UnitEvent_Speech) {
        self.speech = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_speech(&mut self) -> &mut CDOTAUserMsg_UnitEvent_Speech {
        if self.speech.is_none() {
            self.speech.set_default();
        }
        self.speech.as_mut().unwrap()
    }

    // Take field
    pub fn take_speech(&mut self) -> CDOTAUserMsg_UnitEvent_Speech {
        self.speech.take().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_Speech::new())
    }

    pub fn get_speech(&self) -> &CDOTAUserMsg_UnitEvent_Speech {
        self.speech.as_ref().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_Speech::default_instance())
    }

    fn get_speech_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_Speech> {
        &self.speech
    }

    fn mut_speech_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_Speech> {
        &mut self.speech
    }

    // optional .CDOTAUserMsg_UnitEvent.SpeechMute speech_mute = 4;

    pub fn clear_speech_mute(&mut self) {
        self.speech_mute.clear();
    }

    pub fn has_speech_mute(&self) -> bool {
        self.speech_mute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speech_mute(&mut self, v: CDOTAUserMsg_UnitEvent_SpeechMute) {
        self.speech_mute = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_speech_mute(&mut self) -> &mut CDOTAUserMsg_UnitEvent_SpeechMute {
        if self.speech_mute.is_none() {
            self.speech_mute.set_default();
        }
        self.speech_mute.as_mut().unwrap()
    }

    // Take field
    pub fn take_speech_mute(&mut self) -> CDOTAUserMsg_UnitEvent_SpeechMute {
        self.speech_mute.take().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_SpeechMute::new())
    }

    pub fn get_speech_mute(&self) -> &CDOTAUserMsg_UnitEvent_SpeechMute {
        self.speech_mute.as_ref().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_SpeechMute::default_instance())
    }

    fn get_speech_mute_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_SpeechMute> {
        &self.speech_mute
    }

    fn mut_speech_mute_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_SpeechMute> {
        &mut self.speech_mute
    }

    // optional .CDOTAUserMsg_UnitEvent.AddGesture add_gesture = 5;

    pub fn clear_add_gesture(&mut self) {
        self.add_gesture.clear();
    }

    pub fn has_add_gesture(&self) -> bool {
        self.add_gesture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_gesture(&mut self, v: CDOTAUserMsg_UnitEvent_AddGesture) {
        self.add_gesture = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_add_gesture(&mut self) -> &mut CDOTAUserMsg_UnitEvent_AddGesture {
        if self.add_gesture.is_none() {
            self.add_gesture.set_default();
        }
        self.add_gesture.as_mut().unwrap()
    }

    // Take field
    pub fn take_add_gesture(&mut self) -> CDOTAUserMsg_UnitEvent_AddGesture {
        self.add_gesture.take().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_AddGesture::new())
    }

    pub fn get_add_gesture(&self) -> &CDOTAUserMsg_UnitEvent_AddGesture {
        self.add_gesture.as_ref().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_AddGesture::default_instance())
    }

    fn get_add_gesture_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_AddGesture> {
        &self.add_gesture
    }

    fn mut_add_gesture_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_AddGesture> {
        &mut self.add_gesture
    }

    // optional .CDOTAUserMsg_UnitEvent.RemoveGesture remove_gesture = 6;

    pub fn clear_remove_gesture(&mut self) {
        self.remove_gesture.clear();
    }

    pub fn has_remove_gesture(&self) -> bool {
        self.remove_gesture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove_gesture(&mut self, v: CDOTAUserMsg_UnitEvent_RemoveGesture) {
        self.remove_gesture = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remove_gesture(&mut self) -> &mut CDOTAUserMsg_UnitEvent_RemoveGesture {
        if self.remove_gesture.is_none() {
            self.remove_gesture.set_default();
        }
        self.remove_gesture.as_mut().unwrap()
    }

    // Take field
    pub fn take_remove_gesture(&mut self) -> CDOTAUserMsg_UnitEvent_RemoveGesture {
        self.remove_gesture.take().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_RemoveGesture::new())
    }

    pub fn get_remove_gesture(&self) -> &CDOTAUserMsg_UnitEvent_RemoveGesture {
        self.remove_gesture.as_ref().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_RemoveGesture::default_instance())
    }

    fn get_remove_gesture_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_RemoveGesture> {
        &self.remove_gesture
    }

    fn mut_remove_gesture_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_RemoveGesture> {
        &mut self.remove_gesture
    }

    // optional .CDOTAUserMsg_UnitEvent.BloodImpact blood_impact = 7;

    pub fn clear_blood_impact(&mut self) {
        self.blood_impact.clear();
    }

    pub fn has_blood_impact(&self) -> bool {
        self.blood_impact.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blood_impact(&mut self, v: CDOTAUserMsg_UnitEvent_BloodImpact) {
        self.blood_impact = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blood_impact(&mut self) -> &mut CDOTAUserMsg_UnitEvent_BloodImpact {
        if self.blood_impact.is_none() {
            self.blood_impact.set_default();
        }
        self.blood_impact.as_mut().unwrap()
    }

    // Take field
    pub fn take_blood_impact(&mut self) -> CDOTAUserMsg_UnitEvent_BloodImpact {
        self.blood_impact.take().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_BloodImpact::new())
    }

    pub fn get_blood_impact(&self) -> &CDOTAUserMsg_UnitEvent_BloodImpact {
        self.blood_impact.as_ref().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_BloodImpact::default_instance())
    }

    fn get_blood_impact_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_BloodImpact> {
        &self.blood_impact
    }

    fn mut_blood_impact_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_BloodImpact> {
        &mut self.blood_impact
    }

    // optional .CDOTAUserMsg_UnitEvent.FadeGesture fade_gesture = 8;

    pub fn clear_fade_gesture(&mut self) {
        self.fade_gesture.clear();
    }

    pub fn has_fade_gesture(&self) -> bool {
        self.fade_gesture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_gesture(&mut self, v: CDOTAUserMsg_UnitEvent_FadeGesture) {
        self.fade_gesture = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fade_gesture(&mut self) -> &mut CDOTAUserMsg_UnitEvent_FadeGesture {
        if self.fade_gesture.is_none() {
            self.fade_gesture.set_default();
        }
        self.fade_gesture.as_mut().unwrap()
    }

    // Take field
    pub fn take_fade_gesture(&mut self) -> CDOTAUserMsg_UnitEvent_FadeGesture {
        self.fade_gesture.take().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_FadeGesture::new())
    }

    pub fn get_fade_gesture(&self) -> &CDOTAUserMsg_UnitEvent_FadeGesture {
        self.fade_gesture.as_ref().unwrap_or_else(|| CDOTAUserMsg_UnitEvent_FadeGesture::default_instance())
    }

    fn get_fade_gesture_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_FadeGesture> {
        &self.fade_gesture
    }

    fn mut_fade_gesture_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_UnitEvent_FadeGesture> {
        &mut self.fade_gesture
    }

    // optional .CDOTASpeechMatchOnClient speech_match_on_client = 9;

    pub fn clear_speech_match_on_client(&mut self) {
        self.speech_match_on_client.clear();
    }

    pub fn has_speech_match_on_client(&self) -> bool {
        self.speech_match_on_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speech_match_on_client(&mut self, v: CDOTASpeechMatchOnClient) {
        self.speech_match_on_client = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_speech_match_on_client(&mut self) -> &mut CDOTASpeechMatchOnClient {
        if self.speech_match_on_client.is_none() {
            self.speech_match_on_client.set_default();
        }
        self.speech_match_on_client.as_mut().unwrap()
    }

    // Take field
    pub fn take_speech_match_on_client(&mut self) -> CDOTASpeechMatchOnClient {
        self.speech_match_on_client.take().unwrap_or_else(|| CDOTASpeechMatchOnClient::new())
    }

    pub fn get_speech_match_on_client(&self) -> &CDOTASpeechMatchOnClient {
        self.speech_match_on_client.as_ref().unwrap_or_else(|| CDOTASpeechMatchOnClient::default_instance())
    }

    fn get_speech_match_on_client_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTASpeechMatchOnClient> {
        &self.speech_match_on_client
    }

    fn mut_speech_match_on_client_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTASpeechMatchOnClient> {
        &mut self.speech_match_on_client
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UnitEvent {
    fn is_initialized(&self) -> bool {
        if self.msg_type.is_none() {
            return false;
        }
        if self.entity_index.is_none() {
            return false;
        }
        for v in &self.speech {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.speech_mute {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.add_gesture {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remove_gesture {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blood_impact {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fade_gesture {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.speech_match_on_client {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.msg_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entity_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.speech)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.speech_mute)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.add_gesture)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.remove_gesture)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blood_impact)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fade_gesture)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.speech_match_on_client)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.entity_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.speech.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.speech_mute.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.add_gesture.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.remove_gesture.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.blood_impact.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fade_gesture.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.speech_match_on_client.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.msg_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.entity_index {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.speech.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.speech_mute.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.add_gesture.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.remove_gesture.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.blood_impact.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fade_gesture.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.speech_match_on_client.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_UnitEvent {
    fn new() -> CDOTAUserMsg_UnitEvent {
        CDOTAUserMsg_UnitEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_UnitEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EDotaEntityMessages>>(
                    "msg_type",
                    CDOTAUserMsg_UnitEvent::get_msg_type_for_reflect,
                    CDOTAUserMsg_UnitEvent::mut_msg_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entity_index",
                    CDOTAUserMsg_UnitEvent::get_entity_index_for_reflect,
                    CDOTAUserMsg_UnitEvent::mut_entity_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_UnitEvent_Speech>>(
                    "speech",
                    CDOTAUserMsg_UnitEvent::get_speech_for_reflect,
                    CDOTAUserMsg_UnitEvent::mut_speech_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_UnitEvent_SpeechMute>>(
                    "speech_mute",
                    CDOTAUserMsg_UnitEvent::get_speech_mute_for_reflect,
                    CDOTAUserMsg_UnitEvent::mut_speech_mute_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_UnitEvent_AddGesture>>(
                    "add_gesture",
                    CDOTAUserMsg_UnitEvent::get_add_gesture_for_reflect,
                    CDOTAUserMsg_UnitEvent::mut_add_gesture_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_UnitEvent_RemoveGesture>>(
                    "remove_gesture",
                    CDOTAUserMsg_UnitEvent::get_remove_gesture_for_reflect,
                    CDOTAUserMsg_UnitEvent::mut_remove_gesture_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_UnitEvent_BloodImpact>>(
                    "blood_impact",
                    CDOTAUserMsg_UnitEvent::get_blood_impact_for_reflect,
                    CDOTAUserMsg_UnitEvent::mut_blood_impact_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_UnitEvent_FadeGesture>>(
                    "fade_gesture",
                    CDOTAUserMsg_UnitEvent::get_fade_gesture_for_reflect,
                    CDOTAUserMsg_UnitEvent::mut_fade_gesture_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTASpeechMatchOnClient>>(
                    "speech_match_on_client",
                    CDOTAUserMsg_UnitEvent::get_speech_match_on_client_for_reflect,
                    CDOTAUserMsg_UnitEvent::mut_speech_match_on_client_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_UnitEvent>(
                    "CDOTAUserMsg_UnitEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_UnitEvent {
    fn clear(&mut self) {
        self.clear_msg_type();
        self.clear_entity_index();
        self.clear_speech();
        self.clear_speech_mute();
        self.clear_add_gesture();
        self.clear_remove_gesture();
        self.clear_blood_impact();
        self.clear_fade_gesture();
        self.clear_speech_match_on_client();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_UnitEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_UnitEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_UnitEvent_Speech {
    // message fields
    concept: ::std::option::Option<i32>,
    response: ::protobuf::SingularField<::std::string::String>,
    recipient_type: ::std::option::Option<i32>,
    level: ::std::option::Option<i32>,
    muteable: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_UnitEvent_Speech {}

impl CDOTAUserMsg_UnitEvent_Speech {
    pub fn new() -> CDOTAUserMsg_UnitEvent_Speech {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_UnitEvent_Speech {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_UnitEvent_Speech> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_UnitEvent_Speech,
        };
        unsafe {
            instance.get(CDOTAUserMsg_UnitEvent_Speech::new)
        }
    }

    // optional int32 concept = 1;

    pub fn clear_concept(&mut self) {
        self.concept = ::std::option::Option::None;
    }

    pub fn has_concept(&self) -> bool {
        self.concept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_concept(&mut self, v: i32) {
        self.concept = ::std::option::Option::Some(v);
    }

    pub fn get_concept(&self) -> i32 {
        self.concept.unwrap_or(0)
    }

    fn get_concept_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.concept
    }

    fn mut_concept_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.concept
    }

    // optional string response = 2;

    pub fn clear_response(&mut self) {
        self.response.clear();
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: ::std::string::String) {
        self.response = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&mut self) -> &mut ::std::string::String {
        if self.response.is_none() {
            self.response.set_default();
        }
        self.response.as_mut().unwrap()
    }

    // Take field
    pub fn take_response(&mut self) -> ::std::string::String {
        self.response.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_response(&self) -> &str {
        match self.response.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_response_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.response
    }

    fn mut_response_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.response
    }

    // optional int32 recipient_type = 3;

    pub fn clear_recipient_type(&mut self) {
        self.recipient_type = ::std::option::Option::None;
    }

    pub fn has_recipient_type(&self) -> bool {
        self.recipient_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_type(&mut self, v: i32) {
        self.recipient_type = ::std::option::Option::Some(v);
    }

    pub fn get_recipient_type(&self) -> i32 {
        self.recipient_type.unwrap_or(0)
    }

    fn get_recipient_type_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.recipient_type
    }

    fn mut_recipient_type_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.recipient_type
    }

    // optional int32 level = 4;

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: i32) {
        self.level = ::std::option::Option::Some(v);
    }

    pub fn get_level(&self) -> i32 {
        self.level.unwrap_or(0)
    }

    fn get_level_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.level
    }

    fn mut_level_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.level
    }

    // optional bool muteable = 5;

    pub fn clear_muteable(&mut self) {
        self.muteable = ::std::option::Option::None;
    }

    pub fn has_muteable(&self) -> bool {
        self.muteable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_muteable(&mut self, v: bool) {
        self.muteable = ::std::option::Option::Some(v);
    }

    pub fn get_muteable(&self) -> bool {
        self.muteable.unwrap_or(false)
    }

    fn get_muteable_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.muteable
    }

    fn mut_muteable_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.muteable
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UnitEvent_Speech {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.concept = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.response)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.recipient_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.muteable = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.concept {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.response.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.recipient_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.muteable {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.concept {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.response.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.recipient_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.level {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.muteable {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_UnitEvent_Speech {
    fn new() -> CDOTAUserMsg_UnitEvent_Speech {
        CDOTAUserMsg_UnitEvent_Speech::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_UnitEvent_Speech>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "concept",
                    CDOTAUserMsg_UnitEvent_Speech::get_concept_for_reflect,
                    CDOTAUserMsg_UnitEvent_Speech::mut_concept_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "response",
                    CDOTAUserMsg_UnitEvent_Speech::get_response_for_reflect,
                    CDOTAUserMsg_UnitEvent_Speech::mut_response_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "recipient_type",
                    CDOTAUserMsg_UnitEvent_Speech::get_recipient_type_for_reflect,
                    CDOTAUserMsg_UnitEvent_Speech::mut_recipient_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "level",
                    CDOTAUserMsg_UnitEvent_Speech::get_level_for_reflect,
                    CDOTAUserMsg_UnitEvent_Speech::mut_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "muteable",
                    CDOTAUserMsg_UnitEvent_Speech::get_muteable_for_reflect,
                    CDOTAUserMsg_UnitEvent_Speech::mut_muteable_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_UnitEvent_Speech>(
                    "CDOTAUserMsg_UnitEvent_Speech",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_UnitEvent_Speech {
    fn clear(&mut self) {
        self.clear_concept();
        self.clear_response();
        self.clear_recipient_type();
        self.clear_level();
        self.clear_muteable();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_UnitEvent_Speech {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_UnitEvent_Speech {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_UnitEvent_SpeechMute {
    // message fields
    delay: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_UnitEvent_SpeechMute {}

impl CDOTAUserMsg_UnitEvent_SpeechMute {
    pub fn new() -> CDOTAUserMsg_UnitEvent_SpeechMute {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_UnitEvent_SpeechMute {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_UnitEvent_SpeechMute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_UnitEvent_SpeechMute,
        };
        unsafe {
            instance.get(CDOTAUserMsg_UnitEvent_SpeechMute::new)
        }
    }

    // optional float delay = 1;

    pub fn clear_delay(&mut self) {
        self.delay = ::std::option::Option::None;
    }

    pub fn has_delay(&self) -> bool {
        self.delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay(&mut self, v: f32) {
        self.delay = ::std::option::Option::Some(v);
    }

    pub fn get_delay(&self) -> f32 {
        self.delay.unwrap_or(0.5f32)
    }

    fn get_delay_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.delay
    }

    fn mut_delay_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.delay
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UnitEvent_SpeechMute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.delay = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.delay {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.delay {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_UnitEvent_SpeechMute {
    fn new() -> CDOTAUserMsg_UnitEvent_SpeechMute {
        CDOTAUserMsg_UnitEvent_SpeechMute::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_UnitEvent_SpeechMute>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "delay",
                    CDOTAUserMsg_UnitEvent_SpeechMute::get_delay_for_reflect,
                    CDOTAUserMsg_UnitEvent_SpeechMute::mut_delay_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_UnitEvent_SpeechMute>(
                    "CDOTAUserMsg_UnitEvent_SpeechMute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_UnitEvent_SpeechMute {
    fn clear(&mut self) {
        self.clear_delay();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_UnitEvent_SpeechMute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_UnitEvent_SpeechMute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_UnitEvent_AddGesture {
    // message fields
    activity: ::std::option::Option<i32>,
    slot: ::std::option::Option<i32>,
    fade_in: ::std::option::Option<f32>,
    fade_out: ::std::option::Option<f32>,
    playback_rate: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_UnitEvent_AddGesture {}

impl CDOTAUserMsg_UnitEvent_AddGesture {
    pub fn new() -> CDOTAUserMsg_UnitEvent_AddGesture {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_UnitEvent_AddGesture {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_UnitEvent_AddGesture> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_UnitEvent_AddGesture,
        };
        unsafe {
            instance.get(CDOTAUserMsg_UnitEvent_AddGesture::new)
        }
    }

    // optional int32 activity = 1;

    pub fn clear_activity(&mut self) {
        self.activity = ::std::option::Option::None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: i32) {
        self.activity = ::std::option::Option::Some(v);
    }

    pub fn get_activity(&self) -> i32 {
        self.activity.unwrap_or(0)
    }

    fn get_activity_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.activity
    }

    fn mut_activity_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.activity
    }

    // optional int32 slot = 2;

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }

    pub fn get_slot(&self) -> i32 {
        self.slot.unwrap_or(0)
    }

    fn get_slot_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.slot
    }

    fn mut_slot_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.slot
    }

    // optional float fade_in = 3;

    pub fn clear_fade_in(&mut self) {
        self.fade_in = ::std::option::Option::None;
    }

    pub fn has_fade_in(&self) -> bool {
        self.fade_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_in(&mut self, v: f32) {
        self.fade_in = ::std::option::Option::Some(v);
    }

    pub fn get_fade_in(&self) -> f32 {
        self.fade_in.unwrap_or(0f32)
    }

    fn get_fade_in_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.fade_in
    }

    fn mut_fade_in_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.fade_in
    }

    // optional float fade_out = 4;

    pub fn clear_fade_out(&mut self) {
        self.fade_out = ::std::option::Option::None;
    }

    pub fn has_fade_out(&self) -> bool {
        self.fade_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_out(&mut self, v: f32) {
        self.fade_out = ::std::option::Option::Some(v);
    }

    pub fn get_fade_out(&self) -> f32 {
        self.fade_out.unwrap_or(0.1f32)
    }

    fn get_fade_out_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.fade_out
    }

    fn mut_fade_out_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.fade_out
    }

    // optional float playback_rate = 5;

    pub fn clear_playback_rate(&mut self) {
        self.playback_rate = ::std::option::Option::None;
    }

    pub fn has_playback_rate(&self) -> bool {
        self.playback_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playback_rate(&mut self, v: f32) {
        self.playback_rate = ::std::option::Option::Some(v);
    }

    pub fn get_playback_rate(&self) -> f32 {
        self.playback_rate.unwrap_or(1f32)
    }

    fn get_playback_rate_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.playback_rate
    }

    fn mut_playback_rate_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.playback_rate
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UnitEvent_AddGesture {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.activity = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.slot = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.fade_in = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.fade_out = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.playback_rate = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.activity {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fade_in {
            my_size += 5;
        }
        if let Some(v) = self.fade_out {
            my_size += 5;
        }
        if let Some(v) = self.playback_rate {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.activity {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.slot {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.fade_in {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.fade_out {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.playback_rate {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_UnitEvent_AddGesture {
    fn new() -> CDOTAUserMsg_UnitEvent_AddGesture {
        CDOTAUserMsg_UnitEvent_AddGesture::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_UnitEvent_AddGesture>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "activity",
                    CDOTAUserMsg_UnitEvent_AddGesture::get_activity_for_reflect,
                    CDOTAUserMsg_UnitEvent_AddGesture::mut_activity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "slot",
                    CDOTAUserMsg_UnitEvent_AddGesture::get_slot_for_reflect,
                    CDOTAUserMsg_UnitEvent_AddGesture::mut_slot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "fade_in",
                    CDOTAUserMsg_UnitEvent_AddGesture::get_fade_in_for_reflect,
                    CDOTAUserMsg_UnitEvent_AddGesture::mut_fade_in_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "fade_out",
                    CDOTAUserMsg_UnitEvent_AddGesture::get_fade_out_for_reflect,
                    CDOTAUserMsg_UnitEvent_AddGesture::mut_fade_out_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "playback_rate",
                    CDOTAUserMsg_UnitEvent_AddGesture::get_playback_rate_for_reflect,
                    CDOTAUserMsg_UnitEvent_AddGesture::mut_playback_rate_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_UnitEvent_AddGesture>(
                    "CDOTAUserMsg_UnitEvent_AddGesture",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_UnitEvent_AddGesture {
    fn clear(&mut self) {
        self.clear_activity();
        self.clear_slot();
        self.clear_fade_in();
        self.clear_fade_out();
        self.clear_playback_rate();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_UnitEvent_AddGesture {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_UnitEvent_AddGesture {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_UnitEvent_RemoveGesture {
    // message fields
    activity: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_UnitEvent_RemoveGesture {}

impl CDOTAUserMsg_UnitEvent_RemoveGesture {
    pub fn new() -> CDOTAUserMsg_UnitEvent_RemoveGesture {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_UnitEvent_RemoveGesture {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_UnitEvent_RemoveGesture> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_UnitEvent_RemoveGesture,
        };
        unsafe {
            instance.get(CDOTAUserMsg_UnitEvent_RemoveGesture::new)
        }
    }

    // optional int32 activity = 1;

    pub fn clear_activity(&mut self) {
        self.activity = ::std::option::Option::None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: i32) {
        self.activity = ::std::option::Option::Some(v);
    }

    pub fn get_activity(&self) -> i32 {
        self.activity.unwrap_or(0)
    }

    fn get_activity_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.activity
    }

    fn mut_activity_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.activity
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UnitEvent_RemoveGesture {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.activity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.activity {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.activity {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_UnitEvent_RemoveGesture {
    fn new() -> CDOTAUserMsg_UnitEvent_RemoveGesture {
        CDOTAUserMsg_UnitEvent_RemoveGesture::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_UnitEvent_RemoveGesture>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "activity",
                    CDOTAUserMsg_UnitEvent_RemoveGesture::get_activity_for_reflect,
                    CDOTAUserMsg_UnitEvent_RemoveGesture::mut_activity_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_UnitEvent_RemoveGesture>(
                    "CDOTAUserMsg_UnitEvent_RemoveGesture",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_UnitEvent_RemoveGesture {
    fn clear(&mut self) {
        self.clear_activity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_UnitEvent_RemoveGesture {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_UnitEvent_RemoveGesture {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_UnitEvent_BloodImpact {
    // message fields
    scale: ::std::option::Option<i32>,
    x_normal: ::std::option::Option<i32>,
    y_normal: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_UnitEvent_BloodImpact {}

impl CDOTAUserMsg_UnitEvent_BloodImpact {
    pub fn new() -> CDOTAUserMsg_UnitEvent_BloodImpact {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_UnitEvent_BloodImpact {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_UnitEvent_BloodImpact> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_UnitEvent_BloodImpact,
        };
        unsafe {
            instance.get(CDOTAUserMsg_UnitEvent_BloodImpact::new)
        }
    }

    // optional int32 scale = 1;

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: i32) {
        self.scale = ::std::option::Option::Some(v);
    }

    pub fn get_scale(&self) -> i32 {
        self.scale.unwrap_or(0)
    }

    fn get_scale_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.scale
    }

    fn mut_scale_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.scale
    }

    // optional int32 x_normal = 2;

    pub fn clear_x_normal(&mut self) {
        self.x_normal = ::std::option::Option::None;
    }

    pub fn has_x_normal(&self) -> bool {
        self.x_normal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normal(&mut self, v: i32) {
        self.x_normal = ::std::option::Option::Some(v);
    }

    pub fn get_x_normal(&self) -> i32 {
        self.x_normal.unwrap_or(0)
    }

    fn get_x_normal_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.x_normal
    }

    fn mut_x_normal_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.x_normal
    }

    // optional int32 y_normal = 3;

    pub fn clear_y_normal(&mut self) {
        self.y_normal = ::std::option::Option::None;
    }

    pub fn has_y_normal(&self) -> bool {
        self.y_normal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normal(&mut self, v: i32) {
        self.y_normal = ::std::option::Option::Some(v);
    }

    pub fn get_y_normal(&self) -> i32 {
        self.y_normal.unwrap_or(0)
    }

    fn get_y_normal_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.y_normal
    }

    fn mut_y_normal_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.y_normal
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UnitEvent_BloodImpact {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.scale = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.x_normal = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.y_normal = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.scale {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x_normal {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.y_normal {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.scale {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.x_normal {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.y_normal {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_UnitEvent_BloodImpact {
    fn new() -> CDOTAUserMsg_UnitEvent_BloodImpact {
        CDOTAUserMsg_UnitEvent_BloodImpact::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_UnitEvent_BloodImpact>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "scale",
                    CDOTAUserMsg_UnitEvent_BloodImpact::get_scale_for_reflect,
                    CDOTAUserMsg_UnitEvent_BloodImpact::mut_scale_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "x_normal",
                    CDOTAUserMsg_UnitEvent_BloodImpact::get_x_normal_for_reflect,
                    CDOTAUserMsg_UnitEvent_BloodImpact::mut_x_normal_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "y_normal",
                    CDOTAUserMsg_UnitEvent_BloodImpact::get_y_normal_for_reflect,
                    CDOTAUserMsg_UnitEvent_BloodImpact::mut_y_normal_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_UnitEvent_BloodImpact>(
                    "CDOTAUserMsg_UnitEvent_BloodImpact",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_UnitEvent_BloodImpact {
    fn clear(&mut self) {
        self.clear_scale();
        self.clear_x_normal();
        self.clear_y_normal();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_UnitEvent_BloodImpact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_UnitEvent_BloodImpact {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_UnitEvent_FadeGesture {
    // message fields
    activity: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_UnitEvent_FadeGesture {}

impl CDOTAUserMsg_UnitEvent_FadeGesture {
    pub fn new() -> CDOTAUserMsg_UnitEvent_FadeGesture {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_UnitEvent_FadeGesture {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_UnitEvent_FadeGesture> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_UnitEvent_FadeGesture,
        };
        unsafe {
            instance.get(CDOTAUserMsg_UnitEvent_FadeGesture::new)
        }
    }

    // optional int32 activity = 1;

    pub fn clear_activity(&mut self) {
        self.activity = ::std::option::Option::None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: i32) {
        self.activity = ::std::option::Option::Some(v);
    }

    pub fn get_activity(&self) -> i32 {
        self.activity.unwrap_or(0)
    }

    fn get_activity_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.activity
    }

    fn mut_activity_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.activity
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UnitEvent_FadeGesture {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.activity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.activity {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.activity {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_UnitEvent_FadeGesture {
    fn new() -> CDOTAUserMsg_UnitEvent_FadeGesture {
        CDOTAUserMsg_UnitEvent_FadeGesture::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_UnitEvent_FadeGesture>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "activity",
                    CDOTAUserMsg_UnitEvent_FadeGesture::get_activity_for_reflect,
                    CDOTAUserMsg_UnitEvent_FadeGesture::mut_activity_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_UnitEvent_FadeGesture>(
                    "CDOTAUserMsg_UnitEvent_FadeGesture",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_UnitEvent_FadeGesture {
    fn clear(&mut self) {
        self.clear_activity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_UnitEvent_FadeGesture {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_UnitEvent_FadeGesture {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ItemPurchased {
    // message fields
    item_index: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ItemPurchased {}

impl CDOTAUserMsg_ItemPurchased {
    pub fn new() -> CDOTAUserMsg_ItemPurchased {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ItemPurchased {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ItemPurchased> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ItemPurchased,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ItemPurchased::new)
        }
    }

    // optional int32 item_index = 1;

    pub fn clear_item_index(&mut self) {
        self.item_index = ::std::option::Option::None;
    }

    pub fn has_item_index(&self) -> bool {
        self.item_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_index(&mut self, v: i32) {
        self.item_index = ::std::option::Option::Some(v);
    }

    pub fn get_item_index(&self) -> i32 {
        self.item_index.unwrap_or(0)
    }

    fn get_item_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.item_index
    }

    fn mut_item_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.item_index
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ItemPurchased {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.item_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_index {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ItemPurchased {
    fn new() -> CDOTAUserMsg_ItemPurchased {
        CDOTAUserMsg_ItemPurchased::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ItemPurchased>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "item_index",
                    CDOTAUserMsg_ItemPurchased::get_item_index_for_reflect,
                    CDOTAUserMsg_ItemPurchased::mut_item_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ItemPurchased>(
                    "CDOTAUserMsg_ItemPurchased",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ItemPurchased {
    fn clear(&mut self) {
        self.clear_item_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ItemPurchased {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ItemPurchased {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ItemFound {
    // message fields
    player: ::std::option::Option<i32>,
    quality: ::std::option::Option<i32>,
    rarity: ::std::option::Option<i32>,
    method: ::std::option::Option<i32>,
    itemdef: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ItemFound {}

impl CDOTAUserMsg_ItemFound {
    pub fn new() -> CDOTAUserMsg_ItemFound {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ItemFound {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ItemFound> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ItemFound,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ItemFound::new)
        }
    }

    // optional int32 player = 1;

    pub fn clear_player(&mut self) {
        self.player = ::std::option::Option::None;
    }

    pub fn has_player(&self) -> bool {
        self.player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player(&mut self, v: i32) {
        self.player = ::std::option::Option::Some(v);
    }

    pub fn get_player(&self) -> i32 {
        self.player.unwrap_or(0)
    }

    fn get_player_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.player
    }

    fn mut_player_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.player
    }

    // optional int32 quality = 2;

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: i32) {
        self.quality = ::std::option::Option::Some(v);
    }

    pub fn get_quality(&self) -> i32 {
        self.quality.unwrap_or(0)
    }

    fn get_quality_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.quality
    }

    fn mut_quality_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.quality
    }

    // optional int32 rarity = 3;

    pub fn clear_rarity(&mut self) {
        self.rarity = ::std::option::Option::None;
    }

    pub fn has_rarity(&self) -> bool {
        self.rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rarity(&mut self, v: i32) {
        self.rarity = ::std::option::Option::Some(v);
    }

    pub fn get_rarity(&self) -> i32 {
        self.rarity.unwrap_or(0)
    }

    fn get_rarity_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.rarity
    }

    fn mut_rarity_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.rarity
    }

    // optional int32 method = 4;

    pub fn clear_method(&mut self) {
        self.method = ::std::option::Option::None;
    }

    pub fn has_method(&self) -> bool {
        self.method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method(&mut self, v: i32) {
        self.method = ::std::option::Option::Some(v);
    }

    pub fn get_method(&self) -> i32 {
        self.method.unwrap_or(0)
    }

    fn get_method_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.method
    }

    fn mut_method_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.method
    }

    // optional int32 itemdef = 5;

    pub fn clear_itemdef(&mut self) {
        self.itemdef = ::std::option::Option::None;
    }

    pub fn has_itemdef(&self) -> bool {
        self.itemdef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemdef(&mut self, v: i32) {
        self.itemdef = ::std::option::Option::Some(v);
    }

    pub fn get_itemdef(&self) -> i32 {
        self.itemdef.unwrap_or(0)
    }

    fn get_itemdef_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.itemdef
    }

    fn mut_itemdef_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.itemdef
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ItemFound {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.quality = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rarity = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.method = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.itemdef = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rarity {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.method {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.itemdef {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.quality {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.rarity {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.method {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.itemdef {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ItemFound {
    fn new() -> CDOTAUserMsg_ItemFound {
        CDOTAUserMsg_ItemFound::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ItemFound>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player",
                    CDOTAUserMsg_ItemFound::get_player_for_reflect,
                    CDOTAUserMsg_ItemFound::mut_player_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "quality",
                    CDOTAUserMsg_ItemFound::get_quality_for_reflect,
                    CDOTAUserMsg_ItemFound::mut_quality_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "rarity",
                    CDOTAUserMsg_ItemFound::get_rarity_for_reflect,
                    CDOTAUserMsg_ItemFound::mut_rarity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "method",
                    CDOTAUserMsg_ItemFound::get_method_for_reflect,
                    CDOTAUserMsg_ItemFound::mut_method_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "itemdef",
                    CDOTAUserMsg_ItemFound::get_itemdef_for_reflect,
                    CDOTAUserMsg_ItemFound::mut_itemdef_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ItemFound>(
                    "CDOTAUserMsg_ItemFound",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ItemFound {
    fn clear(&mut self) {
        self.clear_player();
        self.clear_quality();
        self.clear_rarity();
        self.clear_method();
        self.clear_itemdef();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ItemFound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ItemFound {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ParticleManager {
    // message fields
    field_type: ::std::option::Option<DOTA_PARTICLE_MESSAGE>,
    index: ::std::option::Option<u32>,
    release_particle_index: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_ReleaseParticleIndex>,
    create_particle: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_CreateParticle>,
    destroy_particle: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_DestroyParticle>,
    destroy_particle_involving: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_DestroyParticleInvolving>,
    update_particle: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticle>,
    update_particle_fwd: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleFwd>,
    update_particle_orient: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleOrient>,
    update_particle_fallback: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleFallback>,
    update_particle_offset: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleOffset>,
    update_particle_ent: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleEnt>,
    update_particle_should_draw: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw>,
    update_particle_set_frozen: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen>,
    change_control_point_attachment: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment>,
    update_entity_position: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateEntityPosition>,
    set_particle_fow_properties: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_SetParticleFoWProperties>,
    set_particle_text: ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_SetParticleText>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ParticleManager {}

impl CDOTAUserMsg_ParticleManager {
    pub fn new() -> CDOTAUserMsg_ParticleManager {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ParticleManager,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ParticleManager::new)
        }
    }

    // required .DOTA_PARTICLE_MESSAGE type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DOTA_PARTICLE_MESSAGE) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> DOTA_PARTICLE_MESSAGE {
        self.field_type.unwrap_or(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_CREATE)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<DOTA_PARTICLE_MESSAGE> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<DOTA_PARTICLE_MESSAGE> {
        &mut self.field_type
    }

    // required uint32 index = 2;

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    pub fn get_index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    fn get_index_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.index
    }

    fn mut_index_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.index
    }

    // optional .CDOTAUserMsg_ParticleManager.ReleaseParticleIndex release_particle_index = 3;

    pub fn clear_release_particle_index(&mut self) {
        self.release_particle_index.clear();
    }

    pub fn has_release_particle_index(&self) -> bool {
        self.release_particle_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_release_particle_index(&mut self, v: CDOTAUserMsg_ParticleManager_ReleaseParticleIndex) {
        self.release_particle_index = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_release_particle_index(&mut self) -> &mut CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
        if self.release_particle_index.is_none() {
            self.release_particle_index.set_default();
        }
        self.release_particle_index.as_mut().unwrap()
    }

    // Take field
    pub fn take_release_particle_index(&mut self) -> CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
        self.release_particle_index.take().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_ReleaseParticleIndex::new())
    }

    pub fn get_release_particle_index(&self) -> &CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
        self.release_particle_index.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_ReleaseParticleIndex::default_instance())
    }

    fn get_release_particle_index_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_ReleaseParticleIndex> {
        &self.release_particle_index
    }

    fn mut_release_particle_index_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_ReleaseParticleIndex> {
        &mut self.release_particle_index
    }

    // optional .CDOTAUserMsg_ParticleManager.CreateParticle create_particle = 4;

    pub fn clear_create_particle(&mut self) {
        self.create_particle.clear();
    }

    pub fn has_create_particle(&self) -> bool {
        self.create_particle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_particle(&mut self, v: CDOTAUserMsg_ParticleManager_CreateParticle) {
        self.create_particle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_particle(&mut self) -> &mut CDOTAUserMsg_ParticleManager_CreateParticle {
        if self.create_particle.is_none() {
            self.create_particle.set_default();
        }
        self.create_particle.as_mut().unwrap()
    }

    // Take field
    pub fn take_create_particle(&mut self) -> CDOTAUserMsg_ParticleManager_CreateParticle {
        self.create_particle.take().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_CreateParticle::new())
    }

    pub fn get_create_particle(&self) -> &CDOTAUserMsg_ParticleManager_CreateParticle {
        self.create_particle.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_CreateParticle::default_instance())
    }

    fn get_create_particle_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_CreateParticle> {
        &self.create_particle
    }

    fn mut_create_particle_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_CreateParticle> {
        &mut self.create_particle
    }

    // optional .CDOTAUserMsg_ParticleManager.DestroyParticle destroy_particle = 5;

    pub fn clear_destroy_particle(&mut self) {
        self.destroy_particle.clear();
    }

    pub fn has_destroy_particle(&self) -> bool {
        self.destroy_particle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroy_particle(&mut self, v: CDOTAUserMsg_ParticleManager_DestroyParticle) {
        self.destroy_particle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destroy_particle(&mut self) -> &mut CDOTAUserMsg_ParticleManager_DestroyParticle {
        if self.destroy_particle.is_none() {
            self.destroy_particle.set_default();
        }
        self.destroy_particle.as_mut().unwrap()
    }

    // Take field
    pub fn take_destroy_particle(&mut self) -> CDOTAUserMsg_ParticleManager_DestroyParticle {
        self.destroy_particle.take().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_DestroyParticle::new())
    }

    pub fn get_destroy_particle(&self) -> &CDOTAUserMsg_ParticleManager_DestroyParticle {
        self.destroy_particle.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_DestroyParticle::default_instance())
    }

    fn get_destroy_particle_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_DestroyParticle> {
        &self.destroy_particle
    }

    fn mut_destroy_particle_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_DestroyParticle> {
        &mut self.destroy_particle
    }

    // optional .CDOTAUserMsg_ParticleManager.DestroyParticleInvolving destroy_particle_involving = 6;

    pub fn clear_destroy_particle_involving(&mut self) {
        self.destroy_particle_involving.clear();
    }

    pub fn has_destroy_particle_involving(&self) -> bool {
        self.destroy_particle_involving.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroy_particle_involving(&mut self, v: CDOTAUserMsg_ParticleManager_DestroyParticleInvolving) {
        self.destroy_particle_involving = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destroy_particle_involving(&mut self) -> &mut CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
        if self.destroy_particle_involving.is_none() {
            self.destroy_particle_involving.set_default();
        }
        self.destroy_particle_involving.as_mut().unwrap()
    }

    // Take field
    pub fn take_destroy_particle_involving(&mut self) -> CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
        self.destroy_particle_involving.take().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_DestroyParticleInvolving::new())
    }

    pub fn get_destroy_particle_involving(&self) -> &CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
        self.destroy_particle_involving.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_DestroyParticleInvolving::default_instance())
    }

    fn get_destroy_particle_involving_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_DestroyParticleInvolving> {
        &self.destroy_particle_involving
    }

    fn mut_destroy_particle_involving_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_DestroyParticleInvolving> {
        &mut self.destroy_particle_involving
    }

    // optional .CDOTAUserMsg_ParticleManager.UpdateParticle update_particle = 7;

    pub fn clear_update_particle(&mut self) {
        self.update_particle.clear();
    }

    pub fn has_update_particle(&self) -> bool {
        self.update_particle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_particle(&mut self, v: CDOTAUserMsg_ParticleManager_UpdateParticle) {
        self.update_particle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_particle(&mut self) -> &mut CDOTAUserMsg_ParticleManager_UpdateParticle {
        if self.update_particle.is_none() {
            self.update_particle.set_default();
        }
        self.update_particle.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_particle(&mut self) -> CDOTAUserMsg_ParticleManager_UpdateParticle {
        self.update_particle.take().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticle::new())
    }

    pub fn get_update_particle(&self) -> &CDOTAUserMsg_ParticleManager_UpdateParticle {
        self.update_particle.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticle::default_instance())
    }

    fn get_update_particle_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticle> {
        &self.update_particle
    }

    fn mut_update_particle_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticle> {
        &mut self.update_particle
    }

    // optional .CDOTAUserMsg_ParticleManager.UpdateParticleFwd update_particle_fwd = 8;

    pub fn clear_update_particle_fwd(&mut self) {
        self.update_particle_fwd.clear();
    }

    pub fn has_update_particle_fwd(&self) -> bool {
        self.update_particle_fwd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_particle_fwd(&mut self, v: CDOTAUserMsg_ParticleManager_UpdateParticleFwd) {
        self.update_particle_fwd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_particle_fwd(&mut self) -> &mut CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
        if self.update_particle_fwd.is_none() {
            self.update_particle_fwd.set_default();
        }
        self.update_particle_fwd.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_particle_fwd(&mut self) -> CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
        self.update_particle_fwd.take().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleFwd::new())
    }

    pub fn get_update_particle_fwd(&self) -> &CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
        self.update_particle_fwd.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleFwd::default_instance())
    }

    fn get_update_particle_fwd_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleFwd> {
        &self.update_particle_fwd
    }

    fn mut_update_particle_fwd_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleFwd> {
        &mut self.update_particle_fwd
    }

    // optional .CDOTAUserMsg_ParticleManager.UpdateParticleOrient update_particle_orient = 9;

    pub fn clear_update_particle_orient(&mut self) {
        self.update_particle_orient.clear();
    }

    pub fn has_update_particle_orient(&self) -> bool {
        self.update_particle_orient.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_particle_orient(&mut self, v: CDOTAUserMsg_ParticleManager_UpdateParticleOrient) {
        self.update_particle_orient = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_particle_orient(&mut self) -> &mut CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
        if self.update_particle_orient.is_none() {
            self.update_particle_orient.set_default();
        }
        self.update_particle_orient.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_particle_orient(&mut self) -> CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
        self.update_particle_orient.take().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleOrient::new())
    }

    pub fn get_update_particle_orient(&self) -> &CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
        self.update_particle_orient.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleOrient::default_instance())
    }

    fn get_update_particle_orient_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleOrient> {
        &self.update_particle_orient
    }

    fn mut_update_particle_orient_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleOrient> {
        &mut self.update_particle_orient
    }

    // optional .CDOTAUserMsg_ParticleManager.UpdateParticleFallback update_particle_fallback = 10;

    pub fn clear_update_particle_fallback(&mut self) {
        self.update_particle_fallback.clear();
    }

    pub fn has_update_particle_fallback(&self) -> bool {
        self.update_particle_fallback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_particle_fallback(&mut self, v: CDOTAUserMsg_ParticleManager_UpdateParticleFallback) {
        self.update_particle_fallback = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_particle_fallback(&mut self) -> &mut CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
        if self.update_particle_fallback.is_none() {
            self.update_particle_fallback.set_default();
        }
        self.update_particle_fallback.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_particle_fallback(&mut self) -> CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
        self.update_particle_fallback.take().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleFallback::new())
    }

    pub fn get_update_particle_fallback(&self) -> &CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
        self.update_particle_fallback.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleFallback::default_instance())
    }

    fn get_update_particle_fallback_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleFallback> {
        &self.update_particle_fallback
    }

    fn mut_update_particle_fallback_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleFallback> {
        &mut self.update_particle_fallback
    }

    // optional .CDOTAUserMsg_ParticleManager.UpdateParticleOffset update_particle_offset = 11;

    pub fn clear_update_particle_offset(&mut self) {
        self.update_particle_offset.clear();
    }

    pub fn has_update_particle_offset(&self) -> bool {
        self.update_particle_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_particle_offset(&mut self, v: CDOTAUserMsg_ParticleManager_UpdateParticleOffset) {
        self.update_particle_offset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_particle_offset(&mut self) -> &mut CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
        if self.update_particle_offset.is_none() {
            self.update_particle_offset.set_default();
        }
        self.update_particle_offset.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_particle_offset(&mut self) -> CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
        self.update_particle_offset.take().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleOffset::new())
    }

    pub fn get_update_particle_offset(&self) -> &CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
        self.update_particle_offset.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleOffset::default_instance())
    }

    fn get_update_particle_offset_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleOffset> {
        &self.update_particle_offset
    }

    fn mut_update_particle_offset_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleOffset> {
        &mut self.update_particle_offset
    }

    // optional .CDOTAUserMsg_ParticleManager.UpdateParticleEnt update_particle_ent = 12;

    pub fn clear_update_particle_ent(&mut self) {
        self.update_particle_ent.clear();
    }

    pub fn has_update_particle_ent(&self) -> bool {
        self.update_particle_ent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_particle_ent(&mut self, v: CDOTAUserMsg_ParticleManager_UpdateParticleEnt) {
        self.update_particle_ent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_particle_ent(&mut self) -> &mut CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
        if self.update_particle_ent.is_none() {
            self.update_particle_ent.set_default();
        }
        self.update_particle_ent.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_particle_ent(&mut self) -> CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
        self.update_particle_ent.take().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleEnt::new())
    }

    pub fn get_update_particle_ent(&self) -> &CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
        self.update_particle_ent.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleEnt::default_instance())
    }

    fn get_update_particle_ent_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleEnt> {
        &self.update_particle_ent
    }

    fn mut_update_particle_ent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleEnt> {
        &mut self.update_particle_ent
    }

    // optional .CDOTAUserMsg_ParticleManager.UpdateParticleShouldDraw update_particle_should_draw = 14;

    pub fn clear_update_particle_should_draw(&mut self) {
        self.update_particle_should_draw.clear();
    }

    pub fn has_update_particle_should_draw(&self) -> bool {
        self.update_particle_should_draw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_particle_should_draw(&mut self, v: CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw) {
        self.update_particle_should_draw = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_particle_should_draw(&mut self) -> &mut CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw {
        if self.update_particle_should_draw.is_none() {
            self.update_particle_should_draw.set_default();
        }
        self.update_particle_should_draw.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_particle_should_draw(&mut self) -> CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw {
        self.update_particle_should_draw.take().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw::new())
    }

    pub fn get_update_particle_should_draw(&self) -> &CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw {
        self.update_particle_should_draw.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw::default_instance())
    }

    fn get_update_particle_should_draw_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw> {
        &self.update_particle_should_draw
    }

    fn mut_update_particle_should_draw_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw> {
        &mut self.update_particle_should_draw
    }

    // optional .CDOTAUserMsg_ParticleManager.UpdateParticleSetFrozen update_particle_set_frozen = 15;

    pub fn clear_update_particle_set_frozen(&mut self) {
        self.update_particle_set_frozen.clear();
    }

    pub fn has_update_particle_set_frozen(&self) -> bool {
        self.update_particle_set_frozen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_particle_set_frozen(&mut self, v: CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen) {
        self.update_particle_set_frozen = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_particle_set_frozen(&mut self) -> &mut CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen {
        if self.update_particle_set_frozen.is_none() {
            self.update_particle_set_frozen.set_default();
        }
        self.update_particle_set_frozen.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_particle_set_frozen(&mut self) -> CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen {
        self.update_particle_set_frozen.take().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen::new())
    }

    pub fn get_update_particle_set_frozen(&self) -> &CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen {
        self.update_particle_set_frozen.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen::default_instance())
    }

    fn get_update_particle_set_frozen_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen> {
        &self.update_particle_set_frozen
    }

    fn mut_update_particle_set_frozen_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen> {
        &mut self.update_particle_set_frozen
    }

    // optional .CDOTAUserMsg_ParticleManager.ChangeControlPointAttachment change_control_point_attachment = 16;

    pub fn clear_change_control_point_attachment(&mut self) {
        self.change_control_point_attachment.clear();
    }

    pub fn has_change_control_point_attachment(&self) -> bool {
        self.change_control_point_attachment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_control_point_attachment(&mut self, v: CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment) {
        self.change_control_point_attachment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_change_control_point_attachment(&mut self) -> &mut CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment {
        if self.change_control_point_attachment.is_none() {
            self.change_control_point_attachment.set_default();
        }
        self.change_control_point_attachment.as_mut().unwrap()
    }

    // Take field
    pub fn take_change_control_point_attachment(&mut self) -> CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment {
        self.change_control_point_attachment.take().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment::new())
    }

    pub fn get_change_control_point_attachment(&self) -> &CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment {
        self.change_control_point_attachment.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment::default_instance())
    }

    fn get_change_control_point_attachment_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment> {
        &self.change_control_point_attachment
    }

    fn mut_change_control_point_attachment_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment> {
        &mut self.change_control_point_attachment
    }

    // optional .CDOTAUserMsg_ParticleManager.UpdateEntityPosition update_entity_position = 17;

    pub fn clear_update_entity_position(&mut self) {
        self.update_entity_position.clear();
    }

    pub fn has_update_entity_position(&self) -> bool {
        self.update_entity_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_entity_position(&mut self, v: CDOTAUserMsg_ParticleManager_UpdateEntityPosition) {
        self.update_entity_position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_entity_position(&mut self) -> &mut CDOTAUserMsg_ParticleManager_UpdateEntityPosition {
        if self.update_entity_position.is_none() {
            self.update_entity_position.set_default();
        }
        self.update_entity_position.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_entity_position(&mut self) -> CDOTAUserMsg_ParticleManager_UpdateEntityPosition {
        self.update_entity_position.take().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateEntityPosition::new())
    }

    pub fn get_update_entity_position(&self) -> &CDOTAUserMsg_ParticleManager_UpdateEntityPosition {
        self.update_entity_position.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_UpdateEntityPosition::default_instance())
    }

    fn get_update_entity_position_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateEntityPosition> {
        &self.update_entity_position
    }

    fn mut_update_entity_position_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_UpdateEntityPosition> {
        &mut self.update_entity_position
    }

    // optional .CDOTAUserMsg_ParticleManager.SetParticleFoWProperties set_particle_fow_properties = 18;

    pub fn clear_set_particle_fow_properties(&mut self) {
        self.set_particle_fow_properties.clear();
    }

    pub fn has_set_particle_fow_properties(&self) -> bool {
        self.set_particle_fow_properties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set_particle_fow_properties(&mut self, v: CDOTAUserMsg_ParticleManager_SetParticleFoWProperties) {
        self.set_particle_fow_properties = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_set_particle_fow_properties(&mut self) -> &mut CDOTAUserMsg_ParticleManager_SetParticleFoWProperties {
        if self.set_particle_fow_properties.is_none() {
            self.set_particle_fow_properties.set_default();
        }
        self.set_particle_fow_properties.as_mut().unwrap()
    }

    // Take field
    pub fn take_set_particle_fow_properties(&mut self) -> CDOTAUserMsg_ParticleManager_SetParticleFoWProperties {
        self.set_particle_fow_properties.take().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_SetParticleFoWProperties::new())
    }

    pub fn get_set_particle_fow_properties(&self) -> &CDOTAUserMsg_ParticleManager_SetParticleFoWProperties {
        self.set_particle_fow_properties.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_SetParticleFoWProperties::default_instance())
    }

    fn get_set_particle_fow_properties_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_SetParticleFoWProperties> {
        &self.set_particle_fow_properties
    }

    fn mut_set_particle_fow_properties_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_SetParticleFoWProperties> {
        &mut self.set_particle_fow_properties
    }

    // optional .CDOTAUserMsg_ParticleManager.SetParticleText set_particle_text = 19;

    pub fn clear_set_particle_text(&mut self) {
        self.set_particle_text.clear();
    }

    pub fn has_set_particle_text(&self) -> bool {
        self.set_particle_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set_particle_text(&mut self, v: CDOTAUserMsg_ParticleManager_SetParticleText) {
        self.set_particle_text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_set_particle_text(&mut self) -> &mut CDOTAUserMsg_ParticleManager_SetParticleText {
        if self.set_particle_text.is_none() {
            self.set_particle_text.set_default();
        }
        self.set_particle_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_set_particle_text(&mut self) -> CDOTAUserMsg_ParticleManager_SetParticleText {
        self.set_particle_text.take().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_SetParticleText::new())
    }

    pub fn get_set_particle_text(&self) -> &CDOTAUserMsg_ParticleManager_SetParticleText {
        self.set_particle_text.as_ref().unwrap_or_else(|| CDOTAUserMsg_ParticleManager_SetParticleText::default_instance())
    }

    fn get_set_particle_text_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_SetParticleText> {
        &self.set_particle_text
    }

    fn mut_set_particle_text_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_ParticleManager_SetParticleText> {
        &mut self.set_particle_text
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.index.is_none() {
            return false;
        }
        for v in &self.release_particle_index {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create_particle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destroy_particle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destroy_particle_involving {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_fwd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_orient {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_fallback {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_ent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_should_draw {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_set_frozen {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.change_control_point_attachment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_entity_position {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_particle_fow_properties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_particle_text {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.release_particle_index)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create_particle)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destroy_particle)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destroy_particle_involving)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_particle)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_particle_fwd)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_particle_orient)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_particle_fallback)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_particle_offset)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_particle_ent)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_particle_should_draw)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_particle_set_frozen)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.change_control_point_attachment)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_entity_position)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.set_particle_fow_properties)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.set_particle_text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.release_particle_index.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.create_particle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.destroy_particle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.destroy_particle_involving.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_particle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_particle_fwd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_particle_orient.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_particle_fallback.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_particle_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_particle_ent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_particle_should_draw.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_particle_set_frozen.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.change_control_point_attachment.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_entity_position.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.set_particle_fow_properties.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.set_particle_text.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.index {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.release_particle_index.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.create_particle.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.destroy_particle.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.destroy_particle_involving.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_particle.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_particle_fwd.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_particle_orient.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_particle_fallback.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_particle_offset.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_particle_ent.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_particle_should_draw.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_particle_set_frozen.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.change_control_point_attachment.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_entity_position.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.set_particle_fow_properties.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.set_particle_text.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ParticleManager {
    fn new() -> CDOTAUserMsg_ParticleManager {
        CDOTAUserMsg_ParticleManager::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ParticleManager>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DOTA_PARTICLE_MESSAGE>>(
                    "type",
                    CDOTAUserMsg_ParticleManager::get_field_type_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "index",
                    CDOTAUserMsg_ParticleManager::get_index_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_ParticleManager_ReleaseParticleIndex>>(
                    "release_particle_index",
                    CDOTAUserMsg_ParticleManager::get_release_particle_index_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_release_particle_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_ParticleManager_CreateParticle>>(
                    "create_particle",
                    CDOTAUserMsg_ParticleManager::get_create_particle_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_create_particle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_ParticleManager_DestroyParticle>>(
                    "destroy_particle",
                    CDOTAUserMsg_ParticleManager::get_destroy_particle_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_destroy_particle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_ParticleManager_DestroyParticleInvolving>>(
                    "destroy_particle_involving",
                    CDOTAUserMsg_ParticleManager::get_destroy_particle_involving_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_destroy_particle_involving_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_ParticleManager_UpdateParticle>>(
                    "update_particle",
                    CDOTAUserMsg_ParticleManager::get_update_particle_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_update_particle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_ParticleManager_UpdateParticleFwd>>(
                    "update_particle_fwd",
                    CDOTAUserMsg_ParticleManager::get_update_particle_fwd_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_update_particle_fwd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_ParticleManager_UpdateParticleOrient>>(
                    "update_particle_orient",
                    CDOTAUserMsg_ParticleManager::get_update_particle_orient_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_update_particle_orient_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_ParticleManager_UpdateParticleFallback>>(
                    "update_particle_fallback",
                    CDOTAUserMsg_ParticleManager::get_update_particle_fallback_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_update_particle_fallback_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_ParticleManager_UpdateParticleOffset>>(
                    "update_particle_offset",
                    CDOTAUserMsg_ParticleManager::get_update_particle_offset_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_update_particle_offset_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_ParticleManager_UpdateParticleEnt>>(
                    "update_particle_ent",
                    CDOTAUserMsg_ParticleManager::get_update_particle_ent_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_update_particle_ent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw>>(
                    "update_particle_should_draw",
                    CDOTAUserMsg_ParticleManager::get_update_particle_should_draw_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_update_particle_should_draw_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen>>(
                    "update_particle_set_frozen",
                    CDOTAUserMsg_ParticleManager::get_update_particle_set_frozen_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_update_particle_set_frozen_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment>>(
                    "change_control_point_attachment",
                    CDOTAUserMsg_ParticleManager::get_change_control_point_attachment_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_change_control_point_attachment_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_ParticleManager_UpdateEntityPosition>>(
                    "update_entity_position",
                    CDOTAUserMsg_ParticleManager::get_update_entity_position_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_update_entity_position_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_ParticleManager_SetParticleFoWProperties>>(
                    "set_particle_fow_properties",
                    CDOTAUserMsg_ParticleManager::get_set_particle_fow_properties_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_set_particle_fow_properties_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_ParticleManager_SetParticleText>>(
                    "set_particle_text",
                    CDOTAUserMsg_ParticleManager::get_set_particle_text_for_reflect,
                    CDOTAUserMsg_ParticleManager::mut_set_particle_text_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager>(
                    "CDOTAUserMsg_ParticleManager",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_index();
        self.clear_release_particle_index();
        self.clear_create_particle();
        self.clear_destroy_particle();
        self.clear_destroy_particle_involving();
        self.clear_update_particle();
        self.clear_update_particle_fwd();
        self.clear_update_particle_orient();
        self.clear_update_particle_fallback();
        self.clear_update_particle_offset();
        self.clear_update_particle_ent();
        self.clear_update_particle_should_draw();
        self.clear_update_particle_set_frozen();
        self.clear_change_control_point_attachment();
        self.clear_update_entity_position();
        self.clear_set_particle_fow_properties();
        self.clear_set_particle_text();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ParticleManager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ParticleManager {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {}

impl CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
    pub fn new() -> CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_ReleaseParticleIndex> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ParticleManager_ReleaseParticleIndex,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ParticleManager_ReleaseParticleIndex::new)
        }
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
    fn new() -> CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
        CDOTAUserMsg_ParticleManager_ReleaseParticleIndex::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ParticleManager_ReleaseParticleIndex>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_ReleaseParticleIndex>(
                    "CDOTAUserMsg_ParticleManager_ReleaseParticleIndex",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ParticleManager_ReleaseParticleIndex {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ParticleManager_CreateParticle {
    // message fields
    particle_name_index: ::std::option::Option<u64>,
    attach_type: ::std::option::Option<i32>,
    entity_handle: ::std::option::Option<i32>,
    entity_handle_for_modifiers: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ParticleManager_CreateParticle {}

impl CDOTAUserMsg_ParticleManager_CreateParticle {
    pub fn new() -> CDOTAUserMsg_ParticleManager_CreateParticle {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_CreateParticle {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_CreateParticle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ParticleManager_CreateParticle,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ParticleManager_CreateParticle::new)
        }
    }

    // optional fixed64 particle_name_index = 1;

    pub fn clear_particle_name_index(&mut self) {
        self.particle_name_index = ::std::option::Option::None;
    }

    pub fn has_particle_name_index(&self) -> bool {
        self.particle_name_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particle_name_index(&mut self, v: u64) {
        self.particle_name_index = ::std::option::Option::Some(v);
    }

    pub fn get_particle_name_index(&self) -> u64 {
        self.particle_name_index.unwrap_or(0)
    }

    fn get_particle_name_index_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.particle_name_index
    }

    fn mut_particle_name_index_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.particle_name_index
    }

    // optional int32 attach_type = 2;

    pub fn clear_attach_type(&mut self) {
        self.attach_type = ::std::option::Option::None;
    }

    pub fn has_attach_type(&self) -> bool {
        self.attach_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_type(&mut self, v: i32) {
        self.attach_type = ::std::option::Option::Some(v);
    }

    pub fn get_attach_type(&self) -> i32 {
        self.attach_type.unwrap_or(0)
    }

    fn get_attach_type_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.attach_type
    }

    fn mut_attach_type_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.attach_type
    }

    // optional int32 entity_handle = 3;

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = ::std::option::Option::None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: i32) {
        self.entity_handle = ::std::option::Option::Some(v);
    }

    pub fn get_entity_handle(&self) -> i32 {
        self.entity_handle.unwrap_or(0)
    }

    fn get_entity_handle_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entity_handle
    }

    fn mut_entity_handle_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entity_handle
    }

    // optional int32 entity_handle_for_modifiers = 4;

    pub fn clear_entity_handle_for_modifiers(&mut self) {
        self.entity_handle_for_modifiers = ::std::option::Option::None;
    }

    pub fn has_entity_handle_for_modifiers(&self) -> bool {
        self.entity_handle_for_modifiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle_for_modifiers(&mut self, v: i32) {
        self.entity_handle_for_modifiers = ::std::option::Option::Some(v);
    }

    pub fn get_entity_handle_for_modifiers(&self) -> i32 {
        self.entity_handle_for_modifiers.unwrap_or(0)
    }

    fn get_entity_handle_for_modifiers_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entity_handle_for_modifiers
    }

    fn mut_entity_handle_for_modifiers_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entity_handle_for_modifiers
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_CreateParticle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.particle_name_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.attach_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entity_handle = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entity_handle_for_modifiers = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.particle_name_index {
            my_size += 9;
        }
        if let Some(v) = self.attach_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entity_handle {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entity_handle_for_modifiers {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.particle_name_index {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.attach_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.entity_handle {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.entity_handle_for_modifiers {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ParticleManager_CreateParticle {
    fn new() -> CDOTAUserMsg_ParticleManager_CreateParticle {
        CDOTAUserMsg_ParticleManager_CreateParticle::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ParticleManager_CreateParticle>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "particle_name_index",
                    CDOTAUserMsg_ParticleManager_CreateParticle::get_particle_name_index_for_reflect,
                    CDOTAUserMsg_ParticleManager_CreateParticle::mut_particle_name_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "attach_type",
                    CDOTAUserMsg_ParticleManager_CreateParticle::get_attach_type_for_reflect,
                    CDOTAUserMsg_ParticleManager_CreateParticle::mut_attach_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entity_handle",
                    CDOTAUserMsg_ParticleManager_CreateParticle::get_entity_handle_for_reflect,
                    CDOTAUserMsg_ParticleManager_CreateParticle::mut_entity_handle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entity_handle_for_modifiers",
                    CDOTAUserMsg_ParticleManager_CreateParticle::get_entity_handle_for_modifiers_for_reflect,
                    CDOTAUserMsg_ParticleManager_CreateParticle::mut_entity_handle_for_modifiers_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_CreateParticle>(
                    "CDOTAUserMsg_ParticleManager_CreateParticle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_CreateParticle {
    fn clear(&mut self) {
        self.clear_particle_name_index();
        self.clear_attach_type();
        self.clear_entity_handle();
        self.clear_entity_handle_for_modifiers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ParticleManager_CreateParticle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ParticleManager_CreateParticle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ParticleManager_DestroyParticle {
    // message fields
    destroy_immediately: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ParticleManager_DestroyParticle {}

impl CDOTAUserMsg_ParticleManager_DestroyParticle {
    pub fn new() -> CDOTAUserMsg_ParticleManager_DestroyParticle {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_DestroyParticle {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_DestroyParticle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ParticleManager_DestroyParticle,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ParticleManager_DestroyParticle::new)
        }
    }

    // optional bool destroy_immediately = 1;

    pub fn clear_destroy_immediately(&mut self) {
        self.destroy_immediately = ::std::option::Option::None;
    }

    pub fn has_destroy_immediately(&self) -> bool {
        self.destroy_immediately.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroy_immediately(&mut self, v: bool) {
        self.destroy_immediately = ::std::option::Option::Some(v);
    }

    pub fn get_destroy_immediately(&self) -> bool {
        self.destroy_immediately.unwrap_or(false)
    }

    fn get_destroy_immediately_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.destroy_immediately
    }

    fn mut_destroy_immediately_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.destroy_immediately
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_DestroyParticle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.destroy_immediately = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.destroy_immediately {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.destroy_immediately {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ParticleManager_DestroyParticle {
    fn new() -> CDOTAUserMsg_ParticleManager_DestroyParticle {
        CDOTAUserMsg_ParticleManager_DestroyParticle::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ParticleManager_DestroyParticle>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "destroy_immediately",
                    CDOTAUserMsg_ParticleManager_DestroyParticle::get_destroy_immediately_for_reflect,
                    CDOTAUserMsg_ParticleManager_DestroyParticle::mut_destroy_immediately_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_DestroyParticle>(
                    "CDOTAUserMsg_ParticleManager_DestroyParticle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_DestroyParticle {
    fn clear(&mut self) {
        self.clear_destroy_immediately();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ParticleManager_DestroyParticle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ParticleManager_DestroyParticle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
    // message fields
    destroy_immediately: ::std::option::Option<bool>,
    entity_handle: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {}

impl CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
    pub fn new() -> CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_DestroyParticleInvolving> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ParticleManager_DestroyParticleInvolving,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ParticleManager_DestroyParticleInvolving::new)
        }
    }

    // optional bool destroy_immediately = 1;

    pub fn clear_destroy_immediately(&mut self) {
        self.destroy_immediately = ::std::option::Option::None;
    }

    pub fn has_destroy_immediately(&self) -> bool {
        self.destroy_immediately.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroy_immediately(&mut self, v: bool) {
        self.destroy_immediately = ::std::option::Option::Some(v);
    }

    pub fn get_destroy_immediately(&self) -> bool {
        self.destroy_immediately.unwrap_or(false)
    }

    fn get_destroy_immediately_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.destroy_immediately
    }

    fn mut_destroy_immediately_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.destroy_immediately
    }

    // optional int32 entity_handle = 3;

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = ::std::option::Option::None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: i32) {
        self.entity_handle = ::std::option::Option::Some(v);
    }

    pub fn get_entity_handle(&self) -> i32 {
        self.entity_handle.unwrap_or(0)
    }

    fn get_entity_handle_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entity_handle
    }

    fn mut_entity_handle_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entity_handle
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.destroy_immediately = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entity_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.destroy_immediately {
            my_size += 2;
        }
        if let Some(v) = self.entity_handle {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.destroy_immediately {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.entity_handle {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
    fn new() -> CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
        CDOTAUserMsg_ParticleManager_DestroyParticleInvolving::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ParticleManager_DestroyParticleInvolving>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "destroy_immediately",
                    CDOTAUserMsg_ParticleManager_DestroyParticleInvolving::get_destroy_immediately_for_reflect,
                    CDOTAUserMsg_ParticleManager_DestroyParticleInvolving::mut_destroy_immediately_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entity_handle",
                    CDOTAUserMsg_ParticleManager_DestroyParticleInvolving::get_entity_handle_for_reflect,
                    CDOTAUserMsg_ParticleManager_DestroyParticleInvolving::mut_entity_handle_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_DestroyParticleInvolving>(
                    "CDOTAUserMsg_ParticleManager_DestroyParticleInvolving",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
    fn clear(&mut self) {
        self.clear_destroy_immediately();
        self.clear_entity_handle();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ParticleManager_DestroyParticleInvolving {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ParticleManager_UpdateParticle {
    // message fields
    control_point: ::std::option::Option<i32>,
    position: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ParticleManager_UpdateParticle {}

impl CDOTAUserMsg_ParticleManager_UpdateParticle {
    pub fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticle {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_UpdateParticle {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_UpdateParticle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ParticleManager_UpdateParticle,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ParticleManager_UpdateParticle::new)
        }
    }

    // optional int32 control_point = 1;

    pub fn clear_control_point(&mut self) {
        self.control_point = ::std::option::Option::None;
    }

    pub fn has_control_point(&self) -> bool {
        self.control_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_point(&mut self, v: i32) {
        self.control_point = ::std::option::Option::Some(v);
    }

    pub fn get_control_point(&self) -> i32 {
        self.control_point.unwrap_or(0)
    }

    fn get_control_point_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.control_point
    }

    fn mut_control_point_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.control_point
    }

    // optional .CMsgVector position = 2;

    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: super::networkbasetypes::CMsgVector) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut super::networkbasetypes::CMsgVector {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> super::networkbasetypes::CMsgVector {
        self.position.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector::new())
    }

    pub fn get_position(&self) -> &super::networkbasetypes::CMsgVector {
        self.position.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector::default_instance())
    }

    fn get_position_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &self.position
    }

    fn mut_position_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &mut self.position
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_UpdateParticle {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.control_point = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.control_point {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.control_point {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ParticleManager_UpdateParticle {
    fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticle {
        CDOTAUserMsg_ParticleManager_UpdateParticle::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ParticleManager_UpdateParticle>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "control_point",
                    CDOTAUserMsg_ParticleManager_UpdateParticle::get_control_point_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticle::mut_control_point_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector>>(
                    "position",
                    CDOTAUserMsg_ParticleManager_UpdateParticle::get_position_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticle::mut_position_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_UpdateParticle>(
                    "CDOTAUserMsg_ParticleManager_UpdateParticle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_UpdateParticle {
    fn clear(&mut self) {
        self.clear_control_point();
        self.clear_position();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ParticleManager_UpdateParticle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ParticleManager_UpdateParticle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
    // message fields
    control_point: ::std::option::Option<i32>,
    forward: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ParticleManager_UpdateParticleFwd {}

impl CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
    pub fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_UpdateParticleFwd> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ParticleManager_UpdateParticleFwd,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ParticleManager_UpdateParticleFwd::new)
        }
    }

    // optional int32 control_point = 1;

    pub fn clear_control_point(&mut self) {
        self.control_point = ::std::option::Option::None;
    }

    pub fn has_control_point(&self) -> bool {
        self.control_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_point(&mut self, v: i32) {
        self.control_point = ::std::option::Option::Some(v);
    }

    pub fn get_control_point(&self) -> i32 {
        self.control_point.unwrap_or(0)
    }

    fn get_control_point_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.control_point
    }

    fn mut_control_point_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.control_point
    }

    // optional .CMsgVector forward = 2;

    pub fn clear_forward(&mut self) {
        self.forward.clear();
    }

    pub fn has_forward(&self) -> bool {
        self.forward.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward(&mut self, v: super::networkbasetypes::CMsgVector) {
        self.forward = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forward(&mut self) -> &mut super::networkbasetypes::CMsgVector {
        if self.forward.is_none() {
            self.forward.set_default();
        }
        self.forward.as_mut().unwrap()
    }

    // Take field
    pub fn take_forward(&mut self) -> super::networkbasetypes::CMsgVector {
        self.forward.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector::new())
    }

    pub fn get_forward(&self) -> &super::networkbasetypes::CMsgVector {
        self.forward.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector::default_instance())
    }

    fn get_forward_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &self.forward
    }

    fn mut_forward_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &mut self.forward
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
    fn is_initialized(&self) -> bool {
        for v in &self.forward {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.control_point = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.forward)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.control_point {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.forward.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.control_point {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.forward.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
    fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
        CDOTAUserMsg_ParticleManager_UpdateParticleFwd::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ParticleManager_UpdateParticleFwd>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "control_point",
                    CDOTAUserMsg_ParticleManager_UpdateParticleFwd::get_control_point_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleFwd::mut_control_point_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector>>(
                    "forward",
                    CDOTAUserMsg_ParticleManager_UpdateParticleFwd::get_forward_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleFwd::mut_forward_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_UpdateParticleFwd>(
                    "CDOTAUserMsg_ParticleManager_UpdateParticleFwd",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
    fn clear(&mut self) {
        self.clear_control_point();
        self.clear_forward();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ParticleManager_UpdateParticleFwd {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
    // message fields
    control_point: ::std::option::Option<i32>,
    forward: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector>,
    right: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector>,
    up: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ParticleManager_UpdateParticleOrient {}

impl CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
    pub fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_UpdateParticleOrient> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ParticleManager_UpdateParticleOrient,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ParticleManager_UpdateParticleOrient::new)
        }
    }

    // optional int32 control_point = 1;

    pub fn clear_control_point(&mut self) {
        self.control_point = ::std::option::Option::None;
    }

    pub fn has_control_point(&self) -> bool {
        self.control_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_point(&mut self, v: i32) {
        self.control_point = ::std::option::Option::Some(v);
    }

    pub fn get_control_point(&self) -> i32 {
        self.control_point.unwrap_or(0)
    }

    fn get_control_point_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.control_point
    }

    fn mut_control_point_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.control_point
    }

    // optional .CMsgVector forward = 2;

    pub fn clear_forward(&mut self) {
        self.forward.clear();
    }

    pub fn has_forward(&self) -> bool {
        self.forward.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward(&mut self, v: super::networkbasetypes::CMsgVector) {
        self.forward = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forward(&mut self) -> &mut super::networkbasetypes::CMsgVector {
        if self.forward.is_none() {
            self.forward.set_default();
        }
        self.forward.as_mut().unwrap()
    }

    // Take field
    pub fn take_forward(&mut self) -> super::networkbasetypes::CMsgVector {
        self.forward.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector::new())
    }

    pub fn get_forward(&self) -> &super::networkbasetypes::CMsgVector {
        self.forward.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector::default_instance())
    }

    fn get_forward_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &self.forward
    }

    fn mut_forward_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &mut self.forward
    }

    // optional .CMsgVector right = 3;

    pub fn clear_right(&mut self) {
        self.right.clear();
    }

    pub fn has_right(&self) -> bool {
        self.right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right(&mut self, v: super::networkbasetypes::CMsgVector) {
        self.right = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_right(&mut self) -> &mut super::networkbasetypes::CMsgVector {
        if self.right.is_none() {
            self.right.set_default();
        }
        self.right.as_mut().unwrap()
    }

    // Take field
    pub fn take_right(&mut self) -> super::networkbasetypes::CMsgVector {
        self.right.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector::new())
    }

    pub fn get_right(&self) -> &super::networkbasetypes::CMsgVector {
        self.right.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector::default_instance())
    }

    fn get_right_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &self.right
    }

    fn mut_right_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &mut self.right
    }

    // optional .CMsgVector up = 4;

    pub fn clear_up(&mut self) {
        self.up.clear();
    }

    pub fn has_up(&self) -> bool {
        self.up.is_some()
    }

    // Param is passed by value, moved
    pub fn set_up(&mut self, v: super::networkbasetypes::CMsgVector) {
        self.up = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_up(&mut self) -> &mut super::networkbasetypes::CMsgVector {
        if self.up.is_none() {
            self.up.set_default();
        }
        self.up.as_mut().unwrap()
    }

    // Take field
    pub fn take_up(&mut self) -> super::networkbasetypes::CMsgVector {
        self.up.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector::new())
    }

    pub fn get_up(&self) -> &super::networkbasetypes::CMsgVector {
        self.up.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector::default_instance())
    }

    fn get_up_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &self.up
    }

    fn mut_up_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &mut self.up
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
    fn is_initialized(&self) -> bool {
        for v in &self.forward {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.right {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.up {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.control_point = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.forward)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.right)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.up)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.control_point {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.forward.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.up.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.control_point {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.forward.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.right.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.up.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
    fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
        CDOTAUserMsg_ParticleManager_UpdateParticleOrient::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ParticleManager_UpdateParticleOrient>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "control_point",
                    CDOTAUserMsg_ParticleManager_UpdateParticleOrient::get_control_point_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleOrient::mut_control_point_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector>>(
                    "forward",
                    CDOTAUserMsg_ParticleManager_UpdateParticleOrient::get_forward_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleOrient::mut_forward_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector>>(
                    "right",
                    CDOTAUserMsg_ParticleManager_UpdateParticleOrient::get_right_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleOrient::mut_right_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector>>(
                    "up",
                    CDOTAUserMsg_ParticleManager_UpdateParticleOrient::get_up_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleOrient::mut_up_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_UpdateParticleOrient>(
                    "CDOTAUserMsg_ParticleManager_UpdateParticleOrient",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
    fn clear(&mut self) {
        self.clear_control_point();
        self.clear_forward();
        self.clear_right();
        self.clear_up();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ParticleManager_UpdateParticleOrient {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
    // message fields
    control_point: ::std::option::Option<i32>,
    position: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ParticleManager_UpdateParticleFallback {}

impl CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
    pub fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_UpdateParticleFallback> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ParticleManager_UpdateParticleFallback,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ParticleManager_UpdateParticleFallback::new)
        }
    }

    // optional int32 control_point = 1;

    pub fn clear_control_point(&mut self) {
        self.control_point = ::std::option::Option::None;
    }

    pub fn has_control_point(&self) -> bool {
        self.control_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_point(&mut self, v: i32) {
        self.control_point = ::std::option::Option::Some(v);
    }

    pub fn get_control_point(&self) -> i32 {
        self.control_point.unwrap_or(0)
    }

    fn get_control_point_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.control_point
    }

    fn mut_control_point_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.control_point
    }

    // optional .CMsgVector position = 2;

    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: super::networkbasetypes::CMsgVector) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut super::networkbasetypes::CMsgVector {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> super::networkbasetypes::CMsgVector {
        self.position.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector::new())
    }

    pub fn get_position(&self) -> &super::networkbasetypes::CMsgVector {
        self.position.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector::default_instance())
    }

    fn get_position_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &self.position
    }

    fn mut_position_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &mut self.position
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.control_point = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.control_point {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.control_point {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
    fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
        CDOTAUserMsg_ParticleManager_UpdateParticleFallback::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ParticleManager_UpdateParticleFallback>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "control_point",
                    CDOTAUserMsg_ParticleManager_UpdateParticleFallback::get_control_point_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleFallback::mut_control_point_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector>>(
                    "position",
                    CDOTAUserMsg_ParticleManager_UpdateParticleFallback::get_position_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleFallback::mut_position_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_UpdateParticleFallback>(
                    "CDOTAUserMsg_ParticleManager_UpdateParticleFallback",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
    fn clear(&mut self) {
        self.clear_control_point();
        self.clear_position();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ParticleManager_UpdateParticleFallback {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
    // message fields
    control_point: ::std::option::Option<i32>,
    origin_offset: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ParticleManager_UpdateParticleOffset {}

impl CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
    pub fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_UpdateParticleOffset> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ParticleManager_UpdateParticleOffset,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ParticleManager_UpdateParticleOffset::new)
        }
    }

    // optional int32 control_point = 1;

    pub fn clear_control_point(&mut self) {
        self.control_point = ::std::option::Option::None;
    }

    pub fn has_control_point(&self) -> bool {
        self.control_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_point(&mut self, v: i32) {
        self.control_point = ::std::option::Option::Some(v);
    }

    pub fn get_control_point(&self) -> i32 {
        self.control_point.unwrap_or(0)
    }

    fn get_control_point_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.control_point
    }

    fn mut_control_point_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.control_point
    }

    // optional .CMsgVector origin_offset = 2;

    pub fn clear_origin_offset(&mut self) {
        self.origin_offset.clear();
    }

    pub fn has_origin_offset(&self) -> bool {
        self.origin_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_offset(&mut self, v: super::networkbasetypes::CMsgVector) {
        self.origin_offset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin_offset(&mut self) -> &mut super::networkbasetypes::CMsgVector {
        if self.origin_offset.is_none() {
            self.origin_offset.set_default();
        }
        self.origin_offset.as_mut().unwrap()
    }

    // Take field
    pub fn take_origin_offset(&mut self) -> super::networkbasetypes::CMsgVector {
        self.origin_offset.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector::new())
    }

    pub fn get_origin_offset(&self) -> &super::networkbasetypes::CMsgVector {
        self.origin_offset.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector::default_instance())
    }

    fn get_origin_offset_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &self.origin_offset
    }

    fn mut_origin_offset_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &mut self.origin_offset
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
    fn is_initialized(&self) -> bool {
        for v in &self.origin_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.control_point = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.origin_offset)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.control_point {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.origin_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.control_point {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.origin_offset.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
    fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
        CDOTAUserMsg_ParticleManager_UpdateParticleOffset::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ParticleManager_UpdateParticleOffset>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "control_point",
                    CDOTAUserMsg_ParticleManager_UpdateParticleOffset::get_control_point_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleOffset::mut_control_point_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector>>(
                    "origin_offset",
                    CDOTAUserMsg_ParticleManager_UpdateParticleOffset::get_origin_offset_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleOffset::mut_origin_offset_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_UpdateParticleOffset>(
                    "CDOTAUserMsg_ParticleManager_UpdateParticleOffset",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
    fn clear(&mut self) {
        self.clear_control_point();
        self.clear_origin_offset();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ParticleManager_UpdateParticleOffset {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
    // message fields
    control_point: ::std::option::Option<i32>,
    entity_handle: ::std::option::Option<i32>,
    attach_type: ::std::option::Option<i32>,
    attachment: ::std::option::Option<i32>,
    fallback_position: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector>,
    include_wearables: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ParticleManager_UpdateParticleEnt {}

impl CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
    pub fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_UpdateParticleEnt> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ParticleManager_UpdateParticleEnt,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ParticleManager_UpdateParticleEnt::new)
        }
    }

    // optional int32 control_point = 1;

    pub fn clear_control_point(&mut self) {
        self.control_point = ::std::option::Option::None;
    }

    pub fn has_control_point(&self) -> bool {
        self.control_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_point(&mut self, v: i32) {
        self.control_point = ::std::option::Option::Some(v);
    }

    pub fn get_control_point(&self) -> i32 {
        self.control_point.unwrap_or(0)
    }

    fn get_control_point_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.control_point
    }

    fn mut_control_point_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.control_point
    }

    // optional int32 entity_handle = 2;

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = ::std::option::Option::None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: i32) {
        self.entity_handle = ::std::option::Option::Some(v);
    }

    pub fn get_entity_handle(&self) -> i32 {
        self.entity_handle.unwrap_or(0)
    }

    fn get_entity_handle_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entity_handle
    }

    fn mut_entity_handle_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entity_handle
    }

    // optional int32 attach_type = 3;

    pub fn clear_attach_type(&mut self) {
        self.attach_type = ::std::option::Option::None;
    }

    pub fn has_attach_type(&self) -> bool {
        self.attach_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attach_type(&mut self, v: i32) {
        self.attach_type = ::std::option::Option::Some(v);
    }

    pub fn get_attach_type(&self) -> i32 {
        self.attach_type.unwrap_or(0)
    }

    fn get_attach_type_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.attach_type
    }

    fn mut_attach_type_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.attach_type
    }

    // optional int32 attachment = 4;

    pub fn clear_attachment(&mut self) {
        self.attachment = ::std::option::Option::None;
    }

    pub fn has_attachment(&self) -> bool {
        self.attachment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachment(&mut self, v: i32) {
        self.attachment = ::std::option::Option::Some(v);
    }

    pub fn get_attachment(&self) -> i32 {
        self.attachment.unwrap_or(0)
    }

    fn get_attachment_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.attachment
    }

    fn mut_attachment_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.attachment
    }

    // optional .CMsgVector fallback_position = 5;

    pub fn clear_fallback_position(&mut self) {
        self.fallback_position.clear();
    }

    pub fn has_fallback_position(&self) -> bool {
        self.fallback_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fallback_position(&mut self, v: super::networkbasetypes::CMsgVector) {
        self.fallback_position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fallback_position(&mut self) -> &mut super::networkbasetypes::CMsgVector {
        if self.fallback_position.is_none() {
            self.fallback_position.set_default();
        }
        self.fallback_position.as_mut().unwrap()
    }

    // Take field
    pub fn take_fallback_position(&mut self) -> super::networkbasetypes::CMsgVector {
        self.fallback_position.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector::new())
    }

    pub fn get_fallback_position(&self) -> &super::networkbasetypes::CMsgVector {
        self.fallback_position.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector::default_instance())
    }

    fn get_fallback_position_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &self.fallback_position
    }

    fn mut_fallback_position_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &mut self.fallback_position
    }

    // optional bool include_wearables = 6;

    pub fn clear_include_wearables(&mut self) {
        self.include_wearables = ::std::option::Option::None;
    }

    pub fn has_include_wearables(&self) -> bool {
        self.include_wearables.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_wearables(&mut self, v: bool) {
        self.include_wearables = ::std::option::Option::Some(v);
    }

    pub fn get_include_wearables(&self) -> bool {
        self.include_wearables.unwrap_or(false)
    }

    fn get_include_wearables_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.include_wearables
    }

    fn mut_include_wearables_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.include_wearables
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
    fn is_initialized(&self) -> bool {
        for v in &self.fallback_position {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.control_point = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entity_handle = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.attach_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.attachment = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fallback_position)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_wearables = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.control_point {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entity_handle {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.attach_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.attachment {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fallback_position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.include_wearables {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.control_point {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.entity_handle {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.attach_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.attachment {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.fallback_position.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.include_wearables {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
    fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
        CDOTAUserMsg_ParticleManager_UpdateParticleEnt::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ParticleManager_UpdateParticleEnt>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "control_point",
                    CDOTAUserMsg_ParticleManager_UpdateParticleEnt::get_control_point_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleEnt::mut_control_point_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entity_handle",
                    CDOTAUserMsg_ParticleManager_UpdateParticleEnt::get_entity_handle_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleEnt::mut_entity_handle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "attach_type",
                    CDOTAUserMsg_ParticleManager_UpdateParticleEnt::get_attach_type_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleEnt::mut_attach_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "attachment",
                    CDOTAUserMsg_ParticleManager_UpdateParticleEnt::get_attachment_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleEnt::mut_attachment_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector>>(
                    "fallback_position",
                    CDOTAUserMsg_ParticleManager_UpdateParticleEnt::get_fallback_position_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleEnt::mut_fallback_position_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "include_wearables",
                    CDOTAUserMsg_ParticleManager_UpdateParticleEnt::get_include_wearables_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleEnt::mut_include_wearables_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_UpdateParticleEnt>(
                    "CDOTAUserMsg_ParticleManager_UpdateParticleEnt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
    fn clear(&mut self) {
        self.clear_control_point();
        self.clear_entity_handle();
        self.clear_attach_type();
        self.clear_attachment();
        self.clear_fallback_position();
        self.clear_include_wearables();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ParticleManager_UpdateParticleEnt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen {
    // message fields
    set_frozen: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen {}

impl CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen {
    pub fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen::new)
        }
    }

    // optional bool set_frozen = 1;

    pub fn clear_set_frozen(&mut self) {
        self.set_frozen = ::std::option::Option::None;
    }

    pub fn has_set_frozen(&self) -> bool {
        self.set_frozen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set_frozen(&mut self, v: bool) {
        self.set_frozen = ::std::option::Option::Some(v);
    }

    pub fn get_set_frozen(&self) -> bool {
        self.set_frozen.unwrap_or(false)
    }

    fn get_set_frozen_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.set_frozen
    }

    fn mut_set_frozen_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.set_frozen
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.set_frozen = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.set_frozen {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.set_frozen {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen {
    fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen {
        CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "set_frozen",
                    CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen::get_set_frozen_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen::mut_set_frozen_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen>(
                    "CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen {
    fn clear(&mut self) {
        self.clear_set_frozen();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ParticleManager_UpdateParticleSetFrozen {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw {
    // message fields
    should_draw: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw {}

impl CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw {
    pub fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw::new)
        }
    }

    // optional bool should_draw = 1;

    pub fn clear_should_draw(&mut self) {
        self.should_draw = ::std::option::Option::None;
    }

    pub fn has_should_draw(&self) -> bool {
        self.should_draw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_should_draw(&mut self, v: bool) {
        self.should_draw = ::std::option::Option::Some(v);
    }

    pub fn get_should_draw(&self) -> bool {
        self.should_draw.unwrap_or(false)
    }

    fn get_should_draw_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.should_draw
    }

    fn mut_should_draw_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.should_draw
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.should_draw = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.should_draw {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.should_draw {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw {
    fn new() -> CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw {
        CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "should_draw",
                    CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw::get_should_draw_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw::mut_should_draw_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw>(
                    "CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw {
    fn clear(&mut self) {
        self.clear_should_draw();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ParticleManager_UpdateParticleShouldDraw {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment {
    // message fields
    attachment_old: ::std::option::Option<i32>,
    attachment_new: ::std::option::Option<i32>,
    entity_handle: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment {}

impl CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment {
    pub fn new() -> CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment::new)
        }
    }

    // optional int32 attachment_old = 1;

    pub fn clear_attachment_old(&mut self) {
        self.attachment_old = ::std::option::Option::None;
    }

    pub fn has_attachment_old(&self) -> bool {
        self.attachment_old.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachment_old(&mut self, v: i32) {
        self.attachment_old = ::std::option::Option::Some(v);
    }

    pub fn get_attachment_old(&self) -> i32 {
        self.attachment_old.unwrap_or(0)
    }

    fn get_attachment_old_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.attachment_old
    }

    fn mut_attachment_old_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.attachment_old
    }

    // optional int32 attachment_new = 2;

    pub fn clear_attachment_new(&mut self) {
        self.attachment_new = ::std::option::Option::None;
    }

    pub fn has_attachment_new(&self) -> bool {
        self.attachment_new.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachment_new(&mut self, v: i32) {
        self.attachment_new = ::std::option::Option::Some(v);
    }

    pub fn get_attachment_new(&self) -> i32 {
        self.attachment_new.unwrap_or(0)
    }

    fn get_attachment_new_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.attachment_new
    }

    fn mut_attachment_new_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.attachment_new
    }

    // optional int32 entity_handle = 3;

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = ::std::option::Option::None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: i32) {
        self.entity_handle = ::std::option::Option::Some(v);
    }

    pub fn get_entity_handle(&self) -> i32 {
        self.entity_handle.unwrap_or(0)
    }

    fn get_entity_handle_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entity_handle
    }

    fn mut_entity_handle_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entity_handle
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.attachment_old = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.attachment_new = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entity_handle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.attachment_old {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.attachment_new {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entity_handle {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.attachment_old {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.attachment_new {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.entity_handle {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment {
    fn new() -> CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment {
        CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "attachment_old",
                    CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment::get_attachment_old_for_reflect,
                    CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment::mut_attachment_old_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "attachment_new",
                    CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment::get_attachment_new_for_reflect,
                    CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment::mut_attachment_new_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entity_handle",
                    CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment::get_entity_handle_for_reflect,
                    CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment::mut_entity_handle_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment>(
                    "CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment {
    fn clear(&mut self) {
        self.clear_attachment_old();
        self.clear_attachment_new();
        self.clear_entity_handle();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ParticleManager_ChangeControlPointAttachment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ParticleManager_UpdateEntityPosition {
    // message fields
    entity_handle: ::std::option::Option<i32>,
    position: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ParticleManager_UpdateEntityPosition {}

impl CDOTAUserMsg_ParticleManager_UpdateEntityPosition {
    pub fn new() -> CDOTAUserMsg_ParticleManager_UpdateEntityPosition {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_UpdateEntityPosition {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_UpdateEntityPosition> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ParticleManager_UpdateEntityPosition,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ParticleManager_UpdateEntityPosition::new)
        }
    }

    // optional int32 entity_handle = 1;

    pub fn clear_entity_handle(&mut self) {
        self.entity_handle = ::std::option::Option::None;
    }

    pub fn has_entity_handle(&self) -> bool {
        self.entity_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_handle(&mut self, v: i32) {
        self.entity_handle = ::std::option::Option::Some(v);
    }

    pub fn get_entity_handle(&self) -> i32 {
        self.entity_handle.unwrap_or(0)
    }

    fn get_entity_handle_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entity_handle
    }

    fn mut_entity_handle_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entity_handle
    }

    // optional .CMsgVector position = 2;

    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: super::networkbasetypes::CMsgVector) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut super::networkbasetypes::CMsgVector {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> super::networkbasetypes::CMsgVector {
        self.position.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector::new())
    }

    pub fn get_position(&self) -> &super::networkbasetypes::CMsgVector {
        self.position.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector::default_instance())
    }

    fn get_position_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &self.position
    }

    fn mut_position_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &mut self.position
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_UpdateEntityPosition {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entity_handle = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entity_handle {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entity_handle {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ParticleManager_UpdateEntityPosition {
    fn new() -> CDOTAUserMsg_ParticleManager_UpdateEntityPosition {
        CDOTAUserMsg_ParticleManager_UpdateEntityPosition::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ParticleManager_UpdateEntityPosition>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entity_handle",
                    CDOTAUserMsg_ParticleManager_UpdateEntityPosition::get_entity_handle_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateEntityPosition::mut_entity_handle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector>>(
                    "position",
                    CDOTAUserMsg_ParticleManager_UpdateEntityPosition::get_position_for_reflect,
                    CDOTAUserMsg_ParticleManager_UpdateEntityPosition::mut_position_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_UpdateEntityPosition>(
                    "CDOTAUserMsg_ParticleManager_UpdateEntityPosition",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_UpdateEntityPosition {
    fn clear(&mut self) {
        self.clear_entity_handle();
        self.clear_position();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ParticleManager_UpdateEntityPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ParticleManager_UpdateEntityPosition {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ParticleManager_SetParticleFoWProperties {
    // message fields
    fow_control_point: ::std::option::Option<i32>,
    fow_control_point2: ::std::option::Option<i32>,
    fow_radius: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ParticleManager_SetParticleFoWProperties {}

impl CDOTAUserMsg_ParticleManager_SetParticleFoWProperties {
    pub fn new() -> CDOTAUserMsg_ParticleManager_SetParticleFoWProperties {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_SetParticleFoWProperties {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_SetParticleFoWProperties> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ParticleManager_SetParticleFoWProperties,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ParticleManager_SetParticleFoWProperties::new)
        }
    }

    // optional int32 fow_control_point = 1;

    pub fn clear_fow_control_point(&mut self) {
        self.fow_control_point = ::std::option::Option::None;
    }

    pub fn has_fow_control_point(&self) -> bool {
        self.fow_control_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fow_control_point(&mut self, v: i32) {
        self.fow_control_point = ::std::option::Option::Some(v);
    }

    pub fn get_fow_control_point(&self) -> i32 {
        self.fow_control_point.unwrap_or(0)
    }

    fn get_fow_control_point_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.fow_control_point
    }

    fn mut_fow_control_point_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.fow_control_point
    }

    // optional int32 fow_control_point2 = 2;

    pub fn clear_fow_control_point2(&mut self) {
        self.fow_control_point2 = ::std::option::Option::None;
    }

    pub fn has_fow_control_point2(&self) -> bool {
        self.fow_control_point2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fow_control_point2(&mut self, v: i32) {
        self.fow_control_point2 = ::std::option::Option::Some(v);
    }

    pub fn get_fow_control_point2(&self) -> i32 {
        self.fow_control_point2.unwrap_or(0)
    }

    fn get_fow_control_point2_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.fow_control_point2
    }

    fn mut_fow_control_point2_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.fow_control_point2
    }

    // optional float fow_radius = 3;

    pub fn clear_fow_radius(&mut self) {
        self.fow_radius = ::std::option::Option::None;
    }

    pub fn has_fow_radius(&self) -> bool {
        self.fow_radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fow_radius(&mut self, v: f32) {
        self.fow_radius = ::std::option::Option::Some(v);
    }

    pub fn get_fow_radius(&self) -> f32 {
        self.fow_radius.unwrap_or(0.)
    }

    fn get_fow_radius_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.fow_radius
    }

    fn mut_fow_radius_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.fow_radius
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_SetParticleFoWProperties {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fow_control_point = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fow_control_point2 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.fow_radius = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fow_control_point {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fow_control_point2 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fow_radius {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fow_control_point {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.fow_control_point2 {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.fow_radius {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ParticleManager_SetParticleFoWProperties {
    fn new() -> CDOTAUserMsg_ParticleManager_SetParticleFoWProperties {
        CDOTAUserMsg_ParticleManager_SetParticleFoWProperties::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ParticleManager_SetParticleFoWProperties>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "fow_control_point",
                    CDOTAUserMsg_ParticleManager_SetParticleFoWProperties::get_fow_control_point_for_reflect,
                    CDOTAUserMsg_ParticleManager_SetParticleFoWProperties::mut_fow_control_point_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "fow_control_point2",
                    CDOTAUserMsg_ParticleManager_SetParticleFoWProperties::get_fow_control_point2_for_reflect,
                    CDOTAUserMsg_ParticleManager_SetParticleFoWProperties::mut_fow_control_point2_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "fow_radius",
                    CDOTAUserMsg_ParticleManager_SetParticleFoWProperties::get_fow_radius_for_reflect,
                    CDOTAUserMsg_ParticleManager_SetParticleFoWProperties::mut_fow_radius_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_SetParticleFoWProperties>(
                    "CDOTAUserMsg_ParticleManager_SetParticleFoWProperties",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_SetParticleFoWProperties {
    fn clear(&mut self) {
        self.clear_fow_control_point();
        self.clear_fow_control_point2();
        self.clear_fow_radius();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ParticleManager_SetParticleFoWProperties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ParticleManager_SetParticleFoWProperties {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ParticleManager_SetParticleText {
    // message fields
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ParticleManager_SetParticleText {}

impl CDOTAUserMsg_ParticleManager_SetParticleText {
    pub fn new() -> CDOTAUserMsg_ParticleManager_SetParticleText {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ParticleManager_SetParticleText {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ParticleManager_SetParticleText> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ParticleManager_SetParticleText,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ParticleManager_SetParticleText::new)
        }
    }

    // optional string text = 1;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_text_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.text
    }

    fn mut_text_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.text
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ParticleManager_SetParticleText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ParticleManager_SetParticleText {
    fn new() -> CDOTAUserMsg_ParticleManager_SetParticleText {
        CDOTAUserMsg_ParticleManager_SetParticleText::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ParticleManager_SetParticleText>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    CDOTAUserMsg_ParticleManager_SetParticleText::get_text_for_reflect,
                    CDOTAUserMsg_ParticleManager_SetParticleText::mut_text_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ParticleManager_SetParticleText>(
                    "CDOTAUserMsg_ParticleManager_SetParticleText",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ParticleManager_SetParticleText {
    fn clear(&mut self) {
        self.clear_text();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ParticleManager_SetParticleText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ParticleManager_SetParticleText {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_OverheadEvent {
    // message fields
    message_type: ::std::option::Option<DOTA_OVERHEAD_ALERT>,
    value: ::std::option::Option<i32>,
    target_player_entindex: ::std::option::Option<i32>,
    target_entindex: ::std::option::Option<i32>,
    source_player_entindex: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_OverheadEvent {}

impl CDOTAUserMsg_OverheadEvent {
    pub fn new() -> CDOTAUserMsg_OverheadEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_OverheadEvent {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_OverheadEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_OverheadEvent,
        };
        unsafe {
            instance.get(CDOTAUserMsg_OverheadEvent::new)
        }
    }

    // required .DOTA_OVERHEAD_ALERT message_type = 1;

    pub fn clear_message_type(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_message_type(&self) -> bool {
        self.message_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_type(&mut self, v: DOTA_OVERHEAD_ALERT) {
        self.message_type = ::std::option::Option::Some(v);
    }

    pub fn get_message_type(&self) -> DOTA_OVERHEAD_ALERT {
        self.message_type.unwrap_or(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_GOLD)
    }

    fn get_message_type_for_reflect(&self) -> &::std::option::Option<DOTA_OVERHEAD_ALERT> {
        &self.message_type
    }

    fn mut_message_type_for_reflect(&mut self) -> &mut ::std::option::Option<DOTA_OVERHEAD_ALERT> {
        &mut self.message_type
    }

    // optional int32 value = 2;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> i32 {
        self.value.unwrap_or(0)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.value
    }

    // optional int32 target_player_entindex = 3;

    pub fn clear_target_player_entindex(&mut self) {
        self.target_player_entindex = ::std::option::Option::None;
    }

    pub fn has_target_player_entindex(&self) -> bool {
        self.target_player_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_entindex(&mut self, v: i32) {
        self.target_player_entindex = ::std::option::Option::Some(v);
    }

    pub fn get_target_player_entindex(&self) -> i32 {
        self.target_player_entindex.unwrap_or(0)
    }

    fn get_target_player_entindex_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.target_player_entindex
    }

    fn mut_target_player_entindex_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.target_player_entindex
    }

    // optional int32 target_entindex = 4;

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    pub fn get_target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }

    fn get_target_entindex_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.target_entindex
    }

    fn mut_target_entindex_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.target_entindex
    }

    // optional int32 source_player_entindex = 5;

    pub fn clear_source_player_entindex(&mut self) {
        self.source_player_entindex = ::std::option::Option::None;
    }

    pub fn has_source_player_entindex(&self) -> bool {
        self.source_player_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_player_entindex(&mut self, v: i32) {
        self.source_player_entindex = ::std::option::Option::Some(v);
    }

    pub fn get_source_player_entindex(&self) -> i32 {
        self.source_player_entindex.unwrap_or(0)
    }

    fn get_source_player_entindex_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.source_player_entindex
    }

    fn mut_source_player_entindex_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.source_player_entindex
    }
}

impl ::protobuf::Message for CDOTAUserMsg_OverheadEvent {
    fn is_initialized(&self) -> bool {
        if self.message_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.message_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_player_entindex = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_entindex = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.source_player_entindex = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.message_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_player_entindex {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.source_player_entindex {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.message_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.value {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.target_player_entindex {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.source_player_entindex {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_OverheadEvent {
    fn new() -> CDOTAUserMsg_OverheadEvent {
        CDOTAUserMsg_OverheadEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_OverheadEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DOTA_OVERHEAD_ALERT>>(
                    "message_type",
                    CDOTAUserMsg_OverheadEvent::get_message_type_for_reflect,
                    CDOTAUserMsg_OverheadEvent::mut_message_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    CDOTAUserMsg_OverheadEvent::get_value_for_reflect,
                    CDOTAUserMsg_OverheadEvent::mut_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_player_entindex",
                    CDOTAUserMsg_OverheadEvent::get_target_player_entindex_for_reflect,
                    CDOTAUserMsg_OverheadEvent::mut_target_player_entindex_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_entindex",
                    CDOTAUserMsg_OverheadEvent::get_target_entindex_for_reflect,
                    CDOTAUserMsg_OverheadEvent::mut_target_entindex_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "source_player_entindex",
                    CDOTAUserMsg_OverheadEvent::get_source_player_entindex_for_reflect,
                    CDOTAUserMsg_OverheadEvent::mut_source_player_entindex_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_OverheadEvent>(
                    "CDOTAUserMsg_OverheadEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_OverheadEvent {
    fn clear(&mut self) {
        self.clear_message_type();
        self.clear_value();
        self.clear_target_player_entindex();
        self.clear_target_entindex();
        self.clear_source_player_entindex();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_OverheadEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_OverheadEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_TutorialTipInfo {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    progress: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_TutorialTipInfo {}

impl CDOTAUserMsg_TutorialTipInfo {
    pub fn new() -> CDOTAUserMsg_TutorialTipInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_TutorialTipInfo {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_TutorialTipInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_TutorialTipInfo,
        };
        unsafe {
            instance.get(CDOTAUserMsg_TutorialTipInfo::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional int32 progress = 2;

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: i32) {
        self.progress = ::std::option::Option::Some(v);
    }

    pub fn get_progress(&self) -> i32 {
        self.progress.unwrap_or(0)
    }

    fn get_progress_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.progress
    }

    fn mut_progress_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.progress
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TutorialTipInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.progress = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.progress {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.progress {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_TutorialTipInfo {
    fn new() -> CDOTAUserMsg_TutorialTipInfo {
        CDOTAUserMsg_TutorialTipInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_TutorialTipInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    CDOTAUserMsg_TutorialTipInfo::get_name_for_reflect,
                    CDOTAUserMsg_TutorialTipInfo::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "progress",
                    CDOTAUserMsg_TutorialTipInfo::get_progress_for_reflect,
                    CDOTAUserMsg_TutorialTipInfo::mut_progress_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_TutorialTipInfo>(
                    "CDOTAUserMsg_TutorialTipInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_TutorialTipInfo {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_progress();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_TutorialTipInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TutorialTipInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_TutorialFinish {
    // message fields
    heading: ::protobuf::SingularField<::std::string::String>,
    emblem: ::protobuf::SingularField<::std::string::String>,
    body: ::protobuf::SingularField<::std::string::String>,
    success: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_TutorialFinish {}

impl CDOTAUserMsg_TutorialFinish {
    pub fn new() -> CDOTAUserMsg_TutorialFinish {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_TutorialFinish {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_TutorialFinish> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_TutorialFinish,
        };
        unsafe {
            instance.get(CDOTAUserMsg_TutorialFinish::new)
        }
    }

    // optional string heading = 1;

    pub fn clear_heading(&mut self) {
        self.heading.clear();
    }

    pub fn has_heading(&self) -> bool {
        self.heading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heading(&mut self, v: ::std::string::String) {
        self.heading = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_heading(&mut self) -> &mut ::std::string::String {
        if self.heading.is_none() {
            self.heading.set_default();
        }
        self.heading.as_mut().unwrap()
    }

    // Take field
    pub fn take_heading(&mut self) -> ::std::string::String {
        self.heading.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_heading(&self) -> &str {
        match self.heading.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_heading_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.heading
    }

    fn mut_heading_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.heading
    }

    // optional string emblem = 2;

    pub fn clear_emblem(&mut self) {
        self.emblem.clear();
    }

    pub fn has_emblem(&self) -> bool {
        self.emblem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emblem(&mut self, v: ::std::string::String) {
        self.emblem = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emblem(&mut self) -> &mut ::std::string::String {
        if self.emblem.is_none() {
            self.emblem.set_default();
        }
        self.emblem.as_mut().unwrap()
    }

    // Take field
    pub fn take_emblem(&mut self) -> ::std::string::String {
        self.emblem.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_emblem(&self) -> &str {
        match self.emblem.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_emblem_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.emblem
    }

    fn mut_emblem_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.emblem
    }

    // optional string body = 3;

    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_body_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.body
    }

    fn mut_body_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.body
    }

    // optional bool success = 4;

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    fn get_success_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.success
    }

    fn mut_success_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.success
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TutorialFinish {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.heading)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.emblem)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.body)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.heading.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.emblem.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.success {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.heading.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.emblem.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.body.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.success {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_TutorialFinish {
    fn new() -> CDOTAUserMsg_TutorialFinish {
        CDOTAUserMsg_TutorialFinish::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_TutorialFinish>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "heading",
                    CDOTAUserMsg_TutorialFinish::get_heading_for_reflect,
                    CDOTAUserMsg_TutorialFinish::mut_heading_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "emblem",
                    CDOTAUserMsg_TutorialFinish::get_emblem_for_reflect,
                    CDOTAUserMsg_TutorialFinish::mut_emblem_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "body",
                    CDOTAUserMsg_TutorialFinish::get_body_for_reflect,
                    CDOTAUserMsg_TutorialFinish::mut_body_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    CDOTAUserMsg_TutorialFinish::get_success_for_reflect,
                    CDOTAUserMsg_TutorialFinish::mut_success_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_TutorialFinish>(
                    "CDOTAUserMsg_TutorialFinish",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_TutorialFinish {
    fn clear(&mut self) {
        self.clear_heading();
        self.clear_emblem();
        self.clear_body();
        self.clear_success();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_TutorialFinish {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TutorialFinish {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_TutorialMinimapPosition {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_TutorialMinimapPosition {}

impl CDOTAUserMsg_TutorialMinimapPosition {
    pub fn new() -> CDOTAUserMsg_TutorialMinimapPosition {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_TutorialMinimapPosition {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_TutorialMinimapPosition> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_TutorialMinimapPosition,
        };
        unsafe {
            instance.get(CDOTAUserMsg_TutorialMinimapPosition::new)
        }
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TutorialMinimapPosition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_TutorialMinimapPosition {
    fn new() -> CDOTAUserMsg_TutorialMinimapPosition {
        CDOTAUserMsg_TutorialMinimapPosition::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_TutorialMinimapPosition>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_TutorialMinimapPosition>(
                    "CDOTAUserMsg_TutorialMinimapPosition",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_TutorialMinimapPosition {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_TutorialMinimapPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TutorialMinimapPosition {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_SendGenericToolTip {
    // message fields
    title: ::protobuf::SingularField<::std::string::String>,
    text: ::protobuf::SingularField<::std::string::String>,
    entindex: ::std::option::Option<i32>,
    close: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_SendGenericToolTip {}

impl CDOTAUserMsg_SendGenericToolTip {
    pub fn new() -> CDOTAUserMsg_SendGenericToolTip {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_SendGenericToolTip {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_SendGenericToolTip> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_SendGenericToolTip,
        };
        unsafe {
            instance.get(CDOTAUserMsg_SendGenericToolTip::new)
        }
    }

    // optional string title = 1;

    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_title_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.title
    }

    fn mut_title_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.title
    }

    // optional string text = 2;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_text_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.text
    }

    fn mut_text_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.text
    }

    // optional int32 entindex = 3;

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    pub fn get_entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    fn get_entindex_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entindex
    }

    fn mut_entindex_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entindex
    }

    // optional bool close = 4;

    pub fn clear_close(&mut self) {
        self.close = ::std::option::Option::None;
    }

    pub fn has_close(&self) -> bool {
        self.close.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close(&mut self, v: bool) {
        self.close = ::std::option::Option::Some(v);
    }

    pub fn get_close(&self) -> bool {
        self.close.unwrap_or(false)
    }

    fn get_close_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.close
    }

    fn mut_close_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.close
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SendGenericToolTip {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entindex = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.close = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.close {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.entindex {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.close {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_SendGenericToolTip {
    fn new() -> CDOTAUserMsg_SendGenericToolTip {
        CDOTAUserMsg_SendGenericToolTip::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_SendGenericToolTip>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    CDOTAUserMsg_SendGenericToolTip::get_title_for_reflect,
                    CDOTAUserMsg_SendGenericToolTip::mut_title_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    CDOTAUserMsg_SendGenericToolTip::get_text_for_reflect,
                    CDOTAUserMsg_SendGenericToolTip::mut_text_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entindex",
                    CDOTAUserMsg_SendGenericToolTip::get_entindex_for_reflect,
                    CDOTAUserMsg_SendGenericToolTip::mut_entindex_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "close",
                    CDOTAUserMsg_SendGenericToolTip::get_close_for_reflect,
                    CDOTAUserMsg_SendGenericToolTip::mut_close_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_SendGenericToolTip>(
                    "CDOTAUserMsg_SendGenericToolTip",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_SendGenericToolTip {
    fn clear(&mut self) {
        self.clear_title();
        self.clear_text();
        self.clear_entindex();
        self.clear_close();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_SendGenericToolTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SendGenericToolTip {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_WorldLine {
    // message fields
    player_id: ::std::option::Option<i32>,
    worldline: ::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_WorldLine>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_WorldLine {}

impl CDOTAUserMsg_WorldLine {
    pub fn new() -> CDOTAUserMsg_WorldLine {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_WorldLine {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_WorldLine> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_WorldLine,
        };
        unsafe {
            instance.get(CDOTAUserMsg_WorldLine::new)
        }
    }

    // optional int32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.player_id
    }

    // optional .CDOTAMsg_WorldLine worldline = 2;

    pub fn clear_worldline(&mut self) {
        self.worldline.clear();
    }

    pub fn has_worldline(&self) -> bool {
        self.worldline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_worldline(&mut self, v: super::dota_commonmessages::CDOTAMsg_WorldLine) {
        self.worldline = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worldline(&mut self) -> &mut super::dota_commonmessages::CDOTAMsg_WorldLine {
        if self.worldline.is_none() {
            self.worldline.set_default();
        }
        self.worldline.as_mut().unwrap()
    }

    // Take field
    pub fn take_worldline(&mut self) -> super::dota_commonmessages::CDOTAMsg_WorldLine {
        self.worldline.take().unwrap_or_else(|| super::dota_commonmessages::CDOTAMsg_WorldLine::new())
    }

    pub fn get_worldline(&self) -> &super::dota_commonmessages::CDOTAMsg_WorldLine {
        self.worldline.as_ref().unwrap_or_else(|| super::dota_commonmessages::CDOTAMsg_WorldLine::default_instance())
    }

    fn get_worldline_for_reflect(&self) -> &::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_WorldLine> {
        &self.worldline
    }

    fn mut_worldline_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_WorldLine> {
        &mut self.worldline
    }
}

impl ::protobuf::Message for CDOTAUserMsg_WorldLine {
    fn is_initialized(&self) -> bool {
        for v in &self.worldline {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.worldline)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.worldline.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.worldline.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_WorldLine {
    fn new() -> CDOTAUserMsg_WorldLine {
        CDOTAUserMsg_WorldLine::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_WorldLine>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_id",
                    CDOTAUserMsg_WorldLine::get_player_id_for_reflect,
                    CDOTAUserMsg_WorldLine::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_commonmessages::CDOTAMsg_WorldLine>>(
                    "worldline",
                    CDOTAUserMsg_WorldLine::get_worldline_for_reflect,
                    CDOTAUserMsg_WorldLine::mut_worldline_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_WorldLine>(
                    "CDOTAUserMsg_WorldLine",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_WorldLine {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_worldline();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_WorldLine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_WorldLine {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ChatWheel {
    // message fields
    chat_message_id: ::std::option::Option<u32>,
    player_id: ::std::option::Option<u32>,
    account_id: ::std::option::Option<u32>,
    param_hero_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ChatWheel {}

impl CDOTAUserMsg_ChatWheel {
    pub fn new() -> CDOTAUserMsg_ChatWheel {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ChatWheel {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ChatWheel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ChatWheel,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ChatWheel::new)
        }
    }

    // optional uint32 chat_message_id = 1;

    pub fn clear_chat_message_id(&mut self) {
        self.chat_message_id = ::std::option::Option::None;
    }

    pub fn has_chat_message_id(&self) -> bool {
        self.chat_message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_message_id(&mut self, v: u32) {
        self.chat_message_id = ::std::option::Option::Some(v);
    }

    pub fn get_chat_message_id(&self) -> u32 {
        self.chat_message_id.unwrap_or(0)
    }

    fn get_chat_message_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.chat_message_id
    }

    fn mut_chat_message_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.chat_message_id
    }

    // optional uint32 player_id = 2;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional uint32 account_id = 3;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // optional uint32 param_hero_id = 4;

    pub fn clear_param_hero_id(&mut self) {
        self.param_hero_id = ::std::option::Option::None;
    }

    pub fn has_param_hero_id(&self) -> bool {
        self.param_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_hero_id(&mut self, v: u32) {
        self.param_hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_param_hero_id(&self) -> u32 {
        self.param_hero_id.unwrap_or(0)
    }

    fn get_param_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.param_hero_id
    }

    fn mut_param_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.param_hero_id
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ChatWheel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.chat_message_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.param_hero_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_message_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.param_hero_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_message_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.param_hero_id {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ChatWheel {
    fn new() -> CDOTAUserMsg_ChatWheel {
        CDOTAUserMsg_ChatWheel::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ChatWheel>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "chat_message_id",
                    CDOTAUserMsg_ChatWheel::get_chat_message_id_for_reflect,
                    CDOTAUserMsg_ChatWheel::mut_chat_message_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_ChatWheel::get_player_id_for_reflect,
                    CDOTAUserMsg_ChatWheel::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CDOTAUserMsg_ChatWheel::get_account_id_for_reflect,
                    CDOTAUserMsg_ChatWheel::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "param_hero_id",
                    CDOTAUserMsg_ChatWheel::get_param_hero_id_for_reflect,
                    CDOTAUserMsg_ChatWheel::mut_param_hero_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ChatWheel>(
                    "CDOTAUserMsg_ChatWheel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ChatWheel {
    fn clear(&mut self) {
        self.clear_chat_message_id();
        self.clear_player_id();
        self.clear_account_id();
        self.clear_param_hero_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ChatWheel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ChatWheel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ReceivedXmasGift {
    // message fields
    player_id: ::std::option::Option<i32>,
    item_name: ::protobuf::SingularField<::std::string::String>,
    inventory_slot: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ReceivedXmasGift {}

impl CDOTAUserMsg_ReceivedXmasGift {
    pub fn new() -> CDOTAUserMsg_ReceivedXmasGift {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ReceivedXmasGift {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ReceivedXmasGift> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ReceivedXmasGift,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ReceivedXmasGift::new)
        }
    }

    // optional int32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.player_id
    }

    // optional string item_name = 2;

    pub fn clear_item_name(&mut self) {
        self.item_name.clear();
    }

    pub fn has_item_name(&self) -> bool {
        self.item_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_name(&mut self, v: ::std::string::String) {
        self.item_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_name(&mut self) -> &mut ::std::string::String {
        if self.item_name.is_none() {
            self.item_name.set_default();
        }
        self.item_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_name(&mut self) -> ::std::string::String {
        self.item_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_item_name(&self) -> &str {
        match self.item_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_item_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.item_name
    }

    fn mut_item_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.item_name
    }

    // optional int32 inventory_slot = 3;

    pub fn clear_inventory_slot(&mut self) {
        self.inventory_slot = ::std::option::Option::None;
    }

    pub fn has_inventory_slot(&self) -> bool {
        self.inventory_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory_slot(&mut self, v: i32) {
        self.inventory_slot = ::std::option::Option::Some(v);
    }

    pub fn get_inventory_slot(&self) -> i32 {
        self.inventory_slot.unwrap_or(0)
    }

    fn get_inventory_slot_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.inventory_slot
    }

    fn mut_inventory_slot_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.inventory_slot
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ReceivedXmasGift {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.item_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.inventory_slot = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.item_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.inventory_slot {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.item_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.inventory_slot {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ReceivedXmasGift {
    fn new() -> CDOTAUserMsg_ReceivedXmasGift {
        CDOTAUserMsg_ReceivedXmasGift::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ReceivedXmasGift>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_id",
                    CDOTAUserMsg_ReceivedXmasGift::get_player_id_for_reflect,
                    CDOTAUserMsg_ReceivedXmasGift::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "item_name",
                    CDOTAUserMsg_ReceivedXmasGift::get_item_name_for_reflect,
                    CDOTAUserMsg_ReceivedXmasGift::mut_item_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "inventory_slot",
                    CDOTAUserMsg_ReceivedXmasGift::get_inventory_slot_for_reflect,
                    CDOTAUserMsg_ReceivedXmasGift::mut_inventory_slot_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ReceivedXmasGift>(
                    "CDOTAUserMsg_ReceivedXmasGift",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ReceivedXmasGift {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_item_name();
        self.clear_inventory_slot();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ReceivedXmasGift {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ReceivedXmasGift {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ShowSurvey {
    // message fields
    survey_id: ::std::option::Option<i32>,
    match_id: ::std::option::Option<u64>,
    response_style: ::protobuf::SingularField<::std::string::String>,
    teammate_hero_id: ::std::option::Option<u32>,
    teammate_name: ::protobuf::SingularField<::std::string::String>,
    teammate_account_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ShowSurvey {}

impl CDOTAUserMsg_ShowSurvey {
    pub fn new() -> CDOTAUserMsg_ShowSurvey {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ShowSurvey {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ShowSurvey> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ShowSurvey,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ShowSurvey::new)
        }
    }

    // optional int32 survey_id = 1;

    pub fn clear_survey_id(&mut self) {
        self.survey_id = ::std::option::Option::None;
    }

    pub fn has_survey_id(&self) -> bool {
        self.survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_id(&mut self, v: i32) {
        self.survey_id = ::std::option::Option::Some(v);
    }

    pub fn get_survey_id(&self) -> i32 {
        self.survey_id.unwrap_or(0)
    }

    fn get_survey_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.survey_id
    }

    fn mut_survey_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.survey_id
    }

    // optional uint64 match_id = 2;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // optional string response_style = 3;

    pub fn clear_response_style(&mut self) {
        self.response_style.clear();
    }

    pub fn has_response_style(&self) -> bool {
        self.response_style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_style(&mut self, v: ::std::string::String) {
        self.response_style = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response_style(&mut self) -> &mut ::std::string::String {
        if self.response_style.is_none() {
            self.response_style.set_default();
        }
        self.response_style.as_mut().unwrap()
    }

    // Take field
    pub fn take_response_style(&mut self) -> ::std::string::String {
        self.response_style.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_response_style(&self) -> &str {
        match self.response_style.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_response_style_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.response_style
    }

    fn mut_response_style_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.response_style
    }

    // optional uint32 teammate_hero_id = 4;

    pub fn clear_teammate_hero_id(&mut self) {
        self.teammate_hero_id = ::std::option::Option::None;
    }

    pub fn has_teammate_hero_id(&self) -> bool {
        self.teammate_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teammate_hero_id(&mut self, v: u32) {
        self.teammate_hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_teammate_hero_id(&self) -> u32 {
        self.teammate_hero_id.unwrap_or(0)
    }

    fn get_teammate_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.teammate_hero_id
    }

    fn mut_teammate_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.teammate_hero_id
    }

    // optional string teammate_name = 5;

    pub fn clear_teammate_name(&mut self) {
        self.teammate_name.clear();
    }

    pub fn has_teammate_name(&self) -> bool {
        self.teammate_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teammate_name(&mut self, v: ::std::string::String) {
        self.teammate_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_teammate_name(&mut self) -> &mut ::std::string::String {
        if self.teammate_name.is_none() {
            self.teammate_name.set_default();
        }
        self.teammate_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_teammate_name(&mut self) -> ::std::string::String {
        self.teammate_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_teammate_name(&self) -> &str {
        match self.teammate_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_teammate_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.teammate_name
    }

    fn mut_teammate_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.teammate_name
    }

    // optional uint32 teammate_account_id = 6;

    pub fn clear_teammate_account_id(&mut self) {
        self.teammate_account_id = ::std::option::Option::None;
    }

    pub fn has_teammate_account_id(&self) -> bool {
        self.teammate_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teammate_account_id(&mut self, v: u32) {
        self.teammate_account_id = ::std::option::Option::Some(v);
    }

    pub fn get_teammate_account_id(&self) -> u32 {
        self.teammate_account_id.unwrap_or(0)
    }

    fn get_teammate_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.teammate_account_id
    }

    fn mut_teammate_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.teammate_account_id
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ShowSurvey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.survey_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.response_style)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.teammate_hero_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.teammate_name)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.teammate_account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.survey_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.response_style.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.teammate_hero_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.teammate_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.teammate_account_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.survey_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.response_style.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.teammate_hero_id {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.teammate_name.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.teammate_account_id {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ShowSurvey {
    fn new() -> CDOTAUserMsg_ShowSurvey {
        CDOTAUserMsg_ShowSurvey::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ShowSurvey>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "survey_id",
                    CDOTAUserMsg_ShowSurvey::get_survey_id_for_reflect,
                    CDOTAUserMsg_ShowSurvey::mut_survey_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CDOTAUserMsg_ShowSurvey::get_match_id_for_reflect,
                    CDOTAUserMsg_ShowSurvey::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "response_style",
                    CDOTAUserMsg_ShowSurvey::get_response_style_for_reflect,
                    CDOTAUserMsg_ShowSurvey::mut_response_style_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "teammate_hero_id",
                    CDOTAUserMsg_ShowSurvey::get_teammate_hero_id_for_reflect,
                    CDOTAUserMsg_ShowSurvey::mut_teammate_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "teammate_name",
                    CDOTAUserMsg_ShowSurvey::get_teammate_name_for_reflect,
                    CDOTAUserMsg_ShowSurvey::mut_teammate_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "teammate_account_id",
                    CDOTAUserMsg_ShowSurvey::get_teammate_account_id_for_reflect,
                    CDOTAUserMsg_ShowSurvey::mut_teammate_account_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ShowSurvey>(
                    "CDOTAUserMsg_ShowSurvey",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ShowSurvey {
    fn clear(&mut self) {
        self.clear_survey_id();
        self.clear_match_id();
        self.clear_response_style();
        self.clear_teammate_hero_id();
        self.clear_teammate_name();
        self.clear_teammate_account_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ShowSurvey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ShowSurvey {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_UpdateSharedContent {
    // message fields
    slot_type: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_UpdateSharedContent {}

impl CDOTAUserMsg_UpdateSharedContent {
    pub fn new() -> CDOTAUserMsg_UpdateSharedContent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_UpdateSharedContent {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_UpdateSharedContent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_UpdateSharedContent,
        };
        unsafe {
            instance.get(CDOTAUserMsg_UpdateSharedContent::new)
        }
    }

    // optional int32 slot_type = 1;

    pub fn clear_slot_type(&mut self) {
        self.slot_type = ::std::option::Option::None;
    }

    pub fn has_slot_type(&self) -> bool {
        self.slot_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_type(&mut self, v: i32) {
        self.slot_type = ::std::option::Option::Some(v);
    }

    pub fn get_slot_type(&self) -> i32 {
        self.slot_type.unwrap_or(0)
    }

    fn get_slot_type_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.slot_type
    }

    fn mut_slot_type_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.slot_type
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UpdateSharedContent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.slot_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.slot_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.slot_type {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_UpdateSharedContent {
    fn new() -> CDOTAUserMsg_UpdateSharedContent {
        CDOTAUserMsg_UpdateSharedContent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_UpdateSharedContent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "slot_type",
                    CDOTAUserMsg_UpdateSharedContent::get_slot_type_for_reflect,
                    CDOTAUserMsg_UpdateSharedContent::mut_slot_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_UpdateSharedContent>(
                    "CDOTAUserMsg_UpdateSharedContent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_UpdateSharedContent {
    fn clear(&mut self) {
        self.clear_slot_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_UpdateSharedContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_UpdateSharedContent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_TutorialRequestExp {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_TutorialRequestExp {}

impl CDOTAUserMsg_TutorialRequestExp {
    pub fn new() -> CDOTAUserMsg_TutorialRequestExp {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_TutorialRequestExp {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_TutorialRequestExp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_TutorialRequestExp,
        };
        unsafe {
            instance.get(CDOTAUserMsg_TutorialRequestExp::new)
        }
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TutorialRequestExp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_TutorialRequestExp {
    fn new() -> CDOTAUserMsg_TutorialRequestExp {
        CDOTAUserMsg_TutorialRequestExp::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_TutorialRequestExp>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_TutorialRequestExp>(
                    "CDOTAUserMsg_TutorialRequestExp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_TutorialRequestExp {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_TutorialRequestExp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TutorialRequestExp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_TutorialFade {
    // message fields
    tgt_alpha: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_TutorialFade {}

impl CDOTAUserMsg_TutorialFade {
    pub fn new() -> CDOTAUserMsg_TutorialFade {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_TutorialFade {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_TutorialFade> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_TutorialFade,
        };
        unsafe {
            instance.get(CDOTAUserMsg_TutorialFade::new)
        }
    }

    // optional int32 tgt_alpha = 1;

    pub fn clear_tgt_alpha(&mut self) {
        self.tgt_alpha = ::std::option::Option::None;
    }

    pub fn has_tgt_alpha(&self) -> bool {
        self.tgt_alpha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tgt_alpha(&mut self, v: i32) {
        self.tgt_alpha = ::std::option::Option::Some(v);
    }

    pub fn get_tgt_alpha(&self) -> i32 {
        self.tgt_alpha.unwrap_or(0)
    }

    fn get_tgt_alpha_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.tgt_alpha
    }

    fn mut_tgt_alpha_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.tgt_alpha
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TutorialFade {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tgt_alpha = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tgt_alpha {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tgt_alpha {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_TutorialFade {
    fn new() -> CDOTAUserMsg_TutorialFade {
        CDOTAUserMsg_TutorialFade::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_TutorialFade>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "tgt_alpha",
                    CDOTAUserMsg_TutorialFade::get_tgt_alpha_for_reflect,
                    CDOTAUserMsg_TutorialFade::mut_tgt_alpha_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_TutorialFade>(
                    "CDOTAUserMsg_TutorialFade",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_TutorialFade {
    fn clear(&mut self) {
        self.clear_tgt_alpha();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_TutorialFade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TutorialFade {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_TutorialPingMinimap {
    // message fields
    player_id: ::std::option::Option<u32>,
    pos_x: ::std::option::Option<f32>,
    pos_y: ::std::option::Option<f32>,
    pos_z: ::std::option::Option<f32>,
    entity_index: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_TutorialPingMinimap {}

impl CDOTAUserMsg_TutorialPingMinimap {
    pub fn new() -> CDOTAUserMsg_TutorialPingMinimap {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_TutorialPingMinimap {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_TutorialPingMinimap> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_TutorialPingMinimap,
        };
        unsafe {
            instance.get(CDOTAUserMsg_TutorialPingMinimap::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional float pos_x = 2;

    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: f32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    pub fn get_pos_x(&self) -> f32 {
        self.pos_x.unwrap_or(0.)
    }

    fn get_pos_x_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.pos_x
    }

    fn mut_pos_x_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.pos_x
    }

    // optional float pos_y = 3;

    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: f32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    pub fn get_pos_y(&self) -> f32 {
        self.pos_y.unwrap_or(0.)
    }

    fn get_pos_y_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.pos_y
    }

    fn mut_pos_y_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.pos_y
    }

    // optional float pos_z = 4;

    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: f32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    pub fn get_pos_z(&self) -> f32 {
        self.pos_z.unwrap_or(0.)
    }

    fn get_pos_z_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.pos_z
    }

    fn mut_pos_z_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.pos_z
    }

    // optional int32 entity_index = 5;

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = ::std::option::Option::Some(v);
    }

    pub fn get_entity_index(&self) -> i32 {
        self.entity_index.unwrap_or(0)
    }

    fn get_entity_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entity_index
    }

    fn mut_entity_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entity_index
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TutorialPingMinimap {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pos_x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pos_y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pos_z = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entity_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_x {
            my_size += 5;
        }
        if let Some(v) = self.pos_y {
            my_size += 5;
        }
        if let Some(v) = self.pos_z {
            my_size += 5;
        }
        if let Some(v) = self.entity_index {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.pos_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.entity_index {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_TutorialPingMinimap {
    fn new() -> CDOTAUserMsg_TutorialPingMinimap {
        CDOTAUserMsg_TutorialPingMinimap::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_TutorialPingMinimap>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_TutorialPingMinimap::get_player_id_for_reflect,
                    CDOTAUserMsg_TutorialPingMinimap::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "pos_x",
                    CDOTAUserMsg_TutorialPingMinimap::get_pos_x_for_reflect,
                    CDOTAUserMsg_TutorialPingMinimap::mut_pos_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "pos_y",
                    CDOTAUserMsg_TutorialPingMinimap::get_pos_y_for_reflect,
                    CDOTAUserMsg_TutorialPingMinimap::mut_pos_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "pos_z",
                    CDOTAUserMsg_TutorialPingMinimap::get_pos_z_for_reflect,
                    CDOTAUserMsg_TutorialPingMinimap::mut_pos_z_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entity_index",
                    CDOTAUserMsg_TutorialPingMinimap::get_entity_index_for_reflect,
                    CDOTAUserMsg_TutorialPingMinimap::mut_entity_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_TutorialPingMinimap>(
                    "CDOTAUserMsg_TutorialPingMinimap",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_TutorialPingMinimap {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_pos_x();
        self.clear_pos_y();
        self.clear_pos_z();
        self.clear_entity_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_TutorialPingMinimap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TutorialPingMinimap {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_GamerulesStateChanged {
    // message fields
    state: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_GamerulesStateChanged {}

impl CDOTAUserMsg_GamerulesStateChanged {
    pub fn new() -> CDOTAUserMsg_GamerulesStateChanged {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_GamerulesStateChanged {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_GamerulesStateChanged> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_GamerulesStateChanged,
        };
        unsafe {
            instance.get(CDOTAUserMsg_GamerulesStateChanged::new)
        }
    }

    // optional uint32 state = 1;

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: u32) {
        self.state = ::std::option::Option::Some(v);
    }

    pub fn get_state(&self) -> u32 {
        self.state.unwrap_or(0)
    }

    fn get_state_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.state
    }

    fn mut_state_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.state
    }
}

impl ::protobuf::Message for CDOTAUserMsg_GamerulesStateChanged {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.state = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.state {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_GamerulesStateChanged {
    fn new() -> CDOTAUserMsg_GamerulesStateChanged {
        CDOTAUserMsg_GamerulesStateChanged::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_GamerulesStateChanged>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "state",
                    CDOTAUserMsg_GamerulesStateChanged::get_state_for_reflect,
                    CDOTAUserMsg_GamerulesStateChanged::mut_state_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_GamerulesStateChanged>(
                    "CDOTAUserMsg_GamerulesStateChanged",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_GamerulesStateChanged {
    fn clear(&mut self) {
        self.clear_state();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_GamerulesStateChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_GamerulesStateChanged {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_AddQuestLogEntry {
    // message fields
    npc_name: ::protobuf::SingularField<::std::string::String>,
    npc_dialog: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_AddQuestLogEntry {}

impl CDOTAUserMsg_AddQuestLogEntry {
    pub fn new() -> CDOTAUserMsg_AddQuestLogEntry {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_AddQuestLogEntry {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_AddQuestLogEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_AddQuestLogEntry,
        };
        unsafe {
            instance.get(CDOTAUserMsg_AddQuestLogEntry::new)
        }
    }

    // optional string npc_name = 1;

    pub fn clear_npc_name(&mut self) {
        self.npc_name.clear();
    }

    pub fn has_npc_name(&self) -> bool {
        self.npc_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_npc_name(&mut self, v: ::std::string::String) {
        self.npc_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_npc_name(&mut self) -> &mut ::std::string::String {
        if self.npc_name.is_none() {
            self.npc_name.set_default();
        }
        self.npc_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_npc_name(&mut self) -> ::std::string::String {
        self.npc_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_npc_name(&self) -> &str {
        match self.npc_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_npc_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.npc_name
    }

    fn mut_npc_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.npc_name
    }

    // optional string npc_dialog = 2;

    pub fn clear_npc_dialog(&mut self) {
        self.npc_dialog.clear();
    }

    pub fn has_npc_dialog(&self) -> bool {
        self.npc_dialog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_npc_dialog(&mut self, v: ::std::string::String) {
        self.npc_dialog = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_npc_dialog(&mut self) -> &mut ::std::string::String {
        if self.npc_dialog.is_none() {
            self.npc_dialog.set_default();
        }
        self.npc_dialog.as_mut().unwrap()
    }

    // Take field
    pub fn take_npc_dialog(&mut self) -> ::std::string::String {
        self.npc_dialog.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_npc_dialog(&self) -> &str {
        match self.npc_dialog.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_npc_dialog_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.npc_dialog
    }

    fn mut_npc_dialog_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.npc_dialog
    }
}

impl ::protobuf::Message for CDOTAUserMsg_AddQuestLogEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.npc_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.npc_dialog)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.npc_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.npc_dialog.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.npc_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.npc_dialog.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_AddQuestLogEntry {
    fn new() -> CDOTAUserMsg_AddQuestLogEntry {
        CDOTAUserMsg_AddQuestLogEntry::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_AddQuestLogEntry>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "npc_name",
                    CDOTAUserMsg_AddQuestLogEntry::get_npc_name_for_reflect,
                    CDOTAUserMsg_AddQuestLogEntry::mut_npc_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "npc_dialog",
                    CDOTAUserMsg_AddQuestLogEntry::get_npc_dialog_for_reflect,
                    CDOTAUserMsg_AddQuestLogEntry::mut_npc_dialog_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_AddQuestLogEntry>(
                    "CDOTAUserMsg_AddQuestLogEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_AddQuestLogEntry {
    fn clear(&mut self) {
        self.clear_npc_name();
        self.clear_npc_dialog();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_AddQuestLogEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_AddQuestLogEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_SendStatPopup {
    // message fields
    player_id: ::std::option::Option<i32>,
    statpopup: ::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_SendStatPopup>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_SendStatPopup {}

impl CDOTAUserMsg_SendStatPopup {
    pub fn new() -> CDOTAUserMsg_SendStatPopup {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_SendStatPopup {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_SendStatPopup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_SendStatPopup,
        };
        unsafe {
            instance.get(CDOTAUserMsg_SendStatPopup::new)
        }
    }

    // optional int32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.player_id
    }

    // optional .CDOTAMsg_SendStatPopup statpopup = 2;

    pub fn clear_statpopup(&mut self) {
        self.statpopup.clear();
    }

    pub fn has_statpopup(&self) -> bool {
        self.statpopup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statpopup(&mut self, v: super::dota_commonmessages::CDOTAMsg_SendStatPopup) {
        self.statpopup = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statpopup(&mut self) -> &mut super::dota_commonmessages::CDOTAMsg_SendStatPopup {
        if self.statpopup.is_none() {
            self.statpopup.set_default();
        }
        self.statpopup.as_mut().unwrap()
    }

    // Take field
    pub fn take_statpopup(&mut self) -> super::dota_commonmessages::CDOTAMsg_SendStatPopup {
        self.statpopup.take().unwrap_or_else(|| super::dota_commonmessages::CDOTAMsg_SendStatPopup::new())
    }

    pub fn get_statpopup(&self) -> &super::dota_commonmessages::CDOTAMsg_SendStatPopup {
        self.statpopup.as_ref().unwrap_or_else(|| super::dota_commonmessages::CDOTAMsg_SendStatPopup::default_instance())
    }

    fn get_statpopup_for_reflect(&self) -> &::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_SendStatPopup> {
        &self.statpopup
    }

    fn mut_statpopup_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_SendStatPopup> {
        &mut self.statpopup
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SendStatPopup {
    fn is_initialized(&self) -> bool {
        for v in &self.statpopup {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statpopup)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.statpopup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.statpopup.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_SendStatPopup {
    fn new() -> CDOTAUserMsg_SendStatPopup {
        CDOTAUserMsg_SendStatPopup::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_SendStatPopup>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_id",
                    CDOTAUserMsg_SendStatPopup::get_player_id_for_reflect,
                    CDOTAUserMsg_SendStatPopup::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_commonmessages::CDOTAMsg_SendStatPopup>>(
                    "statpopup",
                    CDOTAUserMsg_SendStatPopup::get_statpopup_for_reflect,
                    CDOTAUserMsg_SendStatPopup::mut_statpopup_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_SendStatPopup>(
                    "CDOTAUserMsg_SendStatPopup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_SendStatPopup {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_statpopup();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_SendStatPopup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SendStatPopup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_DismissAllStatPopups {
    // message fields
    dismissallmsg: ::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_DismissAllStatPopups>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_DismissAllStatPopups {}

impl CDOTAUserMsg_DismissAllStatPopups {
    pub fn new() -> CDOTAUserMsg_DismissAllStatPopups {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_DismissAllStatPopups {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_DismissAllStatPopups> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_DismissAllStatPopups,
        };
        unsafe {
            instance.get(CDOTAUserMsg_DismissAllStatPopups::new)
        }
    }

    // optional .CDOTAMsg_DismissAllStatPopups dismissallmsg = 1;

    pub fn clear_dismissallmsg(&mut self) {
        self.dismissallmsg.clear();
    }

    pub fn has_dismissallmsg(&self) -> bool {
        self.dismissallmsg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dismissallmsg(&mut self, v: super::dota_commonmessages::CDOTAMsg_DismissAllStatPopups) {
        self.dismissallmsg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dismissallmsg(&mut self) -> &mut super::dota_commonmessages::CDOTAMsg_DismissAllStatPopups {
        if self.dismissallmsg.is_none() {
            self.dismissallmsg.set_default();
        }
        self.dismissallmsg.as_mut().unwrap()
    }

    // Take field
    pub fn take_dismissallmsg(&mut self) -> super::dota_commonmessages::CDOTAMsg_DismissAllStatPopups {
        self.dismissallmsg.take().unwrap_or_else(|| super::dota_commonmessages::CDOTAMsg_DismissAllStatPopups::new())
    }

    pub fn get_dismissallmsg(&self) -> &super::dota_commonmessages::CDOTAMsg_DismissAllStatPopups {
        self.dismissallmsg.as_ref().unwrap_or_else(|| super::dota_commonmessages::CDOTAMsg_DismissAllStatPopups::default_instance())
    }

    fn get_dismissallmsg_for_reflect(&self) -> &::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_DismissAllStatPopups> {
        &self.dismissallmsg
    }

    fn mut_dismissallmsg_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_DismissAllStatPopups> {
        &mut self.dismissallmsg
    }
}

impl ::protobuf::Message for CDOTAUserMsg_DismissAllStatPopups {
    fn is_initialized(&self) -> bool {
        for v in &self.dismissallmsg {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dismissallmsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dismissallmsg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dismissallmsg.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_DismissAllStatPopups {
    fn new() -> CDOTAUserMsg_DismissAllStatPopups {
        CDOTAUserMsg_DismissAllStatPopups::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_DismissAllStatPopups>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_commonmessages::CDOTAMsg_DismissAllStatPopups>>(
                    "dismissallmsg",
                    CDOTAUserMsg_DismissAllStatPopups::get_dismissallmsg_for_reflect,
                    CDOTAUserMsg_DismissAllStatPopups::mut_dismissallmsg_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_DismissAllStatPopups>(
                    "CDOTAUserMsg_DismissAllStatPopups",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_DismissAllStatPopups {
    fn clear(&mut self) {
        self.clear_dismissallmsg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_DismissAllStatPopups {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_DismissAllStatPopups {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_SendRoshanSpectatorPhase {
    // message fields
    phase: ::std::option::Option<DOTA_ROSHAN_PHASE>,
    phase_start_time: ::std::option::Option<i32>,
    phase_length: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_SendRoshanSpectatorPhase {}

impl CDOTAUserMsg_SendRoshanSpectatorPhase {
    pub fn new() -> CDOTAUserMsg_SendRoshanSpectatorPhase {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_SendRoshanSpectatorPhase {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_SendRoshanSpectatorPhase> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_SendRoshanSpectatorPhase,
        };
        unsafe {
            instance.get(CDOTAUserMsg_SendRoshanSpectatorPhase::new)
        }
    }

    // optional .DOTA_ROSHAN_PHASE phase = 1;

    pub fn clear_phase(&mut self) {
        self.phase = ::std::option::Option::None;
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: DOTA_ROSHAN_PHASE) {
        self.phase = ::std::option::Option::Some(v);
    }

    pub fn get_phase(&self) -> DOTA_ROSHAN_PHASE {
        self.phase.unwrap_or(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_ALIVE)
    }

    fn get_phase_for_reflect(&self) -> &::std::option::Option<DOTA_ROSHAN_PHASE> {
        &self.phase
    }

    fn mut_phase_for_reflect(&mut self) -> &mut ::std::option::Option<DOTA_ROSHAN_PHASE> {
        &mut self.phase
    }

    // optional int32 phase_start_time = 2;

    pub fn clear_phase_start_time(&mut self) {
        self.phase_start_time = ::std::option::Option::None;
    }

    pub fn has_phase_start_time(&self) -> bool {
        self.phase_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase_start_time(&mut self, v: i32) {
        self.phase_start_time = ::std::option::Option::Some(v);
    }

    pub fn get_phase_start_time(&self) -> i32 {
        self.phase_start_time.unwrap_or(0)
    }

    fn get_phase_start_time_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.phase_start_time
    }

    fn mut_phase_start_time_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.phase_start_time
    }

    // optional int32 phase_length = 3;

    pub fn clear_phase_length(&mut self) {
        self.phase_length = ::std::option::Option::None;
    }

    pub fn has_phase_length(&self) -> bool {
        self.phase_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase_length(&mut self, v: i32) {
        self.phase_length = ::std::option::Option::Some(v);
    }

    pub fn get_phase_length(&self) -> i32 {
        self.phase_length.unwrap_or(0)
    }

    fn get_phase_length_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.phase_length
    }

    fn mut_phase_length_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.phase_length
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SendRoshanSpectatorPhase {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.phase = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.phase_start_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.phase_length = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.phase {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.phase_start_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.phase_length {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.phase {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.phase_start_time {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.phase_length {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_SendRoshanSpectatorPhase {
    fn new() -> CDOTAUserMsg_SendRoshanSpectatorPhase {
        CDOTAUserMsg_SendRoshanSpectatorPhase::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_SendRoshanSpectatorPhase>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DOTA_ROSHAN_PHASE>>(
                    "phase",
                    CDOTAUserMsg_SendRoshanSpectatorPhase::get_phase_for_reflect,
                    CDOTAUserMsg_SendRoshanSpectatorPhase::mut_phase_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "phase_start_time",
                    CDOTAUserMsg_SendRoshanSpectatorPhase::get_phase_start_time_for_reflect,
                    CDOTAUserMsg_SendRoshanSpectatorPhase::mut_phase_start_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "phase_length",
                    CDOTAUserMsg_SendRoshanSpectatorPhase::get_phase_length_for_reflect,
                    CDOTAUserMsg_SendRoshanSpectatorPhase::mut_phase_length_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_SendRoshanSpectatorPhase>(
                    "CDOTAUserMsg_SendRoshanSpectatorPhase",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_SendRoshanSpectatorPhase {
    fn clear(&mut self) {
        self.clear_phase();
        self.clear_phase_start_time();
        self.clear_phase_length();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_SendRoshanSpectatorPhase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SendRoshanSpectatorPhase {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_SendRoshanPopup {
    // message fields
    reclaimed: ::std::option::Option<bool>,
    gametime: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_SendRoshanPopup {}

impl CDOTAUserMsg_SendRoshanPopup {
    pub fn new() -> CDOTAUserMsg_SendRoshanPopup {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_SendRoshanPopup {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_SendRoshanPopup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_SendRoshanPopup,
        };
        unsafe {
            instance.get(CDOTAUserMsg_SendRoshanPopup::new)
        }
    }

    // optional bool reclaimed = 1;

    pub fn clear_reclaimed(&mut self) {
        self.reclaimed = ::std::option::Option::None;
    }

    pub fn has_reclaimed(&self) -> bool {
        self.reclaimed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reclaimed(&mut self, v: bool) {
        self.reclaimed = ::std::option::Option::Some(v);
    }

    pub fn get_reclaimed(&self) -> bool {
        self.reclaimed.unwrap_or(false)
    }

    fn get_reclaimed_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.reclaimed
    }

    fn mut_reclaimed_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.reclaimed
    }

    // optional int32 gametime = 2;

    pub fn clear_gametime(&mut self) {
        self.gametime = ::std::option::Option::None;
    }

    pub fn has_gametime(&self) -> bool {
        self.gametime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gametime(&mut self, v: i32) {
        self.gametime = ::std::option::Option::Some(v);
    }

    pub fn get_gametime(&self) -> i32 {
        self.gametime.unwrap_or(0)
    }

    fn get_gametime_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.gametime
    }

    fn mut_gametime_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.gametime
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SendRoshanPopup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reclaimed = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.gametime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reclaimed {
            my_size += 2;
        }
        if let Some(v) = self.gametime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reclaimed {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.gametime {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_SendRoshanPopup {
    fn new() -> CDOTAUserMsg_SendRoshanPopup {
        CDOTAUserMsg_SendRoshanPopup::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_SendRoshanPopup>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "reclaimed",
                    CDOTAUserMsg_SendRoshanPopup::get_reclaimed_for_reflect,
                    CDOTAUserMsg_SendRoshanPopup::mut_reclaimed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "gametime",
                    CDOTAUserMsg_SendRoshanPopup::get_gametime_for_reflect,
                    CDOTAUserMsg_SendRoshanPopup::mut_gametime_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_SendRoshanPopup>(
                    "CDOTAUserMsg_SendRoshanPopup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_SendRoshanPopup {
    fn clear(&mut self) {
        self.clear_reclaimed();
        self.clear_gametime();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_SendRoshanPopup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SendRoshanPopup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_SendFinalGold {
    // message fields
    reliable_gold: ::std::vec::Vec<u32>,
    unreliable_gold: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_SendFinalGold {}

impl CDOTAUserMsg_SendFinalGold {
    pub fn new() -> CDOTAUserMsg_SendFinalGold {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_SendFinalGold {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_SendFinalGold> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_SendFinalGold,
        };
        unsafe {
            instance.get(CDOTAUserMsg_SendFinalGold::new)
        }
    }

    // repeated uint32 reliable_gold = 1;

    pub fn clear_reliable_gold(&mut self) {
        self.reliable_gold.clear();
    }

    // Param is passed by value, moved
    pub fn set_reliable_gold(&mut self, v: ::std::vec::Vec<u32>) {
        self.reliable_gold = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reliable_gold(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.reliable_gold
    }

    // Take field
    pub fn take_reliable_gold(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.reliable_gold, ::std::vec::Vec::new())
    }

    pub fn get_reliable_gold(&self) -> &[u32] {
        &self.reliable_gold
    }

    fn get_reliable_gold_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.reliable_gold
    }

    fn mut_reliable_gold_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.reliable_gold
    }

    // repeated uint32 unreliable_gold = 2;

    pub fn clear_unreliable_gold(&mut self) {
        self.unreliable_gold.clear();
    }

    // Param is passed by value, moved
    pub fn set_unreliable_gold(&mut self, v: ::std::vec::Vec<u32>) {
        self.unreliable_gold = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unreliable_gold(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.unreliable_gold
    }

    // Take field
    pub fn take_unreliable_gold(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.unreliable_gold, ::std::vec::Vec::new())
    }

    pub fn get_unreliable_gold(&self) -> &[u32] {
        &self.unreliable_gold
    }

    fn get_unreliable_gold_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.unreliable_gold
    }

    fn mut_unreliable_gold_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.unreliable_gold
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SendFinalGold {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.reliable_gold)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.unreliable_gold)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.reliable_gold {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.unreliable_gold {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.reliable_gold {
            os.write_uint32(1, *v)?;
        };
        for v in &self.unreliable_gold {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_SendFinalGold {
    fn new() -> CDOTAUserMsg_SendFinalGold {
        CDOTAUserMsg_SendFinalGold::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_SendFinalGold>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "reliable_gold",
                    CDOTAUserMsg_SendFinalGold::get_reliable_gold_for_reflect,
                    CDOTAUserMsg_SendFinalGold::mut_reliable_gold_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "unreliable_gold",
                    CDOTAUserMsg_SendFinalGold::get_unreliable_gold_for_reflect,
                    CDOTAUserMsg_SendFinalGold::mut_unreliable_gold_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_SendFinalGold>(
                    "CDOTAUserMsg_SendFinalGold",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_SendFinalGold {
    fn clear(&mut self) {
        self.clear_reliable_gold();
        self.clear_unreliable_gold();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_SendFinalGold {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SendFinalGold {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_CustomMsg {
    // message fields
    message: ::protobuf::SingularField<::std::string::String>,
    player_id: ::std::option::Option<i32>,
    value: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_CustomMsg {}

impl CDOTAUserMsg_CustomMsg {
    pub fn new() -> CDOTAUserMsg_CustomMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_CustomMsg {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_CustomMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_CustomMsg,
        };
        unsafe {
            instance.get(CDOTAUserMsg_CustomMsg::new)
        }
    }

    // optional string message = 1;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }

    // optional int32 player_id = 2;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.player_id
    }

    // optional int32 value = 3;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> i32 {
        self.value.unwrap_or(0)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.value
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CustomMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.value {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_CustomMsg {
    fn new() -> CDOTAUserMsg_CustomMsg {
        CDOTAUserMsg_CustomMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_CustomMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    CDOTAUserMsg_CustomMsg::get_message_for_reflect,
                    CDOTAUserMsg_CustomMsg::mut_message_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_id",
                    CDOTAUserMsg_CustomMsg::get_player_id_for_reflect,
                    CDOTAUserMsg_CustomMsg::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    CDOTAUserMsg_CustomMsg::get_value_for_reflect,
                    CDOTAUserMsg_CustomMsg::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_CustomMsg>(
                    "CDOTAUserMsg_CustomMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_CustomMsg {
    fn clear(&mut self) {
        self.clear_message();
        self.clear_player_id();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_CustomMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CustomMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_CoachHUDPing {
    // message fields
    player_id: ::std::option::Option<u32>,
    hud_ping: ::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_CoachHUDPing>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_CoachHUDPing {}

impl CDOTAUserMsg_CoachHUDPing {
    pub fn new() -> CDOTAUserMsg_CoachHUDPing {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_CoachHUDPing {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_CoachHUDPing> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_CoachHUDPing,
        };
        unsafe {
            instance.get(CDOTAUserMsg_CoachHUDPing::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional .CDOTAMsg_CoachHUDPing hud_ping = 2;

    pub fn clear_hud_ping(&mut self) {
        self.hud_ping.clear();
    }

    pub fn has_hud_ping(&self) -> bool {
        self.hud_ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hud_ping(&mut self, v: super::dota_commonmessages::CDOTAMsg_CoachHUDPing) {
        self.hud_ping = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hud_ping(&mut self) -> &mut super::dota_commonmessages::CDOTAMsg_CoachHUDPing {
        if self.hud_ping.is_none() {
            self.hud_ping.set_default();
        }
        self.hud_ping.as_mut().unwrap()
    }

    // Take field
    pub fn take_hud_ping(&mut self) -> super::dota_commonmessages::CDOTAMsg_CoachHUDPing {
        self.hud_ping.take().unwrap_or_else(|| super::dota_commonmessages::CDOTAMsg_CoachHUDPing::new())
    }

    pub fn get_hud_ping(&self) -> &super::dota_commonmessages::CDOTAMsg_CoachHUDPing {
        self.hud_ping.as_ref().unwrap_or_else(|| super::dota_commonmessages::CDOTAMsg_CoachHUDPing::default_instance())
    }

    fn get_hud_ping_for_reflect(&self) -> &::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_CoachHUDPing> {
        &self.hud_ping
    }

    fn mut_hud_ping_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::dota_commonmessages::CDOTAMsg_CoachHUDPing> {
        &mut self.hud_ping
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CoachHUDPing {
    fn is_initialized(&self) -> bool {
        for v in &self.hud_ping {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hud_ping)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.hud_ping.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.hud_ping.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_CoachHUDPing {
    fn new() -> CDOTAUserMsg_CoachHUDPing {
        CDOTAUserMsg_CoachHUDPing::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_CoachHUDPing>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_CoachHUDPing::get_player_id_for_reflect,
                    CDOTAUserMsg_CoachHUDPing::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::dota_commonmessages::CDOTAMsg_CoachHUDPing>>(
                    "hud_ping",
                    CDOTAUserMsg_CoachHUDPing::get_hud_ping_for_reflect,
                    CDOTAUserMsg_CoachHUDPing::mut_hud_ping_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_CoachHUDPing>(
                    "CDOTAUserMsg_CoachHUDPing",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_CoachHUDPing {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_hud_ping();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_CoachHUDPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CoachHUDPing {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ClientLoadGridNav {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ClientLoadGridNav {}

impl CDOTAUserMsg_ClientLoadGridNav {
    pub fn new() -> CDOTAUserMsg_ClientLoadGridNav {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ClientLoadGridNav {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ClientLoadGridNav> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ClientLoadGridNav,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ClientLoadGridNav::new)
        }
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ClientLoadGridNav {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ClientLoadGridNav {
    fn new() -> CDOTAUserMsg_ClientLoadGridNav {
        CDOTAUserMsg_ClientLoadGridNav::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ClientLoadGridNav>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ClientLoadGridNav>(
                    "CDOTAUserMsg_ClientLoadGridNav",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ClientLoadGridNav {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ClientLoadGridNav {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ClientLoadGridNav {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_TE_Projectile {
    // message fields
    hSource: ::std::option::Option<i32>,
    hTarget: ::std::option::Option<i32>,
    moveSpeed: ::std::option::Option<i32>,
    sourceAttachment: ::std::option::Option<i32>,
    particleSystemHandle: ::std::option::Option<i64>,
    dodgeable: ::std::option::Option<bool>,
    isAttack: ::std::option::Option<bool>,
    isEvaded: ::std::option::Option<bool>,
    expireTime: ::std::option::Option<f32>,
    maximpacttime: ::std::option::Option<f32>,
    colorgemcolor: ::std::option::Option<u32>,
    launch_tick: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_TE_Projectile {}

impl CDOTAUserMsg_TE_Projectile {
    pub fn new() -> CDOTAUserMsg_TE_Projectile {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_TE_Projectile {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_TE_Projectile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_TE_Projectile,
        };
        unsafe {
            instance.get(CDOTAUserMsg_TE_Projectile::new)
        }
    }

    // optional int32 hSource = 1;

    pub fn clear_hSource(&mut self) {
        self.hSource = ::std::option::Option::None;
    }

    pub fn has_hSource(&self) -> bool {
        self.hSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hSource(&mut self, v: i32) {
        self.hSource = ::std::option::Option::Some(v);
    }

    pub fn get_hSource(&self) -> i32 {
        self.hSource.unwrap_or(0)
    }

    fn get_hSource_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.hSource
    }

    fn mut_hSource_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.hSource
    }

    // optional int32 hTarget = 2;

    pub fn clear_hTarget(&mut self) {
        self.hTarget = ::std::option::Option::None;
    }

    pub fn has_hTarget(&self) -> bool {
        self.hTarget.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hTarget(&mut self, v: i32) {
        self.hTarget = ::std::option::Option::Some(v);
    }

    pub fn get_hTarget(&self) -> i32 {
        self.hTarget.unwrap_or(0)
    }

    fn get_hTarget_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.hTarget
    }

    fn mut_hTarget_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.hTarget
    }

    // optional int32 moveSpeed = 3;

    pub fn clear_moveSpeed(&mut self) {
        self.moveSpeed = ::std::option::Option::None;
    }

    pub fn has_moveSpeed(&self) -> bool {
        self.moveSpeed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moveSpeed(&mut self, v: i32) {
        self.moveSpeed = ::std::option::Option::Some(v);
    }

    pub fn get_moveSpeed(&self) -> i32 {
        self.moveSpeed.unwrap_or(0)
    }

    fn get_moveSpeed_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.moveSpeed
    }

    fn mut_moveSpeed_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.moveSpeed
    }

    // optional int32 sourceAttachment = 4;

    pub fn clear_sourceAttachment(&mut self) {
        self.sourceAttachment = ::std::option::Option::None;
    }

    pub fn has_sourceAttachment(&self) -> bool {
        self.sourceAttachment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sourceAttachment(&mut self, v: i32) {
        self.sourceAttachment = ::std::option::Option::Some(v);
    }

    pub fn get_sourceAttachment(&self) -> i32 {
        self.sourceAttachment.unwrap_or(0)
    }

    fn get_sourceAttachment_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.sourceAttachment
    }

    fn mut_sourceAttachment_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.sourceAttachment
    }

    // optional int64 particleSystemHandle = 5;

    pub fn clear_particleSystemHandle(&mut self) {
        self.particleSystemHandle = ::std::option::Option::None;
    }

    pub fn has_particleSystemHandle(&self) -> bool {
        self.particleSystemHandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particleSystemHandle(&mut self, v: i64) {
        self.particleSystemHandle = ::std::option::Option::Some(v);
    }

    pub fn get_particleSystemHandle(&self) -> i64 {
        self.particleSystemHandle.unwrap_or(0)
    }

    fn get_particleSystemHandle_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.particleSystemHandle
    }

    fn mut_particleSystemHandle_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.particleSystemHandle
    }

    // optional bool dodgeable = 6;

    pub fn clear_dodgeable(&mut self) {
        self.dodgeable = ::std::option::Option::None;
    }

    pub fn has_dodgeable(&self) -> bool {
        self.dodgeable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dodgeable(&mut self, v: bool) {
        self.dodgeable = ::std::option::Option::Some(v);
    }

    pub fn get_dodgeable(&self) -> bool {
        self.dodgeable.unwrap_or(false)
    }

    fn get_dodgeable_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.dodgeable
    }

    fn mut_dodgeable_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.dodgeable
    }

    // optional bool isAttack = 7;

    pub fn clear_isAttack(&mut self) {
        self.isAttack = ::std::option::Option::None;
    }

    pub fn has_isAttack(&self) -> bool {
        self.isAttack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isAttack(&mut self, v: bool) {
        self.isAttack = ::std::option::Option::Some(v);
    }

    pub fn get_isAttack(&self) -> bool {
        self.isAttack.unwrap_or(false)
    }

    fn get_isAttack_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.isAttack
    }

    fn mut_isAttack_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.isAttack
    }

    // optional bool isEvaded = 8;

    pub fn clear_isEvaded(&mut self) {
        self.isEvaded = ::std::option::Option::None;
    }

    pub fn has_isEvaded(&self) -> bool {
        self.isEvaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isEvaded(&mut self, v: bool) {
        self.isEvaded = ::std::option::Option::Some(v);
    }

    pub fn get_isEvaded(&self) -> bool {
        self.isEvaded.unwrap_or(false)
    }

    fn get_isEvaded_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.isEvaded
    }

    fn mut_isEvaded_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.isEvaded
    }

    // optional float expireTime = 9;

    pub fn clear_expireTime(&mut self) {
        self.expireTime = ::std::option::Option::None;
    }

    pub fn has_expireTime(&self) -> bool {
        self.expireTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expireTime(&mut self, v: f32) {
        self.expireTime = ::std::option::Option::Some(v);
    }

    pub fn get_expireTime(&self) -> f32 {
        self.expireTime.unwrap_or(0.)
    }

    fn get_expireTime_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.expireTime
    }

    fn mut_expireTime_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.expireTime
    }

    // optional float maximpacttime = 10;

    pub fn clear_maximpacttime(&mut self) {
        self.maximpacttime = ::std::option::Option::None;
    }

    pub fn has_maximpacttime(&self) -> bool {
        self.maximpacttime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximpacttime(&mut self, v: f32) {
        self.maximpacttime = ::std::option::Option::Some(v);
    }

    pub fn get_maximpacttime(&self) -> f32 {
        self.maximpacttime.unwrap_or(0.)
    }

    fn get_maximpacttime_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.maximpacttime
    }

    fn mut_maximpacttime_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.maximpacttime
    }

    // optional fixed32 colorgemcolor = 11;

    pub fn clear_colorgemcolor(&mut self) {
        self.colorgemcolor = ::std::option::Option::None;
    }

    pub fn has_colorgemcolor(&self) -> bool {
        self.colorgemcolor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_colorgemcolor(&mut self, v: u32) {
        self.colorgemcolor = ::std::option::Option::Some(v);
    }

    pub fn get_colorgemcolor(&self) -> u32 {
        self.colorgemcolor.unwrap_or(0)
    }

    fn get_colorgemcolor_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.colorgemcolor
    }

    fn mut_colorgemcolor_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.colorgemcolor
    }

    // optional int32 launch_tick = 12;

    pub fn clear_launch_tick(&mut self) {
        self.launch_tick = ::std::option::Option::None;
    }

    pub fn has_launch_tick(&self) -> bool {
        self.launch_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launch_tick(&mut self, v: i32) {
        self.launch_tick = ::std::option::Option::Some(v);
    }

    pub fn get_launch_tick(&self) -> i32 {
        self.launch_tick.unwrap_or(0)
    }

    fn get_launch_tick_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.launch_tick
    }

    fn mut_launch_tick_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.launch_tick
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TE_Projectile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.hSource = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.hTarget = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.moveSpeed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sourceAttachment = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.particleSystemHandle = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dodgeable = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isAttack = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isEvaded = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.expireTime = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.maximpacttime = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.colorgemcolor = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.launch_tick = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hSource {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hTarget {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.moveSpeed {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sourceAttachment {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.particleSystemHandle {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dodgeable {
            my_size += 2;
        }
        if let Some(v) = self.isAttack {
            my_size += 2;
        }
        if let Some(v) = self.isEvaded {
            my_size += 2;
        }
        if let Some(v) = self.expireTime {
            my_size += 5;
        }
        if let Some(v) = self.maximpacttime {
            my_size += 5;
        }
        if let Some(v) = self.colorgemcolor {
            my_size += 5;
        }
        if let Some(v) = self.launch_tick {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hSource {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hTarget {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.moveSpeed {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.sourceAttachment {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.particleSystemHandle {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.dodgeable {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.isAttack {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.isEvaded {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.expireTime {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.maximpacttime {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.colorgemcolor {
            os.write_fixed32(11, v)?;
        }
        if let Some(v) = self.launch_tick {
            os.write_int32(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_TE_Projectile {
    fn new() -> CDOTAUserMsg_TE_Projectile {
        CDOTAUserMsg_TE_Projectile::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_TE_Projectile>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "hSource",
                    CDOTAUserMsg_TE_Projectile::get_hSource_for_reflect,
                    CDOTAUserMsg_TE_Projectile::mut_hSource_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "hTarget",
                    CDOTAUserMsg_TE_Projectile::get_hTarget_for_reflect,
                    CDOTAUserMsg_TE_Projectile::mut_hTarget_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "moveSpeed",
                    CDOTAUserMsg_TE_Projectile::get_moveSpeed_for_reflect,
                    CDOTAUserMsg_TE_Projectile::mut_moveSpeed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "sourceAttachment",
                    CDOTAUserMsg_TE_Projectile::get_sourceAttachment_for_reflect,
                    CDOTAUserMsg_TE_Projectile::mut_sourceAttachment_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "particleSystemHandle",
                    CDOTAUserMsg_TE_Projectile::get_particleSystemHandle_for_reflect,
                    CDOTAUserMsg_TE_Projectile::mut_particleSystemHandle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "dodgeable",
                    CDOTAUserMsg_TE_Projectile::get_dodgeable_for_reflect,
                    CDOTAUserMsg_TE_Projectile::mut_dodgeable_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isAttack",
                    CDOTAUserMsg_TE_Projectile::get_isAttack_for_reflect,
                    CDOTAUserMsg_TE_Projectile::mut_isAttack_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isEvaded",
                    CDOTAUserMsg_TE_Projectile::get_isEvaded_for_reflect,
                    CDOTAUserMsg_TE_Projectile::mut_isEvaded_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "expireTime",
                    CDOTAUserMsg_TE_Projectile::get_expireTime_for_reflect,
                    CDOTAUserMsg_TE_Projectile::mut_expireTime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "maximpacttime",
                    CDOTAUserMsg_TE_Projectile::get_maximpacttime_for_reflect,
                    CDOTAUserMsg_TE_Projectile::mut_maximpacttime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "colorgemcolor",
                    CDOTAUserMsg_TE_Projectile::get_colorgemcolor_for_reflect,
                    CDOTAUserMsg_TE_Projectile::mut_colorgemcolor_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "launch_tick",
                    CDOTAUserMsg_TE_Projectile::get_launch_tick_for_reflect,
                    CDOTAUserMsg_TE_Projectile::mut_launch_tick_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_TE_Projectile>(
                    "CDOTAUserMsg_TE_Projectile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_TE_Projectile {
    fn clear(&mut self) {
        self.clear_hSource();
        self.clear_hTarget();
        self.clear_moveSpeed();
        self.clear_sourceAttachment();
        self.clear_particleSystemHandle();
        self.clear_dodgeable();
        self.clear_isAttack();
        self.clear_isEvaded();
        self.clear_expireTime();
        self.clear_maximpacttime();
        self.clear_colorgemcolor();
        self.clear_launch_tick();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_TE_Projectile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TE_Projectile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_TE_ProjectileLoc {
    // message fields
    vSourceLoc: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector>,
    hTarget: ::std::option::Option<i32>,
    moveSpeed: ::std::option::Option<i32>,
    particleSystemHandle: ::std::option::Option<i64>,
    dodgeable: ::std::option::Option<bool>,
    isAttack: ::std::option::Option<bool>,
    isEvaded: ::std::option::Option<bool>,
    expireTime: ::std::option::Option<f32>,
    vTargetLoc: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector>,
    colorgemcolor: ::std::option::Option<u32>,
    launch_tick: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_TE_ProjectileLoc {}

impl CDOTAUserMsg_TE_ProjectileLoc {
    pub fn new() -> CDOTAUserMsg_TE_ProjectileLoc {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_TE_ProjectileLoc {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_TE_ProjectileLoc> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_TE_ProjectileLoc,
        };
        unsafe {
            instance.get(CDOTAUserMsg_TE_ProjectileLoc::new)
        }
    }

    // optional .CMsgVector vSourceLoc = 1;

    pub fn clear_vSourceLoc(&mut self) {
        self.vSourceLoc.clear();
    }

    pub fn has_vSourceLoc(&self) -> bool {
        self.vSourceLoc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vSourceLoc(&mut self, v: super::networkbasetypes::CMsgVector) {
        self.vSourceLoc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vSourceLoc(&mut self) -> &mut super::networkbasetypes::CMsgVector {
        if self.vSourceLoc.is_none() {
            self.vSourceLoc.set_default();
        }
        self.vSourceLoc.as_mut().unwrap()
    }

    // Take field
    pub fn take_vSourceLoc(&mut self) -> super::networkbasetypes::CMsgVector {
        self.vSourceLoc.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector::new())
    }

    pub fn get_vSourceLoc(&self) -> &super::networkbasetypes::CMsgVector {
        self.vSourceLoc.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector::default_instance())
    }

    fn get_vSourceLoc_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &self.vSourceLoc
    }

    fn mut_vSourceLoc_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &mut self.vSourceLoc
    }

    // optional int32 hTarget = 2;

    pub fn clear_hTarget(&mut self) {
        self.hTarget = ::std::option::Option::None;
    }

    pub fn has_hTarget(&self) -> bool {
        self.hTarget.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hTarget(&mut self, v: i32) {
        self.hTarget = ::std::option::Option::Some(v);
    }

    pub fn get_hTarget(&self) -> i32 {
        self.hTarget.unwrap_or(0)
    }

    fn get_hTarget_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.hTarget
    }

    fn mut_hTarget_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.hTarget
    }

    // optional int32 moveSpeed = 3;

    pub fn clear_moveSpeed(&mut self) {
        self.moveSpeed = ::std::option::Option::None;
    }

    pub fn has_moveSpeed(&self) -> bool {
        self.moveSpeed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moveSpeed(&mut self, v: i32) {
        self.moveSpeed = ::std::option::Option::Some(v);
    }

    pub fn get_moveSpeed(&self) -> i32 {
        self.moveSpeed.unwrap_or(0)
    }

    fn get_moveSpeed_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.moveSpeed
    }

    fn mut_moveSpeed_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.moveSpeed
    }

    // optional int64 particleSystemHandle = 4;

    pub fn clear_particleSystemHandle(&mut self) {
        self.particleSystemHandle = ::std::option::Option::None;
    }

    pub fn has_particleSystemHandle(&self) -> bool {
        self.particleSystemHandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_particleSystemHandle(&mut self, v: i64) {
        self.particleSystemHandle = ::std::option::Option::Some(v);
    }

    pub fn get_particleSystemHandle(&self) -> i64 {
        self.particleSystemHandle.unwrap_or(0)
    }

    fn get_particleSystemHandle_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.particleSystemHandle
    }

    fn mut_particleSystemHandle_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.particleSystemHandle
    }

    // optional bool dodgeable = 5;

    pub fn clear_dodgeable(&mut self) {
        self.dodgeable = ::std::option::Option::None;
    }

    pub fn has_dodgeable(&self) -> bool {
        self.dodgeable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dodgeable(&mut self, v: bool) {
        self.dodgeable = ::std::option::Option::Some(v);
    }

    pub fn get_dodgeable(&self) -> bool {
        self.dodgeable.unwrap_or(false)
    }

    fn get_dodgeable_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.dodgeable
    }

    fn mut_dodgeable_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.dodgeable
    }

    // optional bool isAttack = 6;

    pub fn clear_isAttack(&mut self) {
        self.isAttack = ::std::option::Option::None;
    }

    pub fn has_isAttack(&self) -> bool {
        self.isAttack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isAttack(&mut self, v: bool) {
        self.isAttack = ::std::option::Option::Some(v);
    }

    pub fn get_isAttack(&self) -> bool {
        self.isAttack.unwrap_or(false)
    }

    fn get_isAttack_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.isAttack
    }

    fn mut_isAttack_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.isAttack
    }

    // optional bool isEvaded = 8;

    pub fn clear_isEvaded(&mut self) {
        self.isEvaded = ::std::option::Option::None;
    }

    pub fn has_isEvaded(&self) -> bool {
        self.isEvaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isEvaded(&mut self, v: bool) {
        self.isEvaded = ::std::option::Option::Some(v);
    }

    pub fn get_isEvaded(&self) -> bool {
        self.isEvaded.unwrap_or(false)
    }

    fn get_isEvaded_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.isEvaded
    }

    fn mut_isEvaded_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.isEvaded
    }

    // optional float expireTime = 9;

    pub fn clear_expireTime(&mut self) {
        self.expireTime = ::std::option::Option::None;
    }

    pub fn has_expireTime(&self) -> bool {
        self.expireTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expireTime(&mut self, v: f32) {
        self.expireTime = ::std::option::Option::Some(v);
    }

    pub fn get_expireTime(&self) -> f32 {
        self.expireTime.unwrap_or(0.)
    }

    fn get_expireTime_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.expireTime
    }

    fn mut_expireTime_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.expireTime
    }

    // optional .CMsgVector vTargetLoc = 10;

    pub fn clear_vTargetLoc(&mut self) {
        self.vTargetLoc.clear();
    }

    pub fn has_vTargetLoc(&self) -> bool {
        self.vTargetLoc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vTargetLoc(&mut self, v: super::networkbasetypes::CMsgVector) {
        self.vTargetLoc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vTargetLoc(&mut self) -> &mut super::networkbasetypes::CMsgVector {
        if self.vTargetLoc.is_none() {
            self.vTargetLoc.set_default();
        }
        self.vTargetLoc.as_mut().unwrap()
    }

    // Take field
    pub fn take_vTargetLoc(&mut self) -> super::networkbasetypes::CMsgVector {
        self.vTargetLoc.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector::new())
    }

    pub fn get_vTargetLoc(&self) -> &super::networkbasetypes::CMsgVector {
        self.vTargetLoc.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector::default_instance())
    }

    fn get_vTargetLoc_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &self.vTargetLoc
    }

    fn mut_vTargetLoc_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &mut self.vTargetLoc
    }

    // optional fixed32 colorgemcolor = 11;

    pub fn clear_colorgemcolor(&mut self) {
        self.colorgemcolor = ::std::option::Option::None;
    }

    pub fn has_colorgemcolor(&self) -> bool {
        self.colorgemcolor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_colorgemcolor(&mut self, v: u32) {
        self.colorgemcolor = ::std::option::Option::Some(v);
    }

    pub fn get_colorgemcolor(&self) -> u32 {
        self.colorgemcolor.unwrap_or(0)
    }

    fn get_colorgemcolor_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.colorgemcolor
    }

    fn mut_colorgemcolor_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.colorgemcolor
    }

    // optional int32 launch_tick = 12;

    pub fn clear_launch_tick(&mut self) {
        self.launch_tick = ::std::option::Option::None;
    }

    pub fn has_launch_tick(&self) -> bool {
        self.launch_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launch_tick(&mut self, v: i32) {
        self.launch_tick = ::std::option::Option::Some(v);
    }

    pub fn get_launch_tick(&self) -> i32 {
        self.launch_tick.unwrap_or(0)
    }

    fn get_launch_tick_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.launch_tick
    }

    fn mut_launch_tick_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.launch_tick
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TE_ProjectileLoc {
    fn is_initialized(&self) -> bool {
        for v in &self.vSourceLoc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vTargetLoc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vSourceLoc)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.hTarget = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.moveSpeed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.particleSystemHandle = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dodgeable = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isAttack = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isEvaded = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.expireTime = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vTargetLoc)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.colorgemcolor = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.launch_tick = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.vSourceLoc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.hTarget {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.moveSpeed {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.particleSystemHandle {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dodgeable {
            my_size += 2;
        }
        if let Some(v) = self.isAttack {
            my_size += 2;
        }
        if let Some(v) = self.isEvaded {
            my_size += 2;
        }
        if let Some(v) = self.expireTime {
            my_size += 5;
        }
        if let Some(ref v) = self.vTargetLoc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.colorgemcolor {
            my_size += 5;
        }
        if let Some(v) = self.launch_tick {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.vSourceLoc.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.hTarget {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.moveSpeed {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.particleSystemHandle {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.dodgeable {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.isAttack {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.isEvaded {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.expireTime {
            os.write_float(9, v)?;
        }
        if let Some(ref v) = self.vTargetLoc.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.colorgemcolor {
            os.write_fixed32(11, v)?;
        }
        if let Some(v) = self.launch_tick {
            os.write_int32(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_TE_ProjectileLoc {
    fn new() -> CDOTAUserMsg_TE_ProjectileLoc {
        CDOTAUserMsg_TE_ProjectileLoc::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_TE_ProjectileLoc>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector>>(
                    "vSourceLoc",
                    CDOTAUserMsg_TE_ProjectileLoc::get_vSourceLoc_for_reflect,
                    CDOTAUserMsg_TE_ProjectileLoc::mut_vSourceLoc_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "hTarget",
                    CDOTAUserMsg_TE_ProjectileLoc::get_hTarget_for_reflect,
                    CDOTAUserMsg_TE_ProjectileLoc::mut_hTarget_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "moveSpeed",
                    CDOTAUserMsg_TE_ProjectileLoc::get_moveSpeed_for_reflect,
                    CDOTAUserMsg_TE_ProjectileLoc::mut_moveSpeed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "particleSystemHandle",
                    CDOTAUserMsg_TE_ProjectileLoc::get_particleSystemHandle_for_reflect,
                    CDOTAUserMsg_TE_ProjectileLoc::mut_particleSystemHandle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "dodgeable",
                    CDOTAUserMsg_TE_ProjectileLoc::get_dodgeable_for_reflect,
                    CDOTAUserMsg_TE_ProjectileLoc::mut_dodgeable_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isAttack",
                    CDOTAUserMsg_TE_ProjectileLoc::get_isAttack_for_reflect,
                    CDOTAUserMsg_TE_ProjectileLoc::mut_isAttack_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isEvaded",
                    CDOTAUserMsg_TE_ProjectileLoc::get_isEvaded_for_reflect,
                    CDOTAUserMsg_TE_ProjectileLoc::mut_isEvaded_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "expireTime",
                    CDOTAUserMsg_TE_ProjectileLoc::get_expireTime_for_reflect,
                    CDOTAUserMsg_TE_ProjectileLoc::mut_expireTime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector>>(
                    "vTargetLoc",
                    CDOTAUserMsg_TE_ProjectileLoc::get_vTargetLoc_for_reflect,
                    CDOTAUserMsg_TE_ProjectileLoc::mut_vTargetLoc_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "colorgemcolor",
                    CDOTAUserMsg_TE_ProjectileLoc::get_colorgemcolor_for_reflect,
                    CDOTAUserMsg_TE_ProjectileLoc::mut_colorgemcolor_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "launch_tick",
                    CDOTAUserMsg_TE_ProjectileLoc::get_launch_tick_for_reflect,
                    CDOTAUserMsg_TE_ProjectileLoc::mut_launch_tick_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_TE_ProjectileLoc>(
                    "CDOTAUserMsg_TE_ProjectileLoc",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_TE_ProjectileLoc {
    fn clear(&mut self) {
        self.clear_vSourceLoc();
        self.clear_hTarget();
        self.clear_moveSpeed();
        self.clear_particleSystemHandle();
        self.clear_dodgeable();
        self.clear_isAttack();
        self.clear_isEvaded();
        self.clear_expireTime();
        self.clear_vTargetLoc();
        self.clear_colorgemcolor();
        self.clear_launch_tick();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_TE_ProjectileLoc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TE_ProjectileLoc {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_TE_DotaBloodImpact {
    // message fields
    entity: ::std::option::Option<i32>,
    scale: ::std::option::Option<f32>,
    xnormal: ::std::option::Option<f32>,
    ynormal: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_TE_DotaBloodImpact {}

impl CDOTAUserMsg_TE_DotaBloodImpact {
    pub fn new() -> CDOTAUserMsg_TE_DotaBloodImpact {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_TE_DotaBloodImpact {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_TE_DotaBloodImpact> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_TE_DotaBloodImpact,
        };
        unsafe {
            instance.get(CDOTAUserMsg_TE_DotaBloodImpact::new)
        }
    }

    // optional int32 entity = 1;

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: i32) {
        self.entity = ::std::option::Option::Some(v);
    }

    pub fn get_entity(&self) -> i32 {
        self.entity.unwrap_or(0)
    }

    fn get_entity_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entity
    }

    fn mut_entity_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entity
    }

    // optional float scale = 2;

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    pub fn get_scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    fn get_scale_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.scale
    }

    fn mut_scale_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.scale
    }

    // optional float xnormal = 3;

    pub fn clear_xnormal(&mut self) {
        self.xnormal = ::std::option::Option::None;
    }

    pub fn has_xnormal(&self) -> bool {
        self.xnormal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xnormal(&mut self, v: f32) {
        self.xnormal = ::std::option::Option::Some(v);
    }

    pub fn get_xnormal(&self) -> f32 {
        self.xnormal.unwrap_or(0.)
    }

    fn get_xnormal_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.xnormal
    }

    fn mut_xnormal_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.xnormal
    }

    // optional float ynormal = 4;

    pub fn clear_ynormal(&mut self) {
        self.ynormal = ::std::option::Option::None;
    }

    pub fn has_ynormal(&self) -> bool {
        self.ynormal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ynormal(&mut self, v: f32) {
        self.ynormal = ::std::option::Option::Some(v);
    }

    pub fn get_ynormal(&self) -> f32 {
        self.ynormal.unwrap_or(0.)
    }

    fn get_ynormal_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.ynormal
    }

    fn mut_ynormal_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.ynormal
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TE_DotaBloodImpact {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entity = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.scale = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.xnormal = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ynormal = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entity {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scale {
            my_size += 5;
        }
        if let Some(v) = self.xnormal {
            my_size += 5;
        }
        if let Some(v) = self.ynormal {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entity {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.xnormal {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.ynormal {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_TE_DotaBloodImpact {
    fn new() -> CDOTAUserMsg_TE_DotaBloodImpact {
        CDOTAUserMsg_TE_DotaBloodImpact::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_TE_DotaBloodImpact>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entity",
                    CDOTAUserMsg_TE_DotaBloodImpact::get_entity_for_reflect,
                    CDOTAUserMsg_TE_DotaBloodImpact::mut_entity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "scale",
                    CDOTAUserMsg_TE_DotaBloodImpact::get_scale_for_reflect,
                    CDOTAUserMsg_TE_DotaBloodImpact::mut_scale_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "xnormal",
                    CDOTAUserMsg_TE_DotaBloodImpact::get_xnormal_for_reflect,
                    CDOTAUserMsg_TE_DotaBloodImpact::mut_xnormal_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "ynormal",
                    CDOTAUserMsg_TE_DotaBloodImpact::get_ynormal_for_reflect,
                    CDOTAUserMsg_TE_DotaBloodImpact::mut_ynormal_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_TE_DotaBloodImpact>(
                    "CDOTAUserMsg_TE_DotaBloodImpact",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_TE_DotaBloodImpact {
    fn clear(&mut self) {
        self.clear_entity();
        self.clear_scale();
        self.clear_xnormal();
        self.clear_ynormal();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_TE_DotaBloodImpact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TE_DotaBloodImpact {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_AbilityPing {
    // message fields
    player_id: ::std::option::Option<u32>,
    ability_id: ::std::option::Option<u32>,
    field_type: ::std::option::Option<DOTA_ABILITY_PING_TYPE>,
    cooldown_seconds: ::std::option::Option<u32>,
    level: ::std::option::Option<u32>,
    passive: ::std::option::Option<bool>,
    mana_needed: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_AbilityPing {}

impl CDOTAUserMsg_AbilityPing {
    pub fn new() -> CDOTAUserMsg_AbilityPing {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_AbilityPing {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_AbilityPing> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_AbilityPing,
        };
        unsafe {
            instance.get(CDOTAUserMsg_AbilityPing::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional uint32 ability_id = 2;

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: u32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    pub fn get_ability_id(&self) -> u32 {
        self.ability_id.unwrap_or(0)
    }

    fn get_ability_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ability_id
    }

    fn mut_ability_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ability_id
    }

    // optional .DOTA_ABILITY_PING_TYPE type = 3;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DOTA_ABILITY_PING_TYPE) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> DOTA_ABILITY_PING_TYPE {
        self.field_type.unwrap_or(DOTA_ABILITY_PING_TYPE::ABILITY_PING_READY)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<DOTA_ABILITY_PING_TYPE> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<DOTA_ABILITY_PING_TYPE> {
        &mut self.field_type
    }

    // optional uint32 cooldown_seconds = 4;

    pub fn clear_cooldown_seconds(&mut self) {
        self.cooldown_seconds = ::std::option::Option::None;
    }

    pub fn has_cooldown_seconds(&self) -> bool {
        self.cooldown_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_seconds(&mut self, v: u32) {
        self.cooldown_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_cooldown_seconds(&self) -> u32 {
        self.cooldown_seconds.unwrap_or(0)
    }

    fn get_cooldown_seconds_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cooldown_seconds
    }

    fn mut_cooldown_seconds_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cooldown_seconds
    }

    // optional uint32 level = 5;

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    pub fn get_level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    fn get_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.level
    }

    fn mut_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.level
    }

    // optional bool passive = 6;

    pub fn clear_passive(&mut self) {
        self.passive = ::std::option::Option::None;
    }

    pub fn has_passive(&self) -> bool {
        self.passive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passive(&mut self, v: bool) {
        self.passive = ::std::option::Option::Some(v);
    }

    pub fn get_passive(&self) -> bool {
        self.passive.unwrap_or(false)
    }

    fn get_passive_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.passive
    }

    fn mut_passive_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.passive
    }

    // optional uint32 mana_needed = 7;

    pub fn clear_mana_needed(&mut self) {
        self.mana_needed = ::std::option::Option::None;
    }

    pub fn has_mana_needed(&self) -> bool {
        self.mana_needed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mana_needed(&mut self, v: u32) {
        self.mana_needed = ::std::option::Option::Some(v);
    }

    pub fn get_mana_needed(&self) -> u32 {
        self.mana_needed.unwrap_or(0)
    }

    fn get_mana_needed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mana_needed
    }

    fn mut_mana_needed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mana_needed
    }
}

impl ::protobuf::Message for CDOTAUserMsg_AbilityPing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ability_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cooldown_seconds = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passive = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mana_needed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.cooldown_seconds {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.passive {
            my_size += 2;
        }
        if let Some(v) = self.mana_needed {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.cooldown_seconds {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.passive {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.mana_needed {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_AbilityPing {
    fn new() -> CDOTAUserMsg_AbilityPing {
        CDOTAUserMsg_AbilityPing::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_AbilityPing>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_AbilityPing::get_player_id_for_reflect,
                    CDOTAUserMsg_AbilityPing::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ability_id",
                    CDOTAUserMsg_AbilityPing::get_ability_id_for_reflect,
                    CDOTAUserMsg_AbilityPing::mut_ability_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DOTA_ABILITY_PING_TYPE>>(
                    "type",
                    CDOTAUserMsg_AbilityPing::get_field_type_for_reflect,
                    CDOTAUserMsg_AbilityPing::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cooldown_seconds",
                    CDOTAUserMsg_AbilityPing::get_cooldown_seconds_for_reflect,
                    CDOTAUserMsg_AbilityPing::mut_cooldown_seconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "level",
                    CDOTAUserMsg_AbilityPing::get_level_for_reflect,
                    CDOTAUserMsg_AbilityPing::mut_level_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "passive",
                    CDOTAUserMsg_AbilityPing::get_passive_for_reflect,
                    CDOTAUserMsg_AbilityPing::mut_passive_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mana_needed",
                    CDOTAUserMsg_AbilityPing::get_mana_needed_for_reflect,
                    CDOTAUserMsg_AbilityPing::mut_mana_needed_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_AbilityPing>(
                    "CDOTAUserMsg_AbilityPing",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_AbilityPing {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_ability_id();
        self.clear_field_type();
        self.clear_cooldown_seconds();
        self.clear_level();
        self.clear_passive();
        self.clear_mana_needed();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_AbilityPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_AbilityPing {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_TE_UnitAnimation {
    // message fields
    entity: ::std::option::Option<i32>,
    sequenceVariant: ::std::option::Option<i32>,
    playbackrate: ::std::option::Option<f32>,
    castpoint: ::std::option::Option<f32>,
    field_type: ::std::option::Option<i32>,
    activity: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_TE_UnitAnimation {}

impl CDOTAUserMsg_TE_UnitAnimation {
    pub fn new() -> CDOTAUserMsg_TE_UnitAnimation {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_TE_UnitAnimation {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_TE_UnitAnimation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_TE_UnitAnimation,
        };
        unsafe {
            instance.get(CDOTAUserMsg_TE_UnitAnimation::new)
        }
    }

    // optional int32 entity = 1;

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: i32) {
        self.entity = ::std::option::Option::Some(v);
    }

    pub fn get_entity(&self) -> i32 {
        self.entity.unwrap_or(0)
    }

    fn get_entity_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entity
    }

    fn mut_entity_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entity
    }

    // optional int32 sequenceVariant = 2;

    pub fn clear_sequenceVariant(&mut self) {
        self.sequenceVariant = ::std::option::Option::None;
    }

    pub fn has_sequenceVariant(&self) -> bool {
        self.sequenceVariant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequenceVariant(&mut self, v: i32) {
        self.sequenceVariant = ::std::option::Option::Some(v);
    }

    pub fn get_sequenceVariant(&self) -> i32 {
        self.sequenceVariant.unwrap_or(0)
    }

    fn get_sequenceVariant_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.sequenceVariant
    }

    fn mut_sequenceVariant_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.sequenceVariant
    }

    // optional float playbackrate = 3;

    pub fn clear_playbackrate(&mut self) {
        self.playbackrate = ::std::option::Option::None;
    }

    pub fn has_playbackrate(&self) -> bool {
        self.playbackrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playbackrate(&mut self, v: f32) {
        self.playbackrate = ::std::option::Option::Some(v);
    }

    pub fn get_playbackrate(&self) -> f32 {
        self.playbackrate.unwrap_or(0.)
    }

    fn get_playbackrate_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.playbackrate
    }

    fn mut_playbackrate_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.playbackrate
    }

    // optional float castpoint = 4;

    pub fn clear_castpoint(&mut self) {
        self.castpoint = ::std::option::Option::None;
    }

    pub fn has_castpoint(&self) -> bool {
        self.castpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_castpoint(&mut self, v: f32) {
        self.castpoint = ::std::option::Option::Some(v);
    }

    pub fn get_castpoint(&self) -> f32 {
        self.castpoint.unwrap_or(0.)
    }

    fn get_castpoint_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.castpoint
    }

    fn mut_castpoint_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.castpoint
    }

    // optional int32 type = 5;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.field_type
    }

    // optional int32 activity = 6;

    pub fn clear_activity(&mut self) {
        self.activity = ::std::option::Option::None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: i32) {
        self.activity = ::std::option::Option::Some(v);
    }

    pub fn get_activity(&self) -> i32 {
        self.activity.unwrap_or(0)
    }

    fn get_activity_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.activity
    }

    fn mut_activity_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.activity
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TE_UnitAnimation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entity = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sequenceVariant = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.playbackrate = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.castpoint = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.activity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entity {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sequenceVariant {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.playbackrate {
            my_size += 5;
        }
        if let Some(v) = self.castpoint {
            my_size += 5;
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.activity {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entity {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.sequenceVariant {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.playbackrate {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.castpoint {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.activity {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_TE_UnitAnimation {
    fn new() -> CDOTAUserMsg_TE_UnitAnimation {
        CDOTAUserMsg_TE_UnitAnimation::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_TE_UnitAnimation>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entity",
                    CDOTAUserMsg_TE_UnitAnimation::get_entity_for_reflect,
                    CDOTAUserMsg_TE_UnitAnimation::mut_entity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "sequenceVariant",
                    CDOTAUserMsg_TE_UnitAnimation::get_sequenceVariant_for_reflect,
                    CDOTAUserMsg_TE_UnitAnimation::mut_sequenceVariant_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "playbackrate",
                    CDOTAUserMsg_TE_UnitAnimation::get_playbackrate_for_reflect,
                    CDOTAUserMsg_TE_UnitAnimation::mut_playbackrate_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "castpoint",
                    CDOTAUserMsg_TE_UnitAnimation::get_castpoint_for_reflect,
                    CDOTAUserMsg_TE_UnitAnimation::mut_castpoint_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type",
                    CDOTAUserMsg_TE_UnitAnimation::get_field_type_for_reflect,
                    CDOTAUserMsg_TE_UnitAnimation::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "activity",
                    CDOTAUserMsg_TE_UnitAnimation::get_activity_for_reflect,
                    CDOTAUserMsg_TE_UnitAnimation::mut_activity_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_TE_UnitAnimation>(
                    "CDOTAUserMsg_TE_UnitAnimation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_TE_UnitAnimation {
    fn clear(&mut self) {
        self.clear_entity();
        self.clear_sequenceVariant();
        self.clear_playbackrate();
        self.clear_castpoint();
        self.clear_field_type();
        self.clear_activity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_TE_UnitAnimation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TE_UnitAnimation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_TE_UnitAnimationEnd {
    // message fields
    entity: ::std::option::Option<i32>,
    snap: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_TE_UnitAnimationEnd {}

impl CDOTAUserMsg_TE_UnitAnimationEnd {
    pub fn new() -> CDOTAUserMsg_TE_UnitAnimationEnd {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_TE_UnitAnimationEnd {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_TE_UnitAnimationEnd> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_TE_UnitAnimationEnd,
        };
        unsafe {
            instance.get(CDOTAUserMsg_TE_UnitAnimationEnd::new)
        }
    }

    // optional int32 entity = 1;

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: i32) {
        self.entity = ::std::option::Option::Some(v);
    }

    pub fn get_entity(&self) -> i32 {
        self.entity.unwrap_or(0)
    }

    fn get_entity_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.entity
    }

    fn mut_entity_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.entity
    }

    // optional bool snap = 2;

    pub fn clear_snap(&mut self) {
        self.snap = ::std::option::Option::None;
    }

    pub fn has_snap(&self) -> bool {
        self.snap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snap(&mut self, v: bool) {
        self.snap = ::std::option::Option::Some(v);
    }

    pub fn get_snap(&self) -> bool {
        self.snap.unwrap_or(false)
    }

    fn get_snap_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.snap
    }

    fn mut_snap_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.snap
    }
}

impl ::protobuf::Message for CDOTAUserMsg_TE_UnitAnimationEnd {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entity = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.snap = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entity {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.snap {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entity {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.snap {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_TE_UnitAnimationEnd {
    fn new() -> CDOTAUserMsg_TE_UnitAnimationEnd {
        CDOTAUserMsg_TE_UnitAnimationEnd::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_TE_UnitAnimationEnd>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "entity",
                    CDOTAUserMsg_TE_UnitAnimationEnd::get_entity_for_reflect,
                    CDOTAUserMsg_TE_UnitAnimationEnd::mut_entity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "snap",
                    CDOTAUserMsg_TE_UnitAnimationEnd::get_snap_for_reflect,
                    CDOTAUserMsg_TE_UnitAnimationEnd::mut_snap_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_TE_UnitAnimationEnd>(
                    "CDOTAUserMsg_TE_UnitAnimationEnd",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_TE_UnitAnimationEnd {
    fn clear(&mut self) {
        self.clear_entity();
        self.clear_snap();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_TE_UnitAnimationEnd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_TE_UnitAnimationEnd {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ShowGenericPopup {
    // message fields
    header: ::protobuf::SingularField<::std::string::String>,
    body: ::protobuf::SingularField<::std::string::String>,
    param1: ::protobuf::SingularField<::std::string::String>,
    param2: ::protobuf::SingularField<::std::string::String>,
    tint_screen: ::std::option::Option<bool>,
    show_no_other_dialogs: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ShowGenericPopup {}

impl CDOTAUserMsg_ShowGenericPopup {
    pub fn new() -> CDOTAUserMsg_ShowGenericPopup {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ShowGenericPopup {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ShowGenericPopup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ShowGenericPopup,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ShowGenericPopup::new)
        }
    }

    // required string header = 1;

    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ::std::string::String) {
        self.header = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ::std::string::String {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ::std::string::String {
        self.header.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_header(&self) -> &str {
        match self.header.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_header_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.header
    }

    fn mut_header_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.header
    }

    // required string body = 2;

    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_body_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.body
    }

    fn mut_body_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.body
    }

    // optional string param1 = 3;

    pub fn clear_param1(&mut self) {
        self.param1.clear();
    }

    pub fn has_param1(&self) -> bool {
        self.param1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param1(&mut self, v: ::std::string::String) {
        self.param1 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param1(&mut self) -> &mut ::std::string::String {
        if self.param1.is_none() {
            self.param1.set_default();
        }
        self.param1.as_mut().unwrap()
    }

    // Take field
    pub fn take_param1(&mut self) -> ::std::string::String {
        self.param1.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_param1(&self) -> &str {
        match self.param1.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_param1_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.param1
    }

    fn mut_param1_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.param1
    }

    // optional string param2 = 4;

    pub fn clear_param2(&mut self) {
        self.param2.clear();
    }

    pub fn has_param2(&self) -> bool {
        self.param2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param2(&mut self, v: ::std::string::String) {
        self.param2 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param2(&mut self) -> &mut ::std::string::String {
        if self.param2.is_none() {
            self.param2.set_default();
        }
        self.param2.as_mut().unwrap()
    }

    // Take field
    pub fn take_param2(&mut self) -> ::std::string::String {
        self.param2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_param2(&self) -> &str {
        match self.param2.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_param2_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.param2
    }

    fn mut_param2_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.param2
    }

    // optional bool tint_screen = 5;

    pub fn clear_tint_screen(&mut self) {
        self.tint_screen = ::std::option::Option::None;
    }

    pub fn has_tint_screen(&self) -> bool {
        self.tint_screen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tint_screen(&mut self, v: bool) {
        self.tint_screen = ::std::option::Option::Some(v);
    }

    pub fn get_tint_screen(&self) -> bool {
        self.tint_screen.unwrap_or(false)
    }

    fn get_tint_screen_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.tint_screen
    }

    fn mut_tint_screen_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.tint_screen
    }

    // optional bool show_no_other_dialogs = 6;

    pub fn clear_show_no_other_dialogs(&mut self) {
        self.show_no_other_dialogs = ::std::option::Option::None;
    }

    pub fn has_show_no_other_dialogs(&self) -> bool {
        self.show_no_other_dialogs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_no_other_dialogs(&mut self, v: bool) {
        self.show_no_other_dialogs = ::std::option::Option::Some(v);
    }

    pub fn get_show_no_other_dialogs(&self) -> bool {
        self.show_no_other_dialogs.unwrap_or(false)
    }

    fn get_show_no_other_dialogs_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.show_no_other_dialogs
    }

    fn mut_show_no_other_dialogs_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.show_no_other_dialogs
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ShowGenericPopup {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        if self.body.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.body)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.param1)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.param2)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tint_screen = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_no_other_dialogs = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.param1.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.param2.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.tint_screen {
            my_size += 2;
        }
        if let Some(v) = self.show_no_other_dialogs {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.body.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.param1.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.param2.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.tint_screen {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.show_no_other_dialogs {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ShowGenericPopup {
    fn new() -> CDOTAUserMsg_ShowGenericPopup {
        CDOTAUserMsg_ShowGenericPopup::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ShowGenericPopup>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "header",
                    CDOTAUserMsg_ShowGenericPopup::get_header_for_reflect,
                    CDOTAUserMsg_ShowGenericPopup::mut_header_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "body",
                    CDOTAUserMsg_ShowGenericPopup::get_body_for_reflect,
                    CDOTAUserMsg_ShowGenericPopup::mut_body_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "param1",
                    CDOTAUserMsg_ShowGenericPopup::get_param1_for_reflect,
                    CDOTAUserMsg_ShowGenericPopup::mut_param1_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "param2",
                    CDOTAUserMsg_ShowGenericPopup::get_param2_for_reflect,
                    CDOTAUserMsg_ShowGenericPopup::mut_param2_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "tint_screen",
                    CDOTAUserMsg_ShowGenericPopup::get_tint_screen_for_reflect,
                    CDOTAUserMsg_ShowGenericPopup::mut_tint_screen_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "show_no_other_dialogs",
                    CDOTAUserMsg_ShowGenericPopup::get_show_no_other_dialogs_for_reflect,
                    CDOTAUserMsg_ShowGenericPopup::mut_show_no_other_dialogs_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ShowGenericPopup>(
                    "CDOTAUserMsg_ShowGenericPopup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ShowGenericPopup {
    fn clear(&mut self) {
        self.clear_header();
        self.clear_body();
        self.clear_param1();
        self.clear_param2();
        self.clear_tint_screen();
        self.clear_show_no_other_dialogs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ShowGenericPopup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ShowGenericPopup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_VoteStart {
    // message fields
    title: ::protobuf::SingularField<::std::string::String>,
    duration: ::std::option::Option<f32>,
    choice_count: ::std::option::Option<i32>,
    choices: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_VoteStart {}

impl CDOTAUserMsg_VoteStart {
    pub fn new() -> CDOTAUserMsg_VoteStart {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_VoteStart {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_VoteStart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_VoteStart,
        };
        unsafe {
            instance.get(CDOTAUserMsg_VoteStart::new)
        }
    }

    // optional string title = 1;

    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_title_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.title
    }

    fn mut_title_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.title
    }

    // optional float duration = 2;

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    fn get_duration_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.duration
    }

    fn mut_duration_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.duration
    }

    // optional int32 choice_count = 3;

    pub fn clear_choice_count(&mut self) {
        self.choice_count = ::std::option::Option::None;
    }

    pub fn has_choice_count(&self) -> bool {
        self.choice_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_choice_count(&mut self, v: i32) {
        self.choice_count = ::std::option::Option::Some(v);
    }

    pub fn get_choice_count(&self) -> i32 {
        self.choice_count.unwrap_or(0)
    }

    fn get_choice_count_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.choice_count
    }

    fn mut_choice_count_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.choice_count
    }

    // repeated string choices = 4;

    pub fn clear_choices(&mut self) {
        self.choices.clear();
    }

    // Param is passed by value, moved
    pub fn set_choices(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.choices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_choices(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.choices
    }

    // Take field
    pub fn take_choices(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.choices, ::protobuf::RepeatedField::new())
    }

    pub fn get_choices(&self) -> &[::std::string::String] {
        &self.choices
    }

    fn get_choices_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.choices
    }

    fn mut_choices_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.choices
    }
}

impl ::protobuf::Message for CDOTAUserMsg_VoteStart {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.choice_count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.choices)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.duration {
            my_size += 5;
        }
        if let Some(v) = self.choice_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.choices {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.choice_count {
            os.write_int32(3, v)?;
        }
        for v in &self.choices {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_VoteStart {
    fn new() -> CDOTAUserMsg_VoteStart {
        CDOTAUserMsg_VoteStart::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_VoteStart>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    CDOTAUserMsg_VoteStart::get_title_for_reflect,
                    CDOTAUserMsg_VoteStart::mut_title_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "duration",
                    CDOTAUserMsg_VoteStart::get_duration_for_reflect,
                    CDOTAUserMsg_VoteStart::mut_duration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "choice_count",
                    CDOTAUserMsg_VoteStart::get_choice_count_for_reflect,
                    CDOTAUserMsg_VoteStart::mut_choice_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "choices",
                    CDOTAUserMsg_VoteStart::get_choices_for_reflect,
                    CDOTAUserMsg_VoteStart::mut_choices_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_VoteStart>(
                    "CDOTAUserMsg_VoteStart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_VoteStart {
    fn clear(&mut self) {
        self.clear_title();
        self.clear_duration();
        self.clear_choice_count();
        self.clear_choices();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_VoteStart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_VoteStart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_VoteUpdate {
    // message fields
    choice_counts: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_VoteUpdate {}

impl CDOTAUserMsg_VoteUpdate {
    pub fn new() -> CDOTAUserMsg_VoteUpdate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_VoteUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_VoteUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_VoteUpdate,
        };
        unsafe {
            instance.get(CDOTAUserMsg_VoteUpdate::new)
        }
    }

    // repeated int32 choice_counts = 1;

    pub fn clear_choice_counts(&mut self) {
        self.choice_counts.clear();
    }

    // Param is passed by value, moved
    pub fn set_choice_counts(&mut self, v: ::std::vec::Vec<i32>) {
        self.choice_counts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_choice_counts(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.choice_counts
    }

    // Take field
    pub fn take_choice_counts(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.choice_counts, ::std::vec::Vec::new())
    }

    pub fn get_choice_counts(&self) -> &[i32] {
        &self.choice_counts
    }

    fn get_choice_counts_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.choice_counts
    }

    fn mut_choice_counts_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.choice_counts
    }
}

impl ::protobuf::Message for CDOTAUserMsg_VoteUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.choice_counts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.choice_counts {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.choice_counts {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_VoteUpdate {
    fn new() -> CDOTAUserMsg_VoteUpdate {
        CDOTAUserMsg_VoteUpdate::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_VoteUpdate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "choice_counts",
                    CDOTAUserMsg_VoteUpdate::get_choice_counts_for_reflect,
                    CDOTAUserMsg_VoteUpdate::mut_choice_counts_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_VoteUpdate>(
                    "CDOTAUserMsg_VoteUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_VoteUpdate {
    fn clear(&mut self) {
        self.clear_choice_counts();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_VoteUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_VoteUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_VoteEnd {
    // message fields
    selected_choice: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_VoteEnd {}

impl CDOTAUserMsg_VoteEnd {
    pub fn new() -> CDOTAUserMsg_VoteEnd {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_VoteEnd {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_VoteEnd> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_VoteEnd,
        };
        unsafe {
            instance.get(CDOTAUserMsg_VoteEnd::new)
        }
    }

    // optional int32 selected_choice = 1;

    pub fn clear_selected_choice(&mut self) {
        self.selected_choice = ::std::option::Option::None;
    }

    pub fn has_selected_choice(&self) -> bool {
        self.selected_choice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_choice(&mut self, v: i32) {
        self.selected_choice = ::std::option::Option::Some(v);
    }

    pub fn get_selected_choice(&self) -> i32 {
        self.selected_choice.unwrap_or(0)
    }

    fn get_selected_choice_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.selected_choice
    }

    fn mut_selected_choice_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.selected_choice
    }
}

impl ::protobuf::Message for CDOTAUserMsg_VoteEnd {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.selected_choice = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.selected_choice {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.selected_choice {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_VoteEnd {
    fn new() -> CDOTAUserMsg_VoteEnd {
        CDOTAUserMsg_VoteEnd::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_VoteEnd>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "selected_choice",
                    CDOTAUserMsg_VoteEnd::get_selected_choice_for_reflect,
                    CDOTAUserMsg_VoteEnd::mut_selected_choice_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_VoteEnd>(
                    "CDOTAUserMsg_VoteEnd",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_VoteEnd {
    fn clear(&mut self) {
        self.clear_selected_choice();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_VoteEnd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_VoteEnd {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_BoosterStatePlayer {
    // message fields
    player_id: ::std::option::Option<u32>,
    bonus: ::std::option::Option<f32>,
    event_bonus: ::std::option::Option<f32>,
    bonus_item_id: ::std::option::Option<u32>,
    event_bonus_item_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_BoosterStatePlayer {}

impl CDOTAUserMsg_BoosterStatePlayer {
    pub fn new() -> CDOTAUserMsg_BoosterStatePlayer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_BoosterStatePlayer {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_BoosterStatePlayer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_BoosterStatePlayer,
        };
        unsafe {
            instance.get(CDOTAUserMsg_BoosterStatePlayer::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional float bonus = 2;

    pub fn clear_bonus(&mut self) {
        self.bonus = ::std::option::Option::None;
    }

    pub fn has_bonus(&self) -> bool {
        self.bonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus(&mut self, v: f32) {
        self.bonus = ::std::option::Option::Some(v);
    }

    pub fn get_bonus(&self) -> f32 {
        self.bonus.unwrap_or(0.)
    }

    fn get_bonus_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.bonus
    }

    fn mut_bonus_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.bonus
    }

    // optional float event_bonus = 3;

    pub fn clear_event_bonus(&mut self) {
        self.event_bonus = ::std::option::Option::None;
    }

    pub fn has_event_bonus(&self) -> bool {
        self.event_bonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_bonus(&mut self, v: f32) {
        self.event_bonus = ::std::option::Option::Some(v);
    }

    pub fn get_event_bonus(&self) -> f32 {
        self.event_bonus.unwrap_or(0.)
    }

    fn get_event_bonus_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.event_bonus
    }

    fn mut_event_bonus_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.event_bonus
    }

    // optional uint32 bonus_item_id = 4;

    pub fn clear_bonus_item_id(&mut self) {
        self.bonus_item_id = ::std::option::Option::None;
    }

    pub fn has_bonus_item_id(&self) -> bool {
        self.bonus_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_item_id(&mut self, v: u32) {
        self.bonus_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_bonus_item_id(&self) -> u32 {
        self.bonus_item_id.unwrap_or(0)
    }

    fn get_bonus_item_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.bonus_item_id
    }

    fn mut_bonus_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.bonus_item_id
    }

    // optional uint32 event_bonus_item_id = 5;

    pub fn clear_event_bonus_item_id(&mut self) {
        self.event_bonus_item_id = ::std::option::Option::None;
    }

    pub fn has_event_bonus_item_id(&self) -> bool {
        self.event_bonus_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_bonus_item_id(&mut self, v: u32) {
        self.event_bonus_item_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_bonus_item_id(&self) -> u32 {
        self.event_bonus_item_id.unwrap_or(0)
    }

    fn get_event_bonus_item_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_bonus_item_id
    }

    fn mut_event_bonus_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_bonus_item_id
    }
}

impl ::protobuf::Message for CDOTAUserMsg_BoosterStatePlayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.bonus = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.event_bonus = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bonus_item_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_bonus_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bonus {
            my_size += 5;
        }
        if let Some(v) = self.event_bonus {
            my_size += 5;
        }
        if let Some(v) = self.bonus_item_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_bonus_item_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bonus {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.event_bonus {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.bonus_item_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.event_bonus_item_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_BoosterStatePlayer {
    fn new() -> CDOTAUserMsg_BoosterStatePlayer {
        CDOTAUserMsg_BoosterStatePlayer::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_BoosterStatePlayer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_BoosterStatePlayer::get_player_id_for_reflect,
                    CDOTAUserMsg_BoosterStatePlayer::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "bonus",
                    CDOTAUserMsg_BoosterStatePlayer::get_bonus_for_reflect,
                    CDOTAUserMsg_BoosterStatePlayer::mut_bonus_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "event_bonus",
                    CDOTAUserMsg_BoosterStatePlayer::get_event_bonus_for_reflect,
                    CDOTAUserMsg_BoosterStatePlayer::mut_event_bonus_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bonus_item_id",
                    CDOTAUserMsg_BoosterStatePlayer::get_bonus_item_id_for_reflect,
                    CDOTAUserMsg_BoosterStatePlayer::mut_bonus_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_bonus_item_id",
                    CDOTAUserMsg_BoosterStatePlayer::get_event_bonus_item_id_for_reflect,
                    CDOTAUserMsg_BoosterStatePlayer::mut_event_bonus_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_BoosterStatePlayer>(
                    "CDOTAUserMsg_BoosterStatePlayer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_BoosterStatePlayer {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_bonus();
        self.clear_event_bonus();
        self.clear_bonus_item_id();
        self.clear_event_bonus_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_BoosterStatePlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_BoosterStatePlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_BoosterState {
    // message fields
    boosted_players: ::protobuf::RepeatedField<CDOTAUserMsg_BoosterStatePlayer>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_BoosterState {}

impl CDOTAUserMsg_BoosterState {
    pub fn new() -> CDOTAUserMsg_BoosterState {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_BoosterState {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_BoosterState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_BoosterState,
        };
        unsafe {
            instance.get(CDOTAUserMsg_BoosterState::new)
        }
    }

    // repeated .CDOTAUserMsg_BoosterStatePlayer boosted_players = 1;

    pub fn clear_boosted_players(&mut self) {
        self.boosted_players.clear();
    }

    // Param is passed by value, moved
    pub fn set_boosted_players(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_BoosterStatePlayer>) {
        self.boosted_players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_boosted_players(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_BoosterStatePlayer> {
        &mut self.boosted_players
    }

    // Take field
    pub fn take_boosted_players(&mut self) -> ::protobuf::RepeatedField<CDOTAUserMsg_BoosterStatePlayer> {
        ::std::mem::replace(&mut self.boosted_players, ::protobuf::RepeatedField::new())
    }

    pub fn get_boosted_players(&self) -> &[CDOTAUserMsg_BoosterStatePlayer] {
        &self.boosted_players
    }

    fn get_boosted_players_for_reflect(&self) -> &::protobuf::RepeatedField<CDOTAUserMsg_BoosterStatePlayer> {
        &self.boosted_players
    }

    fn mut_boosted_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_BoosterStatePlayer> {
        &mut self.boosted_players
    }
}

impl ::protobuf::Message for CDOTAUserMsg_BoosterState {
    fn is_initialized(&self) -> bool {
        for v in &self.boosted_players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.boosted_players)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.boosted_players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.boosted_players {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_BoosterState {
    fn new() -> CDOTAUserMsg_BoosterState {
        CDOTAUserMsg_BoosterState::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_BoosterState>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_BoosterStatePlayer>>(
                    "boosted_players",
                    CDOTAUserMsg_BoosterState::get_boosted_players_for_reflect,
                    CDOTAUserMsg_BoosterState::mut_boosted_players_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_BoosterState>(
                    "CDOTAUserMsg_BoosterState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_BoosterState {
    fn clear(&mut self) {
        self.clear_boosted_players();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_BoosterState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_BoosterState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_PlayerMMR {
    // message fields
    mmr: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_PlayerMMR {}

impl CDOTAUserMsg_PlayerMMR {
    pub fn new() -> CDOTAUserMsg_PlayerMMR {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_PlayerMMR {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_PlayerMMR> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_PlayerMMR,
        };
        unsafe {
            instance.get(CDOTAUserMsg_PlayerMMR::new)
        }
    }

    // repeated sint32 mmr = 1;

    pub fn clear_mmr(&mut self) {
        self.mmr.clear();
    }

    // Param is passed by value, moved
    pub fn set_mmr(&mut self, v: ::std::vec::Vec<i32>) {
        self.mmr = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mmr(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.mmr
    }

    // Take field
    pub fn take_mmr(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.mmr, ::std::vec::Vec::new())
    }

    pub fn get_mmr(&self) -> &[i32] {
        &self.mmr
    }

    fn get_mmr_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.mmr
    }

    fn mut_mmr_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.mmr
    }
}

impl ::protobuf::Message for CDOTAUserMsg_PlayerMMR {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_sint32_into(wire_type, is, &mut self.mmr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mmr.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(1, &self.mmr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.mmr.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.mmr))?;
            for v in &self.mmr {
                os.write_sint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_PlayerMMR {
    fn new() -> CDOTAUserMsg_PlayerMMR {
        CDOTAUserMsg_PlayerMMR::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_PlayerMMR>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "mmr",
                    CDOTAUserMsg_PlayerMMR::get_mmr_for_reflect,
                    CDOTAUserMsg_PlayerMMR::mut_mmr_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_PlayerMMR>(
                    "CDOTAUserMsg_PlayerMMR",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_PlayerMMR {
    fn clear(&mut self) {
        self.clear_mmr();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_PlayerMMR {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_PlayerMMR {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_AbilitySteal {
    // message fields
    player_id: ::std::option::Option<u32>,
    ability_id: ::std::option::Option<u32>,
    ability_level: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_AbilitySteal {}

impl CDOTAUserMsg_AbilitySteal {
    pub fn new() -> CDOTAUserMsg_AbilitySteal {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_AbilitySteal {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_AbilitySteal> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_AbilitySteal,
        };
        unsafe {
            instance.get(CDOTAUserMsg_AbilitySteal::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional uint32 ability_id = 2;

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: u32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    pub fn get_ability_id(&self) -> u32 {
        self.ability_id.unwrap_or(0)
    }

    fn get_ability_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ability_id
    }

    fn mut_ability_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ability_id
    }

    // optional uint32 ability_level = 3;

    pub fn clear_ability_level(&mut self) {
        self.ability_level = ::std::option::Option::None;
    }

    pub fn has_ability_level(&self) -> bool {
        self.ability_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_level(&mut self, v: u32) {
        self.ability_level = ::std::option::Option::Some(v);
    }

    pub fn get_ability_level(&self) -> u32 {
        self.ability_level.unwrap_or(0)
    }

    fn get_ability_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ability_level
    }

    fn mut_ability_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ability_level
    }
}

impl ::protobuf::Message for CDOTAUserMsg_AbilitySteal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ability_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ability_level = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ability_level {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ability_level {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_AbilitySteal {
    fn new() -> CDOTAUserMsg_AbilitySteal {
        CDOTAUserMsg_AbilitySteal::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_AbilitySteal>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_AbilitySteal::get_player_id_for_reflect,
                    CDOTAUserMsg_AbilitySteal::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ability_id",
                    CDOTAUserMsg_AbilitySteal::get_ability_id_for_reflect,
                    CDOTAUserMsg_AbilitySteal::mut_ability_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ability_level",
                    CDOTAUserMsg_AbilitySteal::get_ability_level_for_reflect,
                    CDOTAUserMsg_AbilitySteal::mut_ability_level_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_AbilitySteal>(
                    "CDOTAUserMsg_AbilitySteal",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_AbilitySteal {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_ability_id();
        self.clear_ability_level();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_AbilitySteal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_AbilitySteal {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_StatsHeroLookup {
    // message fields
    player_id: ::std::option::Option<i32>,
    hero_id: ::std::option::Option<i32>,
    hero_name: ::protobuf::SingularField<::std::string::String>,
    persona: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_StatsHeroLookup {}

impl CDOTAUserMsg_StatsHeroLookup {
    pub fn new() -> CDOTAUserMsg_StatsHeroLookup {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_StatsHeroLookup {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_StatsHeroLookup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_StatsHeroLookup,
        };
        unsafe {
            instance.get(CDOTAUserMsg_StatsHeroLookup::new)
        }
    }

    // optional int32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.player_id
    }

    // optional int32 hero_id = 2;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.hero_id
    }

    // optional string hero_name = 3;

    pub fn clear_hero_name(&mut self) {
        self.hero_name.clear();
    }

    pub fn has_hero_name(&self) -> bool {
        self.hero_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_name(&mut self, v: ::std::string::String) {
        self.hero_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hero_name(&mut self) -> &mut ::std::string::String {
        if self.hero_name.is_none() {
            self.hero_name.set_default();
        }
        self.hero_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_hero_name(&mut self) -> ::std::string::String {
        self.hero_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hero_name(&self) -> &str {
        match self.hero_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_hero_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.hero_name
    }

    fn mut_hero_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.hero_name
    }

    // optional string persona = 4;

    pub fn clear_persona(&mut self) {
        self.persona.clear();
    }

    pub fn has_persona(&self) -> bool {
        self.persona.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona(&mut self, v: ::std::string::String) {
        self.persona = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona(&mut self) -> &mut ::std::string::String {
        if self.persona.is_none() {
            self.persona.set_default();
        }
        self.persona.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona(&mut self) -> ::std::string::String {
        self.persona.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_persona(&self) -> &str {
        match self.persona.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_persona_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.persona
    }

    fn mut_persona_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.persona
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsHeroLookup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hero_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.hero_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.persona.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.hero_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.persona.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_StatsHeroLookup {
    fn new() -> CDOTAUserMsg_StatsHeroLookup {
        CDOTAUserMsg_StatsHeroLookup::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_StatsHeroLookup>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_id",
                    CDOTAUserMsg_StatsHeroLookup::get_player_id_for_reflect,
                    CDOTAUserMsg_StatsHeroLookup::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "hero_id",
                    CDOTAUserMsg_StatsHeroLookup::get_hero_id_for_reflect,
                    CDOTAUserMsg_StatsHeroLookup::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hero_name",
                    CDOTAUserMsg_StatsHeroLookup::get_hero_name_for_reflect,
                    CDOTAUserMsg_StatsHeroLookup::mut_hero_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "persona",
                    CDOTAUserMsg_StatsHeroLookup::get_persona_for_reflect,
                    CDOTAUserMsg_StatsHeroLookup::mut_persona_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_StatsHeroLookup>(
                    "CDOTAUserMsg_StatsHeroLookup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_StatsHeroLookup {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_hero_id();
        self.clear_hero_name();
        self.clear_persona();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_StatsHeroLookup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsHeroLookup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_StatsHeroPositionInfo {
    // message fields
    average_position: ::std::option::Option<f32>,
    position_details: ::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroPositionInfo_PositionPair>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_StatsHeroPositionInfo {}

impl CDOTAUserMsg_StatsHeroPositionInfo {
    pub fn new() -> CDOTAUserMsg_StatsHeroPositionInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_StatsHeroPositionInfo {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_StatsHeroPositionInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_StatsHeroPositionInfo,
        };
        unsafe {
            instance.get(CDOTAUserMsg_StatsHeroPositionInfo::new)
        }
    }

    // optional float average_position = 1;

    pub fn clear_average_position(&mut self) {
        self.average_position = ::std::option::Option::None;
    }

    pub fn has_average_position(&self) -> bool {
        self.average_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_position(&mut self, v: f32) {
        self.average_position = ::std::option::Option::Some(v);
    }

    pub fn get_average_position(&self) -> f32 {
        self.average_position.unwrap_or(0.)
    }

    fn get_average_position_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.average_position
    }

    fn mut_average_position_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.average_position
    }

    // repeated .CDOTAUserMsg_StatsHeroPositionInfo.PositionPair position_details = 2;

    pub fn clear_position_details(&mut self) {
        self.position_details.clear();
    }

    // Param is passed by value, moved
    pub fn set_position_details(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroPositionInfo_PositionPair>) {
        self.position_details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_position_details(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroPositionInfo_PositionPair> {
        &mut self.position_details
    }

    // Take field
    pub fn take_position_details(&mut self) -> ::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroPositionInfo_PositionPair> {
        ::std::mem::replace(&mut self.position_details, ::protobuf::RepeatedField::new())
    }

    pub fn get_position_details(&self) -> &[CDOTAUserMsg_StatsHeroPositionInfo_PositionPair] {
        &self.position_details
    }

    fn get_position_details_for_reflect(&self) -> &::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroPositionInfo_PositionPair> {
        &self.position_details
    }

    fn mut_position_details_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroPositionInfo_PositionPair> {
        &mut self.position_details
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsHeroPositionInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.position_details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.average_position = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.position_details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.average_position {
            my_size += 5;
        }
        for value in &self.position_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.average_position {
            os.write_float(1, v)?;
        }
        for v in &self.position_details {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_StatsHeroPositionInfo {
    fn new() -> CDOTAUserMsg_StatsHeroPositionInfo {
        CDOTAUserMsg_StatsHeroPositionInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_StatsHeroPositionInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "average_position",
                    CDOTAUserMsg_StatsHeroPositionInfo::get_average_position_for_reflect,
                    CDOTAUserMsg_StatsHeroPositionInfo::mut_average_position_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_StatsHeroPositionInfo_PositionPair>>(
                    "position_details",
                    CDOTAUserMsg_StatsHeroPositionInfo::get_position_details_for_reflect,
                    CDOTAUserMsg_StatsHeroPositionInfo::mut_position_details_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_StatsHeroPositionInfo>(
                    "CDOTAUserMsg_StatsHeroPositionInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_StatsHeroPositionInfo {
    fn clear(&mut self) {
        self.clear_average_position();
        self.clear_position_details();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_StatsHeroPositionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsHeroPositionInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_StatsHeroPositionInfo_PositionPair {
    // message fields
    position_category: ::std::option::Option<DOTA_POSITION_CATEGORY>,
    position_count: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_StatsHeroPositionInfo_PositionPair {}

impl CDOTAUserMsg_StatsHeroPositionInfo_PositionPair {
    pub fn new() -> CDOTAUserMsg_StatsHeroPositionInfo_PositionPair {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_StatsHeroPositionInfo_PositionPair {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_StatsHeroPositionInfo_PositionPair> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_StatsHeroPositionInfo_PositionPair,
        };
        unsafe {
            instance.get(CDOTAUserMsg_StatsHeroPositionInfo_PositionPair::new)
        }
    }

    // optional .DOTA_POSITION_CATEGORY position_category = 1;

    pub fn clear_position_category(&mut self) {
        self.position_category = ::std::option::Option::None;
    }

    pub fn has_position_category(&self) -> bool {
        self.position_category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_category(&mut self, v: DOTA_POSITION_CATEGORY) {
        self.position_category = ::std::option::Option::Some(v);
    }

    pub fn get_position_category(&self) -> DOTA_POSITION_CATEGORY {
        self.position_category.unwrap_or(DOTA_POSITION_CATEGORY::DOTA_POSITION_NONE)
    }

    fn get_position_category_for_reflect(&self) -> &::std::option::Option<DOTA_POSITION_CATEGORY> {
        &self.position_category
    }

    fn mut_position_category_for_reflect(&mut self) -> &mut ::std::option::Option<DOTA_POSITION_CATEGORY> {
        &mut self.position_category
    }

    // optional uint32 position_count = 2;

    pub fn clear_position_count(&mut self) {
        self.position_count = ::std::option::Option::None;
    }

    pub fn has_position_count(&self) -> bool {
        self.position_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_count(&mut self, v: u32) {
        self.position_count = ::std::option::Option::Some(v);
    }

    pub fn get_position_count(&self) -> u32 {
        self.position_count.unwrap_or(0)
    }

    fn get_position_count_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.position_count
    }

    fn mut_position_count_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.position_count
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsHeroPositionInfo_PositionPair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.position_category = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.position_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.position_category {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.position_count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.position_category {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.position_count {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_StatsHeroPositionInfo_PositionPair {
    fn new() -> CDOTAUserMsg_StatsHeroPositionInfo_PositionPair {
        CDOTAUserMsg_StatsHeroPositionInfo_PositionPair::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_StatsHeroPositionInfo_PositionPair>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DOTA_POSITION_CATEGORY>>(
                    "position_category",
                    CDOTAUserMsg_StatsHeroPositionInfo_PositionPair::get_position_category_for_reflect,
                    CDOTAUserMsg_StatsHeroPositionInfo_PositionPair::mut_position_category_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "position_count",
                    CDOTAUserMsg_StatsHeroPositionInfo_PositionPair::get_position_count_for_reflect,
                    CDOTAUserMsg_StatsHeroPositionInfo_PositionPair::mut_position_count_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_StatsHeroPositionInfo_PositionPair>(
                    "CDOTAUserMsg_StatsHeroPositionInfo_PositionPair",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_StatsHeroPositionInfo_PositionPair {
    fn clear(&mut self) {
        self.clear_position_category();
        self.clear_position_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_StatsHeroPositionInfo_PositionPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsHeroPositionInfo_PositionPair {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_StatsHeroMinuteDetails {
    // message fields
    last_hits: ::std::option::Option<u32>,
    hero_kills: ::std::option::Option<u32>,
    hero_damage: ::std::option::Option<u32>,
    tower_damage: ::std::option::Option<u32>,
    position_info: ::protobuf::SingularPtrField<CDOTAUserMsg_StatsHeroPositionInfo>,
    total_xp: ::std::option::Option<u32>,
    net_worth: ::std::option::Option<u32>,
    harvested_creep_gold: ::std::option::Option<u32>,
    claimed_farm: ::std::option::Option<u32>,
    wards_placed: ::std::option::Option<u32>,
    runes_collected: ::std::option::Option<u32>,
    tps_used: ::std::option::Option<u32>,
    mana_spent: ::std::vec::Vec<u32>,
    damage_absorbed: ::std::vec::Vec<u32>,
    damage_done: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_StatsHeroMinuteDetails {}

impl CDOTAUserMsg_StatsHeroMinuteDetails {
    pub fn new() -> CDOTAUserMsg_StatsHeroMinuteDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_StatsHeroMinuteDetails {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_StatsHeroMinuteDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_StatsHeroMinuteDetails,
        };
        unsafe {
            instance.get(CDOTAUserMsg_StatsHeroMinuteDetails::new)
        }
    }

    // optional uint32 last_hits = 1;

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: u32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    pub fn get_last_hits(&self) -> u32 {
        self.last_hits.unwrap_or(0)
    }

    fn get_last_hits_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.last_hits
    }

    fn mut_last_hits_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.last_hits
    }

    // optional uint32 hero_kills = 2;

    pub fn clear_hero_kills(&mut self) {
        self.hero_kills = ::std::option::Option::None;
    }

    pub fn has_hero_kills(&self) -> bool {
        self.hero_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_kills(&mut self, v: u32) {
        self.hero_kills = ::std::option::Option::Some(v);
    }

    pub fn get_hero_kills(&self) -> u32 {
        self.hero_kills.unwrap_or(0)
    }

    fn get_hero_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_kills
    }

    fn mut_hero_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_kills
    }

    // optional uint32 hero_damage = 3;

    pub fn clear_hero_damage(&mut self) {
        self.hero_damage = ::std::option::Option::None;
    }

    pub fn has_hero_damage(&self) -> bool {
        self.hero_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_damage(&mut self, v: u32) {
        self.hero_damage = ::std::option::Option::Some(v);
    }

    pub fn get_hero_damage(&self) -> u32 {
        self.hero_damage.unwrap_or(0)
    }

    fn get_hero_damage_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_damage
    }

    fn mut_hero_damage_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_damage
    }

    // optional uint32 tower_damage = 4;

    pub fn clear_tower_damage(&mut self) {
        self.tower_damage = ::std::option::Option::None;
    }

    pub fn has_tower_damage(&self) -> bool {
        self.tower_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_damage(&mut self, v: u32) {
        self.tower_damage = ::std::option::Option::Some(v);
    }

    pub fn get_tower_damage(&self) -> u32 {
        self.tower_damage.unwrap_or(0)
    }

    fn get_tower_damage_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tower_damage
    }

    fn mut_tower_damage_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tower_damage
    }

    // optional .CDOTAUserMsg_StatsHeroPositionInfo position_info = 5;

    pub fn clear_position_info(&mut self) {
        self.position_info.clear();
    }

    pub fn has_position_info(&self) -> bool {
        self.position_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_info(&mut self, v: CDOTAUserMsg_StatsHeroPositionInfo) {
        self.position_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position_info(&mut self) -> &mut CDOTAUserMsg_StatsHeroPositionInfo {
        if self.position_info.is_none() {
            self.position_info.set_default();
        }
        self.position_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_position_info(&mut self) -> CDOTAUserMsg_StatsHeroPositionInfo {
        self.position_info.take().unwrap_or_else(|| CDOTAUserMsg_StatsHeroPositionInfo::new())
    }

    pub fn get_position_info(&self) -> &CDOTAUserMsg_StatsHeroPositionInfo {
        self.position_info.as_ref().unwrap_or_else(|| CDOTAUserMsg_StatsHeroPositionInfo::default_instance())
    }

    fn get_position_info_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_StatsHeroPositionInfo> {
        &self.position_info
    }

    fn mut_position_info_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_StatsHeroPositionInfo> {
        &mut self.position_info
    }

    // optional uint32 total_xp = 6;

    pub fn clear_total_xp(&mut self) {
        self.total_xp = ::std::option::Option::None;
    }

    pub fn has_total_xp(&self) -> bool {
        self.total_xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_xp(&mut self, v: u32) {
        self.total_xp = ::std::option::Option::Some(v);
    }

    pub fn get_total_xp(&self) -> u32 {
        self.total_xp.unwrap_or(0)
    }

    fn get_total_xp_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.total_xp
    }

    fn mut_total_xp_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.total_xp
    }

    // optional uint32 net_worth = 7;

    pub fn clear_net_worth(&mut self) {
        self.net_worth = ::std::option::Option::None;
    }

    pub fn has_net_worth(&self) -> bool {
        self.net_worth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_worth(&mut self, v: u32) {
        self.net_worth = ::std::option::Option::Some(v);
    }

    pub fn get_net_worth(&self) -> u32 {
        self.net_worth.unwrap_or(0)
    }

    fn get_net_worth_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.net_worth
    }

    fn mut_net_worth_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.net_worth
    }

    // optional uint32 harvested_creep_gold = 8;

    pub fn clear_harvested_creep_gold(&mut self) {
        self.harvested_creep_gold = ::std::option::Option::None;
    }

    pub fn has_harvested_creep_gold(&self) -> bool {
        self.harvested_creep_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_harvested_creep_gold(&mut self, v: u32) {
        self.harvested_creep_gold = ::std::option::Option::Some(v);
    }

    pub fn get_harvested_creep_gold(&self) -> u32 {
        self.harvested_creep_gold.unwrap_or(0)
    }

    fn get_harvested_creep_gold_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.harvested_creep_gold
    }

    fn mut_harvested_creep_gold_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.harvested_creep_gold
    }

    // optional uint32 claimed_farm = 9;

    pub fn clear_claimed_farm(&mut self) {
        self.claimed_farm = ::std::option::Option::None;
    }

    pub fn has_claimed_farm(&self) -> bool {
        self.claimed_farm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claimed_farm(&mut self, v: u32) {
        self.claimed_farm = ::std::option::Option::Some(v);
    }

    pub fn get_claimed_farm(&self) -> u32 {
        self.claimed_farm.unwrap_or(0)
    }

    fn get_claimed_farm_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.claimed_farm
    }

    fn mut_claimed_farm_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.claimed_farm
    }

    // optional uint32 wards_placed = 10;

    pub fn clear_wards_placed(&mut self) {
        self.wards_placed = ::std::option::Option::None;
    }

    pub fn has_wards_placed(&self) -> bool {
        self.wards_placed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wards_placed(&mut self, v: u32) {
        self.wards_placed = ::std::option::Option::Some(v);
    }

    pub fn get_wards_placed(&self) -> u32 {
        self.wards_placed.unwrap_or(0)
    }

    fn get_wards_placed_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.wards_placed
    }

    fn mut_wards_placed_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.wards_placed
    }

    // optional uint32 runes_collected = 11;

    pub fn clear_runes_collected(&mut self) {
        self.runes_collected = ::std::option::Option::None;
    }

    pub fn has_runes_collected(&self) -> bool {
        self.runes_collected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runes_collected(&mut self, v: u32) {
        self.runes_collected = ::std::option::Option::Some(v);
    }

    pub fn get_runes_collected(&self) -> u32 {
        self.runes_collected.unwrap_or(0)
    }

    fn get_runes_collected_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.runes_collected
    }

    fn mut_runes_collected_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.runes_collected
    }

    // optional uint32 tps_used = 12;

    pub fn clear_tps_used(&mut self) {
        self.tps_used = ::std::option::Option::None;
    }

    pub fn has_tps_used(&self) -> bool {
        self.tps_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tps_used(&mut self, v: u32) {
        self.tps_used = ::std::option::Option::Some(v);
    }

    pub fn get_tps_used(&self) -> u32 {
        self.tps_used.unwrap_or(0)
    }

    fn get_tps_used_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tps_used
    }

    fn mut_tps_used_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tps_used
    }

    // repeated uint32 mana_spent = 13;

    pub fn clear_mana_spent(&mut self) {
        self.mana_spent.clear();
    }

    // Param is passed by value, moved
    pub fn set_mana_spent(&mut self, v: ::std::vec::Vec<u32>) {
        self.mana_spent = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mana_spent(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.mana_spent
    }

    // Take field
    pub fn take_mana_spent(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.mana_spent, ::std::vec::Vec::new())
    }

    pub fn get_mana_spent(&self) -> &[u32] {
        &self.mana_spent
    }

    fn get_mana_spent_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.mana_spent
    }

    fn mut_mana_spent_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.mana_spent
    }

    // repeated uint32 damage_absorbed = 14;

    pub fn clear_damage_absorbed(&mut self) {
        self.damage_absorbed.clear();
    }

    // Param is passed by value, moved
    pub fn set_damage_absorbed(&mut self, v: ::std::vec::Vec<u32>) {
        self.damage_absorbed = v;
    }

    // Mutable pointer to the field.
    pub fn mut_damage_absorbed(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.damage_absorbed
    }

    // Take field
    pub fn take_damage_absorbed(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.damage_absorbed, ::std::vec::Vec::new())
    }

    pub fn get_damage_absorbed(&self) -> &[u32] {
        &self.damage_absorbed
    }

    fn get_damage_absorbed_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.damage_absorbed
    }

    fn mut_damage_absorbed_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.damage_absorbed
    }

    // repeated uint32 damage_done = 15;

    pub fn clear_damage_done(&mut self) {
        self.damage_done.clear();
    }

    // Param is passed by value, moved
    pub fn set_damage_done(&mut self, v: ::std::vec::Vec<u32>) {
        self.damage_done = v;
    }

    // Mutable pointer to the field.
    pub fn mut_damage_done(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.damage_done
    }

    // Take field
    pub fn take_damage_done(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.damage_done, ::std::vec::Vec::new())
    }

    pub fn get_damage_done(&self) -> &[u32] {
        &self.damage_done
    }

    fn get_damage_done_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.damage_done
    }

    fn mut_damage_done_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.damage_done
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsHeroMinuteDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.position_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_hits = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_kills = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_damage = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tower_damage = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position_info)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_xp = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.net_worth = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.harvested_creep_gold = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.claimed_farm = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wards_placed = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.runes_collected = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tps_used = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.mana_spent)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.damage_absorbed)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.damage_done)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.last_hits {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_kills {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_damage {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tower_damage {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.position_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.total_xp {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.net_worth {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.harvested_creep_gold {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.claimed_farm {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wards_placed {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.runes_collected {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tps_used {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.mana_spent {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.damage_absorbed {
            my_size += ::protobuf::rt::value_size(14, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.damage_done {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.last_hits {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_kills {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_damage {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tower_damage {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.position_info.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.total_xp {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.net_worth {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.harvested_creep_gold {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.claimed_farm {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.wards_placed {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.runes_collected {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.tps_used {
            os.write_uint32(12, v)?;
        }
        for v in &self.mana_spent {
            os.write_uint32(13, *v)?;
        };
        for v in &self.damage_absorbed {
            os.write_uint32(14, *v)?;
        };
        for v in &self.damage_done {
            os.write_uint32(15, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_StatsHeroMinuteDetails {
    fn new() -> CDOTAUserMsg_StatsHeroMinuteDetails {
        CDOTAUserMsg_StatsHeroMinuteDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_StatsHeroMinuteDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_hits",
                    CDOTAUserMsg_StatsHeroMinuteDetails::get_last_hits_for_reflect,
                    CDOTAUserMsg_StatsHeroMinuteDetails::mut_last_hits_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_kills",
                    CDOTAUserMsg_StatsHeroMinuteDetails::get_hero_kills_for_reflect,
                    CDOTAUserMsg_StatsHeroMinuteDetails::mut_hero_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_damage",
                    CDOTAUserMsg_StatsHeroMinuteDetails::get_hero_damage_for_reflect,
                    CDOTAUserMsg_StatsHeroMinuteDetails::mut_hero_damage_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tower_damage",
                    CDOTAUserMsg_StatsHeroMinuteDetails::get_tower_damage_for_reflect,
                    CDOTAUserMsg_StatsHeroMinuteDetails::mut_tower_damage_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_StatsHeroPositionInfo>>(
                    "position_info",
                    CDOTAUserMsg_StatsHeroMinuteDetails::get_position_info_for_reflect,
                    CDOTAUserMsg_StatsHeroMinuteDetails::mut_position_info_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_xp",
                    CDOTAUserMsg_StatsHeroMinuteDetails::get_total_xp_for_reflect,
                    CDOTAUserMsg_StatsHeroMinuteDetails::mut_total_xp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "net_worth",
                    CDOTAUserMsg_StatsHeroMinuteDetails::get_net_worth_for_reflect,
                    CDOTAUserMsg_StatsHeroMinuteDetails::mut_net_worth_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "harvested_creep_gold",
                    CDOTAUserMsg_StatsHeroMinuteDetails::get_harvested_creep_gold_for_reflect,
                    CDOTAUserMsg_StatsHeroMinuteDetails::mut_harvested_creep_gold_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "claimed_farm",
                    CDOTAUserMsg_StatsHeroMinuteDetails::get_claimed_farm_for_reflect,
                    CDOTAUserMsg_StatsHeroMinuteDetails::mut_claimed_farm_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "wards_placed",
                    CDOTAUserMsg_StatsHeroMinuteDetails::get_wards_placed_for_reflect,
                    CDOTAUserMsg_StatsHeroMinuteDetails::mut_wards_placed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "runes_collected",
                    CDOTAUserMsg_StatsHeroMinuteDetails::get_runes_collected_for_reflect,
                    CDOTAUserMsg_StatsHeroMinuteDetails::mut_runes_collected_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tps_used",
                    CDOTAUserMsg_StatsHeroMinuteDetails::get_tps_used_for_reflect,
                    CDOTAUserMsg_StatsHeroMinuteDetails::mut_tps_used_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mana_spent",
                    CDOTAUserMsg_StatsHeroMinuteDetails::get_mana_spent_for_reflect,
                    CDOTAUserMsg_StatsHeroMinuteDetails::mut_mana_spent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "damage_absorbed",
                    CDOTAUserMsg_StatsHeroMinuteDetails::get_damage_absorbed_for_reflect,
                    CDOTAUserMsg_StatsHeroMinuteDetails::mut_damage_absorbed_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "damage_done",
                    CDOTAUserMsg_StatsHeroMinuteDetails::get_damage_done_for_reflect,
                    CDOTAUserMsg_StatsHeroMinuteDetails::mut_damage_done_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_StatsHeroMinuteDetails>(
                    "CDOTAUserMsg_StatsHeroMinuteDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_StatsHeroMinuteDetails {
    fn clear(&mut self) {
        self.clear_last_hits();
        self.clear_hero_kills();
        self.clear_hero_damage();
        self.clear_tower_damage();
        self.clear_position_info();
        self.clear_total_xp();
        self.clear_net_worth();
        self.clear_harvested_creep_gold();
        self.clear_claimed_farm();
        self.clear_wards_placed();
        self.clear_runes_collected();
        self.clear_tps_used();
        self.clear_mana_spent();
        self.clear_damage_absorbed();
        self.clear_damage_done();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_StatsHeroMinuteDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsHeroMinuteDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_StatsTeamMinuteDetails {
    // message fields
    player_stats: ::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroMinuteDetails>,
    tower_kills: ::std::option::Option<u32>,
    barrack_kills: ::std::option::Option<u32>,
    available_lane_creep_gold: ::std::option::Option<u32>,
    balance_kill_value: ::std::option::Option<u32>,
    balance_tower_value: ::std::option::Option<u32>,
    balance_barracks_value: ::std::option::Option<u32>,
    balance_gold_value: ::std::option::Option<u32>,
    balance_xp_value: ::std::option::Option<u32>,
    lane_performance: ::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_StatsTeamMinuteDetails {}

impl CDOTAUserMsg_StatsTeamMinuteDetails {
    pub fn new() -> CDOTAUserMsg_StatsTeamMinuteDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_StatsTeamMinuteDetails {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_StatsTeamMinuteDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_StatsTeamMinuteDetails,
        };
        unsafe {
            instance.get(CDOTAUserMsg_StatsTeamMinuteDetails::new)
        }
    }

    // repeated .CDOTAUserMsg_StatsHeroMinuteDetails player_stats = 1;

    pub fn clear_player_stats(&mut self) {
        self.player_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_stats(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroMinuteDetails>) {
        self.player_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_stats(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroMinuteDetails> {
        &mut self.player_stats
    }

    // Take field
    pub fn take_player_stats(&mut self) -> ::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroMinuteDetails> {
        ::std::mem::replace(&mut self.player_stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_player_stats(&self) -> &[CDOTAUserMsg_StatsHeroMinuteDetails] {
        &self.player_stats
    }

    fn get_player_stats_for_reflect(&self) -> &::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroMinuteDetails> {
        &self.player_stats
    }

    fn mut_player_stats_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroMinuteDetails> {
        &mut self.player_stats
    }

    // optional uint32 tower_kills = 2;

    pub fn clear_tower_kills(&mut self) {
        self.tower_kills = ::std::option::Option::None;
    }

    pub fn has_tower_kills(&self) -> bool {
        self.tower_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tower_kills(&mut self, v: u32) {
        self.tower_kills = ::std::option::Option::Some(v);
    }

    pub fn get_tower_kills(&self) -> u32 {
        self.tower_kills.unwrap_or(0)
    }

    fn get_tower_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.tower_kills
    }

    fn mut_tower_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.tower_kills
    }

    // optional uint32 barrack_kills = 3;

    pub fn clear_barrack_kills(&mut self) {
        self.barrack_kills = ::std::option::Option::None;
    }

    pub fn has_barrack_kills(&self) -> bool {
        self.barrack_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_barrack_kills(&mut self, v: u32) {
        self.barrack_kills = ::std::option::Option::Some(v);
    }

    pub fn get_barrack_kills(&self) -> u32 {
        self.barrack_kills.unwrap_or(0)
    }

    fn get_barrack_kills_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.barrack_kills
    }

    fn mut_barrack_kills_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.barrack_kills
    }

    // optional uint32 available_lane_creep_gold = 4;

    pub fn clear_available_lane_creep_gold(&mut self) {
        self.available_lane_creep_gold = ::std::option::Option::None;
    }

    pub fn has_available_lane_creep_gold(&self) -> bool {
        self.available_lane_creep_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_available_lane_creep_gold(&mut self, v: u32) {
        self.available_lane_creep_gold = ::std::option::Option::Some(v);
    }

    pub fn get_available_lane_creep_gold(&self) -> u32 {
        self.available_lane_creep_gold.unwrap_or(0)
    }

    fn get_available_lane_creep_gold_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.available_lane_creep_gold
    }

    fn mut_available_lane_creep_gold_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.available_lane_creep_gold
    }

    // optional uint32 balance_kill_value = 5;

    pub fn clear_balance_kill_value(&mut self) {
        self.balance_kill_value = ::std::option::Option::None;
    }

    pub fn has_balance_kill_value(&self) -> bool {
        self.balance_kill_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_kill_value(&mut self, v: u32) {
        self.balance_kill_value = ::std::option::Option::Some(v);
    }

    pub fn get_balance_kill_value(&self) -> u32 {
        self.balance_kill_value.unwrap_or(0)
    }

    fn get_balance_kill_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.balance_kill_value
    }

    fn mut_balance_kill_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.balance_kill_value
    }

    // optional uint32 balance_tower_value = 6;

    pub fn clear_balance_tower_value(&mut self) {
        self.balance_tower_value = ::std::option::Option::None;
    }

    pub fn has_balance_tower_value(&self) -> bool {
        self.balance_tower_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_tower_value(&mut self, v: u32) {
        self.balance_tower_value = ::std::option::Option::Some(v);
    }

    pub fn get_balance_tower_value(&self) -> u32 {
        self.balance_tower_value.unwrap_or(0)
    }

    fn get_balance_tower_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.balance_tower_value
    }

    fn mut_balance_tower_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.balance_tower_value
    }

    // optional uint32 balance_barracks_value = 7;

    pub fn clear_balance_barracks_value(&mut self) {
        self.balance_barracks_value = ::std::option::Option::None;
    }

    pub fn has_balance_barracks_value(&self) -> bool {
        self.balance_barracks_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_barracks_value(&mut self, v: u32) {
        self.balance_barracks_value = ::std::option::Option::Some(v);
    }

    pub fn get_balance_barracks_value(&self) -> u32 {
        self.balance_barracks_value.unwrap_or(0)
    }

    fn get_balance_barracks_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.balance_barracks_value
    }

    fn mut_balance_barracks_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.balance_barracks_value
    }

    // optional uint32 balance_gold_value = 8;

    pub fn clear_balance_gold_value(&mut self) {
        self.balance_gold_value = ::std::option::Option::None;
    }

    pub fn has_balance_gold_value(&self) -> bool {
        self.balance_gold_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_gold_value(&mut self, v: u32) {
        self.balance_gold_value = ::std::option::Option::Some(v);
    }

    pub fn get_balance_gold_value(&self) -> u32 {
        self.balance_gold_value.unwrap_or(0)
    }

    fn get_balance_gold_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.balance_gold_value
    }

    fn mut_balance_gold_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.balance_gold_value
    }

    // optional uint32 balance_xp_value = 9;

    pub fn clear_balance_xp_value(&mut self) {
        self.balance_xp_value = ::std::option::Option::None;
    }

    pub fn has_balance_xp_value(&self) -> bool {
        self.balance_xp_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_xp_value(&mut self, v: u32) {
        self.balance_xp_value = ::std::option::Option::Some(v);
    }

    pub fn get_balance_xp_value(&self) -> u32 {
        self.balance_xp_value.unwrap_or(0)
    }

    fn get_balance_xp_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.balance_xp_value
    }

    fn mut_balance_xp_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.balance_xp_value
    }

    // repeated .CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformance lane_performance = 10;

    pub fn clear_lane_performance(&mut self) {
        self.lane_performance.clear();
    }

    // Param is passed by value, moved
    pub fn set_lane_performance(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance>) {
        self.lane_performance = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lane_performance(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance> {
        &mut self.lane_performance
    }

    // Take field
    pub fn take_lane_performance(&mut self) -> ::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance> {
        ::std::mem::replace(&mut self.lane_performance, ::protobuf::RepeatedField::new())
    }

    pub fn get_lane_performance(&self) -> &[CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance] {
        &self.lane_performance
    }

    fn get_lane_performance_for_reflect(&self) -> &::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance> {
        &self.lane_performance
    }

    fn mut_lane_performance_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance> {
        &mut self.lane_performance
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsTeamMinuteDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.player_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lane_performance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_stats)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tower_kills = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.barrack_kills = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.available_lane_creep_gold = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.balance_kill_value = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.balance_tower_value = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.balance_barracks_value = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.balance_gold_value = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.balance_xp_value = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.lane_performance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.player_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.tower_kills {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.barrack_kills {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.available_lane_creep_gold {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.balance_kill_value {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.balance_tower_value {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.balance_barracks_value {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.balance_gold_value {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.balance_xp_value {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.lane_performance {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.player_stats {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.tower_kills {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.barrack_kills {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.available_lane_creep_gold {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.balance_kill_value {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.balance_tower_value {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.balance_barracks_value {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.balance_gold_value {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.balance_xp_value {
            os.write_uint32(9, v)?;
        }
        for v in &self.lane_performance {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_StatsTeamMinuteDetails {
    fn new() -> CDOTAUserMsg_StatsTeamMinuteDetails {
        CDOTAUserMsg_StatsTeamMinuteDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_StatsTeamMinuteDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_StatsHeroMinuteDetails>>(
                    "player_stats",
                    CDOTAUserMsg_StatsTeamMinuteDetails::get_player_stats_for_reflect,
                    CDOTAUserMsg_StatsTeamMinuteDetails::mut_player_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tower_kills",
                    CDOTAUserMsg_StatsTeamMinuteDetails::get_tower_kills_for_reflect,
                    CDOTAUserMsg_StatsTeamMinuteDetails::mut_tower_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "barrack_kills",
                    CDOTAUserMsg_StatsTeamMinuteDetails::get_barrack_kills_for_reflect,
                    CDOTAUserMsg_StatsTeamMinuteDetails::mut_barrack_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "available_lane_creep_gold",
                    CDOTAUserMsg_StatsTeamMinuteDetails::get_available_lane_creep_gold_for_reflect,
                    CDOTAUserMsg_StatsTeamMinuteDetails::mut_available_lane_creep_gold_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "balance_kill_value",
                    CDOTAUserMsg_StatsTeamMinuteDetails::get_balance_kill_value_for_reflect,
                    CDOTAUserMsg_StatsTeamMinuteDetails::mut_balance_kill_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "balance_tower_value",
                    CDOTAUserMsg_StatsTeamMinuteDetails::get_balance_tower_value_for_reflect,
                    CDOTAUserMsg_StatsTeamMinuteDetails::mut_balance_tower_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "balance_barracks_value",
                    CDOTAUserMsg_StatsTeamMinuteDetails::get_balance_barracks_value_for_reflect,
                    CDOTAUserMsg_StatsTeamMinuteDetails::mut_balance_barracks_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "balance_gold_value",
                    CDOTAUserMsg_StatsTeamMinuteDetails::get_balance_gold_value_for_reflect,
                    CDOTAUserMsg_StatsTeamMinuteDetails::mut_balance_gold_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "balance_xp_value",
                    CDOTAUserMsg_StatsTeamMinuteDetails::get_balance_xp_value_for_reflect,
                    CDOTAUserMsg_StatsTeamMinuteDetails::mut_balance_xp_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance>>(
                    "lane_performance",
                    CDOTAUserMsg_StatsTeamMinuteDetails::get_lane_performance_for_reflect,
                    CDOTAUserMsg_StatsTeamMinuteDetails::mut_lane_performance_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_StatsTeamMinuteDetails>(
                    "CDOTAUserMsg_StatsTeamMinuteDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_StatsTeamMinuteDetails {
    fn clear(&mut self) {
        self.clear_player_stats();
        self.clear_tower_kills();
        self.clear_barrack_kills();
        self.clear_available_lane_creep_gold();
        self.clear_balance_kill_value();
        self.clear_balance_tower_value();
        self.clear_balance_barracks_value();
        self.clear_balance_gold_value();
        self.clear_balance_xp_value();
        self.clear_lane_performance();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_StatsTeamMinuteDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsTeamMinuteDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance {
    // message fields
    location_category: ::std::option::Option<u32>,
    stat_type: ::std::option::Option<u32>,
    value: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance {}

impl CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance {
    pub fn new() -> CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance,
        };
        unsafe {
            instance.get(CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance::new)
        }
    }

    // optional uint32 location_category = 1;

    pub fn clear_location_category(&mut self) {
        self.location_category = ::std::option::Option::None;
    }

    pub fn has_location_category(&self) -> bool {
        self.location_category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location_category(&mut self, v: u32) {
        self.location_category = ::std::option::Option::Some(v);
    }

    pub fn get_location_category(&self) -> u32 {
        self.location_category.unwrap_or(0)
    }

    fn get_location_category_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.location_category
    }

    fn mut_location_category_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.location_category
    }

    // optional uint32 stat_type = 2;

    pub fn clear_stat_type(&mut self) {
        self.stat_type = ::std::option::Option::None;
    }

    pub fn has_stat_type(&self) -> bool {
        self.stat_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_type(&mut self, v: u32) {
        self.stat_type = ::std::option::Option::Some(v);
    }

    pub fn get_stat_type(&self) -> u32 {
        self.stat_type.unwrap_or(0)
    }

    fn get_stat_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.stat_type
    }

    fn mut_stat_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.stat_type
    }

    // optional uint32 value = 3;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.value
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.location_category = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stat_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.location_category {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stat_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.location_category {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stat_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance {
    fn new() -> CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance {
        CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "location_category",
                    CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance::get_location_category_for_reflect,
                    CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance::mut_location_category_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stat_type",
                    CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance::get_stat_type_for_reflect,
                    CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance::mut_stat_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "value",
                    CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance::get_value_for_reflect,
                    CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance>(
                    "CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance {
    fn clear(&mut self) {
        self.clear_location_category();
        self.clear_stat_type();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsTeamMinuteDetails_LocationPerformance {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_StatsPlayerKillShare {
    // message fields
    player_id: ::std::option::Option<i32>,
    kill_share_percent: ::std::option::Option<f32>,
    player_loc_x: ::std::option::Option<f32>,
    player_loc_y: ::std::option::Option<f32>,
    health_percent: ::std::option::Option<f32>,
    mana_percent: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_StatsPlayerKillShare {}

impl CDOTAUserMsg_StatsPlayerKillShare {
    pub fn new() -> CDOTAUserMsg_StatsPlayerKillShare {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_StatsPlayerKillShare {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_StatsPlayerKillShare> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_StatsPlayerKillShare,
        };
        unsafe {
            instance.get(CDOTAUserMsg_StatsPlayerKillShare::new)
        }
    }

    // optional int32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: i32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> i32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.player_id
    }

    // optional float kill_share_percent = 2;

    pub fn clear_kill_share_percent(&mut self) {
        self.kill_share_percent = ::std::option::Option::None;
    }

    pub fn has_kill_share_percent(&self) -> bool {
        self.kill_share_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kill_share_percent(&mut self, v: f32) {
        self.kill_share_percent = ::std::option::Option::Some(v);
    }

    pub fn get_kill_share_percent(&self) -> f32 {
        self.kill_share_percent.unwrap_or(0.)
    }

    fn get_kill_share_percent_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.kill_share_percent
    }

    fn mut_kill_share_percent_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.kill_share_percent
    }

    // optional float player_loc_x = 3;

    pub fn clear_player_loc_x(&mut self) {
        self.player_loc_x = ::std::option::Option::None;
    }

    pub fn has_player_loc_x(&self) -> bool {
        self.player_loc_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_loc_x(&mut self, v: f32) {
        self.player_loc_x = ::std::option::Option::Some(v);
    }

    pub fn get_player_loc_x(&self) -> f32 {
        self.player_loc_x.unwrap_or(0.)
    }

    fn get_player_loc_x_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.player_loc_x
    }

    fn mut_player_loc_x_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.player_loc_x
    }

    // optional float player_loc_y = 4;

    pub fn clear_player_loc_y(&mut self) {
        self.player_loc_y = ::std::option::Option::None;
    }

    pub fn has_player_loc_y(&self) -> bool {
        self.player_loc_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_loc_y(&mut self, v: f32) {
        self.player_loc_y = ::std::option::Option::Some(v);
    }

    pub fn get_player_loc_y(&self) -> f32 {
        self.player_loc_y.unwrap_or(0.)
    }

    fn get_player_loc_y_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.player_loc_y
    }

    fn mut_player_loc_y_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.player_loc_y
    }

    // optional float health_percent = 5;

    pub fn clear_health_percent(&mut self) {
        self.health_percent = ::std::option::Option::None;
    }

    pub fn has_health_percent(&self) -> bool {
        self.health_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_percent(&mut self, v: f32) {
        self.health_percent = ::std::option::Option::Some(v);
    }

    pub fn get_health_percent(&self) -> f32 {
        self.health_percent.unwrap_or(0.)
    }

    fn get_health_percent_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.health_percent
    }

    fn mut_health_percent_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.health_percent
    }

    // optional float mana_percent = 6;

    pub fn clear_mana_percent(&mut self) {
        self.mana_percent = ::std::option::Option::None;
    }

    pub fn has_mana_percent(&self) -> bool {
        self.mana_percent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mana_percent(&mut self, v: f32) {
        self.mana_percent = ::std::option::Option::Some(v);
    }

    pub fn get_mana_percent(&self) -> f32 {
        self.mana_percent.unwrap_or(0.)
    }

    fn get_mana_percent_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.mana_percent
    }

    fn mut_mana_percent_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.mana_percent
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsPlayerKillShare {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.kill_share_percent = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.player_loc_x = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.player_loc_y = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.health_percent = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.mana_percent = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kill_share_percent {
            my_size += 5;
        }
        if let Some(v) = self.player_loc_x {
            my_size += 5;
        }
        if let Some(v) = self.player_loc_y {
            my_size += 5;
        }
        if let Some(v) = self.health_percent {
            my_size += 5;
        }
        if let Some(v) = self.mana_percent {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.kill_share_percent {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.player_loc_x {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.player_loc_y {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.health_percent {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.mana_percent {
            os.write_float(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_StatsPlayerKillShare {
    fn new() -> CDOTAUserMsg_StatsPlayerKillShare {
        CDOTAUserMsg_StatsPlayerKillShare::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_StatsPlayerKillShare>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "player_id",
                    CDOTAUserMsg_StatsPlayerKillShare::get_player_id_for_reflect,
                    CDOTAUserMsg_StatsPlayerKillShare::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "kill_share_percent",
                    CDOTAUserMsg_StatsPlayerKillShare::get_kill_share_percent_for_reflect,
                    CDOTAUserMsg_StatsPlayerKillShare::mut_kill_share_percent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "player_loc_x",
                    CDOTAUserMsg_StatsPlayerKillShare::get_player_loc_x_for_reflect,
                    CDOTAUserMsg_StatsPlayerKillShare::mut_player_loc_x_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "player_loc_y",
                    CDOTAUserMsg_StatsPlayerKillShare::get_player_loc_y_for_reflect,
                    CDOTAUserMsg_StatsPlayerKillShare::mut_player_loc_y_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "health_percent",
                    CDOTAUserMsg_StatsPlayerKillShare::get_health_percent_for_reflect,
                    CDOTAUserMsg_StatsPlayerKillShare::mut_health_percent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "mana_percent",
                    CDOTAUserMsg_StatsPlayerKillShare::get_mana_percent_for_reflect,
                    CDOTAUserMsg_StatsPlayerKillShare::mut_mana_percent_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_StatsPlayerKillShare>(
                    "CDOTAUserMsg_StatsPlayerKillShare",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_StatsPlayerKillShare {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_kill_share_percent();
        self.clear_player_loc_x();
        self.clear_player_loc_y();
        self.clear_health_percent();
        self.clear_mana_percent();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_StatsPlayerKillShare {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsPlayerKillShare {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_StatsKillDetails {
    // message fields
    victim_id: ::std::option::Option<u32>,
    kill_shares: ::protobuf::RepeatedField<CDOTAUserMsg_StatsPlayerKillShare>,
    damage_to_kill: ::std::option::Option<u32>,
    effective_health: ::std::option::Option<u32>,
    death_time: ::std::option::Option<f32>,
    killer_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_StatsKillDetails {}

impl CDOTAUserMsg_StatsKillDetails {
    pub fn new() -> CDOTAUserMsg_StatsKillDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_StatsKillDetails {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_StatsKillDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_StatsKillDetails,
        };
        unsafe {
            instance.get(CDOTAUserMsg_StatsKillDetails::new)
        }
    }

    // optional uint32 victim_id = 1;

    pub fn clear_victim_id(&mut self) {
        self.victim_id = ::std::option::Option::None;
    }

    pub fn has_victim_id(&self) -> bool {
        self.victim_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_id(&mut self, v: u32) {
        self.victim_id = ::std::option::Option::Some(v);
    }

    pub fn get_victim_id(&self) -> u32 {
        self.victim_id.unwrap_or(0)
    }

    fn get_victim_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.victim_id
    }

    fn mut_victim_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.victim_id
    }

    // repeated .CDOTAUserMsg_StatsPlayerKillShare kill_shares = 2;

    pub fn clear_kill_shares(&mut self) {
        self.kill_shares.clear();
    }

    // Param is passed by value, moved
    pub fn set_kill_shares(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_StatsPlayerKillShare>) {
        self.kill_shares = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kill_shares(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsPlayerKillShare> {
        &mut self.kill_shares
    }

    // Take field
    pub fn take_kill_shares(&mut self) -> ::protobuf::RepeatedField<CDOTAUserMsg_StatsPlayerKillShare> {
        ::std::mem::replace(&mut self.kill_shares, ::protobuf::RepeatedField::new())
    }

    pub fn get_kill_shares(&self) -> &[CDOTAUserMsg_StatsPlayerKillShare] {
        &self.kill_shares
    }

    fn get_kill_shares_for_reflect(&self) -> &::protobuf::RepeatedField<CDOTAUserMsg_StatsPlayerKillShare> {
        &self.kill_shares
    }

    fn mut_kill_shares_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsPlayerKillShare> {
        &mut self.kill_shares
    }

    // optional uint32 damage_to_kill = 3;

    pub fn clear_damage_to_kill(&mut self) {
        self.damage_to_kill = ::std::option::Option::None;
    }

    pub fn has_damage_to_kill(&self) -> bool {
        self.damage_to_kill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_to_kill(&mut self, v: u32) {
        self.damage_to_kill = ::std::option::Option::Some(v);
    }

    pub fn get_damage_to_kill(&self) -> u32 {
        self.damage_to_kill.unwrap_or(0)
    }

    fn get_damage_to_kill_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.damage_to_kill
    }

    fn mut_damage_to_kill_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.damage_to_kill
    }

    // optional uint32 effective_health = 4;

    pub fn clear_effective_health(&mut self) {
        self.effective_health = ::std::option::Option::None;
    }

    pub fn has_effective_health(&self) -> bool {
        self.effective_health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effective_health(&mut self, v: u32) {
        self.effective_health = ::std::option::Option::Some(v);
    }

    pub fn get_effective_health(&self) -> u32 {
        self.effective_health.unwrap_or(0)
    }

    fn get_effective_health_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.effective_health
    }

    fn mut_effective_health_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.effective_health
    }

    // optional float death_time = 5;

    pub fn clear_death_time(&mut self) {
        self.death_time = ::std::option::Option::None;
    }

    pub fn has_death_time(&self) -> bool {
        self.death_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_death_time(&mut self, v: f32) {
        self.death_time = ::std::option::Option::Some(v);
    }

    pub fn get_death_time(&self) -> f32 {
        self.death_time.unwrap_or(0.)
    }

    fn get_death_time_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.death_time
    }

    fn mut_death_time_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.death_time
    }

    // optional uint32 killer_id = 6;

    pub fn clear_killer_id(&mut self) {
        self.killer_id = ::std::option::Option::None;
    }

    pub fn has_killer_id(&self) -> bool {
        self.killer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_id(&mut self, v: u32) {
        self.killer_id = ::std::option::Option::Some(v);
    }

    pub fn get_killer_id(&self) -> u32 {
        self.killer_id.unwrap_or(0)
    }

    fn get_killer_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.killer_id
    }

    fn mut_killer_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.killer_id
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsKillDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.kill_shares {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.victim_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.kill_shares)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.damage_to_kill = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.effective_health = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.death_time = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.killer_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.victim_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.kill_shares {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.damage_to_kill {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.effective_health {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.death_time {
            my_size += 5;
        }
        if let Some(v) = self.killer_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.victim_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.kill_shares {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.damage_to_kill {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.effective_health {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.death_time {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.killer_id {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_StatsKillDetails {
    fn new() -> CDOTAUserMsg_StatsKillDetails {
        CDOTAUserMsg_StatsKillDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_StatsKillDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "victim_id",
                    CDOTAUserMsg_StatsKillDetails::get_victim_id_for_reflect,
                    CDOTAUserMsg_StatsKillDetails::mut_victim_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_StatsPlayerKillShare>>(
                    "kill_shares",
                    CDOTAUserMsg_StatsKillDetails::get_kill_shares_for_reflect,
                    CDOTAUserMsg_StatsKillDetails::mut_kill_shares_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "damage_to_kill",
                    CDOTAUserMsg_StatsKillDetails::get_damage_to_kill_for_reflect,
                    CDOTAUserMsg_StatsKillDetails::mut_damage_to_kill_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "effective_health",
                    CDOTAUserMsg_StatsKillDetails::get_effective_health_for_reflect,
                    CDOTAUserMsg_StatsKillDetails::mut_effective_health_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "death_time",
                    CDOTAUserMsg_StatsKillDetails::get_death_time_for_reflect,
                    CDOTAUserMsg_StatsKillDetails::mut_death_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "killer_id",
                    CDOTAUserMsg_StatsKillDetails::get_killer_id_for_reflect,
                    CDOTAUserMsg_StatsKillDetails::mut_killer_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_StatsKillDetails>(
                    "CDOTAUserMsg_StatsKillDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_StatsKillDetails {
    fn clear(&mut self) {
        self.clear_victim_id();
        self.clear_kill_shares();
        self.clear_damage_to_kill();
        self.clear_effective_health();
        self.clear_death_time();
        self.clear_killer_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_StatsKillDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsKillDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_StatsMatchDetails {
    // message fields
    hero_lookup: ::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroLookup>,
    radiant_stats: ::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails>,
    dire_stats: ::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails>,
    radiant_kills: ::protobuf::RepeatedField<CDOTAUserMsg_StatsKillDetails>,
    dire_kills: ::protobuf::RepeatedField<CDOTAUserMsg_StatsKillDetails>,
    fight_details: ::protobuf::RepeatedField<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_StatsMatchDetails {}

impl CDOTAUserMsg_StatsMatchDetails {
    pub fn new() -> CDOTAUserMsg_StatsMatchDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_StatsMatchDetails {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_StatsMatchDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_StatsMatchDetails,
        };
        unsafe {
            instance.get(CDOTAUserMsg_StatsMatchDetails::new)
        }
    }

    // repeated .CDOTAUserMsg_StatsHeroLookup hero_lookup = 1;

    pub fn clear_hero_lookup(&mut self) {
        self.hero_lookup.clear();
    }

    // Param is passed by value, moved
    pub fn set_hero_lookup(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroLookup>) {
        self.hero_lookup = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hero_lookup(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroLookup> {
        &mut self.hero_lookup
    }

    // Take field
    pub fn take_hero_lookup(&mut self) -> ::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroLookup> {
        ::std::mem::replace(&mut self.hero_lookup, ::protobuf::RepeatedField::new())
    }

    pub fn get_hero_lookup(&self) -> &[CDOTAUserMsg_StatsHeroLookup] {
        &self.hero_lookup
    }

    fn get_hero_lookup_for_reflect(&self) -> &::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroLookup> {
        &self.hero_lookup
    }

    fn mut_hero_lookup_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsHeroLookup> {
        &mut self.hero_lookup
    }

    // repeated .CDOTAUserMsg_StatsTeamMinuteDetails radiant_stats = 2;

    pub fn clear_radiant_stats(&mut self) {
        self.radiant_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_radiant_stats(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails>) {
        self.radiant_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_radiant_stats(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails> {
        &mut self.radiant_stats
    }

    // Take field
    pub fn take_radiant_stats(&mut self) -> ::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails> {
        ::std::mem::replace(&mut self.radiant_stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_radiant_stats(&self) -> &[CDOTAUserMsg_StatsTeamMinuteDetails] {
        &self.radiant_stats
    }

    fn get_radiant_stats_for_reflect(&self) -> &::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails> {
        &self.radiant_stats
    }

    fn mut_radiant_stats_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails> {
        &mut self.radiant_stats
    }

    // repeated .CDOTAUserMsg_StatsTeamMinuteDetails dire_stats = 3;

    pub fn clear_dire_stats(&mut self) {
        self.dire_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_dire_stats(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails>) {
        self.dire_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dire_stats(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails> {
        &mut self.dire_stats
    }

    // Take field
    pub fn take_dire_stats(&mut self) -> ::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails> {
        ::std::mem::replace(&mut self.dire_stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_dire_stats(&self) -> &[CDOTAUserMsg_StatsTeamMinuteDetails] {
        &self.dire_stats
    }

    fn get_dire_stats_for_reflect(&self) -> &::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails> {
        &self.dire_stats
    }

    fn mut_dire_stats_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsTeamMinuteDetails> {
        &mut self.dire_stats
    }

    // repeated .CDOTAUserMsg_StatsKillDetails radiant_kills = 4;

    pub fn clear_radiant_kills(&mut self) {
        self.radiant_kills.clear();
    }

    // Param is passed by value, moved
    pub fn set_radiant_kills(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_StatsKillDetails>) {
        self.radiant_kills = v;
    }

    // Mutable pointer to the field.
    pub fn mut_radiant_kills(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsKillDetails> {
        &mut self.radiant_kills
    }

    // Take field
    pub fn take_radiant_kills(&mut self) -> ::protobuf::RepeatedField<CDOTAUserMsg_StatsKillDetails> {
        ::std::mem::replace(&mut self.radiant_kills, ::protobuf::RepeatedField::new())
    }

    pub fn get_radiant_kills(&self) -> &[CDOTAUserMsg_StatsKillDetails] {
        &self.radiant_kills
    }

    fn get_radiant_kills_for_reflect(&self) -> &::protobuf::RepeatedField<CDOTAUserMsg_StatsKillDetails> {
        &self.radiant_kills
    }

    fn mut_radiant_kills_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsKillDetails> {
        &mut self.radiant_kills
    }

    // repeated .CDOTAUserMsg_StatsKillDetails dire_kills = 5;

    pub fn clear_dire_kills(&mut self) {
        self.dire_kills.clear();
    }

    // Param is passed by value, moved
    pub fn set_dire_kills(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_StatsKillDetails>) {
        self.dire_kills = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dire_kills(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsKillDetails> {
        &mut self.dire_kills
    }

    // Take field
    pub fn take_dire_kills(&mut self) -> ::protobuf::RepeatedField<CDOTAUserMsg_StatsKillDetails> {
        ::std::mem::replace(&mut self.dire_kills, ::protobuf::RepeatedField::new())
    }

    pub fn get_dire_kills(&self) -> &[CDOTAUserMsg_StatsKillDetails] {
        &self.dire_kills
    }

    fn get_dire_kills_for_reflect(&self) -> &::protobuf::RepeatedField<CDOTAUserMsg_StatsKillDetails> {
        &self.dire_kills
    }

    fn mut_dire_kills_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsKillDetails> {
        &mut self.dire_kills
    }

    // repeated .CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightDetails fight_details = 6;

    pub fn clear_fight_details(&mut self) {
        self.fight_details.clear();
    }

    // Param is passed by value, moved
    pub fn set_fight_details(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails>) {
        self.fight_details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fight_details(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails> {
        &mut self.fight_details
    }

    // Take field
    pub fn take_fight_details(&mut self) -> ::protobuf::RepeatedField<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails> {
        ::std::mem::replace(&mut self.fight_details, ::protobuf::RepeatedField::new())
    }

    pub fn get_fight_details(&self) -> &[CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails] {
        &self.fight_details
    }

    fn get_fight_details_for_reflect(&self) -> &::protobuf::RepeatedField<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails> {
        &self.fight_details
    }

    fn mut_fight_details_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails> {
        &mut self.fight_details
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsMatchDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.hero_lookup {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.radiant_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dire_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.radiant_kills {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dire_kills {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fight_details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hero_lookup)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.radiant_stats)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dire_stats)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.radiant_kills)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dire_kills)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fight_details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.hero_lookup {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.radiant_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.dire_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.radiant_kills {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.dire_kills {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.fight_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.hero_lookup {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.radiant_stats {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.dire_stats {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.radiant_kills {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.dire_kills {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.fight_details {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_StatsMatchDetails {
    fn new() -> CDOTAUserMsg_StatsMatchDetails {
        CDOTAUserMsg_StatsMatchDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_StatsMatchDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_StatsHeroLookup>>(
                    "hero_lookup",
                    CDOTAUserMsg_StatsMatchDetails::get_hero_lookup_for_reflect,
                    CDOTAUserMsg_StatsMatchDetails::mut_hero_lookup_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_StatsTeamMinuteDetails>>(
                    "radiant_stats",
                    CDOTAUserMsg_StatsMatchDetails::get_radiant_stats_for_reflect,
                    CDOTAUserMsg_StatsMatchDetails::mut_radiant_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_StatsTeamMinuteDetails>>(
                    "dire_stats",
                    CDOTAUserMsg_StatsMatchDetails::get_dire_stats_for_reflect,
                    CDOTAUserMsg_StatsMatchDetails::mut_dire_stats_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_StatsKillDetails>>(
                    "radiant_kills",
                    CDOTAUserMsg_StatsMatchDetails::get_radiant_kills_for_reflect,
                    CDOTAUserMsg_StatsMatchDetails::mut_radiant_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_StatsKillDetails>>(
                    "dire_kills",
                    CDOTAUserMsg_StatsMatchDetails::get_dire_kills_for_reflect,
                    CDOTAUserMsg_StatsMatchDetails::mut_dire_kills_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails>>(
                    "fight_details",
                    CDOTAUserMsg_StatsMatchDetails::get_fight_details_for_reflect,
                    CDOTAUserMsg_StatsMatchDetails::mut_fight_details_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_StatsMatchDetails>(
                    "CDOTAUserMsg_StatsMatchDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_StatsMatchDetails {
    fn clear(&mut self) {
        self.clear_hero_lookup();
        self.clear_radiant_stats();
        self.clear_dire_stats();
        self.clear_radiant_kills();
        self.clear_dire_kills();
        self.clear_fight_details();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_StatsMatchDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsMatchDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails {
    // message fields
    participants: ::std::vec::Vec<u32>,
    deaths: ::std::vec::Vec<u32>,
    gold_delta: ::std::option::Option<u32>,
    xp_delta: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails {}

impl CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails {
    pub fn new() -> CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails,
        };
        unsafe {
            instance.get(CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails::new)
        }
    }

    // repeated uint32 participants = 1;

    pub fn clear_participants(&mut self) {
        self.participants.clear();
    }

    // Param is passed by value, moved
    pub fn set_participants(&mut self, v: ::std::vec::Vec<u32>) {
        self.participants = v;
    }

    // Mutable pointer to the field.
    pub fn mut_participants(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.participants
    }

    // Take field
    pub fn take_participants(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.participants, ::std::vec::Vec::new())
    }

    pub fn get_participants(&self) -> &[u32] {
        &self.participants
    }

    fn get_participants_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.participants
    }

    fn mut_participants_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.participants
    }

    // repeated uint32 deaths = 2;

    pub fn clear_deaths(&mut self) {
        self.deaths.clear();
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: ::std::vec::Vec<u32>) {
        self.deaths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deaths(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.deaths
    }

    // Take field
    pub fn take_deaths(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.deaths, ::std::vec::Vec::new())
    }

    pub fn get_deaths(&self) -> &[u32] {
        &self.deaths
    }

    fn get_deaths_for_reflect(&self) -> &::std::vec::Vec<u32> {
        &self.deaths
    }

    fn mut_deaths_for_reflect(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.deaths
    }

    // optional uint32 gold_delta = 3;

    pub fn clear_gold_delta(&mut self) {
        self.gold_delta = ::std::option::Option::None;
    }

    pub fn has_gold_delta(&self) -> bool {
        self.gold_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold_delta(&mut self, v: u32) {
        self.gold_delta = ::std::option::Option::Some(v);
    }

    pub fn get_gold_delta(&self) -> u32 {
        self.gold_delta.unwrap_or(0)
    }

    fn get_gold_delta_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.gold_delta
    }

    fn mut_gold_delta_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.gold_delta
    }

    // optional uint32 xp_delta = 4;

    pub fn clear_xp_delta(&mut self) {
        self.xp_delta = ::std::option::Option::None;
    }

    pub fn has_xp_delta(&self) -> bool {
        self.xp_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_delta(&mut self, v: u32) {
        self.xp_delta = ::std::option::Option::Some(v);
    }

    pub fn get_xp_delta(&self) -> u32 {
        self.xp_delta.unwrap_or(0)
    }

    fn get_xp_delta_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.xp_delta
    }

    fn mut_xp_delta_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.xp_delta
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.participants)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.deaths)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gold_delta = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xp_delta = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.participants {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.deaths {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.gold_delta {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.xp_delta {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.participants {
            os.write_uint32(1, *v)?;
        };
        for v in &self.deaths {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.gold_delta {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.xp_delta {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails {
    fn new() -> CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails {
        CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "participants",
                    CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails::get_participants_for_reflect,
                    CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails::mut_participants_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "deaths",
                    CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails::get_deaths_for_reflect,
                    CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails::mut_deaths_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "gold_delta",
                    CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails::get_gold_delta_for_reflect,
                    CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails::mut_gold_delta_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "xp_delta",
                    CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails::get_xp_delta_for_reflect,
                    CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails::mut_xp_delta_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails>(
                    "CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails {
    fn clear(&mut self) {
        self.clear_participants();
        self.clear_deaths();
        self.clear_gold_delta();
        self.clear_xp_delta();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails {
    // message fields
    start_time: ::std::option::Option<f32>,
    end_time: ::std::option::Option<f32>,
    radiant_fight_details: ::protobuf::SingularPtrField<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails>,
    dire_fight_details: ::protobuf::SingularPtrField<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails {}

impl CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails {
    pub fn new() -> CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails,
        };
        unsafe {
            instance.get(CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails::new)
        }
    }

    // optional float start_time = 1;

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: f32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    pub fn get_start_time(&self) -> f32 {
        self.start_time.unwrap_or(0.)
    }

    fn get_start_time_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.start_time
    }

    fn mut_start_time_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.start_time
    }

    // optional float end_time = 2;

    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: f32) {
        self.end_time = ::std::option::Option::Some(v);
    }

    pub fn get_end_time(&self) -> f32 {
        self.end_time.unwrap_or(0.)
    }

    fn get_end_time_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.end_time
    }

    fn mut_end_time_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.end_time
    }

    // optional .CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails radiant_fight_details = 3;

    pub fn clear_radiant_fight_details(&mut self) {
        self.radiant_fight_details.clear();
    }

    pub fn has_radiant_fight_details(&self) -> bool {
        self.radiant_fight_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_fight_details(&mut self, v: CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails) {
        self.radiant_fight_details = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_radiant_fight_details(&mut self) -> &mut CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails {
        if self.radiant_fight_details.is_none() {
            self.radiant_fight_details.set_default();
        }
        self.radiant_fight_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_radiant_fight_details(&mut self) -> CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails {
        self.radiant_fight_details.take().unwrap_or_else(|| CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails::new())
    }

    pub fn get_radiant_fight_details(&self) -> &CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails {
        self.radiant_fight_details.as_ref().unwrap_or_else(|| CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails::default_instance())
    }

    fn get_radiant_fight_details_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails> {
        &self.radiant_fight_details
    }

    fn mut_radiant_fight_details_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails> {
        &mut self.radiant_fight_details
    }

    // optional .CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_StatsFightTeamDetails dire_fight_details = 4;

    pub fn clear_dire_fight_details(&mut self) {
        self.dire_fight_details.clear();
    }

    pub fn has_dire_fight_details(&self) -> bool {
        self.dire_fight_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_fight_details(&mut self, v: CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails) {
        self.dire_fight_details = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dire_fight_details(&mut self) -> &mut CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails {
        if self.dire_fight_details.is_none() {
            self.dire_fight_details.set_default();
        }
        self.dire_fight_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_dire_fight_details(&mut self) -> CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails {
        self.dire_fight_details.take().unwrap_or_else(|| CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails::new())
    }

    pub fn get_dire_fight_details(&self) -> &CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails {
        self.dire_fight_details.as_ref().unwrap_or_else(|| CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails::default_instance())
    }

    fn get_dire_fight_details_for_reflect(&self) -> &::protobuf::SingularPtrField<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails> {
        &self.dire_fight_details
    }

    fn mut_dire_fight_details_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails> {
        &mut self.dire_fight_details
    }
}

impl ::protobuf::Message for CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.radiant_fight_details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dire_fight_details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.end_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.radiant_fight_details)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dire_fight_details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.start_time {
            my_size += 5;
        }
        if let Some(v) = self.end_time {
            my_size += 5;
        }
        if let Some(ref v) = self.radiant_fight_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dire_fight_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.start_time {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_float(2, v)?;
        }
        if let Some(ref v) = self.radiant_fight_details.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dire_fight_details.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails {
    fn new() -> CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails {
        CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "start_time",
                    CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails::get_start_time_for_reflect,
                    CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails::mut_start_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "end_time",
                    CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails::get_end_time_for_reflect,
                    CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails::mut_end_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails>>(
                    "radiant_fight_details",
                    CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails::get_radiant_fight_details_for_reflect,
                    CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails::mut_radiant_fight_details_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightTeamDetails>>(
                    "dire_fight_details",
                    CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails::get_dire_fight_details_for_reflect,
                    CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails::mut_dire_fight_details_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails>(
                    "CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails {
    fn clear(&mut self) {
        self.clear_start_time();
        self.clear_end_time();
        self.clear_radiant_fight_details();
        self.clear_dire_fight_details();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_StatsMatchDetails_CDOTAUserMsg_StatsFightDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_MiniTaunt {
    // message fields
    taunting_player_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_MiniTaunt {}

impl CDOTAUserMsg_MiniTaunt {
    pub fn new() -> CDOTAUserMsg_MiniTaunt {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_MiniTaunt {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_MiniTaunt> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_MiniTaunt,
        };
        unsafe {
            instance.get(CDOTAUserMsg_MiniTaunt::new)
        }
    }

    // optional uint32 taunting_player_id = 1;

    pub fn clear_taunting_player_id(&mut self) {
        self.taunting_player_id = ::std::option::Option::None;
    }

    pub fn has_taunting_player_id(&self) -> bool {
        self.taunting_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_taunting_player_id(&mut self, v: u32) {
        self.taunting_player_id = ::std::option::Option::Some(v);
    }

    pub fn get_taunting_player_id(&self) -> u32 {
        self.taunting_player_id.unwrap_or(0)
    }

    fn get_taunting_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.taunting_player_id
    }

    fn mut_taunting_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.taunting_player_id
    }
}

impl ::protobuf::Message for CDOTAUserMsg_MiniTaunt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.taunting_player_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.taunting_player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.taunting_player_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_MiniTaunt {
    fn new() -> CDOTAUserMsg_MiniTaunt {
        CDOTAUserMsg_MiniTaunt::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_MiniTaunt>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "taunting_player_id",
                    CDOTAUserMsg_MiniTaunt::get_taunting_player_id_for_reflect,
                    CDOTAUserMsg_MiniTaunt::mut_taunting_player_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_MiniTaunt>(
                    "CDOTAUserMsg_MiniTaunt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_MiniTaunt {
    fn clear(&mut self) {
        self.clear_taunting_player_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_MiniTaunt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_MiniTaunt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_SpeechBubble {
    // message fields
    destroy_all: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_SpeechBubble {}

impl CDOTAUserMsg_SpeechBubble {
    pub fn new() -> CDOTAUserMsg_SpeechBubble {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_SpeechBubble {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_SpeechBubble> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_SpeechBubble,
        };
        unsafe {
            instance.get(CDOTAUserMsg_SpeechBubble::new)
        }
    }

    // optional bool destroy_all = 1;

    pub fn clear_destroy_all(&mut self) {
        self.destroy_all = ::std::option::Option::None;
    }

    pub fn has_destroy_all(&self) -> bool {
        self.destroy_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroy_all(&mut self, v: bool) {
        self.destroy_all = ::std::option::Option::Some(v);
    }

    pub fn get_destroy_all(&self) -> bool {
        self.destroy_all.unwrap_or(false)
    }

    fn get_destroy_all_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.destroy_all
    }

    fn mut_destroy_all_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.destroy_all
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SpeechBubble {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.destroy_all = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.destroy_all {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.destroy_all {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_SpeechBubble {
    fn new() -> CDOTAUserMsg_SpeechBubble {
        CDOTAUserMsg_SpeechBubble::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_SpeechBubble>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "destroy_all",
                    CDOTAUserMsg_SpeechBubble::get_destroy_all_for_reflect,
                    CDOTAUserMsg_SpeechBubble::mut_destroy_all_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_SpeechBubble>(
                    "CDOTAUserMsg_SpeechBubble",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_SpeechBubble {
    fn clear(&mut self) {
        self.clear_destroy_all();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_SpeechBubble {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SpeechBubble {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_CustomHeaderMessage {
    // message fields
    player_id: ::std::option::Option<u32>,
    duration: ::std::option::Option<f32>,
    message: ::protobuf::SingularField<::std::string::String>,
    value: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_CustomHeaderMessage {}

impl CDOTAUserMsg_CustomHeaderMessage {
    pub fn new() -> CDOTAUserMsg_CustomHeaderMessage {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_CustomHeaderMessage {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_CustomHeaderMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_CustomHeaderMessage,
        };
        unsafe {
            instance.get(CDOTAUserMsg_CustomHeaderMessage::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional float duration = 2;

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    fn get_duration_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.duration
    }

    fn mut_duration_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.duration
    }

    // optional string message = 3;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }

    // optional int32 value = 4;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> i32 {
        self.value.unwrap_or(0)
    }

    fn get_value_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.value
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CustomHeaderMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.duration {
            my_size += 5;
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.value {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_CustomHeaderMessage {
    fn new() -> CDOTAUserMsg_CustomHeaderMessage {
        CDOTAUserMsg_CustomHeaderMessage::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_CustomHeaderMessage>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_CustomHeaderMessage::get_player_id_for_reflect,
                    CDOTAUserMsg_CustomHeaderMessage::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "duration",
                    CDOTAUserMsg_CustomHeaderMessage::get_duration_for_reflect,
                    CDOTAUserMsg_CustomHeaderMessage::mut_duration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    CDOTAUserMsg_CustomHeaderMessage::get_message_for_reflect,
                    CDOTAUserMsg_CustomHeaderMessage::mut_message_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    CDOTAUserMsg_CustomHeaderMessage::get_value_for_reflect,
                    CDOTAUserMsg_CustomHeaderMessage::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_CustomHeaderMessage>(
                    "CDOTAUserMsg_CustomHeaderMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_CustomHeaderMessage {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_duration();
        self.clear_message();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_CustomHeaderMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CustomHeaderMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgHeroAbilityStat {
    // message fields
    stat_type: ::std::option::Option<EHeroStatType>,
    int_value: ::std::option::Option<i32>,
    float_value: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgHeroAbilityStat {}

impl CMsgHeroAbilityStat {
    pub fn new() -> CMsgHeroAbilityStat {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgHeroAbilityStat {
        static mut instance: ::protobuf::lazy::Lazy<CMsgHeroAbilityStat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgHeroAbilityStat,
        };
        unsafe {
            instance.get(CMsgHeroAbilityStat::new)
        }
    }

    // optional .EHeroStatType stat_type = 1;

    pub fn clear_stat_type(&mut self) {
        self.stat_type = ::std::option::Option::None;
    }

    pub fn has_stat_type(&self) -> bool {
        self.stat_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_type(&mut self, v: EHeroStatType) {
        self.stat_type = ::std::option::Option::Some(v);
    }

    pub fn get_stat_type(&self) -> EHeroStatType {
        self.stat_type.unwrap_or(EHeroStatType::k_EHeroStatType_None)
    }

    fn get_stat_type_for_reflect(&self) -> &::std::option::Option<EHeroStatType> {
        &self.stat_type
    }

    fn mut_stat_type_for_reflect(&mut self) -> &mut ::std::option::Option<EHeroStatType> {
        &mut self.stat_type
    }

    // optional int32 int_value = 2;

    pub fn clear_int_value(&mut self) {
        self.int_value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        self.int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i32) {
        self.int_value = ::std::option::Option::Some(v);
    }

    pub fn get_int_value(&self) -> i32 {
        self.int_value.unwrap_or(0)
    }

    fn get_int_value_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.int_value
    }

    fn mut_int_value_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.int_value
    }

    // optional float float_value = 3;

    pub fn clear_float_value(&mut self) {
        self.float_value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        self.float_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.float_value = ::std::option::Option::Some(v);
    }

    pub fn get_float_value(&self) -> f32 {
        self.float_value.unwrap_or(0.)
    }

    fn get_float_value_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.float_value
    }

    fn mut_float_value_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.float_value
    }
}

impl ::protobuf::Message for CMsgHeroAbilityStat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.stat_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.int_value = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.float_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stat_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.int_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.float_value {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stat_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.int_value {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.float_value {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgHeroAbilityStat {
    fn new() -> CMsgHeroAbilityStat {
        CMsgHeroAbilityStat::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgHeroAbilityStat>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EHeroStatType>>(
                    "stat_type",
                    CMsgHeroAbilityStat::get_stat_type_for_reflect,
                    CMsgHeroAbilityStat::mut_stat_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "int_value",
                    CMsgHeroAbilityStat::get_int_value_for_reflect,
                    CMsgHeroAbilityStat::mut_int_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "float_value",
                    CMsgHeroAbilityStat::get_float_value_for_reflect,
                    CMsgHeroAbilityStat::mut_float_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgHeroAbilityStat>(
                    "CMsgHeroAbilityStat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgHeroAbilityStat {
    fn clear(&mut self) {
        self.clear_stat_type();
        self.clear_int_value();
        self.clear_float_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgHeroAbilityStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHeroAbilityStat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCombatAnalyzerPlayerStat {
    // message fields
    account_id: ::std::option::Option<u32>,
    hero_ability_stats: ::protobuf::RepeatedField<CMsgHeroAbilityStat>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgCombatAnalyzerPlayerStat {}

impl CMsgCombatAnalyzerPlayerStat {
    pub fn new() -> CMsgCombatAnalyzerPlayerStat {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgCombatAnalyzerPlayerStat {
        static mut instance: ::protobuf::lazy::Lazy<CMsgCombatAnalyzerPlayerStat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgCombatAnalyzerPlayerStat,
        };
        unsafe {
            instance.get(CMsgCombatAnalyzerPlayerStat::new)
        }
    }

    // optional uint32 account_id = 1;

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    fn get_account_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.account_id
    }

    fn mut_account_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.account_id
    }

    // repeated .CMsgHeroAbilityStat hero_ability_stats = 2;

    pub fn clear_hero_ability_stats(&mut self) {
        self.hero_ability_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_hero_ability_stats(&mut self, v: ::protobuf::RepeatedField<CMsgHeroAbilityStat>) {
        self.hero_ability_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hero_ability_stats(&mut self) -> &mut ::protobuf::RepeatedField<CMsgHeroAbilityStat> {
        &mut self.hero_ability_stats
    }

    // Take field
    pub fn take_hero_ability_stats(&mut self) -> ::protobuf::RepeatedField<CMsgHeroAbilityStat> {
        ::std::mem::replace(&mut self.hero_ability_stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_hero_ability_stats(&self) -> &[CMsgHeroAbilityStat] {
        &self.hero_ability_stats
    }

    fn get_hero_ability_stats_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgHeroAbilityStat> {
        &self.hero_ability_stats
    }

    fn mut_hero_ability_stats_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgHeroAbilityStat> {
        &mut self.hero_ability_stats
    }
}

impl ::protobuf::Message for CMsgCombatAnalyzerPlayerStat {
    fn is_initialized(&self) -> bool {
        for v in &self.hero_ability_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hero_ability_stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.hero_ability_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.hero_ability_stats {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgCombatAnalyzerPlayerStat {
    fn new() -> CMsgCombatAnalyzerPlayerStat {
        CMsgCombatAnalyzerPlayerStat::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgCombatAnalyzerPlayerStat>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account_id",
                    CMsgCombatAnalyzerPlayerStat::get_account_id_for_reflect,
                    CMsgCombatAnalyzerPlayerStat::mut_account_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgHeroAbilityStat>>(
                    "hero_ability_stats",
                    CMsgCombatAnalyzerPlayerStat::get_hero_ability_stats_for_reflect,
                    CMsgCombatAnalyzerPlayerStat::mut_hero_ability_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgCombatAnalyzerPlayerStat>(
                    "CMsgCombatAnalyzerPlayerStat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgCombatAnalyzerPlayerStat {
    fn clear(&mut self) {
        self.clear_account_id();
        self.clear_hero_ability_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCombatAnalyzerPlayerStat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCombatAnalyzerPlayerStat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCombatAnalyzerStats {
    // message fields
    match_id: ::std::option::Option<u64>,
    player_stats: ::protobuf::RepeatedField<CMsgCombatAnalyzerPlayerStat>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgCombatAnalyzerStats {}

impl CMsgCombatAnalyzerStats {
    pub fn new() -> CMsgCombatAnalyzerStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgCombatAnalyzerStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgCombatAnalyzerStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgCombatAnalyzerStats,
        };
        unsafe {
            instance.get(CMsgCombatAnalyzerStats::new)
        }
    }

    // optional uint64 match_id = 1;

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    fn get_match_id_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.match_id
    }

    fn mut_match_id_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.match_id
    }

    // repeated .CMsgCombatAnalyzerPlayerStat player_stats = 2;

    pub fn clear_player_stats(&mut self) {
        self.player_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_stats(&mut self, v: ::protobuf::RepeatedField<CMsgCombatAnalyzerPlayerStat>) {
        self.player_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_stats(&mut self) -> &mut ::protobuf::RepeatedField<CMsgCombatAnalyzerPlayerStat> {
        &mut self.player_stats
    }

    // Take field
    pub fn take_player_stats(&mut self) -> ::protobuf::RepeatedField<CMsgCombatAnalyzerPlayerStat> {
        ::std::mem::replace(&mut self.player_stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_player_stats(&self) -> &[CMsgCombatAnalyzerPlayerStat] {
        &self.player_stats
    }

    fn get_player_stats_for_reflect(&self) -> &::protobuf::RepeatedField<CMsgCombatAnalyzerPlayerStat> {
        &self.player_stats
    }

    fn mut_player_stats_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CMsgCombatAnalyzerPlayerStat> {
        &mut self.player_stats
    }
}

impl ::protobuf::Message for CMsgCombatAnalyzerStats {
    fn is_initialized(&self) -> bool {
        for v in &self.player_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.player_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.player_stats {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgCombatAnalyzerStats {
    fn new() -> CMsgCombatAnalyzerStats {
        CMsgCombatAnalyzerStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgCombatAnalyzerStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "match_id",
                    CMsgCombatAnalyzerStats::get_match_id_for_reflect,
                    CMsgCombatAnalyzerStats::mut_match_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgCombatAnalyzerPlayerStat>>(
                    "player_stats",
                    CMsgCombatAnalyzerStats::get_player_stats_for_reflect,
                    CMsgCombatAnalyzerStats::mut_player_stats_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgCombatAnalyzerStats>(
                    "CMsgCombatAnalyzerStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgCombatAnalyzerStats {
    fn clear(&mut self) {
        self.clear_match_id();
        self.clear_player_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCombatAnalyzerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCombatAnalyzerStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_BeastChat {
    // message fields
    team: ::std::option::Option<u32>,
    format: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    target: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_BeastChat {}

impl CDOTAUserMsg_BeastChat {
    pub fn new() -> CDOTAUserMsg_BeastChat {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_BeastChat {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_BeastChat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_BeastChat,
        };
        unsafe {
            instance.get(CDOTAUserMsg_BeastChat::new)
        }
    }

    // optional uint32 team = 1;

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    pub fn get_team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    fn get_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team
    }

    fn mut_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team
    }

    // optional string format = 2;

    pub fn clear_format(&mut self) {
        self.format.clear();
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: ::std::string::String) {
        self.format = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_format(&mut self) -> &mut ::std::string::String {
        if self.format.is_none() {
            self.format.set_default();
        }
        self.format.as_mut().unwrap()
    }

    // Take field
    pub fn take_format(&mut self) -> ::std::string::String {
        self.format.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_format(&self) -> &str {
        match self.format.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_format_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.format
    }

    fn mut_format_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.format
    }

    // optional string message = 3;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }

    // optional string target = 4;

    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::string::String) {
        self.target = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ::std::string::String {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::string::String {
        self.target.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_target(&self) -> &str {
        match self.target.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_target_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.target
    }

    fn mut_target_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.target
    }
}

impl ::protobuf::Message for CDOTAUserMsg_BeastChat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.format)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.target)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.format.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.target.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.format.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.target.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_BeastChat {
    fn new() -> CDOTAUserMsg_BeastChat {
        CDOTAUserMsg_BeastChat::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_BeastChat>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team",
                    CDOTAUserMsg_BeastChat::get_team_for_reflect,
                    CDOTAUserMsg_BeastChat::mut_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "format",
                    CDOTAUserMsg_BeastChat::get_format_for_reflect,
                    CDOTAUserMsg_BeastChat::mut_format_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    CDOTAUserMsg_BeastChat::get_message_for_reflect,
                    CDOTAUserMsg_BeastChat::mut_message_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "target",
                    CDOTAUserMsg_BeastChat::get_target_for_reflect,
                    CDOTAUserMsg_BeastChat::mut_target_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_BeastChat>(
                    "CDOTAUserMsg_BeastChat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_BeastChat {
    fn clear(&mut self) {
        self.clear_team();
        self.clear_format();
        self.clear_message();
        self.clear_target();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_BeastChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_BeastChat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_CustomHudElement_Create {
    // message fields
    element_id: ::protobuf::SingularField<::std::string::String>,
    layout_filename: ::protobuf::SingularField<::std::string::String>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_CustomHudElement_Create {}

impl CDOTAUserMsg_CustomHudElement_Create {
    pub fn new() -> CDOTAUserMsg_CustomHudElement_Create {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_CustomHudElement_Create {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_CustomHudElement_Create> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_CustomHudElement_Create,
        };
        unsafe {
            instance.get(CDOTAUserMsg_CustomHudElement_Create::new)
        }
    }

    // optional string element_id = 1;

    pub fn clear_element_id(&mut self) {
        self.element_id.clear();
    }

    pub fn has_element_id(&self) -> bool {
        self.element_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_element_id(&mut self, v: ::std::string::String) {
        self.element_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_element_id(&mut self) -> &mut ::std::string::String {
        if self.element_id.is_none() {
            self.element_id.set_default();
        }
        self.element_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_element_id(&mut self) -> ::std::string::String {
        self.element_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_element_id(&self) -> &str {
        match self.element_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_element_id_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.element_id
    }

    fn mut_element_id_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.element_id
    }

    // optional string layout_filename = 2;

    pub fn clear_layout_filename(&mut self) {
        self.layout_filename.clear();
    }

    pub fn has_layout_filename(&self) -> bool {
        self.layout_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layout_filename(&mut self, v: ::std::string::String) {
        self.layout_filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_layout_filename(&mut self) -> &mut ::std::string::String {
        if self.layout_filename.is_none() {
            self.layout_filename.set_default();
        }
        self.layout_filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_layout_filename(&mut self) -> ::std::string::String {
        self.layout_filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_layout_filename(&self) -> &str {
        match self.layout_filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_layout_filename_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.layout_filename
    }

    fn mut_layout_filename_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.layout_filename
    }

    // optional bytes data = 3;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.data
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CustomHudElement_Create {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.element_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.layout_filename)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.element_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.layout_filename.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.element_id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.layout_filename.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_CustomHudElement_Create {
    fn new() -> CDOTAUserMsg_CustomHudElement_Create {
        CDOTAUserMsg_CustomHudElement_Create::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_CustomHudElement_Create>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "element_id",
                    CDOTAUserMsg_CustomHudElement_Create::get_element_id_for_reflect,
                    CDOTAUserMsg_CustomHudElement_Create::mut_element_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "layout_filename",
                    CDOTAUserMsg_CustomHudElement_Create::get_layout_filename_for_reflect,
                    CDOTAUserMsg_CustomHudElement_Create::mut_layout_filename_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    CDOTAUserMsg_CustomHudElement_Create::get_data_for_reflect,
                    CDOTAUserMsg_CustomHudElement_Create::mut_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_CustomHudElement_Create>(
                    "CDOTAUserMsg_CustomHudElement_Create",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_CustomHudElement_Create {
    fn clear(&mut self) {
        self.clear_element_id();
        self.clear_layout_filename();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_CustomHudElement_Create {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CustomHudElement_Create {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_CustomHudElement_Modify {
    // message fields
    element_id: ::protobuf::SingularField<::std::string::String>,
    modify_visible: ::std::option::Option<bool>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_CustomHudElement_Modify {}

impl CDOTAUserMsg_CustomHudElement_Modify {
    pub fn new() -> CDOTAUserMsg_CustomHudElement_Modify {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_CustomHudElement_Modify {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_CustomHudElement_Modify> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_CustomHudElement_Modify,
        };
        unsafe {
            instance.get(CDOTAUserMsg_CustomHudElement_Modify::new)
        }
    }

    // optional string element_id = 1;

    pub fn clear_element_id(&mut self) {
        self.element_id.clear();
    }

    pub fn has_element_id(&self) -> bool {
        self.element_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_element_id(&mut self, v: ::std::string::String) {
        self.element_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_element_id(&mut self) -> &mut ::std::string::String {
        if self.element_id.is_none() {
            self.element_id.set_default();
        }
        self.element_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_element_id(&mut self) -> ::std::string::String {
        self.element_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_element_id(&self) -> &str {
        match self.element_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_element_id_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.element_id
    }

    fn mut_element_id_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.element_id
    }

    // optional bool modify_visible = 2;

    pub fn clear_modify_visible(&mut self) {
        self.modify_visible = ::std::option::Option::None;
    }

    pub fn has_modify_visible(&self) -> bool {
        self.modify_visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modify_visible(&mut self, v: bool) {
        self.modify_visible = ::std::option::Option::Some(v);
    }

    pub fn get_modify_visible(&self) -> bool {
        self.modify_visible.unwrap_or(false)
    }

    fn get_modify_visible_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.modify_visible
    }

    fn mut_modify_visible_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.modify_visible
    }

    // optional bytes data = 3;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.data
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CustomHudElement_Modify {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.element_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.modify_visible = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.element_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.modify_visible {
            my_size += 2;
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.element_id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.modify_visible {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_CustomHudElement_Modify {
    fn new() -> CDOTAUserMsg_CustomHudElement_Modify {
        CDOTAUserMsg_CustomHudElement_Modify::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_CustomHudElement_Modify>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "element_id",
                    CDOTAUserMsg_CustomHudElement_Modify::get_element_id_for_reflect,
                    CDOTAUserMsg_CustomHudElement_Modify::mut_element_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "modify_visible",
                    CDOTAUserMsg_CustomHudElement_Modify::get_modify_visible_for_reflect,
                    CDOTAUserMsg_CustomHudElement_Modify::mut_modify_visible_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    CDOTAUserMsg_CustomHudElement_Modify::get_data_for_reflect,
                    CDOTAUserMsg_CustomHudElement_Modify::mut_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_CustomHudElement_Modify>(
                    "CDOTAUserMsg_CustomHudElement_Modify",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_CustomHudElement_Modify {
    fn clear(&mut self) {
        self.clear_element_id();
        self.clear_modify_visible();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_CustomHudElement_Modify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CustomHudElement_Modify {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_CustomHudElement_Destroy {
    // message fields
    element_id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_CustomHudElement_Destroy {}

impl CDOTAUserMsg_CustomHudElement_Destroy {
    pub fn new() -> CDOTAUserMsg_CustomHudElement_Destroy {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_CustomHudElement_Destroy {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_CustomHudElement_Destroy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_CustomHudElement_Destroy,
        };
        unsafe {
            instance.get(CDOTAUserMsg_CustomHudElement_Destroy::new)
        }
    }

    // optional string element_id = 1;

    pub fn clear_element_id(&mut self) {
        self.element_id.clear();
    }

    pub fn has_element_id(&self) -> bool {
        self.element_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_element_id(&mut self, v: ::std::string::String) {
        self.element_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_element_id(&mut self) -> &mut ::std::string::String {
        if self.element_id.is_none() {
            self.element_id.set_default();
        }
        self.element_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_element_id(&mut self) -> ::std::string::String {
        self.element_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_element_id(&self) -> &str {
        match self.element_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_element_id_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.element_id
    }

    fn mut_element_id_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.element_id
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CustomHudElement_Destroy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.element_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.element_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.element_id.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_CustomHudElement_Destroy {
    fn new() -> CDOTAUserMsg_CustomHudElement_Destroy {
        CDOTAUserMsg_CustomHudElement_Destroy::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_CustomHudElement_Destroy>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "element_id",
                    CDOTAUserMsg_CustomHudElement_Destroy::get_element_id_for_reflect,
                    CDOTAUserMsg_CustomHudElement_Destroy::mut_element_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_CustomHudElement_Destroy>(
                    "CDOTAUserMsg_CustomHudElement_Destroy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_CustomHudElement_Destroy {
    fn clear(&mut self) {
        self.clear_element_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_CustomHudElement_Destroy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CustomHudElement_Destroy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_CompendiumStatePlayer {
    // message fields
    player_id: ::std::option::Option<u32>,
    level: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_CompendiumStatePlayer {}

impl CDOTAUserMsg_CompendiumStatePlayer {
    pub fn new() -> CDOTAUserMsg_CompendiumStatePlayer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_CompendiumStatePlayer {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_CompendiumStatePlayer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_CompendiumStatePlayer,
        };
        unsafe {
            instance.get(CDOTAUserMsg_CompendiumStatePlayer::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional uint32 level = 2;

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    pub fn get_level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    fn get_level_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.level
    }

    fn mut_level_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.level
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CompendiumStatePlayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_CompendiumStatePlayer {
    fn new() -> CDOTAUserMsg_CompendiumStatePlayer {
        CDOTAUserMsg_CompendiumStatePlayer::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_CompendiumStatePlayer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_CompendiumStatePlayer::get_player_id_for_reflect,
                    CDOTAUserMsg_CompendiumStatePlayer::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "level",
                    CDOTAUserMsg_CompendiumStatePlayer::get_level_for_reflect,
                    CDOTAUserMsg_CompendiumStatePlayer::mut_level_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_CompendiumStatePlayer>(
                    "CDOTAUserMsg_CompendiumStatePlayer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_CompendiumStatePlayer {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_level();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_CompendiumStatePlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CompendiumStatePlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_CompendiumState {
    // message fields
    compendium_players: ::protobuf::RepeatedField<CDOTAUserMsg_CompendiumStatePlayer>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_CompendiumState {}

impl CDOTAUserMsg_CompendiumState {
    pub fn new() -> CDOTAUserMsg_CompendiumState {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_CompendiumState {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_CompendiumState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_CompendiumState,
        };
        unsafe {
            instance.get(CDOTAUserMsg_CompendiumState::new)
        }
    }

    // repeated .CDOTAUserMsg_CompendiumStatePlayer compendium_players = 1;

    pub fn clear_compendium_players(&mut self) {
        self.compendium_players.clear();
    }

    // Param is passed by value, moved
    pub fn set_compendium_players(&mut self, v: ::protobuf::RepeatedField<CDOTAUserMsg_CompendiumStatePlayer>) {
        self.compendium_players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_compendium_players(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_CompendiumStatePlayer> {
        &mut self.compendium_players
    }

    // Take field
    pub fn take_compendium_players(&mut self) -> ::protobuf::RepeatedField<CDOTAUserMsg_CompendiumStatePlayer> {
        ::std::mem::replace(&mut self.compendium_players, ::protobuf::RepeatedField::new())
    }

    pub fn get_compendium_players(&self) -> &[CDOTAUserMsg_CompendiumStatePlayer] {
        &self.compendium_players
    }

    fn get_compendium_players_for_reflect(&self) -> &::protobuf::RepeatedField<CDOTAUserMsg_CompendiumStatePlayer> {
        &self.compendium_players
    }

    fn mut_compendium_players_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<CDOTAUserMsg_CompendiumStatePlayer> {
        &mut self.compendium_players
    }
}

impl ::protobuf::Message for CDOTAUserMsg_CompendiumState {
    fn is_initialized(&self) -> bool {
        for v in &self.compendium_players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.compendium_players)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.compendium_players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.compendium_players {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_CompendiumState {
    fn new() -> CDOTAUserMsg_CompendiumState {
        CDOTAUserMsg_CompendiumState::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_CompendiumState>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CDOTAUserMsg_CompendiumStatePlayer>>(
                    "compendium_players",
                    CDOTAUserMsg_CompendiumState::get_compendium_players_for_reflect,
                    CDOTAUserMsg_CompendiumState::mut_compendium_players_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_CompendiumState>(
                    "CDOTAUserMsg_CompendiumState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_CompendiumState {
    fn clear(&mut self) {
        self.clear_compendium_players();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_CompendiumState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_CompendiumState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ProjectionAbility {
    // message fields
    ability_id: ::std::option::Option<u32>,
    caster_ent_index: ::std::option::Option<i32>,
    caster_team: ::std::option::Option<i32>,
    channel_end: ::std::option::Option<bool>,
    origin: ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector>,
    track_caster_only: ::std::option::Option<bool>,
    end_time: ::std::option::Option<f32>,
    victim_ent_index: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ProjectionAbility {}

impl CDOTAUserMsg_ProjectionAbility {
    pub fn new() -> CDOTAUserMsg_ProjectionAbility {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ProjectionAbility {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ProjectionAbility> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ProjectionAbility,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ProjectionAbility::new)
        }
    }

    // optional uint32 ability_id = 1;

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: u32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    pub fn get_ability_id(&self) -> u32 {
        self.ability_id.unwrap_or(0)
    }

    fn get_ability_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ability_id
    }

    fn mut_ability_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ability_id
    }

    // optional int32 caster_ent_index = 2;

    pub fn clear_caster_ent_index(&mut self) {
        self.caster_ent_index = ::std::option::Option::None;
    }

    pub fn has_caster_ent_index(&self) -> bool {
        self.caster_ent_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caster_ent_index(&mut self, v: i32) {
        self.caster_ent_index = ::std::option::Option::Some(v);
    }

    pub fn get_caster_ent_index(&self) -> i32 {
        self.caster_ent_index.unwrap_or(0)
    }

    fn get_caster_ent_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.caster_ent_index
    }

    fn mut_caster_ent_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.caster_ent_index
    }

    // optional int32 caster_team = 3;

    pub fn clear_caster_team(&mut self) {
        self.caster_team = ::std::option::Option::None;
    }

    pub fn has_caster_team(&self) -> bool {
        self.caster_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caster_team(&mut self, v: i32) {
        self.caster_team = ::std::option::Option::Some(v);
    }

    pub fn get_caster_team(&self) -> i32 {
        self.caster_team.unwrap_or(0)
    }

    fn get_caster_team_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.caster_team
    }

    fn mut_caster_team_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.caster_team
    }

    // optional bool channel_end = 4;

    pub fn clear_channel_end(&mut self) {
        self.channel_end = ::std::option::Option::None;
    }

    pub fn has_channel_end(&self) -> bool {
        self.channel_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_end(&mut self, v: bool) {
        self.channel_end = ::std::option::Option::Some(v);
    }

    pub fn get_channel_end(&self) -> bool {
        self.channel_end.unwrap_or(false)
    }

    fn get_channel_end_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.channel_end
    }

    fn mut_channel_end_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.channel_end
    }

    // optional .CMsgVector origin = 5;

    pub fn clear_origin(&mut self) {
        self.origin.clear();
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: super::networkbasetypes::CMsgVector) {
        self.origin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin(&mut self) -> &mut super::networkbasetypes::CMsgVector {
        if self.origin.is_none() {
            self.origin.set_default();
        }
        self.origin.as_mut().unwrap()
    }

    // Take field
    pub fn take_origin(&mut self) -> super::networkbasetypes::CMsgVector {
        self.origin.take().unwrap_or_else(|| super::networkbasetypes::CMsgVector::new())
    }

    pub fn get_origin(&self) -> &super::networkbasetypes::CMsgVector {
        self.origin.as_ref().unwrap_or_else(|| super::networkbasetypes::CMsgVector::default_instance())
    }

    fn get_origin_for_reflect(&self) -> &::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &self.origin
    }

    fn mut_origin_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::networkbasetypes::CMsgVector> {
        &mut self.origin
    }

    // optional bool track_caster_only = 6;

    pub fn clear_track_caster_only(&mut self) {
        self.track_caster_only = ::std::option::Option::None;
    }

    pub fn has_track_caster_only(&self) -> bool {
        self.track_caster_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_track_caster_only(&mut self, v: bool) {
        self.track_caster_only = ::std::option::Option::Some(v);
    }

    pub fn get_track_caster_only(&self) -> bool {
        self.track_caster_only.unwrap_or(false)
    }

    fn get_track_caster_only_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.track_caster_only
    }

    fn mut_track_caster_only_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.track_caster_only
    }

    // optional float end_time = 7;

    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: f32) {
        self.end_time = ::std::option::Option::Some(v);
    }

    pub fn get_end_time(&self) -> f32 {
        self.end_time.unwrap_or(0.)
    }

    fn get_end_time_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.end_time
    }

    fn mut_end_time_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.end_time
    }

    // optional int32 victim_ent_index = 8;

    pub fn clear_victim_ent_index(&mut self) {
        self.victim_ent_index = ::std::option::Option::None;
    }

    pub fn has_victim_ent_index(&self) -> bool {
        self.victim_ent_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_ent_index(&mut self, v: i32) {
        self.victim_ent_index = ::std::option::Option::Some(v);
    }

    pub fn get_victim_ent_index(&self) -> i32 {
        self.victim_ent_index.unwrap_or(0)
    }

    fn get_victim_ent_index_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.victim_ent_index
    }

    fn mut_victim_ent_index_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.victim_ent_index
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ProjectionAbility {
    fn is_initialized(&self) -> bool {
        for v in &self.origin {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ability_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.caster_ent_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.caster_team = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.channel_end = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.origin)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.track_caster_only = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.end_time = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.victim_ent_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.caster_ent_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.caster_team {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.channel_end {
            my_size += 2;
        }
        if let Some(ref v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.track_caster_only {
            my_size += 2;
        }
        if let Some(v) = self.end_time {
            my_size += 5;
        }
        if let Some(v) = self.victim_ent_index {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ability_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.caster_ent_index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.caster_team {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.channel_end {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.origin.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.track_caster_only {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.victim_ent_index {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ProjectionAbility {
    fn new() -> CDOTAUserMsg_ProjectionAbility {
        CDOTAUserMsg_ProjectionAbility::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ProjectionAbility>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ability_id",
                    CDOTAUserMsg_ProjectionAbility::get_ability_id_for_reflect,
                    CDOTAUserMsg_ProjectionAbility::mut_ability_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "caster_ent_index",
                    CDOTAUserMsg_ProjectionAbility::get_caster_ent_index_for_reflect,
                    CDOTAUserMsg_ProjectionAbility::mut_caster_ent_index_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "caster_team",
                    CDOTAUserMsg_ProjectionAbility::get_caster_team_for_reflect,
                    CDOTAUserMsg_ProjectionAbility::mut_caster_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "channel_end",
                    CDOTAUserMsg_ProjectionAbility::get_channel_end_for_reflect,
                    CDOTAUserMsg_ProjectionAbility::mut_channel_end_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::networkbasetypes::CMsgVector>>(
                    "origin",
                    CDOTAUserMsg_ProjectionAbility::get_origin_for_reflect,
                    CDOTAUserMsg_ProjectionAbility::mut_origin_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "track_caster_only",
                    CDOTAUserMsg_ProjectionAbility::get_track_caster_only_for_reflect,
                    CDOTAUserMsg_ProjectionAbility::mut_track_caster_only_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "end_time",
                    CDOTAUserMsg_ProjectionAbility::get_end_time_for_reflect,
                    CDOTAUserMsg_ProjectionAbility::mut_end_time_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "victim_ent_index",
                    CDOTAUserMsg_ProjectionAbility::get_victim_ent_index_for_reflect,
                    CDOTAUserMsg_ProjectionAbility::mut_victim_ent_index_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ProjectionAbility>(
                    "CDOTAUserMsg_ProjectionAbility",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ProjectionAbility {
    fn clear(&mut self) {
        self.clear_ability_id();
        self.clear_caster_ent_index();
        self.clear_caster_team();
        self.clear_channel_end();
        self.clear_origin();
        self.clear_track_caster_only();
        self.clear_end_time();
        self.clear_victim_ent_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ProjectionAbility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ProjectionAbility {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ProjectionEvent {
    // message fields
    event_id: ::std::option::Option<EProjectionEvent>,
    team: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ProjectionEvent {}

impl CDOTAUserMsg_ProjectionEvent {
    pub fn new() -> CDOTAUserMsg_ProjectionEvent {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ProjectionEvent {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ProjectionEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ProjectionEvent,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ProjectionEvent::new)
        }
    }

    // optional .EProjectionEvent event_id = 1;

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: EProjectionEvent) {
        self.event_id = ::std::option::Option::Some(v);
    }

    pub fn get_event_id(&self) -> EProjectionEvent {
        self.event_id.unwrap_or(EProjectionEvent::ePE_FirstBlood)
    }

    fn get_event_id_for_reflect(&self) -> &::std::option::Option<EProjectionEvent> {
        &self.event_id
    }

    fn mut_event_id_for_reflect(&mut self) -> &mut ::std::option::Option<EProjectionEvent> {
        &mut self.event_id
    }

    // optional uint32 team = 2;

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    pub fn get_team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    fn get_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team
    }

    fn mut_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ProjectionEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.event_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.team {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ProjectionEvent {
    fn new() -> CDOTAUserMsg_ProjectionEvent {
        CDOTAUserMsg_ProjectionEvent::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ProjectionEvent>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EProjectionEvent>>(
                    "event_id",
                    CDOTAUserMsg_ProjectionEvent::get_event_id_for_reflect,
                    CDOTAUserMsg_ProjectionEvent::mut_event_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team",
                    CDOTAUserMsg_ProjectionEvent::get_team_for_reflect,
                    CDOTAUserMsg_ProjectionEvent::mut_team_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ProjectionEvent>(
                    "CDOTAUserMsg_ProjectionEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ProjectionEvent {
    fn clear(&mut self) {
        self.clear_event_id();
        self.clear_team();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ProjectionEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ProjectionEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_XPAlert {
    // message fields
    player_id: ::std::option::Option<u32>,
    target_entindex: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_XPAlert {}

impl CDOTAUserMsg_XPAlert {
    pub fn new() -> CDOTAUserMsg_XPAlert {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_XPAlert {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_XPAlert> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_XPAlert,
        };
        unsafe {
            instance.get(CDOTAUserMsg_XPAlert::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional uint32 target_entindex = 2;

    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: u32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    pub fn get_target_entindex(&self) -> u32 {
        self.target_entindex.unwrap_or(0)
    }

    fn get_target_entindex_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.target_entindex
    }

    fn mut_target_entindex_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.target_entindex
    }
}

impl ::protobuf::Message for CDOTAUserMsg_XPAlert {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_entindex = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.target_entindex {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_XPAlert {
    fn new() -> CDOTAUserMsg_XPAlert {
        CDOTAUserMsg_XPAlert::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_XPAlert>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_XPAlert::get_player_id_for_reflect,
                    CDOTAUserMsg_XPAlert::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "target_entindex",
                    CDOTAUserMsg_XPAlert::get_target_entindex_for_reflect,
                    CDOTAUserMsg_XPAlert::mut_target_entindex_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_XPAlert>(
                    "CDOTAUserMsg_XPAlert",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_XPAlert {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_target_entindex();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_XPAlert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_XPAlert {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_UpdateQuestProgress {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_UpdateQuestProgress {}

impl CDOTAUserMsg_UpdateQuestProgress {
    pub fn new() -> CDOTAUserMsg_UpdateQuestProgress {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_UpdateQuestProgress {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_UpdateQuestProgress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_UpdateQuestProgress,
        };
        unsafe {
            instance.get(CDOTAUserMsg_UpdateQuestProgress::new)
        }
    }
}

impl ::protobuf::Message for CDOTAUserMsg_UpdateQuestProgress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_UpdateQuestProgress {
    fn new() -> CDOTAUserMsg_UpdateQuestProgress {
        CDOTAUserMsg_UpdateQuestProgress::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_UpdateQuestProgress>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_UpdateQuestProgress>(
                    "CDOTAUserMsg_UpdateQuestProgress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_UpdateQuestProgress {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_UpdateQuestProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_UpdateQuestProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_QuestStatus {
    // message fields
    player_id: ::std::option::Option<u32>,
    quest_id: ::std::option::Option<u32>,
    challenge_id: ::std::option::Option<u32>,
    progress: ::std::option::Option<u32>,
    goal: ::std::option::Option<u32>,
    query: ::std::option::Option<u32>,
    fail_gametime: ::std::option::Option<f32>,
    item_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_QuestStatus {}

impl CDOTAUserMsg_QuestStatus {
    pub fn new() -> CDOTAUserMsg_QuestStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_QuestStatus {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_QuestStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_QuestStatus,
        };
        unsafe {
            instance.get(CDOTAUserMsg_QuestStatus::new)
        }
    }

    // required uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional uint32 quest_id = 2;

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u32) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    pub fn get_quest_id(&self) -> u32 {
        self.quest_id.unwrap_or(0)
    }

    fn get_quest_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.quest_id
    }

    fn mut_quest_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.quest_id
    }

    // optional uint32 challenge_id = 3;

    pub fn clear_challenge_id(&mut self) {
        self.challenge_id = ::std::option::Option::None;
    }

    pub fn has_challenge_id(&self) -> bool {
        self.challenge_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_id(&mut self, v: u32) {
        self.challenge_id = ::std::option::Option::Some(v);
    }

    pub fn get_challenge_id(&self) -> u32 {
        self.challenge_id.unwrap_or(0)
    }

    fn get_challenge_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.challenge_id
    }

    fn mut_challenge_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.challenge_id
    }

    // optional uint32 progress = 4;

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: u32) {
        self.progress = ::std::option::Option::Some(v);
    }

    pub fn get_progress(&self) -> u32 {
        self.progress.unwrap_or(0)
    }

    fn get_progress_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.progress
    }

    fn mut_progress_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.progress
    }

    // optional uint32 goal = 5;

    pub fn clear_goal(&mut self) {
        self.goal = ::std::option::Option::None;
    }

    pub fn has_goal(&self) -> bool {
        self.goal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_goal(&mut self, v: u32) {
        self.goal = ::std::option::Option::Some(v);
    }

    pub fn get_goal(&self) -> u32 {
        self.goal.unwrap_or(0)
    }

    fn get_goal_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.goal
    }

    fn mut_goal_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.goal
    }

    // optional uint32 query = 6;

    pub fn clear_query(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: u32) {
        self.query = ::std::option::Option::Some(v);
    }

    pub fn get_query(&self) -> u32 {
        self.query.unwrap_or(0)
    }

    fn get_query_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.query
    }

    fn mut_query_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.query
    }

    // optional float fail_gametime = 7;

    pub fn clear_fail_gametime(&mut self) {
        self.fail_gametime = ::std::option::Option::None;
    }

    pub fn has_fail_gametime(&self) -> bool {
        self.fail_gametime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fail_gametime(&mut self, v: f32) {
        self.fail_gametime = ::std::option::Option::Some(v);
    }

    pub fn get_fail_gametime(&self) -> f32 {
        self.fail_gametime.unwrap_or(0.)
    }

    fn get_fail_gametime_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.fail_gametime
    }

    fn mut_fail_gametime_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.fail_gametime
    }

    // optional uint32 item_id = 8;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u32) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u32 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_id
    }
}

impl ::protobuf::Message for CDOTAUserMsg_QuestStatus {
    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.challenge_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.progress = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.goal = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.query = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.fail_gametime = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.challenge_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.progress {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.goal {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.query {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fail_gametime {
            my_size += 5;
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quest_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.challenge_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.progress {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.goal {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.query {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.fail_gametime {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_QuestStatus {
    fn new() -> CDOTAUserMsg_QuestStatus {
        CDOTAUserMsg_QuestStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_QuestStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_QuestStatus::get_player_id_for_reflect,
                    CDOTAUserMsg_QuestStatus::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "quest_id",
                    CDOTAUserMsg_QuestStatus::get_quest_id_for_reflect,
                    CDOTAUserMsg_QuestStatus::mut_quest_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "challenge_id",
                    CDOTAUserMsg_QuestStatus::get_challenge_id_for_reflect,
                    CDOTAUserMsg_QuestStatus::mut_challenge_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "progress",
                    CDOTAUserMsg_QuestStatus::get_progress_for_reflect,
                    CDOTAUserMsg_QuestStatus::mut_progress_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "goal",
                    CDOTAUserMsg_QuestStatus::get_goal_for_reflect,
                    CDOTAUserMsg_QuestStatus::mut_goal_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "query",
                    CDOTAUserMsg_QuestStatus::get_query_for_reflect,
                    CDOTAUserMsg_QuestStatus::mut_query_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "fail_gametime",
                    CDOTAUserMsg_QuestStatus::get_fail_gametime_for_reflect,
                    CDOTAUserMsg_QuestStatus::mut_fail_gametime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_id",
                    CDOTAUserMsg_QuestStatus::get_item_id_for_reflect,
                    CDOTAUserMsg_QuestStatus::mut_item_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_QuestStatus>(
                    "CDOTAUserMsg_QuestStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_QuestStatus {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_quest_id();
        self.clear_challenge_id();
        self.clear_progress();
        self.clear_goal();
        self.clear_query();
        self.clear_fail_gametime();
        self.clear_item_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_QuestStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_QuestStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_SuggestHeroPick {
    // message fields
    player_id: ::std::option::Option<u32>,
    hero_id: ::std::option::Option<u32>,
    ban: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_SuggestHeroPick {}

impl CDOTAUserMsg_SuggestHeroPick {
    pub fn new() -> CDOTAUserMsg_SuggestHeroPick {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_SuggestHeroPick {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_SuggestHeroPick> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_SuggestHeroPick,
        };
        unsafe {
            instance.get(CDOTAUserMsg_SuggestHeroPick::new)
        }
    }

    // required uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional uint32 hero_id = 2;

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: u32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    pub fn get_hero_id(&self) -> u32 {
        self.hero_id.unwrap_or(0)
    }

    fn get_hero_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.hero_id
    }

    fn mut_hero_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.hero_id
    }

    // optional bool ban = 3;

    pub fn clear_ban(&mut self) {
        self.ban = ::std::option::Option::None;
    }

    pub fn has_ban(&self) -> bool {
        self.ban.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban(&mut self, v: bool) {
        self.ban = ::std::option::Option::Some(v);
    }

    pub fn get_ban(&self) -> bool {
        self.ban.unwrap_or(false)
    }

    fn get_ban_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.ban
    }

    fn mut_ban_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.ban
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SuggestHeroPick {
    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hero_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ban = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hero_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ban {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ban {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_SuggestHeroPick {
    fn new() -> CDOTAUserMsg_SuggestHeroPick {
        CDOTAUserMsg_SuggestHeroPick::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_SuggestHeroPick>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_SuggestHeroPick::get_player_id_for_reflect,
                    CDOTAUserMsg_SuggestHeroPick::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "hero_id",
                    CDOTAUserMsg_SuggestHeroPick::get_hero_id_for_reflect,
                    CDOTAUserMsg_SuggestHeroPick::mut_hero_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ban",
                    CDOTAUserMsg_SuggestHeroPick::get_ban_for_reflect,
                    CDOTAUserMsg_SuggestHeroPick::mut_ban_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_SuggestHeroPick>(
                    "CDOTAUserMsg_SuggestHeroPick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_SuggestHeroPick {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_hero_id();
        self.clear_ban();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_SuggestHeroPick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SuggestHeroPick {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_SuggestHeroRole {
    // message fields
    player_id: ::std::option::Option<u32>,
    hero_role: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_SuggestHeroRole {}

impl CDOTAUserMsg_SuggestHeroRole {
    pub fn new() -> CDOTAUserMsg_SuggestHeroRole {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_SuggestHeroRole {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_SuggestHeroRole> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_SuggestHeroRole,
        };
        unsafe {
            instance.get(CDOTAUserMsg_SuggestHeroRole::new)
        }
    }

    // required uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional string hero_role = 2;

    pub fn clear_hero_role(&mut self) {
        self.hero_role.clear();
    }

    pub fn has_hero_role(&self) -> bool {
        self.hero_role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_role(&mut self, v: ::std::string::String) {
        self.hero_role = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hero_role(&mut self) -> &mut ::std::string::String {
        if self.hero_role.is_none() {
            self.hero_role.set_default();
        }
        self.hero_role.as_mut().unwrap()
    }

    // Take field
    pub fn take_hero_role(&mut self) -> ::std::string::String {
        self.hero_role.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hero_role(&self) -> &str {
        match self.hero_role.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_hero_role_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.hero_role
    }

    fn mut_hero_role_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.hero_role
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SuggestHeroRole {
    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hero_role)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.hero_role.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.hero_role.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_SuggestHeroRole {
    fn new() -> CDOTAUserMsg_SuggestHeroRole {
        CDOTAUserMsg_SuggestHeroRole::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_SuggestHeroRole>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_SuggestHeroRole::get_player_id_for_reflect,
                    CDOTAUserMsg_SuggestHeroRole::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hero_role",
                    CDOTAUserMsg_SuggestHeroRole::get_hero_role_for_reflect,
                    CDOTAUserMsg_SuggestHeroRole::mut_hero_role_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_SuggestHeroRole>(
                    "CDOTAUserMsg_SuggestHeroRole",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_SuggestHeroRole {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_hero_role();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_SuggestHeroRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SuggestHeroRole {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_KillcamDamageTaken {
    // message fields
    player_id: ::std::option::Option<u32>,
    damage_taken: ::std::option::Option<u32>,
    item_type: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u32>,
    hero_name: ::protobuf::SingularField<::std::string::String>,
    damage_color: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_KillcamDamageTaken {}

impl CDOTAUserMsg_KillcamDamageTaken {
    pub fn new() -> CDOTAUserMsg_KillcamDamageTaken {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_KillcamDamageTaken {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_KillcamDamageTaken> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_KillcamDamageTaken,
        };
        unsafe {
            instance.get(CDOTAUserMsg_KillcamDamageTaken::new)
        }
    }

    // required uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional uint32 damage_taken = 2;

    pub fn clear_damage_taken(&mut self) {
        self.damage_taken = ::std::option::Option::None;
    }

    pub fn has_damage_taken(&self) -> bool {
        self.damage_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_taken(&mut self, v: u32) {
        self.damage_taken = ::std::option::Option::Some(v);
    }

    pub fn get_damage_taken(&self) -> u32 {
        self.damage_taken.unwrap_or(0)
    }

    fn get_damage_taken_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.damage_taken
    }

    fn mut_damage_taken_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.damage_taken
    }

    // optional uint32 item_type = 3;

    pub fn clear_item_type(&mut self) {
        self.item_type = ::std::option::Option::None;
    }

    pub fn has_item_type(&self) -> bool {
        self.item_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_type(&mut self, v: u32) {
        self.item_type = ::std::option::Option::Some(v);
    }

    pub fn get_item_type(&self) -> u32 {
        self.item_type.unwrap_or(0)
    }

    fn get_item_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_type
    }

    fn mut_item_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_type
    }

    // optional uint32 item_id = 4;

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u32) {
        self.item_id = ::std::option::Option::Some(v);
    }

    pub fn get_item_id(&self) -> u32 {
        self.item_id.unwrap_or(0)
    }

    fn get_item_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.item_id
    }

    fn mut_item_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.item_id
    }

    // optional string hero_name = 5;

    pub fn clear_hero_name(&mut self) {
        self.hero_name.clear();
    }

    pub fn has_hero_name(&self) -> bool {
        self.hero_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_name(&mut self, v: ::std::string::String) {
        self.hero_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hero_name(&mut self) -> &mut ::std::string::String {
        if self.hero_name.is_none() {
            self.hero_name.set_default();
        }
        self.hero_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_hero_name(&mut self) -> ::std::string::String {
        self.hero_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hero_name(&self) -> &str {
        match self.hero_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_hero_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.hero_name
    }

    fn mut_hero_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.hero_name
    }

    // optional string damage_color = 6;

    pub fn clear_damage_color(&mut self) {
        self.damage_color.clear();
    }

    pub fn has_damage_color(&self) -> bool {
        self.damage_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_color(&mut self, v: ::std::string::String) {
        self.damage_color = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_damage_color(&mut self) -> &mut ::std::string::String {
        if self.damage_color.is_none() {
            self.damage_color.set_default();
        }
        self.damage_color.as_mut().unwrap()
    }

    // Take field
    pub fn take_damage_color(&mut self) -> ::std::string::String {
        self.damage_color.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_damage_color(&self) -> &str {
        match self.damage_color.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_damage_color_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.damage_color
    }

    fn mut_damage_color_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.damage_color
    }
}

impl ::protobuf::Message for CDOTAUserMsg_KillcamDamageTaken {
    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.damage_taken = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hero_name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.damage_color)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.damage_taken {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.hero_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.damage_color.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.damage_taken {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.hero_name.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.damage_color.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_KillcamDamageTaken {
    fn new() -> CDOTAUserMsg_KillcamDamageTaken {
        CDOTAUserMsg_KillcamDamageTaken::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_KillcamDamageTaken>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_KillcamDamageTaken::get_player_id_for_reflect,
                    CDOTAUserMsg_KillcamDamageTaken::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "damage_taken",
                    CDOTAUserMsg_KillcamDamageTaken::get_damage_taken_for_reflect,
                    CDOTAUserMsg_KillcamDamageTaken::mut_damage_taken_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_type",
                    CDOTAUserMsg_KillcamDamageTaken::get_item_type_for_reflect,
                    CDOTAUserMsg_KillcamDamageTaken::mut_item_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "item_id",
                    CDOTAUserMsg_KillcamDamageTaken::get_item_id_for_reflect,
                    CDOTAUserMsg_KillcamDamageTaken::mut_item_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hero_name",
                    CDOTAUserMsg_KillcamDamageTaken::get_hero_name_for_reflect,
                    CDOTAUserMsg_KillcamDamageTaken::mut_hero_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "damage_color",
                    CDOTAUserMsg_KillcamDamageTaken::get_damage_color_for_reflect,
                    CDOTAUserMsg_KillcamDamageTaken::mut_damage_color_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_KillcamDamageTaken>(
                    "CDOTAUserMsg_KillcamDamageTaken",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_KillcamDamageTaken {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_damage_taken();
        self.clear_item_type();
        self.clear_item_id();
        self.clear_hero_name();
        self.clear_damage_color();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_KillcamDamageTaken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_KillcamDamageTaken {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_SelectPenaltyGold {
    // message fields
    player_id: ::std::option::Option<u32>,
    cost: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_SelectPenaltyGold {}

impl CDOTAUserMsg_SelectPenaltyGold {
    pub fn new() -> CDOTAUserMsg_SelectPenaltyGold {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_SelectPenaltyGold {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_SelectPenaltyGold> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_SelectPenaltyGold,
        };
        unsafe {
            instance.get(CDOTAUserMsg_SelectPenaltyGold::new)
        }
    }

    // required uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional sint32 cost = 2;

    pub fn clear_cost(&mut self) {
        self.cost = ::std::option::Option::None;
    }

    pub fn has_cost(&self) -> bool {
        self.cost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cost(&mut self, v: i32) {
        self.cost = ::std::option::Option::Some(v);
    }

    pub fn get_cost(&self) -> i32 {
        self.cost.unwrap_or(0)
    }

    fn get_cost_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.cost
    }

    fn mut_cost_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.cost
    }
}

impl ::protobuf::Message for CDOTAUserMsg_SelectPenaltyGold {
    fn is_initialized(&self) -> bool {
        if self.player_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.cost = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cost {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cost {
            os.write_sint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_SelectPenaltyGold {
    fn new() -> CDOTAUserMsg_SelectPenaltyGold {
        CDOTAUserMsg_SelectPenaltyGold::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_SelectPenaltyGold>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_SelectPenaltyGold::get_player_id_for_reflect,
                    CDOTAUserMsg_SelectPenaltyGold::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "cost",
                    CDOTAUserMsg_SelectPenaltyGold::get_cost_for_reflect,
                    CDOTAUserMsg_SelectPenaltyGold::mut_cost_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_SelectPenaltyGold>(
                    "CDOTAUserMsg_SelectPenaltyGold",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_SelectPenaltyGold {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_cost();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_SelectPenaltyGold {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_SelectPenaltyGold {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_RollDiceResult {
    // message fields
    player_id: ::std::option::Option<u32>,
    channel_type: ::std::option::Option<u32>,
    roll_min: ::std::option::Option<u32>,
    roll_max: ::std::option::Option<u32>,
    result: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_RollDiceResult {}

impl CDOTAUserMsg_RollDiceResult {
    pub fn new() -> CDOTAUserMsg_RollDiceResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_RollDiceResult {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_RollDiceResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_RollDiceResult,
        };
        unsafe {
            instance.get(CDOTAUserMsg_RollDiceResult::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional uint32 channel_type = 2;

    pub fn clear_channel_type(&mut self) {
        self.channel_type = ::std::option::Option::None;
    }

    pub fn has_channel_type(&self) -> bool {
        self.channel_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_type(&mut self, v: u32) {
        self.channel_type = ::std::option::Option::Some(v);
    }

    pub fn get_channel_type(&self) -> u32 {
        self.channel_type.unwrap_or(0)
    }

    fn get_channel_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.channel_type
    }

    fn mut_channel_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.channel_type
    }

    // optional uint32 roll_min = 3;

    pub fn clear_roll_min(&mut self) {
        self.roll_min = ::std::option::Option::None;
    }

    pub fn has_roll_min(&self) -> bool {
        self.roll_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roll_min(&mut self, v: u32) {
        self.roll_min = ::std::option::Option::Some(v);
    }

    pub fn get_roll_min(&self) -> u32 {
        self.roll_min.unwrap_or(0)
    }

    fn get_roll_min_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.roll_min
    }

    fn mut_roll_min_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.roll_min
    }

    // optional uint32 roll_max = 4;

    pub fn clear_roll_max(&mut self) {
        self.roll_max = ::std::option::Option::None;
    }

    pub fn has_roll_max(&self) -> bool {
        self.roll_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roll_max(&mut self, v: u32) {
        self.roll_max = ::std::option::Option::Some(v);
    }

    pub fn get_roll_max(&self) -> u32 {
        self.roll_max.unwrap_or(0)
    }

    fn get_roll_max_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.roll_max
    }

    fn mut_roll_max_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.roll_max
    }

    // optional uint32 result = 5;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.result
    }
}

impl ::protobuf::Message for CDOTAUserMsg_RollDiceResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.roll_min = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.roll_max = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.channel_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.roll_min {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.roll_max {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.channel_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.roll_min {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.roll_max {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.result {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_RollDiceResult {
    fn new() -> CDOTAUserMsg_RollDiceResult {
        CDOTAUserMsg_RollDiceResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_RollDiceResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_RollDiceResult::get_player_id_for_reflect,
                    CDOTAUserMsg_RollDiceResult::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "channel_type",
                    CDOTAUserMsg_RollDiceResult::get_channel_type_for_reflect,
                    CDOTAUserMsg_RollDiceResult::mut_channel_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "roll_min",
                    CDOTAUserMsg_RollDiceResult::get_roll_min_for_reflect,
                    CDOTAUserMsg_RollDiceResult::mut_roll_min_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "roll_max",
                    CDOTAUserMsg_RollDiceResult::get_roll_max_for_reflect,
                    CDOTAUserMsg_RollDiceResult::mut_roll_max_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "result",
                    CDOTAUserMsg_RollDiceResult::get_result_for_reflect,
                    CDOTAUserMsg_RollDiceResult::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_RollDiceResult>(
                    "CDOTAUserMsg_RollDiceResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_RollDiceResult {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_channel_type();
        self.clear_roll_min();
        self.clear_roll_max();
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_RollDiceResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_RollDiceResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_FlipCoinResult {
    // message fields
    player_id: ::std::option::Option<u32>,
    channel_type: ::std::option::Option<u32>,
    result: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_FlipCoinResult {}

impl CDOTAUserMsg_FlipCoinResult {
    pub fn new() -> CDOTAUserMsg_FlipCoinResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_FlipCoinResult {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_FlipCoinResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_FlipCoinResult,
        };
        unsafe {
            instance.get(CDOTAUserMsg_FlipCoinResult::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }

    // optional uint32 channel_type = 2;

    pub fn clear_channel_type(&mut self) {
        self.channel_type = ::std::option::Option::None;
    }

    pub fn has_channel_type(&self) -> bool {
        self.channel_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_type(&mut self, v: u32) {
        self.channel_type = ::std::option::Option::Some(v);
    }

    pub fn get_channel_type(&self) -> u32 {
        self.channel_type.unwrap_or(0)
    }

    fn get_channel_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.channel_type
    }

    fn mut_channel_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.channel_type
    }

    // optional bool result = 3;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.result
    }
}

impl ::protobuf::Message for CDOTAUserMsg_FlipCoinResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.channel_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.channel_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.result {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_FlipCoinResult {
    fn new() -> CDOTAUserMsg_FlipCoinResult {
        CDOTAUserMsg_FlipCoinResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_FlipCoinResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMsg_FlipCoinResult::get_player_id_for_reflect,
                    CDOTAUserMsg_FlipCoinResult::mut_player_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "channel_type",
                    CDOTAUserMsg_FlipCoinResult::get_channel_type_for_reflect,
                    CDOTAUserMsg_FlipCoinResult::mut_channel_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    CDOTAUserMsg_FlipCoinResult::get_result_for_reflect,
                    CDOTAUserMsg_FlipCoinResult::mut_result_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_FlipCoinResult>(
                    "CDOTAUserMsg_FlipCoinResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_FlipCoinResult {
    fn clear(&mut self) {
        self.clear_player_id();
        self.clear_channel_type();
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_FlipCoinResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_FlipCoinResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMessage_RequestItemSuggestions {
    // message fields
    player_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMessage_RequestItemSuggestions {}

impl CDOTAUserMessage_RequestItemSuggestions {
    pub fn new() -> CDOTAUserMessage_RequestItemSuggestions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMessage_RequestItemSuggestions {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMessage_RequestItemSuggestions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMessage_RequestItemSuggestions,
        };
        unsafe {
            instance.get(CDOTAUserMessage_RequestItemSuggestions::new)
        }
    }

    // optional uint32 player_id = 1;

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    pub fn get_player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    fn get_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.player_id
    }

    fn mut_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.player_id
    }
}

impl ::protobuf::Message for CDOTAUserMessage_RequestItemSuggestions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMessage_RequestItemSuggestions {
    fn new() -> CDOTAUserMessage_RequestItemSuggestions {
        CDOTAUserMessage_RequestItemSuggestions::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMessage_RequestItemSuggestions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_id",
                    CDOTAUserMessage_RequestItemSuggestions::get_player_id_for_reflect,
                    CDOTAUserMessage_RequestItemSuggestions::mut_player_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMessage_RequestItemSuggestions>(
                    "CDOTAUserMessage_RequestItemSuggestions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMessage_RequestItemSuggestions {
    fn clear(&mut self) {
        self.clear_player_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMessage_RequestItemSuggestions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMessage_RequestItemSuggestions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMessage_TeamCaptainChanged {
    // message fields
    team: ::std::option::Option<u32>,
    captain_player_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMessage_TeamCaptainChanged {}

impl CDOTAUserMessage_TeamCaptainChanged {
    pub fn new() -> CDOTAUserMessage_TeamCaptainChanged {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMessage_TeamCaptainChanged {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMessage_TeamCaptainChanged> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMessage_TeamCaptainChanged,
        };
        unsafe {
            instance.get(CDOTAUserMessage_TeamCaptainChanged::new)
        }
    }

    // optional uint32 team = 1;

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    pub fn get_team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    fn get_team_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.team
    }

    fn mut_team_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.team
    }

    // optional uint32 captain_player_id = 2;

    pub fn clear_captain_player_id(&mut self) {
        self.captain_player_id = ::std::option::Option::None;
    }

    pub fn has_captain_player_id(&self) -> bool {
        self.captain_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_captain_player_id(&mut self, v: u32) {
        self.captain_player_id = ::std::option::Option::Some(v);
    }

    pub fn get_captain_player_id(&self) -> u32 {
        self.captain_player_id.unwrap_or(0)
    }

    fn get_captain_player_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.captain_player_id
    }

    fn mut_captain_player_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.captain_player_id
    }
}

impl ::protobuf::Message for CDOTAUserMessage_TeamCaptainChanged {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.captain_player_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.captain_player_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.captain_player_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMessage_TeamCaptainChanged {
    fn new() -> CDOTAUserMessage_TeamCaptainChanged {
        CDOTAUserMessage_TeamCaptainChanged::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMessage_TeamCaptainChanged>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "team",
                    CDOTAUserMessage_TeamCaptainChanged::get_team_for_reflect,
                    CDOTAUserMessage_TeamCaptainChanged::mut_team_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "captain_player_id",
                    CDOTAUserMessage_TeamCaptainChanged::get_captain_player_id_for_reflect,
                    CDOTAUserMessage_TeamCaptainChanged::mut_captain_player_id_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMessage_TeamCaptainChanged>(
                    "CDOTAUserMessage_TeamCaptainChanged",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMessage_TeamCaptainChanged {
    fn clear(&mut self) {
        self.clear_team();
        self.clear_captain_player_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMessage_TeamCaptainChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMessage_TeamCaptainChanged {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDOTAUserMsg_ChatWheelCooldown {
    // message fields
    message_id: ::std::option::Option<u32>,
    cooldown_remaining: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CDOTAUserMsg_ChatWheelCooldown {}

impl CDOTAUserMsg_ChatWheelCooldown {
    pub fn new() -> CDOTAUserMsg_ChatWheelCooldown {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CDOTAUserMsg_ChatWheelCooldown {
        static mut instance: ::protobuf::lazy::Lazy<CDOTAUserMsg_ChatWheelCooldown> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CDOTAUserMsg_ChatWheelCooldown,
        };
        unsafe {
            instance.get(CDOTAUserMsg_ChatWheelCooldown::new)
        }
    }

    // optional uint32 message_id = 1;

    pub fn clear_message_id(&mut self) {
        self.message_id = ::std::option::Option::None;
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: u32) {
        self.message_id = ::std::option::Option::Some(v);
    }

    pub fn get_message_id(&self) -> u32 {
        self.message_id.unwrap_or(0)
    }

    fn get_message_id_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.message_id
    }

    fn mut_message_id_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.message_id
    }

    // optional float cooldown_remaining = 2;

    pub fn clear_cooldown_remaining(&mut self) {
        self.cooldown_remaining = ::std::option::Option::None;
    }

    pub fn has_cooldown_remaining(&self) -> bool {
        self.cooldown_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cooldown_remaining(&mut self, v: f32) {
        self.cooldown_remaining = ::std::option::Option::Some(v);
    }

    pub fn get_cooldown_remaining(&self) -> f32 {
        self.cooldown_remaining.unwrap_or(0.)
    }

    fn get_cooldown_remaining_for_reflect(&self) -> &::std::option::Option<f32> {
        &self.cooldown_remaining
    }

    fn mut_cooldown_remaining_for_reflect(&mut self) -> &mut ::std::option::Option<f32> {
        &mut self.cooldown_remaining
    }
}

impl ::protobuf::Message for CDOTAUserMsg_ChatWheelCooldown {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.message_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cooldown_remaining = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.message_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cooldown_remaining {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.message_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cooldown_remaining {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CDOTAUserMsg_ChatWheelCooldown {
    fn new() -> CDOTAUserMsg_ChatWheelCooldown {
        CDOTAUserMsg_ChatWheelCooldown::new()
    }

    fn descriptor_static(_: ::std::option::Option<CDOTAUserMsg_ChatWheelCooldown>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "message_id",
                    CDOTAUserMsg_ChatWheelCooldown::get_message_id_for_reflect,
                    CDOTAUserMsg_ChatWheelCooldown::mut_message_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "cooldown_remaining",
                    CDOTAUserMsg_ChatWheelCooldown::get_cooldown_remaining_for_reflect,
                    CDOTAUserMsg_ChatWheelCooldown::mut_cooldown_remaining_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CDOTAUserMsg_ChatWheelCooldown>(
                    "CDOTAUserMsg_ChatWheelCooldown",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CDOTAUserMsg_ChatWheelCooldown {
    fn clear(&mut self) {
        self.clear_message_id();
        self.clear_cooldown_remaining();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDOTAUserMsg_ChatWheelCooldown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDOTAUserMsg_ChatWheelCooldown {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EDotaUserMessages {
    DOTA_UM_AddUnitToSelection = 464,
    DOTA_UM_AIDebugLine = 465,
    DOTA_UM_ChatEvent = 466,
    DOTA_UM_CombatHeroPositions = 467,
    DOTA_UM_CombatLogData = 468,
    DOTA_UM_CombatLogShowDeath = 470,
    DOTA_UM_CreateLinearProjectile = 471,
    DOTA_UM_DestroyLinearProjectile = 472,
    DOTA_UM_DodgeTrackingProjectiles = 473,
    DOTA_UM_GlobalLightColor = 474,
    DOTA_UM_GlobalLightDirection = 475,
    DOTA_UM_InvalidCommand = 476,
    DOTA_UM_LocationPing = 477,
    DOTA_UM_MapLine = 478,
    DOTA_UM_MiniKillCamInfo = 479,
    DOTA_UM_MinimapDebugPoint = 480,
    DOTA_UM_MinimapEvent = 481,
    DOTA_UM_NevermoreRequiem = 482,
    DOTA_UM_OverheadEvent = 483,
    DOTA_UM_SetNextAutobuyItem = 484,
    DOTA_UM_SharedCooldown = 485,
    DOTA_UM_SpectatorPlayerClick = 486,
    DOTA_UM_TutorialTipInfo = 487,
    DOTA_UM_UnitEvent = 488,
    DOTA_UM_ParticleManager = 489,
    DOTA_UM_BotChat = 490,
    DOTA_UM_HudError = 491,
    DOTA_UM_ItemPurchased = 492,
    DOTA_UM_Ping = 493,
    DOTA_UM_ItemFound = 494,
    DOTA_UM_CharacterSpeakConcept = 495,
    DOTA_UM_SwapVerify = 496,
    DOTA_UM_WorldLine = 497,
    DOTA_UM_TournamentDrop = 498,
    DOTA_UM_ItemAlert = 499,
    DOTA_UM_HalloweenDrops = 500,
    DOTA_UM_ChatWheel = 501,
    DOTA_UM_ReceivedXmasGift = 502,
    DOTA_UM_UpdateSharedContent = 503,
    DOTA_UM_TutorialRequestExp = 504,
    DOTA_UM_TutorialPingMinimap = 505,
    DOTA_UM_GamerulesStateChanged = 506,
    DOTA_UM_ShowSurvey = 507,
    DOTA_UM_TutorialFade = 508,
    DOTA_UM_AddQuestLogEntry = 509,
    DOTA_UM_SendStatPopup = 510,
    DOTA_UM_TutorialFinish = 511,
    DOTA_UM_SendRoshanPopup = 512,
    DOTA_UM_SendGenericToolTip = 513,
    DOTA_UM_SendFinalGold = 514,
    DOTA_UM_CustomMsg = 515,
    DOTA_UM_CoachHUDPing = 516,
    DOTA_UM_ClientLoadGridNav = 517,
    DOTA_UM_TE_Projectile = 518,
    DOTA_UM_TE_ProjectileLoc = 519,
    DOTA_UM_TE_DotaBloodImpact = 520,
    DOTA_UM_TE_UnitAnimation = 521,
    DOTA_UM_TE_UnitAnimationEnd = 522,
    DOTA_UM_AbilityPing = 523,
    DOTA_UM_ShowGenericPopup = 524,
    DOTA_UM_VoteStart = 525,
    DOTA_UM_VoteUpdate = 526,
    DOTA_UM_VoteEnd = 527,
    DOTA_UM_BoosterState = 528,
    DOTA_UM_WillPurchaseAlert = 529,
    DOTA_UM_TutorialMinimapPosition = 530,
    DOTA_UM_PlayerMMR = 531,
    DOTA_UM_AbilitySteal = 532,
    DOTA_UM_CourierKilledAlert = 533,
    DOTA_UM_EnemyItemAlert = 534,
    DOTA_UM_StatsMatchDetails = 535,
    DOTA_UM_MiniTaunt = 536,
    DOTA_UM_BuyBackStateAlert = 537,
    DOTA_UM_SpeechBubble = 538,
    DOTA_UM_CustomHeaderMessage = 539,
    DOTA_UM_QuickBuyAlert = 540,
    DOTA_UM_StatsHeroDetails = 541,
    DOTA_UM_PredictionResult = 542,
    DOTA_UM_ModifierAlert = 543,
    DOTA_UM_HPManaAlert = 544,
    DOTA_UM_GlyphAlert = 545,
    DOTA_UM_BeastChat = 546,
    DOTA_UM_SpectatorPlayerUnitOrders = 547,
    DOTA_UM_CustomHudElement_Create = 548,
    DOTA_UM_CustomHudElement_Modify = 549,
    DOTA_UM_CustomHudElement_Destroy = 550,
    DOTA_UM_CompendiumState = 551,
    DOTA_UM_ProjectionAbility = 552,
    DOTA_UM_ProjectionEvent = 553,
    DOTA_UM_CombatLogDataHLTV = 554,
    DOTA_UM_XPAlert = 555,
    DOTA_UM_UpdateQuestProgress = 556,
    DOTA_UM_MatchMetadata = 557,
    DOTA_UM_MatchDetails = 558,
    DOTA_UM_QuestStatus = 559,
    DOTA_UM_SuggestHeroPick = 560,
    DOTA_UM_SuggestHeroRole = 561,
    DOTA_UM_KillcamDamageTaken = 562,
    DOTA_UM_SelectPenaltyGold = 563,
    DOTA_UM_RollDiceResult = 564,
    DOTA_UM_FlipCoinResult = 565,
    DOTA_UM_RequestItemSuggestions = 566,
    DOTA_UM_TeamCaptainChanged = 567,
    DOTA_UM_SendRoshanSpectatorPhase = 568,
    DOTA_UM_ChatWheelCooldown = 569,
    DOTA_UM_DismissAllStatPopups = 570,
}

impl ::protobuf::ProtobufEnum for EDotaUserMessages {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDotaUserMessages> {
        match value {
            464 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AddUnitToSelection),
            465 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AIDebugLine),
            466 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatEvent),
            467 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatHeroPositions),
            468 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatLogData),
            470 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatLogShowDeath),
            471 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CreateLinearProjectile),
            472 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DestroyLinearProjectile),
            473 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DodgeTrackingProjectiles),
            474 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GlobalLightColor),
            475 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GlobalLightDirection),
            476 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_InvalidCommand),
            477 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_LocationPing),
            478 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MapLine),
            479 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MiniKillCamInfo),
            480 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MinimapDebugPoint),
            481 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MinimapEvent),
            482 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_NevermoreRequiem),
            483 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_OverheadEvent),
            484 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SetNextAutobuyItem),
            485 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SharedCooldown),
            486 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SpectatorPlayerClick),
            487 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialTipInfo),
            488 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_UnitEvent),
            489 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ParticleManager),
            490 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BotChat),
            491 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HudError),
            492 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemPurchased),
            493 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_Ping),
            494 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemFound),
            495 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CharacterSpeakConcept),
            496 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SwapVerify),
            497 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WorldLine),
            498 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TournamentDrop),
            499 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ItemAlert),
            500 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HalloweenDrops),
            501 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatWheel),
            502 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ReceivedXmasGift),
            503 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_UpdateSharedContent),
            504 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialRequestExp),
            505 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialPingMinimap),
            506 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GamerulesStateChanged),
            507 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ShowSurvey),
            508 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialFade),
            509 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AddQuestLogEntry),
            510 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendStatPopup),
            511 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialFinish),
            512 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendRoshanPopup),
            513 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendGenericToolTip),
            514 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendFinalGold),
            515 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomMsg),
            516 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CoachHUDPing),
            517 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ClientLoadGridNav),
            518 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_Projectile),
            519 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_ProjectileLoc),
            520 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_DotaBloodImpact),
            521 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_UnitAnimation),
            522 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TE_UnitAnimationEnd),
            523 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AbilityPing),
            524 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ShowGenericPopup),
            525 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VoteStart),
            526 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VoteUpdate),
            527 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_VoteEnd),
            528 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BoosterState),
            529 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_WillPurchaseAlert),
            530 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TutorialMinimapPosition),
            531 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PlayerMMR),
            532 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_AbilitySteal),
            533 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CourierKilledAlert),
            534 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_EnemyItemAlert),
            535 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_StatsMatchDetails),
            536 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MiniTaunt),
            537 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BuyBackStateAlert),
            538 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SpeechBubble),
            539 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHeaderMessage),
            540 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QuickBuyAlert),
            541 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_StatsHeroDetails),
            542 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_PredictionResult),
            543 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ModifierAlert),
            544 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_HPManaAlert),
            545 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_GlyphAlert),
            546 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_BeastChat),
            547 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SpectatorPlayerUnitOrders),
            548 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHudElement_Create),
            549 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHudElement_Modify),
            550 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CustomHudElement_Destroy),
            551 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CompendiumState),
            552 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ProjectionAbility),
            553 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ProjectionEvent),
            554 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_CombatLogDataHLTV),
            555 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_XPAlert),
            556 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_UpdateQuestProgress),
            557 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MatchMetadata),
            558 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_MatchDetails),
            559 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_QuestStatus),
            560 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SuggestHeroPick),
            561 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SuggestHeroRole),
            562 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_KillcamDamageTaken),
            563 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SelectPenaltyGold),
            564 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RollDiceResult),
            565 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_FlipCoinResult),
            566 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_RequestItemSuggestions),
            567 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_TeamCaptainChanged),
            568 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_SendRoshanSpectatorPhase),
            569 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_ChatWheelCooldown),
            570 => ::std::option::Option::Some(EDotaUserMessages::DOTA_UM_DismissAllStatPopups),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EDotaUserMessages] = &[
            EDotaUserMessages::DOTA_UM_AddUnitToSelection,
            EDotaUserMessages::DOTA_UM_AIDebugLine,
            EDotaUserMessages::DOTA_UM_ChatEvent,
            EDotaUserMessages::DOTA_UM_CombatHeroPositions,
            EDotaUserMessages::DOTA_UM_CombatLogData,
            EDotaUserMessages::DOTA_UM_CombatLogShowDeath,
            EDotaUserMessages::DOTA_UM_CreateLinearProjectile,
            EDotaUserMessages::DOTA_UM_DestroyLinearProjectile,
            EDotaUserMessages::DOTA_UM_DodgeTrackingProjectiles,
            EDotaUserMessages::DOTA_UM_GlobalLightColor,
            EDotaUserMessages::DOTA_UM_GlobalLightDirection,
            EDotaUserMessages::DOTA_UM_InvalidCommand,
            EDotaUserMessages::DOTA_UM_LocationPing,
            EDotaUserMessages::DOTA_UM_MapLine,
            EDotaUserMessages::DOTA_UM_MiniKillCamInfo,
            EDotaUserMessages::DOTA_UM_MinimapDebugPoint,
            EDotaUserMessages::DOTA_UM_MinimapEvent,
            EDotaUserMessages::DOTA_UM_NevermoreRequiem,
            EDotaUserMessages::DOTA_UM_OverheadEvent,
            EDotaUserMessages::DOTA_UM_SetNextAutobuyItem,
            EDotaUserMessages::DOTA_UM_SharedCooldown,
            EDotaUserMessages::DOTA_UM_SpectatorPlayerClick,
            EDotaUserMessages::DOTA_UM_TutorialTipInfo,
            EDotaUserMessages::DOTA_UM_UnitEvent,
            EDotaUserMessages::DOTA_UM_ParticleManager,
            EDotaUserMessages::DOTA_UM_BotChat,
            EDotaUserMessages::DOTA_UM_HudError,
            EDotaUserMessages::DOTA_UM_ItemPurchased,
            EDotaUserMessages::DOTA_UM_Ping,
            EDotaUserMessages::DOTA_UM_ItemFound,
            EDotaUserMessages::DOTA_UM_CharacterSpeakConcept,
            EDotaUserMessages::DOTA_UM_SwapVerify,
            EDotaUserMessages::DOTA_UM_WorldLine,
            EDotaUserMessages::DOTA_UM_TournamentDrop,
            EDotaUserMessages::DOTA_UM_ItemAlert,
            EDotaUserMessages::DOTA_UM_HalloweenDrops,
            EDotaUserMessages::DOTA_UM_ChatWheel,
            EDotaUserMessages::DOTA_UM_ReceivedXmasGift,
            EDotaUserMessages::DOTA_UM_UpdateSharedContent,
            EDotaUserMessages::DOTA_UM_TutorialRequestExp,
            EDotaUserMessages::DOTA_UM_TutorialPingMinimap,
            EDotaUserMessages::DOTA_UM_GamerulesStateChanged,
            EDotaUserMessages::DOTA_UM_ShowSurvey,
            EDotaUserMessages::DOTA_UM_TutorialFade,
            EDotaUserMessages::DOTA_UM_AddQuestLogEntry,
            EDotaUserMessages::DOTA_UM_SendStatPopup,
            EDotaUserMessages::DOTA_UM_TutorialFinish,
            EDotaUserMessages::DOTA_UM_SendRoshanPopup,
            EDotaUserMessages::DOTA_UM_SendGenericToolTip,
            EDotaUserMessages::DOTA_UM_SendFinalGold,
            EDotaUserMessages::DOTA_UM_CustomMsg,
            EDotaUserMessages::DOTA_UM_CoachHUDPing,
            EDotaUserMessages::DOTA_UM_ClientLoadGridNav,
            EDotaUserMessages::DOTA_UM_TE_Projectile,
            EDotaUserMessages::DOTA_UM_TE_ProjectileLoc,
            EDotaUserMessages::DOTA_UM_TE_DotaBloodImpact,
            EDotaUserMessages::DOTA_UM_TE_UnitAnimation,
            EDotaUserMessages::DOTA_UM_TE_UnitAnimationEnd,
            EDotaUserMessages::DOTA_UM_AbilityPing,
            EDotaUserMessages::DOTA_UM_ShowGenericPopup,
            EDotaUserMessages::DOTA_UM_VoteStart,
            EDotaUserMessages::DOTA_UM_VoteUpdate,
            EDotaUserMessages::DOTA_UM_VoteEnd,
            EDotaUserMessages::DOTA_UM_BoosterState,
            EDotaUserMessages::DOTA_UM_WillPurchaseAlert,
            EDotaUserMessages::DOTA_UM_TutorialMinimapPosition,
            EDotaUserMessages::DOTA_UM_PlayerMMR,
            EDotaUserMessages::DOTA_UM_AbilitySteal,
            EDotaUserMessages::DOTA_UM_CourierKilledAlert,
            EDotaUserMessages::DOTA_UM_EnemyItemAlert,
            EDotaUserMessages::DOTA_UM_StatsMatchDetails,
            EDotaUserMessages::DOTA_UM_MiniTaunt,
            EDotaUserMessages::DOTA_UM_BuyBackStateAlert,
            EDotaUserMessages::DOTA_UM_SpeechBubble,
            EDotaUserMessages::DOTA_UM_CustomHeaderMessage,
            EDotaUserMessages::DOTA_UM_QuickBuyAlert,
            EDotaUserMessages::DOTA_UM_StatsHeroDetails,
            EDotaUserMessages::DOTA_UM_PredictionResult,
            EDotaUserMessages::DOTA_UM_ModifierAlert,
            EDotaUserMessages::DOTA_UM_HPManaAlert,
            EDotaUserMessages::DOTA_UM_GlyphAlert,
            EDotaUserMessages::DOTA_UM_BeastChat,
            EDotaUserMessages::DOTA_UM_SpectatorPlayerUnitOrders,
            EDotaUserMessages::DOTA_UM_CustomHudElement_Create,
            EDotaUserMessages::DOTA_UM_CustomHudElement_Modify,
            EDotaUserMessages::DOTA_UM_CustomHudElement_Destroy,
            EDotaUserMessages::DOTA_UM_CompendiumState,
            EDotaUserMessages::DOTA_UM_ProjectionAbility,
            EDotaUserMessages::DOTA_UM_ProjectionEvent,
            EDotaUserMessages::DOTA_UM_CombatLogDataHLTV,
            EDotaUserMessages::DOTA_UM_XPAlert,
            EDotaUserMessages::DOTA_UM_UpdateQuestProgress,
            EDotaUserMessages::DOTA_UM_MatchMetadata,
            EDotaUserMessages::DOTA_UM_MatchDetails,
            EDotaUserMessages::DOTA_UM_QuestStatus,
            EDotaUserMessages::DOTA_UM_SuggestHeroPick,
            EDotaUserMessages::DOTA_UM_SuggestHeroRole,
            EDotaUserMessages::DOTA_UM_KillcamDamageTaken,
            EDotaUserMessages::DOTA_UM_SelectPenaltyGold,
            EDotaUserMessages::DOTA_UM_RollDiceResult,
            EDotaUserMessages::DOTA_UM_FlipCoinResult,
            EDotaUserMessages::DOTA_UM_RequestItemSuggestions,
            EDotaUserMessages::DOTA_UM_TeamCaptainChanged,
            EDotaUserMessages::DOTA_UM_SendRoshanSpectatorPhase,
            EDotaUserMessages::DOTA_UM_ChatWheelCooldown,
            EDotaUserMessages::DOTA_UM_DismissAllStatPopups,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EDotaUserMessages>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EDotaUserMessages", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EDotaUserMessages {
}

impl ::protobuf::reflect::ProtobufValue for EDotaUserMessages {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DOTA_CHAT_MESSAGE {
    CHAT_MESSAGE_INVALID = -1,
    CHAT_MESSAGE_HERO_KILL = 0,
    CHAT_MESSAGE_HERO_DENY = 1,
    CHAT_MESSAGE_BARRACKS_KILL = 2,
    CHAT_MESSAGE_TOWER_KILL = 3,
    CHAT_MESSAGE_TOWER_DENY = 4,
    CHAT_MESSAGE_FIRSTBLOOD = 5,
    CHAT_MESSAGE_STREAK_KILL = 6,
    CHAT_MESSAGE_BUYBACK = 7,
    CHAT_MESSAGE_AEGIS = 8,
    CHAT_MESSAGE_ROSHAN_KILL = 9,
    CHAT_MESSAGE_COURIER_LOST = 10,
    CHAT_MESSAGE_COURIER_RESPAWNED = 11,
    CHAT_MESSAGE_GLYPH_USED = 12,
    CHAT_MESSAGE_ITEM_PURCHASE = 13,
    CHAT_MESSAGE_CONNECT = 14,
    CHAT_MESSAGE_DISCONNECT = 15,
    CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT = 16,
    CHAT_MESSAGE_DISCONNECT_TIME_REMAINING = 17,
    CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL = 18,
    CHAT_MESSAGE_RECONNECT = 19,
    CHAT_MESSAGE_PLAYER_LEFT = 20,
    CHAT_MESSAGE_SAFE_TO_LEAVE = 21,
    CHAT_MESSAGE_RUNE_PICKUP = 22,
    CHAT_MESSAGE_RUNE_BOTTLE = 23,
    CHAT_MESSAGE_INTHEBAG = 24,
    CHAT_MESSAGE_SECRETSHOP = 25,
    CHAT_MESSAGE_ITEM_AUTOPURCHASED = 26,
    CHAT_MESSAGE_ITEMS_COMBINED = 27,
    CHAT_MESSAGE_SUPER_CREEPS = 28,
    CHAT_MESSAGE_CANT_USE_ACTION_ITEM = 29,
    CHAT_MESSAGE_CHARGES_EXHAUSTED = 30,
    CHAT_MESSAGE_CANTPAUSE = 31,
    CHAT_MESSAGE_NOPAUSESLEFT = 32,
    CHAT_MESSAGE_CANTPAUSEYET = 33,
    CHAT_MESSAGE_PAUSED = 34,
    CHAT_MESSAGE_UNPAUSE_COUNTDOWN = 35,
    CHAT_MESSAGE_UNPAUSED = 36,
    CHAT_MESSAGE_AUTO_UNPAUSED = 37,
    CHAT_MESSAGE_YOUPAUSED = 38,
    CHAT_MESSAGE_CANTUNPAUSETEAM = 39,
    CHAT_MESSAGE_VOICE_TEXT_BANNED = 41,
    CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME = 42,
    CHAT_MESSAGE_REPORT_REMINDER = 43,
    CHAT_MESSAGE_ECON_ITEM = 44,
    CHAT_MESSAGE_TAUNT = 45,
    CHAT_MESSAGE_RANDOM = 46,
    CHAT_MESSAGE_RD_TURN = 47,
    CHAT_MESSAGE_DROP_RATE_BONUS = 49,
    CHAT_MESSAGE_NO_BATTLE_POINTS = 50,
    CHAT_MESSAGE_DENIED_AEGIS = 51,
    CHAT_MESSAGE_INFORMATIONAL = 52,
    CHAT_MESSAGE_AEGIS_STOLEN = 53,
    CHAT_MESSAGE_ROSHAN_CANDY = 54,
    CHAT_MESSAGE_ITEM_GIFTED = 55,
    CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL = 56,
    CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED = 57,
    CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED = 58,
    CHAT_MESSAGE_HOLDOUT_WALL_FINISHED = 59,
    CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO = 62,
    CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION = 63,
    CHAT_MESSAGE_DISCONNECT_LIMITED_HERO = 64,
    CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION = 65,
    CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS = 66,
    CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE = 67,
    CHAT_MESSAGE_PLAYER_LEFT_AFK = 73,
    CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG = 74,
    CHAT_MESSAGE_PLAYER_ABANDONED = 75,
    CHAT_MESSAGE_PLAYER_ABANDONED_AFK = 76,
    CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG = 77,
    CHAT_MESSAGE_WILL_NOT_BE_SCORED = 78,
    CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED = 79,
    CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK = 80,
    CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED = 81,
    CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON = 82,
    CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS = 83,
    CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY = 84,
    CHAT_MESSAGE_COMPENDIUM_LEVEL = 85,
    CHAT_MESSAGE_VICTORY_PREDICTION_STREAK = 86,
    CHAT_MESSAGE_ASSASSIN_ANNOUNCE = 87,
    CHAT_MESSAGE_ASSASSIN_SUCCESS = 88,
    CHAT_MESSAGE_ASSASSIN_DENIED = 89,
    CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM = 90,
    CHAT_MESSAGE_EFFIGY_KILL = 91,
    CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW = 92,
    CHAT_MESSAGE_YEAR_BEAST_KILLED = 93,
    CHAT_MESSAGE_PAUSE_COUNTDOWN = 94,
    CHAT_MESSAGE_COINS_WAGERED = 95,
    CHAT_MESSAGE_HERO_NOMINATED_BAN = 96,
    CHAT_MESSAGE_HERO_BANNED = 97,
    CHAT_MESSAGE_HERO_BAN_COUNT = 98,
    CHAT_MESSAGE_RIVER_PAINTED = 99,
    CHAT_MESSAGE_SCAN_USED = 100,
    CHAT_MESSAGE_SHRINE_KILLED = 101,
    CHAT_MESSAGE_WAGER_TOKEN_SPENT = 102,
    CHAT_MESSAGE_RANK_WAGER = 103,
}

impl ::protobuf::ProtobufEnum for DOTA_CHAT_MESSAGE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_CHAT_MESSAGE> {
        match value {
            -1 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INVALID),
            0 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL),
            1 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_DENY),
            2 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BARRACKS_KILL),
            3 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_KILL),
            4 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_DENY),
            5 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FIRSTBLOOD),
            6 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_STREAK_KILL),
            7 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BUYBACK),
            8 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS),
            9 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_KILL),
            10 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_LOST),
            11 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_RESPAWNED),
            12 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_GLYPH_USED),
            13 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_PURCHASE),
            14 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CONNECT),
            15 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT),
            16 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT),
            17 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING),
            18 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL),
            19 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECONNECT),
            20 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT),
            21 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SAFE_TO_LEAVE),
            22 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_PICKUP),
            23 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_BOTTLE),
            24 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INTHEBAG),
            25 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SECRETSHOP),
            26 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_AUTOPURCHASED),
            27 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEMS_COMBINED),
            28 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SUPER_CREEPS),
            29 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANT_USE_ACTION_ITEM),
            30 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CHARGES_EXHAUSTED),
            31 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSE),
            32 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NOPAUSESLEFT),
            33 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSEYET),
            34 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSED),
            35 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSE_COUNTDOWN),
            36 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSED),
            37 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AUTO_UNPAUSED),
            38 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YOUPAUSED),
            39 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTUNPAUSETEAM),
            41 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED),
            42 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME),
            43 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_REPORT_REMINDER),
            44 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ECON_ITEM),
            45 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TAUNT),
            46 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANDOM),
            47 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RD_TURN),
            49 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DROP_RATE_BONUS),
            50 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NO_BATTLE_POINTS),
            51 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DENIED_AEGIS),
            52 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INFORMATIONAL),
            53 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS_STOLEN),
            54 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_CANDY),
            55 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_GIFTED),
            56 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL),
            57 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED),
            58 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED),
            59 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_FINISHED),
            62 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO),
            63 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION),
            64 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_LIMITED_HERO),
            65 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION),
            66 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS),
            67 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE),
            73 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_AFK),
            74 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG),
            75 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED),
            76 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_AFK),
            77 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG),
            78 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED),
            79 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED),
            80 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK),
            81 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED),
            82 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON),
            83 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS),
            84 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY),
            85 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COMPENDIUM_LEVEL),
            86 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_STREAK),
            87 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_ANNOUNCE),
            88 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_SUCCESS),
            89 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_DENIED),
            90 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM),
            91 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_EFFIGY_KILL),
            92 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW),
            93 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YEAR_BEAST_KILLED),
            94 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSE_COUNTDOWN),
            95 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COINS_WAGERED),
            96 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_NOMINATED_BAN),
            97 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BANNED),
            98 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BAN_COUNT),
            99 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RIVER_PAINTED),
            100 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SCAN_USED),
            101 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SHRINE_KILLED),
            102 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WAGER_TOKEN_SPENT),
            103 => ::std::option::Option::Some(DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANK_WAGER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DOTA_CHAT_MESSAGE] = &[
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INVALID,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_DENY,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BARRACKS_KILL,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_KILL,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TOWER_DENY,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FIRSTBLOOD,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_STREAK_KILL,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_BUYBACK,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_KILL,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_LOST,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COURIER_RESPAWNED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_GLYPH_USED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_PURCHASE,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CONNECT,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECONNECT,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SAFE_TO_LEAVE,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_PICKUP,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RUNE_BOTTLE,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INTHEBAG,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SECRETSHOP,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_AUTOPURCHASED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEMS_COMBINED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SUPER_CREEPS,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANT_USE_ACTION_ITEM,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CHARGES_EXHAUSTED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSE,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NOPAUSESLEFT,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTPAUSEYET,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSE_COUNTDOWN,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_UNPAUSED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AUTO_UNPAUSED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YOUPAUSED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CANTUNPAUSETEAM,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_REPORT_REMINDER,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ECON_ITEM,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_TAUNT,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANDOM,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RD_TURN,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DROP_RATE_BONUS,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_NO_BATTLE_POINTS,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DENIED_AEGIS,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_INFORMATIONAL,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_AEGIS_STOLEN,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ROSHAN_CANDY,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ITEM_GIFTED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HOLDOUT_WALL_FINISHED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_DISCONNECT_LIMITED_HERO,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_AFK,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_AFK,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COMPENDIUM_LEVEL,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_STREAK,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_ANNOUNCE,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_SUCCESS,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_ASSASSIN_DENIED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_EFFIGY_KILL,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_YEAR_BEAST_KILLED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_PAUSE_COUNTDOWN,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_COINS_WAGERED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_NOMINATED_BAN,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BANNED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_HERO_BAN_COUNT,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RIVER_PAINTED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SCAN_USED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_SHRINE_KILLED,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_WAGER_TOKEN_SPENT,
            DOTA_CHAT_MESSAGE::CHAT_MESSAGE_RANK_WAGER,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<DOTA_CHAT_MESSAGE>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DOTA_CHAT_MESSAGE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DOTA_CHAT_MESSAGE {
}

impl ::protobuf::reflect::ProtobufValue for DOTA_CHAT_MESSAGE {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DOTA_NO_BATTLE_POINTS_REASONS {
    NO_BATTLE_POINTS_WRONG_LOBBY_TYPE = 1,
    NO_BATTLE_POINTS_PRACTICE_BOTS = 2,
    NO_BATTLE_POINTS_CHEATS_ENABLED = 3,
    NO_BATTLE_POINTS_LOW_PRIORITY = 4,
}

impl ::protobuf::ProtobufEnum for DOTA_NO_BATTLE_POINTS_REASONS {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_NO_BATTLE_POINTS_REASONS> {
        match value {
            1 => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_WRONG_LOBBY_TYPE),
            2 => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_PRACTICE_BOTS),
            3 => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_CHEATS_ENABLED),
            4 => ::std::option::Option::Some(DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_LOW_PRIORITY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DOTA_NO_BATTLE_POINTS_REASONS] = &[
            DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_WRONG_LOBBY_TYPE,
            DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_PRACTICE_BOTS,
            DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_CHEATS_ENABLED,
            DOTA_NO_BATTLE_POINTS_REASONS::NO_BATTLE_POINTS_LOW_PRIORITY,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<DOTA_NO_BATTLE_POINTS_REASONS>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DOTA_NO_BATTLE_POINTS_REASONS", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DOTA_NO_BATTLE_POINTS_REASONS {
}

impl ::protobuf::reflect::ProtobufValue for DOTA_NO_BATTLE_POINTS_REASONS {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DOTA_CHAT_INFORMATIONAL {
    INFO_COOP_BATTLE_POINTS_RULES = 1,
    INFO_FROSTIVUS_ABANDON_REMINDER = 2,
    INFO_RANKED_REMINDER = 3,
    INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER = 4,
}

impl ::protobuf::ProtobufEnum for DOTA_CHAT_INFORMATIONAL {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_CHAT_INFORMATIONAL> {
        match value {
            1 => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_COOP_BATTLE_POINTS_RULES),
            2 => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_FROSTIVUS_ABANDON_REMINDER),
            3 => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_RANKED_REMINDER),
            4 => ::std::option::Option::Some(DOTA_CHAT_INFORMATIONAL::INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DOTA_CHAT_INFORMATIONAL] = &[
            DOTA_CHAT_INFORMATIONAL::INFO_COOP_BATTLE_POINTS_RULES,
            DOTA_CHAT_INFORMATIONAL::INFO_FROSTIVUS_ABANDON_REMINDER,
            DOTA_CHAT_INFORMATIONAL::INFO_RANKED_REMINDER,
            DOTA_CHAT_INFORMATIONAL::INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<DOTA_CHAT_INFORMATIONAL>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DOTA_CHAT_INFORMATIONAL", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DOTA_CHAT_INFORMATIONAL {
}

impl ::protobuf::reflect::ProtobufValue for DOTA_CHAT_INFORMATIONAL {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DOTA_ABILITY_PING_TYPE {
    ABILITY_PING_READY = 1,
    ABILITY_PING_MANA = 2,
    ABILITY_PING_COOLDOWN = 3,
    ABILITY_PING_ENEMY = 4,
    ABILITY_PING_UNLEARNED = 5,
    ABILITY_PING_INBACKPACK = 6,
}

impl ::protobuf::ProtobufEnum for DOTA_ABILITY_PING_TYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_ABILITY_PING_TYPE> {
        match value {
            1 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_READY),
            2 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_MANA),
            3 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_COOLDOWN),
            4 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_ENEMY),
            5 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_UNLEARNED),
            6 => ::std::option::Option::Some(DOTA_ABILITY_PING_TYPE::ABILITY_PING_INBACKPACK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DOTA_ABILITY_PING_TYPE] = &[
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_READY,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_MANA,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_COOLDOWN,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_ENEMY,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_UNLEARNED,
            DOTA_ABILITY_PING_TYPE::ABILITY_PING_INBACKPACK,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<DOTA_ABILITY_PING_TYPE>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DOTA_ABILITY_PING_TYPE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DOTA_ABILITY_PING_TYPE {
}

impl ::protobuf::reflect::ProtobufValue for DOTA_ABILITY_PING_TYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DOTA_REPLAY_STATE_EVENT {
    DOTA_REPLAY_STATE_EVENT_GAME_START = 1,
    DOTA_REPLAY_STATE_EVENT_STARTING_HORN = 2,
    DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD = 3,
    DOTA_REPLAY_STATE_EVENT_SHOWCASE = 4,
}

impl ::protobuf::ProtobufEnum for DOTA_REPLAY_STATE_EVENT {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_REPLAY_STATE_EVENT> {
        match value {
            1 => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_GAME_START),
            2 => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_STARTING_HORN),
            3 => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD),
            4 => ::std::option::Option::Some(DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_SHOWCASE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DOTA_REPLAY_STATE_EVENT] = &[
            DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_GAME_START,
            DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_STARTING_HORN,
            DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD,
            DOTA_REPLAY_STATE_EVENT::DOTA_REPLAY_STATE_EVENT_SHOWCASE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<DOTA_REPLAY_STATE_EVENT>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DOTA_REPLAY_STATE_EVENT", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DOTA_REPLAY_STATE_EVENT {
}

impl ::protobuf::reflect::ProtobufValue for DOTA_REPLAY_STATE_EVENT {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EDotaEntityMessages {
    DOTA_UNIT_SPEECH = 0,
    DOTA_UNIT_SPEECH_MUTE = 1,
    DOTA_UNIT_ADD_GESTURE = 2,
    DOTA_UNIT_REMOVE_GESTURE = 3,
    DOTA_UNIT_REMOVE_ALL_GESTURES = 4,
    DOTA_UNIT_FADE_GESTURE = 6,
    DOTA_UNIT_SPEECH_CLIENTSIDE_RULES = 7,
}

impl ::protobuf::ProtobufEnum for EDotaEntityMessages {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDotaEntityMessages> {
        match value {
            0 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_SPEECH),
            1 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_SPEECH_MUTE),
            2 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_ADD_GESTURE),
            3 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_REMOVE_GESTURE),
            4 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_REMOVE_ALL_GESTURES),
            6 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_FADE_GESTURE),
            7 => ::std::option::Option::Some(EDotaEntityMessages::DOTA_UNIT_SPEECH_CLIENTSIDE_RULES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EDotaEntityMessages] = &[
            EDotaEntityMessages::DOTA_UNIT_SPEECH,
            EDotaEntityMessages::DOTA_UNIT_SPEECH_MUTE,
            EDotaEntityMessages::DOTA_UNIT_ADD_GESTURE,
            EDotaEntityMessages::DOTA_UNIT_REMOVE_GESTURE,
            EDotaEntityMessages::DOTA_UNIT_REMOVE_ALL_GESTURES,
            EDotaEntityMessages::DOTA_UNIT_FADE_GESTURE,
            EDotaEntityMessages::DOTA_UNIT_SPEECH_CLIENTSIDE_RULES,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EDotaEntityMessages>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EDotaEntityMessages", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EDotaEntityMessages {
}

impl ::protobuf::reflect::ProtobufValue for EDotaEntityMessages {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DOTA_PARTICLE_MESSAGE {
    DOTA_PARTICLE_MANAGER_EVENT_CREATE = 0,
    DOTA_PARTICLE_MANAGER_EVENT_UPDATE = 1,
    DOTA_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD = 2,
    DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION = 3,
    DOTA_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK = 4,
    DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ENT = 5,
    DOTA_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET = 6,
    DOTA_PARTICLE_MANAGER_EVENT_DESTROY = 7,
    DOTA_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING = 8,
    DOTA_PARTICLE_MANAGER_EVENT_RELEASE = 9,
    DOTA_PARTICLE_MANAGER_EVENT_LATENCY = 10,
    DOTA_PARTICLE_MANAGER_EVENT_SHOULD_DRAW = 11,
    DOTA_PARTICLE_MANAGER_EVENT_FROZEN = 12,
    DOTA_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT = 13,
    DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION = 14,
    DOTA_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES = 15,
    DOTA_PARTICLE_MANAGER_EVENT_SET_TEXT = 16,
}

impl ::protobuf::ProtobufEnum for DOTA_PARTICLE_MESSAGE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_PARTICLE_MESSAGE> {
        match value {
            0 => ::std::option::Option::Some(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_CREATE),
            1 => ::std::option::Option::Some(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_UPDATE),
            2 => ::std::option::Option::Some(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD),
            3 => ::std::option::Option::Some(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION),
            4 => ::std::option::Option::Some(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK),
            5 => ::std::option::Option::Some(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ENT),
            6 => ::std::option::Option::Some(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET),
            7 => ::std::option::Option::Some(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_DESTROY),
            8 => ::std::option::Option::Some(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING),
            9 => ::std::option::Option::Some(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_RELEASE),
            10 => ::std::option::Option::Some(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_LATENCY),
            11 => ::std::option::Option::Some(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_SHOULD_DRAW),
            12 => ::std::option::Option::Some(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_FROZEN),
            13 => ::std::option::Option::Some(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT),
            14 => ::std::option::Option::Some(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION),
            15 => ::std::option::Option::Some(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES),
            16 => ::std::option::Option::Some(DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_SET_TEXT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DOTA_PARTICLE_MESSAGE] = &[
            DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_CREATE,
            DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_UPDATE,
            DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD,
            DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION,
            DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK,
            DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ENT,
            DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET,
            DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_DESTROY,
            DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING,
            DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_RELEASE,
            DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_LATENCY,
            DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_SHOULD_DRAW,
            DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_FROZEN,
            DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT,
            DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION,
            DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES,
            DOTA_PARTICLE_MESSAGE::DOTA_PARTICLE_MANAGER_EVENT_SET_TEXT,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<DOTA_PARTICLE_MESSAGE>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DOTA_PARTICLE_MESSAGE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DOTA_PARTICLE_MESSAGE {
}

impl ::protobuf::reflect::ProtobufValue for DOTA_PARTICLE_MESSAGE {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DOTA_OVERHEAD_ALERT {
    OVERHEAD_ALERT_GOLD = 0,
    OVERHEAD_ALERT_DENY = 1,
    OVERHEAD_ALERT_CRITICAL = 2,
    OVERHEAD_ALERT_XP = 3,
    OVERHEAD_ALERT_BONUS_SPELL_DAMAGE = 4,
    OVERHEAD_ALERT_MISS = 5,
    OVERHEAD_ALERT_DAMAGE = 6,
    OVERHEAD_ALERT_EVADE = 7,
    OVERHEAD_ALERT_BLOCK = 8,
    OVERHEAD_ALERT_BONUS_POISON_DAMAGE = 9,
    OVERHEAD_ALERT_HEAL = 10,
    OVERHEAD_ALERT_MANA_ADD = 11,
    OVERHEAD_ALERT_MANA_LOSS = 12,
    OVERHEAD_ALERT_LAST_HIT_EARLY = 13,
    OVERHEAD_ALERT_LAST_HIT_CLOSE = 14,
    OVERHEAD_ALERT_LAST_HIT_MISS = 15,
    OVERHEAD_ALERT_MAGICAL_BLOCK = 16,
    OVERHEAD_ALERT_INCOMING_DAMAGE = 17,
    OVERHEAD_ALERT_OUTGOING_DAMAGE = 18,
    OVERHEAD_ALERT_DISABLE_RESIST = 19,
    OVERHEAD_ALERT_DEATH = 20,
}

impl ::protobuf::ProtobufEnum for DOTA_OVERHEAD_ALERT {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_OVERHEAD_ALERT> {
        match value {
            0 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_GOLD),
            1 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DENY),
            2 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_CRITICAL),
            3 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_XP),
            4 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BONUS_SPELL_DAMAGE),
            5 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MISS),
            6 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DAMAGE),
            7 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_EVADE),
            8 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BLOCK),
            9 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BONUS_POISON_DAMAGE),
            10 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_HEAL),
            11 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MANA_ADD),
            12 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MANA_LOSS),
            13 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_EARLY),
            14 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_CLOSE),
            15 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_MISS),
            16 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MAGICAL_BLOCK),
            17 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_INCOMING_DAMAGE),
            18 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_OUTGOING_DAMAGE),
            19 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DISABLE_RESIST),
            20 => ::std::option::Option::Some(DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DEATH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DOTA_OVERHEAD_ALERT] = &[
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_GOLD,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DENY,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_CRITICAL,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_XP,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BONUS_SPELL_DAMAGE,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MISS,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DAMAGE,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_EVADE,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BLOCK,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_BONUS_POISON_DAMAGE,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_HEAL,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MANA_ADD,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MANA_LOSS,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_EARLY,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_CLOSE,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_LAST_HIT_MISS,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_MAGICAL_BLOCK,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_INCOMING_DAMAGE,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_OUTGOING_DAMAGE,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DISABLE_RESIST,
            DOTA_OVERHEAD_ALERT::OVERHEAD_ALERT_DEATH,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<DOTA_OVERHEAD_ALERT>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DOTA_OVERHEAD_ALERT", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DOTA_OVERHEAD_ALERT {
}

impl ::protobuf::reflect::ProtobufValue for DOTA_OVERHEAD_ALERT {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DOTA_ROSHAN_PHASE {
    k_SRSP_ROSHAN_ALIVE = 0,
    k_SRSP_ROSHAN_BASE_TIMER = 1,
    k_SRSP_ROSHAN_VISIBLE_TIMER = 2,
}

impl ::protobuf::ProtobufEnum for DOTA_ROSHAN_PHASE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_ROSHAN_PHASE> {
        match value {
            0 => ::std::option::Option::Some(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_ALIVE),
            1 => ::std::option::Option::Some(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_BASE_TIMER),
            2 => ::std::option::Option::Some(DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_VISIBLE_TIMER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DOTA_ROSHAN_PHASE] = &[
            DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_ALIVE,
            DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_BASE_TIMER,
            DOTA_ROSHAN_PHASE::k_SRSP_ROSHAN_VISIBLE_TIMER,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<DOTA_ROSHAN_PHASE>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DOTA_ROSHAN_PHASE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DOTA_ROSHAN_PHASE {
}

impl ::protobuf::reflect::ProtobufValue for DOTA_ROSHAN_PHASE {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DOTA_POSITION_CATEGORY {
    DOTA_POSITION_NONE = 0,
    DOTA_POSITION_BOTTOM_LANE = 1,
    DOTA_POSITION_MID_LANE = 2,
    DOTA_POSITION_TOP_LANE = 3,
    DOTA_POSITION_RADIANT_JUNGLE = 4,
    DOTA_POSITION_DIRE_JUNGLE = 5,
    DOTA_POSITION_RADIANT_ANCIENTS = 6,
    DOTA_POSITION_DIRE_ANCIENTS = 7,
    DOTA_POSITION_RADIANT_SECRET_SHOP = 8,
    DOTA_POSITION_DIRE_SECRET_SHOP = 9,
    DOTA_POSITION_RIVER = 10,
    DOTA_POSITION_ROSHAN_PIT = 11,
    DOTA_POSITION_RADIANT_BASE = 12,
    DOTA_POSITION_DIRE_BASE = 13,
    DOTA_POSITION_FOUNTAIN = 14,
    DOTA_POSITION_OTHER = 15,
}

impl ::protobuf::ProtobufEnum for DOTA_POSITION_CATEGORY {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_POSITION_CATEGORY> {
        match value {
            0 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_NONE),
            1 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_BOTTOM_LANE),
            2 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_MID_LANE),
            3 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_TOP_LANE),
            4 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_JUNGLE),
            5 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_JUNGLE),
            6 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_ANCIENTS),
            7 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_ANCIENTS),
            8 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_SECRET_SHOP),
            9 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_SECRET_SHOP),
            10 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RIVER),
            11 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_ROSHAN_PIT),
            12 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_BASE),
            13 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_BASE),
            14 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_FOUNTAIN),
            15 => ::std::option::Option::Some(DOTA_POSITION_CATEGORY::DOTA_POSITION_OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DOTA_POSITION_CATEGORY] = &[
            DOTA_POSITION_CATEGORY::DOTA_POSITION_NONE,
            DOTA_POSITION_CATEGORY::DOTA_POSITION_BOTTOM_LANE,
            DOTA_POSITION_CATEGORY::DOTA_POSITION_MID_LANE,
            DOTA_POSITION_CATEGORY::DOTA_POSITION_TOP_LANE,
            DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_JUNGLE,
            DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_JUNGLE,
            DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_ANCIENTS,
            DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_ANCIENTS,
            DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_SECRET_SHOP,
            DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_SECRET_SHOP,
            DOTA_POSITION_CATEGORY::DOTA_POSITION_RIVER,
            DOTA_POSITION_CATEGORY::DOTA_POSITION_ROSHAN_PIT,
            DOTA_POSITION_CATEGORY::DOTA_POSITION_RADIANT_BASE,
            DOTA_POSITION_CATEGORY::DOTA_POSITION_DIRE_BASE,
            DOTA_POSITION_CATEGORY::DOTA_POSITION_FOUNTAIN,
            DOTA_POSITION_CATEGORY::DOTA_POSITION_OTHER,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<DOTA_POSITION_CATEGORY>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DOTA_POSITION_CATEGORY", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DOTA_POSITION_CATEGORY {
}

impl ::protobuf::reflect::ProtobufValue for DOTA_POSITION_CATEGORY {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DOTA_ABILITY_TARGET_TYPE {
    DOTA_ABILITY_TARGET_NONE = 0,
    DOTA_ABILITY_TARGET_SELF = 1,
    DOTA_ABILITY_TARGET_ALLY_HERO = 2,
    DOTA_ABILITY_TARGET_ALLY_CREEP = 3,
    DOTA_ABILITY_TARGET_ENEMY_HERO = 4,
    DOTA_ABILITY_TARGET_ENEMY_CREEP = 5,
}

impl ::protobuf::ProtobufEnum for DOTA_ABILITY_TARGET_TYPE {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_ABILITY_TARGET_TYPE> {
        match value {
            0 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_NONE),
            1 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_SELF),
            2 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ALLY_HERO),
            3 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ALLY_CREEP),
            4 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ENEMY_HERO),
            5 => ::std::option::Option::Some(DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ENEMY_CREEP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DOTA_ABILITY_TARGET_TYPE] = &[
            DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_NONE,
            DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_SELF,
            DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ALLY_HERO,
            DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ALLY_CREEP,
            DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ENEMY_HERO,
            DOTA_ABILITY_TARGET_TYPE::DOTA_ABILITY_TARGET_ENEMY_CREEP,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<DOTA_ABILITY_TARGET_TYPE>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DOTA_ABILITY_TARGET_TYPE", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DOTA_ABILITY_TARGET_TYPE {
}

impl ::protobuf::reflect::ProtobufValue for DOTA_ABILITY_TARGET_TYPE {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EHeroStatType {
    k_EHeroStatType_None = 0,
    k_EHeroStatType_AxeTotalDamage = 2000,
    k_EHeroStatType_BattleHungerDamage = 2001,
    k_EHeroStatType_CounterHelixDamage = 2002,
    k_EHeroStatType_CullingBladeDamage = 2003,
    k_EHeroStatType_BerserkersCallCastCount = 2004,
    k_EHeroStatType_BerserkersCallHeroesHitAverage = 2005,
    k_EHeroStatType_BerserkersCallOtherUnitsHit = 2006,
    k_EHeroStatType_BerserkersCallHeroAttacksTaken = 2007,
    k_EHeroStatType_BerserkersCallOtherAttacksTaken = 2008,
    k_EHeroStatType_BattleHungerCastCount = 2009,
    k_EHeroStatType_BattleHungerPotentialDuration = 2010,
    k_EHeroStatType_BattleHungerAverageDuration = 2011,
    k_EHeroStatType_CounterHelixProcCount = 2012,
    k_EHeroStatType_CounterHelixHeroProcCount = 2013,
    k_EHeroStatType_CounterHelixHeroesHitAverage = 2014,
    k_EHeroStatType_CounterHelixOtherUnitsHitCount = 2015,
    k_EHeroStatType_CullingBladeCastCount = 2016,
    k_EHeroStatType_CullingBladeKillCount = 2017,
    k_EHeroStatType_CullingBladeAverageHealthCulled = 2018,
    k_EHeroStatType_CullingBladeAverageDamageAvailable = 2019,
    k_EHeroStatType_CullingBladeHeroBuffAverage = 2020,
}

impl ::protobuf::ProtobufEnum for EHeroStatType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EHeroStatType> {
        match value {
            0 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_None),
            2000 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_AxeTotalDamage),
            2001 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerDamage),
            2002 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixDamage),
            2003 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeDamage),
            2004 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallCastCount),
            2005 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallHeroesHitAverage),
            2006 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallOtherUnitsHit),
            2007 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallHeroAttacksTaken),
            2008 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BerserkersCallOtherAttacksTaken),
            2009 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerCastCount),
            2010 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerPotentialDuration),
            2011 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_BattleHungerAverageDuration),
            2012 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixProcCount),
            2013 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixHeroProcCount),
            2014 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixHeroesHitAverage),
            2015 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CounterHelixOtherUnitsHitCount),
            2016 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeCastCount),
            2017 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeKillCount),
            2018 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeAverageHealthCulled),
            2019 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeAverageDamageAvailable),
            2020 => ::std::option::Option::Some(EHeroStatType::k_EHeroStatType_CullingBladeHeroBuffAverage),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EHeroStatType] = &[
            EHeroStatType::k_EHeroStatType_None,
            EHeroStatType::k_EHeroStatType_AxeTotalDamage,
            EHeroStatType::k_EHeroStatType_BattleHungerDamage,
            EHeroStatType::k_EHeroStatType_CounterHelixDamage,
            EHeroStatType::k_EHeroStatType_CullingBladeDamage,
            EHeroStatType::k_EHeroStatType_BerserkersCallCastCount,
            EHeroStatType::k_EHeroStatType_BerserkersCallHeroesHitAverage,
            EHeroStatType::k_EHeroStatType_BerserkersCallOtherUnitsHit,
            EHeroStatType::k_EHeroStatType_BerserkersCallHeroAttacksTaken,
            EHeroStatType::k_EHeroStatType_BerserkersCallOtherAttacksTaken,
            EHeroStatType::k_EHeroStatType_BattleHungerCastCount,
            EHeroStatType::k_EHeroStatType_BattleHungerPotentialDuration,
            EHeroStatType::k_EHeroStatType_BattleHungerAverageDuration,
            EHeroStatType::k_EHeroStatType_CounterHelixProcCount,
            EHeroStatType::k_EHeroStatType_CounterHelixHeroProcCount,
            EHeroStatType::k_EHeroStatType_CounterHelixHeroesHitAverage,
            EHeroStatType::k_EHeroStatType_CounterHelixOtherUnitsHitCount,
            EHeroStatType::k_EHeroStatType_CullingBladeCastCount,
            EHeroStatType::k_EHeroStatType_CullingBladeKillCount,
            EHeroStatType::k_EHeroStatType_CullingBladeAverageHealthCulled,
            EHeroStatType::k_EHeroStatType_CullingBladeAverageDamageAvailable,
            EHeroStatType::k_EHeroStatType_CullingBladeHeroBuffAverage,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EHeroStatType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EHeroStatType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EHeroStatType {
}

impl ::protobuf::reflect::ProtobufValue for EHeroStatType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EPlayerVoiceListenState {
    kPVLS_None = 0,
    kPVLS_DeniedChatBanned = 1,
    kPVLS_DeniedPartner = 2,
    kPVLS_DeniedHLTVTalkerNotSpectator = 3,
    kPVLS_DeniedHLTVNoTalkerPlayerID = 4,
    kPVLS_DeniedHLTVTalkerNotBroadcaster = 5,
    kPVLS_DeniedTeamSpectator = 6,
    kPVLS_DeniedStudent = 8,
    kPVLS_Denied = 64,
    kPVLS_AllowHLTVTalkerIsBroadcaster = 65,
    kPVLS_AllowCoBroadcaster = 66,
    kPVLS_AllowAllChat = 67,
    kPVLS_AllowStudentToCoach = 68,
    kPVLS_AllowFellowStudent = 69,
    kPVLS_AllowTalkerIsCoach = 70,
    kPVLS_AllowCoachHearTeam = 71,
    kPVLS_AllowSameTeam = 72,
    kPVLS_AllowShowcase = 73,
}

impl ::protobuf::ProtobufEnum for EPlayerVoiceListenState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPlayerVoiceListenState> {
        match value {
            0 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_None),
            1 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedChatBanned),
            2 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedPartner),
            3 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotSpectator),
            4 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedHLTVNoTalkerPlayerID),
            5 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotBroadcaster),
            6 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedTeamSpectator),
            8 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_DeniedStudent),
            64 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_Denied),
            65 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowHLTVTalkerIsBroadcaster),
            66 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowCoBroadcaster),
            67 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowAllChat),
            68 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowStudentToCoach),
            69 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowFellowStudent),
            70 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowTalkerIsCoach),
            71 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowCoachHearTeam),
            72 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowSameTeam),
            73 => ::std::option::Option::Some(EPlayerVoiceListenState::kPVLS_AllowShowcase),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EPlayerVoiceListenState] = &[
            EPlayerVoiceListenState::kPVLS_None,
            EPlayerVoiceListenState::kPVLS_DeniedChatBanned,
            EPlayerVoiceListenState::kPVLS_DeniedPartner,
            EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotSpectator,
            EPlayerVoiceListenState::kPVLS_DeniedHLTVNoTalkerPlayerID,
            EPlayerVoiceListenState::kPVLS_DeniedHLTVTalkerNotBroadcaster,
            EPlayerVoiceListenState::kPVLS_DeniedTeamSpectator,
            EPlayerVoiceListenState::kPVLS_DeniedStudent,
            EPlayerVoiceListenState::kPVLS_Denied,
            EPlayerVoiceListenState::kPVLS_AllowHLTVTalkerIsBroadcaster,
            EPlayerVoiceListenState::kPVLS_AllowCoBroadcaster,
            EPlayerVoiceListenState::kPVLS_AllowAllChat,
            EPlayerVoiceListenState::kPVLS_AllowStudentToCoach,
            EPlayerVoiceListenState::kPVLS_AllowFellowStudent,
            EPlayerVoiceListenState::kPVLS_AllowTalkerIsCoach,
            EPlayerVoiceListenState::kPVLS_AllowCoachHearTeam,
            EPlayerVoiceListenState::kPVLS_AllowSameTeam,
            EPlayerVoiceListenState::kPVLS_AllowShowcase,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EPlayerVoiceListenState>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EPlayerVoiceListenState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EPlayerVoiceListenState {
}

impl ::protobuf::reflect::ProtobufValue for EPlayerVoiceListenState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EProjectionEvent {
    ePE_FirstBlood = 0,
    ePE_Killstreak_godlike = 1,
}

impl ::protobuf::ProtobufEnum for EProjectionEvent {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProjectionEvent> {
        match value {
            0 => ::std::option::Option::Some(EProjectionEvent::ePE_FirstBlood),
            1 => ::std::option::Option::Some(EProjectionEvent::ePE_Killstreak_godlike),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EProjectionEvent] = &[
            EProjectionEvent::ePE_FirstBlood,
            EProjectionEvent::ePE_Killstreak_godlike,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EProjectionEvent>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EProjectionEvent", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EProjectionEvent {
}

impl ::protobuf::reflect::ProtobufValue for EProjectionEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17dota_usermessages.proto\x1a\x16networkbasetypes.proto\x1a\x19dota_\
    commonmessages.proto\"4\n\x18CDOTAUserMsg_AIDebugLine\x12\x18\n\x07messa\
    ge\x18\x01\x20\x01(\tR\x07message\";\n\x11CDOTAUserMsg_Ping\x12\x12\n\
    \x04ping\x18\x02\x20\x01(\rR\x04ping\x12\x12\n\x04loss\x18\x03\x20\x01(\
    \rR\x04loss\"6\n\x17CDOTAUserMsg_SwapVerify\x12\x1b\n\tplayer_id\x18\x01\
    \x20\x01(\rR\x08playerId\"\xee\x02\n\x16CDOTAUserMsg_ChatEvent\x12<\n\
    \x04type\x18\x01\x20\x02(\x0e2\x12.DOTA_CHAT_MESSAGE:\x14CHAT_MESSAGE_IN\
    VALIDR\x04type\x12\x14\n\x05value\x18\x02\x20\x01(\rR\x05value\x12!\n\np\
    layerid_1\x18\x03\x20\x01(\x11:\x02-1R\tplayerid1\x12!\n\nplayerid_2\x18\
    \x04\x20\x01(\x11:\x02-1R\tplayerid2\x12!\n\nplayerid_3\x18\x05\x20\x01(\
    \x11:\x02-1R\tplayerid3\x12!\n\nplayerid_4\x18\x06\x20\x01(\x11:\x02-1R\
    \tplayerid4\x12!\n\nplayerid_5\x18\x07\x20\x01(\x11:\x02-1R\tplayerid5\
    \x12!\n\nplayerid_6\x18\x08\x20\x01(\x11:\x02-1R\tplayerid6\x12\x16\n\
    \x06value2\x18\t\x20\x01(\rR\x06value2\x12\x16\n\x06value3\x18\n\x20\x01\
    (\rR\x06value3\"!\n\x1fCDOTAUserMsg_CombatLogShowDeath\"\x82\x01\n\x14CD\
    OTAUserMsg_BotChat\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\rR\x08playerId\
    \x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07message\x12\x16\n\x06target\
    \x18\x04\x20\x01(\tR\x06target\x12\x1b\n\tteam_only\x18\x05\x20\x01(\x08\
    R\x08teamOnly\"\x90\x01\n\x20CDOTAUserMsg_CombatHeroPositions\x12\x14\n\
    \x05index\x18\x01\x20\x01(\rR\x05index\x12\x12\n\x04time\x18\x02\x20\x01\
    (\x05R\x04time\x12*\n\tworld_pos\x18\x03\x20\x01(\x0b2\r.CMsgVector2DR\
    \x08worldPos\x12\x16\n\x06health\x18\x04\x20\x01(\x05R\x06health\"\xe0\
    \x02\n\x1cCDOTAUserMsg_MiniKillCamInfo\x12D\n\tattackers\x18\x01\x20\x03\
    (\x0b2&.CDOTAUserMsg_MiniKillCamInfo.AttackerR\tattackers\x1a\xf9\x01\n\
    \x08Attacker\x12\x1a\n\x08attacker\x18\x01\x20\x01(\rR\x08attacker\x12!\
    \n\x0ctotal_damage\x18\x02\x20\x01(\x05R\x0btotalDamage\x12L\n\tabilitie\
    s\x18\x03\x20\x03(\x0b2..CDOTAUserMsg_MiniKillCamInfo.Attacker.AbilityR\
    \tabilities\x12#\n\rattacker_name\x18\x04\x20\x01(\tR\x0cattackerName\
    \x1a;\n\x07Ability\x12\x18\n\x07ability\x18\x01\x20\x01(\rR\x07ability\
    \x12\x16\n\x06damage\x18\x02\x20\x01(\x05R\x06damage\"Q\n\x1dCDOTAUserMs\
    g_GlobalLightColor\x12\x14\n\x05color\x18\x01\x20\x01(\rR\x05color\x12\
    \x1a\n\x08duration\x18\x02\x20\x01(\x02R\x08duration\"j\n!CDOTAUserMsg_G\
    lobalLightDirection\x12)\n\tdirection\x18\x01\x20\x01(\x0b2\x0b.CMsgVect\
    orR\tdirection\x12\x1a\n\x08duration\x18\x02\x20\x01(\x02R\x08duration\"\
    u\n\x19CDOTAUserMsg_LocationPing\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\r\
    R\x08playerId\x12;\n\rlocation_ping\x18\x02\x20\x01(\x0b2\x16.CDOTAMsg_L\
    ocationPingR\x0clocationPing\"i\n\x16CDOTAUserMsg_ItemAlert\x12\x1b\n\tp\
    layer_id\x18\x01\x20\x01(\rR\x08playerId\x122\n\nitem_alert\x18\x02\x20\
    \x01(\x0b2\x13.CDOTAMsg_ItemAlertR\titemAlert\"\x99\x01\n\x1bCDOTAUserMs\
    g_EnemyItemAlert\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\rR\x08playerId\
    \x12(\n\x10target_player_id\x18\x02\x20\x01(\rR\x0etargetPlayerId\x12\
    \x16\n\x06itemid\x18\x03\x20\x01(\x05R\x06itemid\x12\x1b\n\trune_type\
    \x18\x04\x20\x01(\rR\x08runeType\"\xbf\x01\n\x1aCDOTAUserMsg_ModifierAle\
    rt\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\rR\x08playerId\x12\x1d\n\nclass\
    _name\x18\x02\x20\x01(\tR\tclassName\x12\x1f\n\x0bstack_count\x18\x03\
    \x20\x01(\rR\nstackCount\x12\x1b\n\tis_debuff\x18\x04\x20\x01(\x08R\x08i\
    sDebuff\x12'\n\x0ftarget_entindex\x18\x05\x20\x01(\rR\x0etargetEntindex\
    \"`\n\x18CDOTAUserMsg_HPManaAlert\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\
    \rR\x08playerId\x12'\n\x0ftarget_entindex\x18\x02\x20\x01(\rR\x0etargetE\
    ntindex\"R\n\x17CDOTAUserMsg_GlyphAlert\x12\x1b\n\tplayer_id\x18\x01\x20\
    \x01(\rR\x08playerId\x12\x1a\n\x08negative\x18\x02\x20\x01(\x08R\x08nega\
    tive\"\xae\x01\n\x1eCDOTAUserMsg_WillPurchaseAlert\x12\x16\n\x06itemid\
    \x18\x01\x20\x01(\x05R\x06itemid\x12\x1b\n\tplayer_id\x18\x02\x20\x01(\
    \x05R\x08playerId\x12%\n\x0egold_remaining\x18\x03\x20\x01(\rR\rgoldRema\
    ining\x120\n\x14suggestion_player_id\x18\x04\x20\x01(\x05R\x12suggestion\
    PlayerId\"=\n\x1eCDOTAUserMsg_BuyBackStateAlert\x12\x1b\n\tplayer_id\x18\
    \x01\x20\x01(\x05R\x08playerId\"v\n\x1aCDOTAUserMsg_QuickBuyAlert\x12\
    \x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\x12\x16\n\x06itemid\
    \x18\x02\x20\x01(\x05R\x06itemid\x12#\n\rgold_required\x18\x03\x20\x01(\
    \x05R\x0cgoldRequired\"\x9d\x02\n\x1fCDOTAUserMsg_CourierKilledAlert\x12\
    \x12\n\x04team\x18\x01\x20\x01(\rR\x04team\x12\x1d\n\ngold_value\x18\x02\
    \x20\x01(\rR\tgoldValue\x12#\n\rentity_handle\x18\x03\x20\x01(\x05R\x0ce\
    ntityHandle\x12\x1c\n\ttimestamp\x18\x04\x20\x01(\x05R\ttimestamp\x12H\n\
    \nlost_items\x18\x05\x20\x03(\x0b2).CDOTAUserMsg_CourierKilledAlert.Lost\
    ItemR\tlostItems\x1a:\n\x08LostItem\x12\x12\n\x04item\x18\x01\x20\x01(\
    \x05R\x04item\x12\x1a\n\x08quantity\x18\x02\x20\x01(\rR\x08quantity\"\
    \xc9\x01\n\x19CDOTAUserMsg_MinimapEvent\x12\x1d\n\nevent_type\x18\x01\
    \x20\x01(\x05R\teventType\x12#\n\rentity_handle\x18\x02\x20\x01(\x05R\
    \x0centityHandle\x12\x0c\n\x01x\x18\x03\x20\x01(\x05R\x01x\x12\x0c\n\x01\
    y\x18\x04\x20\x01(\x05R\x01y\x12\x1a\n\x08duration\x18\x05\x20\x01(\x05R\
    \x08duration\x120\n\x14target_entity_handle\x18\x06\x20\x01(\x05R\x12tar\
    getEntityHandle\"`\n\x14CDOTAUserMsg_MapLine\x12\x1b\n\tplayer_id\x18\
    \x01\x20\x01(\x05R\x08playerId\x12+\n\x07mapline\x18\x02\x20\x01(\x0b2\
    \x11.CDOTAMsg_MapLineR\x07mapline\"\xa5\x01\n\x1eCDOTAUserMsg_MinimapDeb\
    ugPoint\x12'\n\x08location\x18\x01\x20\x01(\x0b2\x0b.CMsgVectorR\x08loca\
    tion\x12\x14\n\x05color\x18\x02\x20\x01(\rR\x05color\x12\x12\n\x04size\
    \x18\x03\x20\x01(\x05R\x04size\x12\x1a\n\x08duration\x18\x04\x20\x01(\
    \x02R\x08duration\x12\x14\n\x05index\x18\x05\x20\x01(\x05R\x05index\"\
    \x87\x03\n#CDOTAUserMsg_CreateLinearProjectile\x12#\n\x06origin\x18\x01\
    \x20\x01(\x0b2\x0b.CMsgVectorR\x06origin\x12)\n\x08velocity\x18\x02\x20\
    \x01(\x0b2\r.CMsgVector2DR\x08velocity\x12\x1a\n\x08entindex\x18\x04\x20\
    \x01(\x05R\x08entindex\x12%\n\x0eparticle_index\x18\x05\x20\x01(\x04R\rp\
    articleIndex\x12\x16\n\x06handle\x18\x06\x20\x01(\x05R\x06handle\x121\n\
    \x0cacceleration\x18\x07\x20\x01(\x0b2\r.CMsgVector2DR\x0cacceleration\
    \x12\x1b\n\tmax_speed\x18\x08\x20\x01(\x02R\x08maxSpeed\x12\x1d\n\nfow_r\
    adius\x18\t\x20\x01(\x02R\tfowRadius\x12*\n\x11sticky_fow_reveal\x18\n\
    \x20\x01(\x08R\x0fstickyFowReveal\x12\x1a\n\x08distance\x18\x0b\x20\x01(\
    \x02R\x08distance\">\n$CDOTAUserMsg_DestroyLinearProjectile\x12\x16\n\
    \x06handle\x18\x01\x20\x01(\x05R\x06handle\"f\n%CDOTAUserMsg_DodgeTracki\
    ngProjectiles\x12\x1a\n\x08entindex\x18\x01\x20\x02(\x05R\x08entindex\
    \x12!\n\x0cattacks_only\x18\x02\x20\x01(\x08R\x0battacksOnly\"\x81\x01\n\
    !CDOTAUserMsg_SpectatorPlayerClick\x12\x1a\n\x08entindex\x18\x01\x20\x02\
    (\x05R\x08entindex\x12\x1d\n\norder_type\x18\x02\x20\x01(\x05R\torderTyp\
    e\x12!\n\x0ctarget_index\x18\x03\x20\x01(\x05R\x0btargetIndex\"\xa9\x02\
    \n&CDOTAUserMsg_SpectatorPlayerUnitOrders\x12\x1a\n\x08entindex\x18\x01\
    \x20\x01(\x05R\x08entindex\x12\x1d\n\norder_type\x18\x02\x20\x01(\x05R\t\
    orderType\x12\x14\n\x05units\x18\x03\x20\x03(\x05R\x05units\x12!\n\x0cta\
    rget_index\x18\x04\x20\x01(\x05R\x0btargetIndex\x12#\n\rability_index\
    \x18\x05\x20\x01(\x05R\x0cabilityIndex\x12'\n\x08position\x18\x06\x20\
    \x01(\x0b2\x0b.CMsgVectorR\x08position\x12\x14\n\x05queue\x18\x07\x20\
    \x01(\x08R\x05queue\x12'\n\x0fsequence_number\x18\x08\x20\x01(\x05R\x0es\
    equenceNumber\"\x99\x01\n\x1dCDOTAUserMsg_NevermoreRequiem\x12#\n\rentit\
    y_handle\x18\x01\x20\x01(\x05R\x0centityHandle\x12\x14\n\x05lines\x18\
    \x02\x20\x01(\x05R\x05lines\x12#\n\x06origin\x18\x03\x20\x01(\x0b2\x0b.C\
    MsgVectorR\x06origin\x12\x18\n\x07reverse\x18\x04\x20\x01(\x08R\x07rever\
    se\"7\n\x1bCDOTAUserMsg_InvalidCommand\x12\x18\n\x07message\x18\x01\x20\
    \x01(\tR\x07message\"2\n\x15CDOTAUserMsg_HudError\x12\x19\n\x08order_id\
    \x18\x01\x20\x01(\x05R\x07orderId\"\x88\x01\n\x1bCDOTAUserMsg_SharedCool\
    down\x12\x1a\n\x08entindex\x18\x01\x20\x01(\x05R\x08entindex\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\x12\x1a\n\x08cooldown\x18\x03\x20\
    \x01(\x02R\x08cooldown\x12\x1d\n\nname_index\x18\x04\x20\x01(\x05R\tname\
    Index\"5\n\x1fCDOTAUserMsg_SetNextAutobuyItem\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\"x\n\x1bCDOTAUserMsg_HalloweenDrops\x12\x1b\n\titem\
    _defs\x18\x01\x20\x03(\rR\x08itemDefs\x12\x1d\n\nplayer_ids\x18\x02\x20\
    \x03(\rR\tplayerIds\x12\x1d\n\nprize_list\x18\x03\x20\x01(\rR\tprizeList\
    \"\xf5\x03\n\x1dCDOTAUserMsg_PredictionResult\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12\x19\n\x08match_id\x18\x02\x20\x01(\x04R\
    \x07matchId\x12\x18\n\x07correct\x18\x03\x20\x01(\x08R\x07correct\x12K\n\
    \x0bpredictions\x18\x04\x20\x03(\x0b2).CDOTAUserMsg_PredictionResult.Pre\
    dictionR\x0bpredictions\x1a\xb2\x02\n\nPrediction\x12\x19\n\x08item_def\
    \x18\x01\x20\x01(\rR\x07itemDef\x12\x1f\n\x0bnum_correct\x18\x02\x20\x01\
    (\rR\nnumCorrect\x12\x1b\n\tnum_fails\x18\x03\x20\x01(\rR\x08numFails\
    \x12`\n\x06result\x18\x04\x20\x01(\x0e21.CDOTAUserMsg_PredictionResult.P\
    rediction.EResult:\x15k_eResult_ItemGrantedR\x06result\x12*\n\x11granted\
    _item_defs\x18\x06\x20\x03(\rR\x0fgrantedItemDefs\"=\n\x07EResult\x12\
    \x19\n\x15k_eResult_ItemGranted\x10\x01\x12\x17\n\x13k_eResult_Destroyed\
    \x10\x02\"\xaa\x02\n\x1cCDOTAResponseQuerySerialized\x128\n\x05facts\x18\
    \x01\x20\x03(\x0b2\".CDOTAResponseQuerySerialized.FactR\x05facts\x1a\xcf\
    \x01\n\x04Fact\x12\x10\n\x03key\x18\x01\x20\x02(\x05R\x03key\x12O\n\x07v\
    altype\x18\x02\x20\x02(\x0e2,.CDOTAResponseQuerySerialized.Fact.ValueTyp\
    e:\x07NUMERICR\x07valtype\x12\x1f\n\x0bval_numeric\x18\x03\x20\x01(\x02R\
    \nvalNumeric\x12\x1d\n\nval_string\x18\x04\x20\x01(\tR\tvalString\"$\n\t\
    ValueType\x12\x0b\n\x07NUMERIC\x10\x01\x12\n\n\x06STRING\x10\x02\"\xc3\
    \x01\n\x18CDOTASpeechMatchOnClient\x12\x18\n\x07concept\x18\x01\x20\x01(\
    \x05R\x07concept\x12%\n\x0erecipient_type\x18\x02\x20\x01(\x05R\rrecipie\
    ntType\x12C\n\rresponsequery\x18\x03\x20\x01(\x0b2\x1d.CDOTAResponseQuer\
    ySerializedR\rresponsequery\x12!\n\nrandomseed\x18\x04\x20\x01(\x0f:\x01\
    0R\nrandomseed\"\x8e\t\n\x16CDOTAUserMsg_UnitEvent\x12A\n\x08msg_type\
    \x18\x01\x20\x02(\x0e2\x14.EDotaEntityMessages:\x10DOTA_UNIT_SPEECHR\x07\
    msgType\x12!\n\x0centity_index\x18\x02\x20\x02(\x05R\x0bentityIndex\x126\
    \n\x06speech\x18\x03\x20\x01(\x0b2\x1e.CDOTAUserMsg_UnitEvent.SpeechR\
    \x06speech\x12C\n\x0bspeech_mute\x18\x04\x20\x01(\x0b2\".CDOTAUserMsg_Un\
    itEvent.SpeechMuteR\nspeechMute\x12C\n\x0badd_gesture\x18\x05\x20\x01(\
    \x0b2\".CDOTAUserMsg_UnitEvent.AddGestureR\naddGesture\x12L\n\x0eremove_\
    gesture\x18\x06\x20\x01(\x0b2%.CDOTAUserMsg_UnitEvent.RemoveGestureR\rre\
    moveGesture\x12F\n\x0cblood_impact\x18\x07\x20\x01(\x0b2#.CDOTAUserMsg_U\
    nitEvent.BloodImpactR\x0bbloodImpact\x12F\n\x0cfade_gesture\x18\x08\x20\
    \x01(\x0b2#.CDOTAUserMsg_UnitEvent.FadeGestureR\x0bfadeGesture\x12N\n\
    \x16speech_match_on_client\x18\t\x20\x01(\x0b2\x19.CDOTASpeechMatchOnCli\
    entR\x13speechMatchOnClient\x1a\x9e\x01\n\x06Speech\x12\x18\n\x07concept\
    \x18\x01\x20\x01(\x05R\x07concept\x12\x1a\n\x08response\x18\x02\x20\x01(\
    \tR\x08response\x12%\n\x0erecipient_type\x18\x03\x20\x01(\x05R\rrecipien\
    tType\x12\x14\n\x05level\x18\x04\x20\x01(\x05R\x05level\x12!\n\x08muteab\
    le\x18\x05\x20\x01(\x08:\x05falseR\x08muteable\x1a'\n\nSpeechMute\x12\
    \x19\n\x05delay\x18\x01\x20\x01(\x02:\x030.5R\x05delay\x1a\xa0\x01\n\nAd\
    dGesture\x12\x1a\n\x08activity\x18\x01\x20\x01(\x05R\x08activity\x12\x12\
    \n\x04slot\x18\x02\x20\x01(\x05R\x04slot\x12\x1a\n\x07fade_in\x18\x03\
    \x20\x01(\x02:\x010R\x06fadeIn\x12\x1e\n\x08fade_out\x18\x04\x20\x01(\
    \x02:\x030.1R\x07fadeOut\x12&\n\rplayback_rate\x18\x05\x20\x01(\x02:\x01\
    1R\x0cplaybackRate\x1a+\n\rRemoveGesture\x12\x1a\n\x08activity\x18\x01\
    \x20\x01(\x05R\x08activity\x1aY\n\x0bBloodImpact\x12\x14\n\x05scale\x18\
    \x01\x20\x01(\x05R\x05scale\x12\x19\n\x08x_normal\x18\x02\x20\x01(\x05R\
    \x07xNormal\x12\x19\n\x08y_normal\x18\x03\x20\x01(\x05R\x07yNormal\x1a)\
    \n\x0bFadeGesture\x12\x1a\n\x08activity\x18\x01\x20\x01(\x05R\x08activit\
    y\";\n\x1aCDOTAUserMsg_ItemPurchased\x12\x1d\n\nitem_index\x18\x01\x20\
    \x01(\x05R\titemIndex\"\x94\x01\n\x16CDOTAUserMsg_ItemFound\x12\x16\n\
    \x06player\x18\x01\x20\x01(\x05R\x06player\x12\x18\n\x07quality\x18\x02\
    \x20\x01(\x05R\x07quality\x12\x16\n\x06rarity\x18\x03\x20\x01(\x05R\x06r\
    arity\x12\x16\n\x06method\x18\x04\x20\x01(\x05R\x06method\x12\x18\n\x07i\
    temdef\x18\x05\x20\x01(\x05R\x07itemdef\"\xa6\x1c\n\x1cCDOTAUserMsg_Part\
    icleManager\x12N\n\x04type\x18\x01\x20\x02(\x0e2\x16.DOTA_PARTICLE_MESSA\
    GE:\"DOTA_PARTICLE_MANAGER_EVENT_CREATER\x04type\x12\x14\n\x05index\x18\
    \x02\x20\x02(\rR\x05index\x12h\n\x16release_particle_index\x18\x03\x20\
    \x01(\x0b22.CDOTAUserMsg_ParticleManager.ReleaseParticleIndexR\x14releas\
    eParticleIndex\x12U\n\x0fcreate_particle\x18\x04\x20\x01(\x0b2,.CDOTAUse\
    rMsg_ParticleManager.CreateParticleR\x0ecreateParticle\x12X\n\x10destroy\
    _particle\x18\x05\x20\x01(\x0b2-.CDOTAUserMsg_ParticleManager.DestroyPar\
    ticleR\x0fdestroyParticle\x12t\n\x1adestroy_particle_involving\x18\x06\
    \x20\x01(\x0b26.CDOTAUserMsg_ParticleManager.DestroyParticleInvolvingR\
    \x18destroyParticleInvolving\x12U\n\x0fupdate_particle\x18\x07\x20\x01(\
    \x0b2,.CDOTAUserMsg_ParticleManager.UpdateParticleR\x0eupdateParticle\
    \x12_\n\x13update_particle_fwd\x18\x08\x20\x01(\x0b2/.CDOTAUserMsg_Parti\
    cleManager.UpdateParticleFwdR\x11updateParticleFwd\x12h\n\x16update_part\
    icle_orient\x18\t\x20\x01(\x0b22.CDOTAUserMsg_ParticleManager.UpdatePart\
    icleOrientR\x14updateParticleOrient\x12n\n\x18update_particle_fallback\
    \x18\n\x20\x01(\x0b24.CDOTAUserMsg_ParticleManager.UpdateParticleFallbac\
    kR\x16updateParticleFallback\x12h\n\x16update_particle_offset\x18\x0b\
    \x20\x01(\x0b22.CDOTAUserMsg_ParticleManager.UpdateParticleOffsetR\x14up\
    dateParticleOffset\x12_\n\x13update_particle_ent\x18\x0c\x20\x01(\x0b2/.\
    CDOTAUserMsg_ParticleManager.UpdateParticleEntR\x11updateParticleEnt\x12\
    u\n\x1bupdate_particle_should_draw\x18\x0e\x20\x01(\x0b26.CDOTAUserMsg_P\
    articleManager.UpdateParticleShouldDrawR\x18updateParticleShouldDraw\x12\
    r\n\x1aupdate_particle_set_frozen\x18\x0f\x20\x01(\x0b25.CDOTAUserMsg_Pa\
    rticleManager.UpdateParticleSetFrozenR\x17updateParticleSetFrozen\x12\
    \x81\x01\n\x1fchange_control_point_attachment\x18\x10\x20\x01(\x0b2:.CDO\
    TAUserMsg_ParticleManager.ChangeControlPointAttachmentR\x1cchangeControl\
    PointAttachment\x12h\n\x16update_entity_position\x18\x11\x20\x01(\x0b22.\
    CDOTAUserMsg_ParticleManager.UpdateEntityPositionR\x14updateEntityPositi\
    on\x12u\n\x1bset_particle_fow_properties\x18\x12\x20\x01(\x0b26.CDOTAUse\
    rMsg_ParticleManager.SetParticleFoWPropertiesR\x18setParticleFowProperti\
    es\x12Y\n\x11set_particle_text\x18\x13\x20\x01(\x0b2-.CDOTAUserMsg_Parti\
    cleManager.SetParticleTextR\x0fsetParticleText\x1a\x16\n\x14ReleaseParti\
    cleIndex\x1a\xc5\x01\n\x0eCreateParticle\x12.\n\x13particle_name_index\
    \x18\x01\x20\x01(\x06R\x11particleNameIndex\x12\x1f\n\x0battach_type\x18\
    \x02\x20\x01(\x05R\nattachType\x12#\n\rentity_handle\x18\x03\x20\x01(\
    \x05R\x0centityHandle\x12=\n\x1bentity_handle_for_modifiers\x18\x04\x20\
    \x01(\x05R\x18entityHandleForModifiers\x1aB\n\x0fDestroyParticle\x12/\n\
    \x13destroy_immediately\x18\x01\x20\x01(\x08R\x12destroyImmediately\x1ap\
    \n\x18DestroyParticleInvolving\x12/\n\x13destroy_immediately\x18\x01\x20\
    \x01(\x08R\x12destroyImmediately\x12#\n\rentity_handle\x18\x03\x20\x01(\
    \x05R\x0centityHandle\x1a^\n\x0eUpdateParticle\x12#\n\rcontrol_point\x18\
    \x01\x20\x01(\x05R\x0ccontrolPoint\x12'\n\x08position\x18\x02\x20\x01(\
    \x0b2\x0b.CMsgVectorR\x08position\x1a_\n\x11UpdateParticleFwd\x12#\n\rco\
    ntrol_point\x18\x01\x20\x01(\x05R\x0ccontrolPoint\x12%\n\x07forward\x18\
    \x02\x20\x01(\x0b2\x0b.CMsgVectorR\x07forward\x1a\xa2\x01\n\x14UpdatePar\
    ticleOrient\x12#\n\rcontrol_point\x18\x01\x20\x01(\x05R\x0ccontrolPoint\
    \x12%\n\x07forward\x18\x02\x20\x01(\x0b2\x0b.CMsgVectorR\x07forward\x12!\
    \n\x05right\x18\x03\x20\x01(\x0b2\x0b.CMsgVectorR\x05right\x12\x1b\n\x02\
    up\x18\x04\x20\x01(\x0b2\x0b.CMsgVectorR\x02up\x1af\n\x16UpdateParticleF\
    allback\x12#\n\rcontrol_point\x18\x01\x20\x01(\x05R\x0ccontrolPoint\x12'\
    \n\x08position\x18\x02\x20\x01(\x0b2\x0b.CMsgVectorR\x08position\x1am\n\
    \x14UpdateParticleOffset\x12#\n\rcontrol_point\x18\x01\x20\x01(\x05R\x0c\
    controlPoint\x120\n\rorigin_offset\x18\x02\x20\x01(\x0b2\x0b.CMsgVectorR\
    \x0coriginOffset\x1a\x85\x02\n\x11UpdateParticleEnt\x12#\n\rcontrol_poin\
    t\x18\x01\x20\x01(\x05R\x0ccontrolPoint\x12#\n\rentity_handle\x18\x02\
    \x20\x01(\x05R\x0centityHandle\x12\x1f\n\x0battach_type\x18\x03\x20\x01(\
    \x05R\nattachType\x12\x1e\n\nattachment\x18\x04\x20\x01(\x05R\nattachmen\
    t\x128\n\x11fallback_position\x18\x05\x20\x01(\x0b2\x0b.CMsgVectorR\x10f\
    allbackPosition\x12+\n\x11include_wearables\x18\x06\x20\x01(\x08R\x10inc\
    ludeWearables\x1a8\n\x17UpdateParticleSetFrozen\x12\x1d\n\nset_frozen\
    \x18\x01\x20\x01(\x08R\tsetFrozen\x1a;\n\x18UpdateParticleShouldDraw\x12\
    \x1f\n\x0bshould_draw\x18\x01\x20\x01(\x08R\nshouldDraw\x1a\x91\x01\n\
    \x1cChangeControlPointAttachment\x12%\n\x0eattachment_old\x18\x01\x20\
    \x01(\x05R\rattachmentOld\x12%\n\x0eattachment_new\x18\x02\x20\x01(\x05R\
    \rattachmentNew\x12#\n\rentity_handle\x18\x03\x20\x01(\x05R\x0centityHan\
    dle\x1ad\n\x14UpdateEntityPosition\x12#\n\rentity_handle\x18\x01\x20\x01\
    (\x05R\x0centityHandle\x12'\n\x08position\x18\x02\x20\x01(\x0b2\x0b.CMsg\
    VectorR\x08position\x1a\x93\x01\n\x18SetParticleFoWProperties\x12*\n\x11\
    fow_control_point\x18\x01\x20\x01(\x05R\x0ffowControlPoint\x12,\n\x12fow\
    _control_point2\x18\x02\x20\x01(\x05R\x10fowControlPoint2\x12\x1d\n\nfow\
    _radius\x18\x03\x20\x01(\x02R\tfowRadius\x1a%\n\x0fSetParticleText\x12\
    \x12\n\x04text\x18\x01\x20\x01(\tR\x04text\"\x95\x02\n\x1aCDOTAUserMsg_O\
    verheadEvent\x12L\n\x0cmessage_type\x18\x01\x20\x02(\x0e2\x14.DOTA_OVERH\
    EAD_ALERT:\x13OVERHEAD_ALERT_GOLDR\x0bmessageType\x12\x14\n\x05value\x18\
    \x02\x20\x01(\x05R\x05value\x124\n\x16target_player_entindex\x18\x03\x20\
    \x01(\x05R\x14targetPlayerEntindex\x12'\n\x0ftarget_entindex\x18\x04\x20\
    \x01(\x05R\x0etargetEntindex\x124\n\x16source_player_entindex\x18\x05\
    \x20\x01(\x05R\x14sourcePlayerEntindex\"N\n\x1cCDOTAUserMsg_TutorialTipI\
    nfo\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1a\n\x08progress\
    \x18\x02\x20\x01(\x05R\x08progress\"}\n\x1bCDOTAUserMsg_TutorialFinish\
    \x12\x18\n\x07heading\x18\x01\x20\x01(\tR\x07heading\x12\x16\n\x06emblem\
    \x18\x02\x20\x01(\tR\x06emblem\x12\x12\n\x04body\x18\x03\x20\x01(\tR\x04\
    body\x12\x18\n\x07success\x18\x04\x20\x01(\x08R\x07success\"&\n$CDOTAUse\
    rMsg_TutorialMinimapPosition\"}\n\x1fCDOTAUserMsg_SendGenericToolTip\x12\
    \x14\n\x05title\x18\x01\x20\x01(\tR\x05title\x12\x12\n\x04text\x18\x02\
    \x20\x01(\tR\x04text\x12\x1a\n\x08entindex\x18\x03\x20\x01(\x05R\x08enti\
    ndex\x12\x14\n\x05close\x18\x04\x20\x01(\x08R\x05close\"h\n\x16CDOTAUser\
    Msg_WorldLine\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playerId\x12\
    1\n\tworldline\x18\x02\x20\x01(\x0b2\x13.CDOTAMsg_WorldLineR\tworldline\
    \"\xa0\x01\n\x16CDOTAUserMsg_ChatWheel\x12&\n\x0fchat_message_id\x18\x01\
    \x20\x01(\rR\rchatMessageId\x12\x1b\n\tplayer_id\x18\x02\x20\x01(\rR\x08\
    playerId\x12\x1d\n\naccount_id\x18\x03\x20\x01(\rR\taccountId\x12\"\n\rp\
    aram_hero_id\x18\x04\x20\x01(\rR\x0bparamHeroId\"\x80\x01\n\x1dCDOTAUser\
    Msg_ReceivedXmasGift\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08playe\
    rId\x12\x1b\n\titem_name\x18\x02\x20\x01(\tR\x08itemName\x12%\n\x0einven\
    tory_slot\x18\x03\x20\x01(\x05R\rinventorySlot\"\xf7\x01\n\x17CDOTAUserM\
    sg_ShowSurvey\x12\x1b\n\tsurvey_id\x18\x01\x20\x01(\x05R\x08surveyId\x12\
    \x19\n\x08match_id\x18\x02\x20\x01(\x04R\x07matchId\x12%\n\x0eresponse_s\
    tyle\x18\x03\x20\x01(\tR\rresponseStyle\x12(\n\x10teammate_hero_id\x18\
    \x04\x20\x01(\rR\x0eteammateHeroId\x12#\n\rteammate_name\x18\x05\x20\x01\
    (\tR\x0cteammateName\x12.\n\x13teammate_account_id\x18\x06\x20\x01(\rR\
    \x11teammateAccountId\"?\n\x20CDOTAUserMsg_UpdateSharedContent\x12\x1b\n\
    \tslot_type\x18\x01\x20\x01(\x05R\x08slotType\"!\n\x1fCDOTAUserMsg_Tutor\
    ialRequestExp\"8\n\x19CDOTAUserMsg_TutorialFade\x12\x1b\n\ttgt_alpha\x18\
    \x01\x20\x01(\x05R\x08tgtAlpha\"\xa1\x01\n\x20CDOTAUserMsg_TutorialPingM\
    inimap\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\rR\x08playerId\x12\x13\n\
    \x05pos_x\x18\x02\x20\x01(\x02R\x04posX\x12\x13\n\x05pos_y\x18\x03\x20\
    \x01(\x02R\x04posY\x12\x13\n\x05pos_z\x18\x04\x20\x01(\x02R\x04posZ\x12!\
    \n\x0centity_index\x18\x05\x20\x01(\x05R\x0bentityIndex\":\n\"CDOTAUserM\
    sg_GamerulesStateChanged\x12\x14\n\x05state\x18\x01\x20\x01(\rR\x05state\
    \"Y\n\x1dCDOTAUserMsg_AddQuestLogEntry\x12\x19\n\x08npc_name\x18\x01\x20\
    \x01(\tR\x07npcName\x12\x1d\n\nnpc_dialog\x18\x02\x20\x01(\tR\tnpcDialog\
    \"p\n\x1aCDOTAUserMsg_SendStatPopup\x12\x1b\n\tplayer_id\x18\x01\x20\x01\
    (\x05R\x08playerId\x125\n\tstatpopup\x18\x02\x20\x01(\x0b2\x17.CDOTAMsg_\
    SendStatPopupR\tstatpopup\"i\n!CDOTAUserMsg_DismissAllStatPopups\x12D\n\
    \rdismissallmsg\x18\x01\x20\x01(\x0b2\x1e.CDOTAMsg_DismissAllStatPopupsR\
    \rdismissallmsg\"\xb3\x01\n%CDOTAUserMsg_SendRoshanSpectatorPhase\x12=\n\
    \x05phase\x18\x01\x20\x01(\x0e2\x12.DOTA_ROSHAN_PHASE:\x13k_SRSP_ROSHAN_\
    ALIVER\x05phase\x12(\n\x10phase_start_time\x18\x02\x20\x01(\x05R\x0ephas\
    eStartTime\x12!\n\x0cphase_length\x18\x03\x20\x01(\x05R\x0bphaseLength\"\
    X\n\x1cCDOTAUserMsg_SendRoshanPopup\x12\x1c\n\treclaimed\x18\x01\x20\x01\
    (\x08R\treclaimed\x12\x1a\n\x08gametime\x18\x02\x20\x01(\x05R\x08gametim\
    e\"j\n\x1aCDOTAUserMsg_SendFinalGold\x12#\n\rreliable_gold\x18\x01\x20\
    \x03(\rR\x0creliableGold\x12'\n\x0funreliable_gold\x18\x02\x20\x03(\rR\
    \x0eunreliableGold\"e\n\x16CDOTAUserMsg_CustomMsg\x12\x18\n\x07message\
    \x18\x01\x20\x01(\tR\x07message\x12\x1b\n\tplayer_id\x18\x02\x20\x01(\
    \x05R\x08playerId\x12\x14\n\x05value\x18\x03\x20\x01(\x05R\x05value\"k\n\
    \x19CDOTAUserMsg_CoachHUDPing\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\rR\
    \x08playerId\x121\n\x08hud_ping\x18\x02\x20\x01(\x0b2\x16.CDOTAMsg_Coach\
    HUDPingR\x07hudPing\"\x20\n\x1eCDOTAUserMsg_ClientLoadGridNav\"\xb1\x03\
    \n\x1aCDOTAUserMsg_TE_Projectile\x12\x18\n\x07hSource\x18\x01\x20\x01(\
    \x05R\x07hSource\x12\x18\n\x07hTarget\x18\x02\x20\x01(\x05R\x07hTarget\
    \x12\x1c\n\tmoveSpeed\x18\x03\x20\x01(\x05R\tmoveSpeed\x12*\n\x10sourceA\
    ttachment\x18\x04\x20\x01(\x05R\x10sourceAttachment\x122\n\x14particleSy\
    stemHandle\x18\x05\x20\x01(\x03R\x14particleSystemHandle\x12\x1c\n\tdodg\
    eable\x18\x06\x20\x01(\x08R\tdodgeable\x12\x1a\n\x08isAttack\x18\x07\x20\
    \x01(\x08R\x08isAttack\x12\x1a\n\x08isEvaded\x18\x08\x20\x01(\x08R\x08is\
    Evaded\x12\x1e\n\nexpireTime\x18\t\x20\x01(\x02R\nexpireTime\x12$\n\rmax\
    impacttime\x18\n\x20\x01(\x02R\rmaximpacttime\x12$\n\rcolorgemcolor\x18\
    \x0b\x20\x01(\x07R\rcolorgemcolor\x12\x1f\n\x0blaunch_tick\x18\x0c\x20\
    \x01(\x05R\nlaunchTick\"\xa2\x03\n\x1dCDOTAUserMsg_TE_ProjectileLoc\x12+\
    \n\nvSourceLoc\x18\x01\x20\x01(\x0b2\x0b.CMsgVectorR\nvSourceLoc\x12\x18\
    \n\x07hTarget\x18\x02\x20\x01(\x05R\x07hTarget\x12\x1c\n\tmoveSpeed\x18\
    \x03\x20\x01(\x05R\tmoveSpeed\x122\n\x14particleSystemHandle\x18\x04\x20\
    \x01(\x03R\x14particleSystemHandle\x12\x1c\n\tdodgeable\x18\x05\x20\x01(\
    \x08R\tdodgeable\x12\x1a\n\x08isAttack\x18\x06\x20\x01(\x08R\x08isAttack\
    \x12\x1a\n\x08isEvaded\x18\x08\x20\x01(\x08R\x08isEvaded\x12\x1e\n\nexpi\
    reTime\x18\t\x20\x01(\x02R\nexpireTime\x12+\n\nvTargetLoc\x18\n\x20\x01(\
    \x0b2\x0b.CMsgVectorR\nvTargetLoc\x12$\n\rcolorgemcolor\x18\x0b\x20\x01(\
    \x07R\rcolorgemcolor\x12\x1f\n\x0blaunch_tick\x18\x0c\x20\x01(\x05R\nlau\
    nchTick\"\x83\x01\n\x1fCDOTAUserMsg_TE_DotaBloodImpact\x12\x16\n\x06enti\
    ty\x18\x01\x20\x01(\x05R\x06entity\x12\x14\n\x05scale\x18\x02\x20\x01(\
    \x02R\x05scale\x12\x18\n\x07xnormal\x18\x03\x20\x01(\x02R\x07xnormal\x12\
    \x18\n\x07ynormal\x18\x04\x20\x01(\x02R\x07ynormal\"\x93\x02\n\x18CDOTAU\
    serMsg_AbilityPing\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\rR\x08playerId\
    \x12\x1d\n\nability_id\x18\x02\x20\x01(\rR\tabilityId\x12?\n\x04type\x18\
    \x03\x20\x01(\x0e2\x17.DOTA_ABILITY_PING_TYPE:\x12ABILITY_PING_READYR\
    \x04type\x12)\n\x10cooldown_seconds\x18\x04\x20\x01(\rR\x0fcooldownSecon\
    ds\x12\x14\n\x05level\x18\x05\x20\x01(\rR\x05level\x12\x18\n\x07passive\
    \x18\x06\x20\x01(\x08R\x07passive\x12\x1f\n\x0bmana_needed\x18\x07\x20\
    \x01(\rR\nmanaNeeded\"\xd3\x01\n\x1dCDOTAUserMsg_TE_UnitAnimation\x12\
    \x16\n\x06entity\x18\x01\x20\x01(\x05R\x06entity\x12(\n\x0fsequenceVaria\
    nt\x18\x02\x20\x01(\x05R\x0fsequenceVariant\x12\"\n\x0cplaybackrate\x18\
    \x03\x20\x01(\x02R\x0cplaybackrate\x12\x1c\n\tcastpoint\x18\x04\x20\x01(\
    \x02R\tcastpoint\x12\x12\n\x04type\x18\x05\x20\x01(\x05R\x04type\x12\x1a\
    \n\x08activity\x18\x06\x20\x01(\x05R\x08activity\"N\n\x20CDOTAUserMsg_TE\
    _UnitAnimationEnd\x12\x16\n\x06entity\x18\x01\x20\x01(\x05R\x06entity\
    \x12\x12\n\x04snap\x18\x02\x20\x01(\x08R\x04snap\"\xcf\x01\n\x1dCDOTAUse\
    rMsg_ShowGenericPopup\x12\x16\n\x06header\x18\x01\x20\x02(\tR\x06header\
    \x12\x12\n\x04body\x18\x02\x20\x02(\tR\x04body\x12\x16\n\x06param1\x18\
    \x03\x20\x01(\tR\x06param1\x12\x16\n\x06param2\x18\x04\x20\x01(\tR\x06pa\
    ram2\x12\x1f\n\x0btint_screen\x18\x05\x20\x01(\x08R\ntintScreen\x121\n\
    \x15show_no_other_dialogs\x18\x06\x20\x01(\x08R\x12showNoOtherDialogs\"\
    \x87\x01\n\x16CDOTAUserMsg_VoteStart\x12\x14\n\x05title\x18\x01\x20\x01(\
    \tR\x05title\x12\x1a\n\x08duration\x18\x02\x20\x01(\x02R\x08duration\x12\
    !\n\x0cchoice_count\x18\x03\x20\x01(\x05R\x0bchoiceCount\x12\x18\n\x07ch\
    oices\x18\x04\x20\x03(\tR\x07choices\">\n\x17CDOTAUserMsg_VoteUpdate\x12\
    #\n\rchoice_counts\x18\x01\x20\x03(\x05R\x0cchoiceCounts\"?\n\x14CDOTAUs\
    erMsg_VoteEnd\x12'\n\x0fselected_choice\x18\x01\x20\x01(\x05R\x0eselecte\
    dChoice\"\xc8\x01\n\x1fCDOTAUserMsg_BoosterStatePlayer\x12\x1b\n\tplayer\
    _id\x18\x01\x20\x01(\rR\x08playerId\x12\x14\n\x05bonus\x18\x02\x20\x01(\
    \x02R\x05bonus\x12\x1f\n\x0bevent_bonus\x18\x03\x20\x01(\x02R\neventBonu\
    s\x12\"\n\rbonus_item_id\x18\x04\x20\x01(\rR\x0bbonusItemId\x12-\n\x13ev\
    ent_bonus_item_id\x18\x05\x20\x01(\rR\x10eventBonusItemId\"f\n\x19CDOTAU\
    serMsg_BoosterState\x12I\n\x0fboosted_players\x18\x01\x20\x03(\x0b2\x20.\
    CDOTAUserMsg_BoosterStatePlayerR\x0eboostedPlayers\".\n\x16CDOTAUserMsg_\
    PlayerMMR\x12\x14\n\x03mmr\x18\x01\x20\x03(\x11R\x03mmrB\x02\x10\x01\"|\
    \n\x19CDOTAUserMsg_AbilitySteal\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\rR\
    \x08playerId\x12\x1d\n\nability_id\x18\x02\x20\x01(\rR\tabilityId\x12#\n\
    \rability_level\x18\x03\x20\x01(\rR\x0cabilityLevel\"\x8b\x01\n\x1cCDOTA\
    UserMsg_StatsHeroLookup\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\x05R\x08pl\
    ayerId\x12\x17\n\x07hero_id\x18\x02\x20\x01(\x05R\x06heroId\x12\x1b\n\th\
    ero_name\x18\x03\x20\x01(\tR\x08heroName\x12\x18\n\x07persona\x18\x04\
    \x20\x01(\tR\x07persona\"\xbe\x02\n\"CDOTAUserMsg_StatsHeroPositionInfo\
    \x12)\n\x10average_position\x18\x01\x20\x01(\x02R\x0faveragePosition\x12\
    [\n\x10position_details\x18\x02\x20\x03(\x0b20.CDOTAUserMsg_StatsHeroPos\
    itionInfo.PositionPairR\x0fpositionDetails\x1a\x8f\x01\n\x0cPositionPair\
    \x12X\n\x11position_category\x18\x01\x20\x01(\x0e2\x17.DOTA_POSITION_CAT\
    EGORY:\x12DOTA_POSITION_NONER\x10positionCategory\x12%\n\x0eposition_cou\
    nt\x18\x02\x20\x01(\rR\rpositionCount\"\xcc\x04\n#CDOTAUserMsg_StatsHero\
    MinuteDetails\x12\x1b\n\tlast_hits\x18\x01\x20\x01(\rR\x08lastHits\x12\
    \x1d\n\nhero_kills\x18\x02\x20\x01(\rR\theroKills\x12\x1f\n\x0bhero_dama\
    ge\x18\x03\x20\x01(\rR\nheroDamage\x12!\n\x0ctower_damage\x18\x04\x20\
    \x01(\rR\x0btowerDamage\x12H\n\rposition_info\x18\x05\x20\x01(\x0b2#.CDO\
    TAUserMsg_StatsHeroPositionInfoR\x0cpositionInfo\x12\x19\n\x08total_xp\
    \x18\x06\x20\x01(\rR\x07totalXp\x12\x1b\n\tnet_worth\x18\x07\x20\x01(\rR\
    \x08netWorth\x120\n\x14harvested_creep_gold\x18\x08\x20\x01(\rR\x12harve\
    stedCreepGold\x12!\n\x0cclaimed_farm\x18\t\x20\x01(\rR\x0bclaimedFarm\
    \x12!\n\x0cwards_placed\x18\n\x20\x01(\rR\x0bwardsPlaced\x12'\n\x0frunes\
    _collected\x18\x0b\x20\x01(\rR\x0erunesCollected\x12\x19\n\x08tps_used\
    \x18\x0c\x20\x01(\rR\x07tpsUsed\x12\x1d\n\nmana_spent\x18\r\x20\x03(\rR\
    \tmanaSpent\x12'\n\x0fdamage_absorbed\x18\x0e\x20\x03(\rR\x0edamageAbsor\
    bed\x12\x1f\n\x0bdamage_done\x18\x0f\x20\x03(\rR\ndamageDone\"\xb7\x05\n\
    #CDOTAUserMsg_StatsTeamMinuteDetails\x12G\n\x0cplayer_stats\x18\x01\x20\
    \x03(\x0b2$.CDOTAUserMsg_StatsHeroMinuteDetailsR\x0bplayerStats\x12\x1f\
    \n\x0btower_kills\x18\x02\x20\x01(\rR\ntowerKills\x12#\n\rbarrack_kills\
    \x18\x03\x20\x01(\rR\x0cbarrackKills\x129\n\x19available_lane_creep_gold\
    \x18\x04\x20\x01(\rR\x16availableLaneCreepGold\x12,\n\x12balance_kill_va\
    lue\x18\x05\x20\x01(\rR\x10balanceKillValue\x12.\n\x13balance_tower_valu\
    e\x18\x06\x20\x01(\rR\x11balanceTowerValue\x124\n\x16balance_barracks_va\
    lue\x18\x07\x20\x01(\rR\x14balanceBarracksValue\x12,\n\x12balance_gold_v\
    alue\x18\x08\x20\x01(\rR\x10balanceGoldValue\x12(\n\x10balance_xp_value\
    \x18\t\x20\x01(\rR\x0ebalanceXpValue\x12c\n\x10lane_performance\x18\n\
    \x20\x03(\x0b28.CDOTAUserMsg_StatsTeamMinuteDetails.LocationPerformanceR\
    \x0flanePerformance\x1au\n\x13LocationPerformance\x12+\n\x11location_cat\
    egory\x18\x01\x20\x01(\rR\x10locationCategory\x12\x1b\n\tstat_type\x18\
    \x02\x20\x01(\rR\x08statType\x12\x14\n\x05value\x18\x03\x20\x01(\rR\x05v\
    alue\"\xfc\x01\n!CDOTAUserMsg_StatsPlayerKillShare\x12\x1b\n\tplayer_id\
    \x18\x01\x20\x01(\x05R\x08playerId\x12,\n\x12kill_share_percent\x18\x02\
    \x20\x01(\x02R\x10killSharePercent\x12\x20\n\x0cplayer_loc_x\x18\x03\x20\
    \x01(\x02R\nplayerLocX\x12\x20\n\x0cplayer_loc_y\x18\x04\x20\x01(\x02R\n\
    playerLocY\x12%\n\x0ehealth_percent\x18\x05\x20\x01(\x02R\rhealthPercent\
    \x12!\n\x0cmana_percent\x18\x06\x20\x01(\x02R\x0bmanaPercent\"\x8e\x02\n\
    \x1dCDOTAUserMsg_StatsKillDetails\x12\x1b\n\tvictim_id\x18\x01\x20\x01(\
    \rR\x08victimId\x12C\n\x0bkill_shares\x18\x02\x20\x03(\x0b2\".CDOTAUserM\
    sg_StatsPlayerKillShareR\nkillShares\x12$\n\x0edamage_to_kill\x18\x03\
    \x20\x01(\rR\x0cdamageToKill\x12)\n\x10effective_health\x18\x04\x20\x01(\
    \rR\x0feffectiveHealth\x12\x1d\n\ndeath_time\x18\x05\x20\x01(\x02R\tdeat\
    hTime\x12\x1b\n\tkiller_id\x18\x06\x20\x01(\rR\x08killerId\"\xbd\x07\n\
    \x1eCDOTAUserMsg_StatsMatchDetails\x12>\n\x0bhero_lookup\x18\x01\x20\x03\
    (\x0b2\x1d.CDOTAUserMsg_StatsHeroLookupR\nheroLookup\x12I\n\rradiant_sta\
    ts\x18\x02\x20\x03(\x0b2$.CDOTAUserMsg_StatsTeamMinuteDetailsR\x0cradian\
    tStats\x12C\n\ndire_stats\x18\x03\x20\x03(\x0b2$.CDOTAUserMsg_StatsTeamM\
    inuteDetailsR\tdireStats\x12C\n\rradiant_kills\x18\x04\x20\x03(\x0b2\x1e\
    .CDOTAUserMsg_StatsKillDetailsR\x0cradiantKills\x12=\n\ndire_kills\x18\
    \x05\x20\x03(\x0b2\x1e.CDOTAUserMsg_StatsKillDetailsR\tdireKills\x12c\n\
    \rfight_details\x18\x06\x20\x03(\x0b2>.CDOTAUserMsg_StatsMatchDetails.CD\
    OTAUserMsg_StatsFightDetailsR\x0cfightDetails\x1a\x9a\x01\n\"CDOTAUserMs\
    g_StatsFightTeamDetails\x12\"\n\x0cparticipants\x18\x01\x20\x03(\rR\x0cp\
    articipants\x12\x16\n\x06deaths\x18\x02\x20\x03(\rR\x06deaths\x12\x1d\n\
    \ngold_delta\x18\x03\x20\x01(\rR\tgoldDelta\x12\x19\n\x08xp_delta\x18\
    \x04\x20\x01(\rR\x07xpDelta\x1a\xc4\x02\n\x1eCDOTAUserMsg_StatsFightDeta\
    ils\x12\x1d\n\nstart_time\x18\x01\x20\x01(\x02R\tstartTime\x12\x19\n\x08\
    end_time\x18\x02\x20\x01(\x02R\x07endTime\x12v\n\x15radiant_fight_detail\
    s\x18\x03\x20\x01(\x0b2B.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_Sta\
    tsFightTeamDetailsR\x13radiantFightDetails\x12p\n\x12dire_fight_details\
    \x18\x04\x20\x01(\x0b2B.CDOTAUserMsg_StatsMatchDetails.CDOTAUserMsg_Stat\
    sFightTeamDetailsR\x10direFightDetails\"F\n\x16CDOTAUserMsg_MiniTaunt\
    \x12,\n\x12taunting_player_id\x18\x01\x20\x01(\rR\x10tauntingPlayerId\"<\
    \n\x19CDOTAUserMsg_SpeechBubble\x12\x1f\n\x0bdestroy_all\x18\x01\x20\x01\
    (\x08R\ndestroyAll\"\x8b\x01\n\x20CDOTAUserMsg_CustomHeaderMessage\x12\
    \x1b\n\tplayer_id\x18\x01\x20\x01(\rR\x08playerId\x12\x1a\n\x08duration\
    \x18\x02\x20\x01(\x02R\x08duration\x12\x18\n\x07message\x18\x03\x20\x01(\
    \tR\x07message\x12\x14\n\x05value\x18\x04\x20\x01(\x05R\x05value\"\x96\
    \x01\n\x13CMsgHeroAbilityStat\x12A\n\tstat_type\x18\x01\x20\x01(\x0e2\
    \x0e.EHeroStatType:\x14k_EHeroStatType_NoneR\x08statType\x12\x1b\n\tint_\
    value\x18\x02\x20\x01(\x05R\x08intValue\x12\x1f\n\x0bfloat_value\x18\x03\
    \x20\x01(\x02R\nfloatValue\"\x81\x01\n\x1cCMsgCombatAnalyzerPlayerStat\
    \x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12B\n\x12hero_abi\
    lity_stats\x18\x02\x20\x03(\x0b2\x14.CMsgHeroAbilityStatR\x10heroAbility\
    Stats\"v\n\x17CMsgCombatAnalyzerStats\x12\x19\n\x08match_id\x18\x01\x20\
    \x01(\x04R\x07matchId\x12@\n\x0cplayer_stats\x18\x02\x20\x03(\x0b2\x1d.C\
    MsgCombatAnalyzerPlayerStatR\x0bplayerStats\"v\n\x16CDOTAUserMsg_BeastCh\
    at\x12\x12\n\x04team\x18\x01\x20\x01(\rR\x04team\x12\x16\n\x06format\x18\
    \x02\x20\x01(\tR\x06format\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07m\
    essage\x12\x16\n\x06target\x18\x04\x20\x01(\tR\x06target\"\x82\x01\n$CDO\
    TAUserMsg_CustomHudElement_Create\x12\x1d\n\nelement_id\x18\x01\x20\x01(\
    \tR\telementId\x12'\n\x0flayout_filename\x18\x02\x20\x01(\tR\x0elayoutFi\
    lename\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\"\x80\x01\n$CDOTA\
    UserMsg_CustomHudElement_Modify\x12\x1d\n\nelement_id\x18\x01\x20\x01(\t\
    R\telementId\x12%\n\x0emodify_visible\x18\x02\x20\x01(\x08R\rmodifyVisib\
    le\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\"F\n%CDOTAUserMsg_Cus\
    tomHudElement_Destroy\x12\x1d\n\nelement_id\x18\x01\x20\x01(\tR\telement\
    Id\"W\n\"CDOTAUserMsg_CompendiumStatePlayer\x12\x1b\n\tplayer_id\x18\x01\
    \x20\x01(\rR\x08playerId\x12\x14\n\x05level\x18\x02\x20\x01(\rR\x05level\
    \"r\n\x1cCDOTAUserMsg_CompendiumState\x12R\n\x12compendium_players\x18\
    \x01\x20\x03(\x0b2#.CDOTAUserMsg_CompendiumStatePlayerR\x11compendiumPla\
    yers\"\xc1\x02\n\x1eCDOTAUserMsg_ProjectionAbility\x12\x1d\n\nability_id\
    \x18\x01\x20\x01(\rR\tabilityId\x12(\n\x10caster_ent_index\x18\x02\x20\
    \x01(\x05R\x0ecasterEntIndex\x12\x1f\n\x0bcaster_team\x18\x03\x20\x01(\
    \x05R\ncasterTeam\x12\x1f\n\x0bchannel_end\x18\x04\x20\x01(\x08R\nchanne\
    lEnd\x12#\n\x06origin\x18\x05\x20\x01(\x0b2\x0b.CMsgVectorR\x06origin\
    \x12*\n\x11track_caster_only\x18\x06\x20\x01(\x08R\x0ftrackCasterOnly\
    \x12\x19\n\x08end_time\x18\x07\x20\x01(\x02R\x07endTime\x12(\n\x10victim\
    _ent_index\x18\x08\x20\x01(\x05R\x0evictimEntIndex\"p\n\x1cCDOTAUserMsg_\
    ProjectionEvent\x12<\n\x08event_id\x18\x01\x20\x01(\x0e2\x11.EProjection\
    Event:\x0eePE_FirstBloodR\x07eventId\x12\x12\n\x04team\x18\x02\x20\x01(\
    \rR\x04team\"\\\n\x14CDOTAUserMsg_XPAlert\x12\x1b\n\tplayer_id\x18\x01\
    \x20\x01(\rR\x08playerId\x12'\n\x0ftarget_entindex\x18\x02\x20\x01(\rR\
    \x0etargetEntindex\"\"\n\x20CDOTAUserMsg_UpdateQuestProgress\"\xf9\x01\n\
    \x18CDOTAUserMsg_QuestStatus\x12\x1b\n\tplayer_id\x18\x01\x20\x02(\rR\
    \x08playerId\x12\x19\n\x08quest_id\x18\x02\x20\x01(\rR\x07questId\x12!\n\
    \x0cchallenge_id\x18\x03\x20\x01(\rR\x0bchallengeId\x12\x1a\n\x08progres\
    s\x18\x04\x20\x01(\rR\x08progress\x12\x12\n\x04goal\x18\x05\x20\x01(\rR\
    \x04goal\x12\x14\n\x05query\x18\x06\x20\x01(\rR\x05query\x12#\n\rfail_ga\
    metime\x18\x07\x20\x01(\x02R\x0cfailGametime\x12\x17\n\x07item_id\x18\
    \x08\x20\x01(\rR\x06itemId\"f\n\x1cCDOTAUserMsg_SuggestHeroPick\x12\x1b\
    \n\tplayer_id\x18\x01\x20\x02(\rR\x08playerId\x12\x17\n\x07hero_id\x18\
    \x02\x20\x01(\rR\x06heroId\x12\x10\n\x03ban\x18\x03\x20\x01(\x08R\x03ban\
    \"X\n\x1cCDOTAUserMsg_SuggestHeroRole\x12\x1b\n\tplayer_id\x18\x01\x20\
    \x02(\rR\x08playerId\x12\x1b\n\thero_role\x18\x02\x20\x01(\tR\x08heroRol\
    e\"\xd7\x01\n\x1fCDOTAUserMsg_KillcamDamageTaken\x12\x1b\n\tplayer_id\
    \x18\x01\x20\x02(\rR\x08playerId\x12!\n\x0cdamage_taken\x18\x02\x20\x01(\
    \rR\x0bdamageTaken\x12\x1b\n\titem_type\x18\x03\x20\x01(\rR\x08itemType\
    \x12\x17\n\x07item_id\x18\x04\x20\x01(\rR\x06itemId\x12\x1b\n\thero_name\
    \x18\x05\x20\x01(\tR\x08heroName\x12!\n\x0cdamage_color\x18\x06\x20\x01(\
    \tR\x0bdamageColor\"Q\n\x1eCDOTAUserMsg_SelectPenaltyGold\x12\x1b\n\tpla\
    yer_id\x18\x01\x20\x02(\rR\x08playerId\x12\x12\n\x04cost\x18\x02\x20\x01\
    (\x11R\x04cost\"\xab\x01\n\x1bCDOTAUserMsg_RollDiceResult\x12\x1b\n\tpla\
    yer_id\x18\x01\x20\x01(\rR\x08playerId\x12!\n\x0cchannel_type\x18\x02\
    \x20\x01(\rR\x0bchannelType\x12\x19\n\x08roll_min\x18\x03\x20\x01(\rR\
    \x07rollMin\x12\x19\n\x08roll_max\x18\x04\x20\x01(\rR\x07rollMax\x12\x16\
    \n\x06result\x18\x05\x20\x01(\rR\x06result\"u\n\x1bCDOTAUserMsg_FlipCoin\
    Result\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\rR\x08playerId\x12!\n\x0cch\
    annel_type\x18\x02\x20\x01(\rR\x0bchannelType\x12\x16\n\x06result\x18\
    \x03\x20\x01(\x08R\x06result\"F\n'CDOTAUserMessage_RequestItemSuggestion\
    s\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\rR\x08playerId\"e\n#CDOTAUserMes\
    sage_TeamCaptainChanged\x12\x12\n\x04team\x18\x01\x20\x01(\rR\x04team\
    \x12*\n\x11captain_player_id\x18\x02\x20\x01(\rR\x0fcaptainPlayerId\"n\n\
    \x1eCDOTAUserMsg_ChatWheelCooldown\x12\x1d\n\nmessage_id\x18\x01\x20\x01\
    (\rR\tmessageId\x12-\n\x12cooldown_remaining\x18\x02\x20\x01(\x02R\x11co\
    oldownRemaining*\xf1\x18\n\x11EDotaUserMessages\x12\x1f\n\x1aDOTA_UM_Add\
    UnitToSelection\x10\xd0\x03\x12\x18\n\x13DOTA_UM_AIDebugLine\x10\xd1\x03\
    \x12\x16\n\x11DOTA_UM_ChatEvent\x10\xd2\x03\x12\x20\n\x1bDOTA_UM_CombatH\
    eroPositions\x10\xd3\x03\x12\x1a\n\x15DOTA_UM_CombatLogData\x10\xd4\x03\
    \x12\x1f\n\x1aDOTA_UM_CombatLogShowDeath\x10\xd6\x03\x12#\n\x1eDOTA_UM_C\
    reateLinearProjectile\x10\xd7\x03\x12$\n\x1fDOTA_UM_DestroyLinearProject\
    ile\x10\xd8\x03\x12%\n\x20DOTA_UM_DodgeTrackingProjectiles\x10\xd9\x03\
    \x12\x1d\n\x18DOTA_UM_GlobalLightColor\x10\xda\x03\x12!\n\x1cDOTA_UM_Glo\
    balLightDirection\x10\xdb\x03\x12\x1b\n\x16DOTA_UM_InvalidCommand\x10\
    \xdc\x03\x12\x19\n\x14DOTA_UM_LocationPing\x10\xdd\x03\x12\x14\n\x0fDOTA\
    _UM_MapLine\x10\xde\x03\x12\x1c\n\x17DOTA_UM_MiniKillCamInfo\x10\xdf\x03\
    \x12\x1e\n\x19DOTA_UM_MinimapDebugPoint\x10\xe0\x03\x12\x19\n\x14DOTA_UM\
    _MinimapEvent\x10\xe1\x03\x12\x1d\n\x18DOTA_UM_NevermoreRequiem\x10\xe2\
    \x03\x12\x1a\n\x15DOTA_UM_OverheadEvent\x10\xe3\x03\x12\x1f\n\x1aDOTA_UM\
    _SetNextAutobuyItem\x10\xe4\x03\x12\x1b\n\x16DOTA_UM_SharedCooldown\x10\
    \xe5\x03\x12!\n\x1cDOTA_UM_SpectatorPlayerClick\x10\xe6\x03\x12\x1c\n\
    \x17DOTA_UM_TutorialTipInfo\x10\xe7\x03\x12\x16\n\x11DOTA_UM_UnitEvent\
    \x10\xe8\x03\x12\x1c\n\x17DOTA_UM_ParticleManager\x10\xe9\x03\x12\x14\n\
    \x0fDOTA_UM_BotChat\x10\xea\x03\x12\x15\n\x10DOTA_UM_HudError\x10\xeb\
    \x03\x12\x1a\n\x15DOTA_UM_ItemPurchased\x10\xec\x03\x12\x11\n\x0cDOTA_UM\
    _Ping\x10\xed\x03\x12\x16\n\x11DOTA_UM_ItemFound\x10\xee\x03\x12\"\n\x1d\
    DOTA_UM_CharacterSpeakConcept\x10\xef\x03\x12\x17\n\x12DOTA_UM_SwapVerif\
    y\x10\xf0\x03\x12\x16\n\x11DOTA_UM_WorldLine\x10\xf1\x03\x12\x1b\n\x16DO\
    TA_UM_TournamentDrop\x10\xf2\x03\x12\x16\n\x11DOTA_UM_ItemAlert\x10\xf3\
    \x03\x12\x1b\n\x16DOTA_UM_HalloweenDrops\x10\xf4\x03\x12\x16\n\x11DOTA_U\
    M_ChatWheel\x10\xf5\x03\x12\x1d\n\x18DOTA_UM_ReceivedXmasGift\x10\xf6\
    \x03\x12\x20\n\x1bDOTA_UM_UpdateSharedContent\x10\xf7\x03\x12\x1f\n\x1aD\
    OTA_UM_TutorialRequestExp\x10\xf8\x03\x12\x20\n\x1bDOTA_UM_TutorialPingM\
    inimap\x10\xf9\x03\x12\"\n\x1dDOTA_UM_GamerulesStateChanged\x10\xfa\x03\
    \x12\x17\n\x12DOTA_UM_ShowSurvey\x10\xfb\x03\x12\x19\n\x14DOTA_UM_Tutori\
    alFade\x10\xfc\x03\x12\x1d\n\x18DOTA_UM_AddQuestLogEntry\x10\xfd\x03\x12\
    \x1a\n\x15DOTA_UM_SendStatPopup\x10\xfe\x03\x12\x1b\n\x16DOTA_UM_Tutoria\
    lFinish\x10\xff\x03\x12\x1c\n\x17DOTA_UM_SendRoshanPopup\x10\x80\x04\x12\
    \x1f\n\x1aDOTA_UM_SendGenericToolTip\x10\x81\x04\x12\x1a\n\x15DOTA_UM_Se\
    ndFinalGold\x10\x82\x04\x12\x16\n\x11DOTA_UM_CustomMsg\x10\x83\x04\x12\
    \x19\n\x14DOTA_UM_CoachHUDPing\x10\x84\x04\x12\x1e\n\x19DOTA_UM_ClientLo\
    adGridNav\x10\x85\x04\x12\x1a\n\x15DOTA_UM_TE_Projectile\x10\x86\x04\x12\
    \x1d\n\x18DOTA_UM_TE_ProjectileLoc\x10\x87\x04\x12\x1f\n\x1aDOTA_UM_TE_D\
    otaBloodImpact\x10\x88\x04\x12\x1d\n\x18DOTA_UM_TE_UnitAnimation\x10\x89\
    \x04\x12\x20\n\x1bDOTA_UM_TE_UnitAnimationEnd\x10\x8a\x04\x12\x18\n\x13D\
    OTA_UM_AbilityPing\x10\x8b\x04\x12\x1d\n\x18DOTA_UM_ShowGenericPopup\x10\
    \x8c\x04\x12\x16\n\x11DOTA_UM_VoteStart\x10\x8d\x04\x12\x17\n\x12DOTA_UM\
    _VoteUpdate\x10\x8e\x04\x12\x14\n\x0fDOTA_UM_VoteEnd\x10\x8f\x04\x12\x19\
    \n\x14DOTA_UM_BoosterState\x10\x90\x04\x12\x1e\n\x19DOTA_UM_WillPurchase\
    Alert\x10\x91\x04\x12$\n\x1fDOTA_UM_TutorialMinimapPosition\x10\x92\x04\
    \x12\x16\n\x11DOTA_UM_PlayerMMR\x10\x93\x04\x12\x19\n\x14DOTA_UM_Ability\
    Steal\x10\x94\x04\x12\x1f\n\x1aDOTA_UM_CourierKilledAlert\x10\x95\x04\
    \x12\x1b\n\x16DOTA_UM_EnemyItemAlert\x10\x96\x04\x12\x1e\n\x19DOTA_UM_St\
    atsMatchDetails\x10\x97\x04\x12\x16\n\x11DOTA_UM_MiniTaunt\x10\x98\x04\
    \x12\x1e\n\x19DOTA_UM_BuyBackStateAlert\x10\x99\x04\x12\x19\n\x14DOTA_UM\
    _SpeechBubble\x10\x9a\x04\x12\x20\n\x1bDOTA_UM_CustomHeaderMessage\x10\
    \x9b\x04\x12\x1a\n\x15DOTA_UM_QuickBuyAlert\x10\x9c\x04\x12\x1d\n\x18DOT\
    A_UM_StatsHeroDetails\x10\x9d\x04\x12\x1d\n\x18DOTA_UM_PredictionResult\
    \x10\x9e\x04\x12\x1a\n\x15DOTA_UM_ModifierAlert\x10\x9f\x04\x12\x18\n\
    \x13DOTA_UM_HPManaAlert\x10\xa0\x04\x12\x17\n\x12DOTA_UM_GlyphAlert\x10\
    \xa1\x04\x12\x16\n\x11DOTA_UM_BeastChat\x10\xa2\x04\x12&\n!DOTA_UM_Spect\
    atorPlayerUnitOrders\x10\xa3\x04\x12$\n\x1fDOTA_UM_CustomHudElement_Crea\
    te\x10\xa4\x04\x12$\n\x1fDOTA_UM_CustomHudElement_Modify\x10\xa5\x04\x12\
    %\n\x20DOTA_UM_CustomHudElement_Destroy\x10\xa6\x04\x12\x1c\n\x17DOTA_UM\
    _CompendiumState\x10\xa7\x04\x12\x1e\n\x19DOTA_UM_ProjectionAbility\x10\
    \xa8\x04\x12\x1c\n\x17DOTA_UM_ProjectionEvent\x10\xa9\x04\x12\x1e\n\x19D\
    OTA_UM_CombatLogDataHLTV\x10\xaa\x04\x12\x14\n\x0fDOTA_UM_XPAlert\x10\
    \xab\x04\x12\x20\n\x1bDOTA_UM_UpdateQuestProgress\x10\xac\x04\x12\x1a\n\
    \x15DOTA_UM_MatchMetadata\x10\xad\x04\x12\x19\n\x14DOTA_UM_MatchDetails\
    \x10\xae\x04\x12\x18\n\x13DOTA_UM_QuestStatus\x10\xaf\x04\x12\x1c\n\x17D\
    OTA_UM_SuggestHeroPick\x10\xb0\x04\x12\x1c\n\x17DOTA_UM_SuggestHeroRole\
    \x10\xb1\x04\x12\x1f\n\x1aDOTA_UM_KillcamDamageTaken\x10\xb2\x04\x12\x1e\
    \n\x19DOTA_UM_SelectPenaltyGold\x10\xb3\x04\x12\x1b\n\x16DOTA_UM_RollDic\
    eResult\x10\xb4\x04\x12\x1b\n\x16DOTA_UM_FlipCoinResult\x10\xb5\x04\x12#\
    \n\x1eDOTA_UM_RequestItemSuggestions\x10\xb6\x04\x12\x1f\n\x1aDOTA_UM_Te\
    amCaptainChanged\x10\xb7\x04\x12%\n\x20DOTA_UM_SendRoshanSpectatorPhase\
    \x10\xb8\x04\x12\x1e\n\x19DOTA_UM_ChatWheelCooldown\x10\xb9\x04\x12!\n\
    \x1cDOTA_UM_DismissAllStatPopups\x10\xba\x04*\xf5\x1a\n\x11DOTA_CHAT_MES\
    SAGE\x12!\n\x14CHAT_MESSAGE_INVALID\x10\xff\xff\xff\xff\xff\xff\xff\xff\
    \xff\x01\x12\x1a\n\x16CHAT_MESSAGE_HERO_KILL\x10\0\x12\x1a\n\x16CHAT_MES\
    SAGE_HERO_DENY\x10\x01\x12\x1e\n\x1aCHAT_MESSAGE_BARRACKS_KILL\x10\x02\
    \x12\x1b\n\x17CHAT_MESSAGE_TOWER_KILL\x10\x03\x12\x1b\n\x17CHAT_MESSAGE_\
    TOWER_DENY\x10\x04\x12\x1b\n\x17CHAT_MESSAGE_FIRSTBLOOD\x10\x05\x12\x1c\
    \n\x18CHAT_MESSAGE_STREAK_KILL\x10\x06\x12\x18\n\x14CHAT_MESSAGE_BUYBACK\
    \x10\x07\x12\x16\n\x12CHAT_MESSAGE_AEGIS\x10\x08\x12\x1c\n\x18CHAT_MESSA\
    GE_ROSHAN_KILL\x10\t\x12\x1d\n\x19CHAT_MESSAGE_COURIER_LOST\x10\n\x12\"\
    \n\x1eCHAT_MESSAGE_COURIER_RESPAWNED\x10\x0b\x12\x1b\n\x17CHAT_MESSAGE_G\
    LYPH_USED\x10\x0c\x12\x1e\n\x1aCHAT_MESSAGE_ITEM_PURCHASE\x10\r\x12\x18\
    \n\x14CHAT_MESSAGE_CONNECT\x10\x0e\x12\x1b\n\x17CHAT_MESSAGE_DISCONNECT\
    \x10\x0f\x12.\n*CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT\x10\x10\x12*\
    \n&CHAT_MESSAGE_DISCONNECT_TIME_REMAINING\x10\x11\x121\n-CHAT_MESSAGE_DI\
    SCONNECT_TIME_REMAINING_PLURAL\x10\x12\x12\x1a\n\x16CHAT_MESSAGE_RECONNE\
    CT\x10\x13\x12\x1c\n\x18CHAT_MESSAGE_PLAYER_LEFT\x10\x14\x12\x1e\n\x1aCH\
    AT_MESSAGE_SAFE_TO_LEAVE\x10\x15\x12\x1c\n\x18CHAT_MESSAGE_RUNE_PICKUP\
    \x10\x16\x12\x1c\n\x18CHAT_MESSAGE_RUNE_BOTTLE\x10\x17\x12\x19\n\x15CHAT\
    _MESSAGE_INTHEBAG\x10\x18\x12\x1b\n\x17CHAT_MESSAGE_SECRETSHOP\x10\x19\
    \x12#\n\x1fCHAT_MESSAGE_ITEM_AUTOPURCHASED\x10\x1a\x12\x1f\n\x1bCHAT_MES\
    SAGE_ITEMS_COMBINED\x10\x1b\x12\x1d\n\x19CHAT_MESSAGE_SUPER_CREEPS\x10\
    \x1c\x12%\n!CHAT_MESSAGE_CANT_USE_ACTION_ITEM\x10\x1d\x12\"\n\x1eCHAT_ME\
    SSAGE_CHARGES_EXHAUSTED\x10\x1e\x12\x1a\n\x16CHAT_MESSAGE_CANTPAUSE\x10\
    \x1f\x12\x1d\n\x19CHAT_MESSAGE_NOPAUSESLEFT\x10\x20\x12\x1d\n\x19CHAT_ME\
    SSAGE_CANTPAUSEYET\x10!\x12\x17\n\x13CHAT_MESSAGE_PAUSED\x10\"\x12\"\n\
    \x1eCHAT_MESSAGE_UNPAUSE_COUNTDOWN\x10#\x12\x19\n\x15CHAT_MESSAGE_UNPAUS\
    ED\x10$\x12\x1e\n\x1aCHAT_MESSAGE_AUTO_UNPAUSED\x10%\x12\x1a\n\x16CHAT_M\
    ESSAGE_YOUPAUSED\x10&\x12\x20\n\x1cCHAT_MESSAGE_CANTUNPAUSETEAM\x10'\x12\
    \"\n\x1eCHAT_MESSAGE_VOICE_TEXT_BANNED\x10)\x12.\n*CHAT_MESSAGE_SPECTATO\
    RS_WATCHING_THIS_GAME\x10*\x12\x20\n\x1cCHAT_MESSAGE_REPORT_REMINDER\x10\
    +\x12\x1a\n\x16CHAT_MESSAGE_ECON_ITEM\x10,\x12\x16\n\x12CHAT_MESSAGE_TAU\
    NT\x10-\x12\x17\n\x13CHAT_MESSAGE_RANDOM\x10.\x12\x18\n\x14CHAT_MESSAGE_\
    RD_TURN\x10/\x12\x20\n\x1cCHAT_MESSAGE_DROP_RATE_BONUS\x101\x12!\n\x1dCH\
    AT_MESSAGE_NO_BATTLE_POINTS\x102\x12\x1d\n\x19CHAT_MESSAGE_DENIED_AEGIS\
    \x103\x12\x1e\n\x1aCHAT_MESSAGE_INFORMATIONAL\x104\x12\x1d\n\x19CHAT_MES\
    SAGE_AEGIS_STOLEN\x105\x12\x1d\n\x19CHAT_MESSAGE_ROSHAN_CANDY\x106\x12\
    \x1c\n\x18CHAT_MESSAGE_ITEM_GIFTED\x107\x12'\n#CHAT_MESSAGE_HERO_KILL_WI\
    TH_GREEVIL\x108\x12(\n$CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED\x109\x12'\n#\
    CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED\x10:\x12&\n\"CHAT_MESSAGE_HOLDOUT_WA\
    LL_FINISHED\x10;\x12)\n%CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO\x10>\x121\
    \n-CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION\x10?\x12(\n$CHAT_MESSAG\
    E_DISCONNECT_LIMITED_HERO\x10@\x123\n/CHAT_MESSAGE_LOW_PRIORITY_COMPLETE\
    D_EXPLANATION\x10A\x12,\n(CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS\x10B\
    \x121\n-CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE\x10C\x12\x20\n\x1c\
    CHAT_MESSAGE_PLAYER_LEFT_AFK\x10I\x122\n.CHAT_MESSAGE_PLAYER_LEFT_DISCON\
    NECTED_TOO_LONG\x10J\x12!\n\x1dCHAT_MESSAGE_PLAYER_ABANDONED\x10K\x12%\n\
    !CHAT_MESSAGE_PLAYER_ABANDONED_AFK\x10L\x127\n3CHAT_MESSAGE_PLAYER_ABAND\
    ONED_DISCONNECTED_TOO_LONG\x10M\x12#\n\x1fCHAT_MESSAGE_WILL_NOT_BE_SCORE\
    D\x10N\x12*\n&CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED\x10O\x12+\n'CHAT_ME\
    SSAGE_WILL_NOT_BE_SCORED_NETWORK\x10P\x122\n.CHAT_MESSAGE_WILL_NOT_BE_SC\
    ORED_NETWORK_RANKED\x10Q\x12)\n%CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON\
    \x10R\x12:\n6CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS\x10S\
    \x128\n4CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY\x10T\x12!\n\
    \x1dCHAT_MESSAGE_COMPENDIUM_LEVEL\x10U\x12*\n&CHAT_MESSAGE_VICTORY_PREDI\
    CTION_STREAK\x10V\x12\"\n\x1eCHAT_MESSAGE_ASSASSIN_ANNOUNCE\x10W\x12!\n\
    \x1dCHAT_MESSAGE_ASSASSIN_SUCCESS\x10X\x12\x20\n\x1cCHAT_MESSAGE_ASSASSI\
    N_DENIED\x10Y\x127\n3CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM\
    \x10Z\x12\x1c\n\x18CHAT_MESSAGE_EFFIGY_KILL\x10[\x12+\n'CHAT_MESSAGE_VOI\
    CE_TEXT_BANNED_OVERFLOW\x10\\\x12\"\n\x1eCHAT_MESSAGE_YEAR_BEAST_KILLED\
    \x10]\x12\x20\n\x1cCHAT_MESSAGE_PAUSE_COUNTDOWN\x10^\x12\x1e\n\x1aCHAT_M\
    ESSAGE_COINS_WAGERED\x10_\x12#\n\x1fCHAT_MESSAGE_HERO_NOMINATED_BAN\x10`\
    \x12\x1c\n\x18CHAT_MESSAGE_HERO_BANNED\x10a\x12\x1f\n\x1bCHAT_MESSAGE_HE\
    RO_BAN_COUNT\x10b\x12\x1e\n\x1aCHAT_MESSAGE_RIVER_PAINTED\x10c\x12\x1a\n\
    \x16CHAT_MESSAGE_SCAN_USED\x10d\x12\x1e\n\x1aCHAT_MESSAGE_SHRINE_KILLED\
    \x10e\x12\"\n\x1eCHAT_MESSAGE_WAGER_TOKEN_SPENT\x10f\x12\x1b\n\x17CHAT_M\
    ESSAGE_RANK_WAGER\x10g*\xb2\x01\n\x1dDOTA_NO_BATTLE_POINTS_REASONS\x12%\
    \n!NO_BATTLE_POINTS_WRONG_LOBBY_TYPE\x10\x01\x12\"\n\x1eNO_BATTLE_POINTS\
    _PRACTICE_BOTS\x10\x02\x12#\n\x1fNO_BATTLE_POINTS_CHEATS_ENABLED\x10\x03\
    \x12!\n\x1dNO_BATTLE_POINTS_LOW_PRIORITY\x10\x04*\xa8\x01\n\x17DOTA_CHAT\
    _INFORMATIONAL\x12!\n\x1dINFO_COOP_BATTLE_POINTS_RULES\x10\x01\x12#\n\
    \x1fINFO_FROSTIVUS_ABANDON_REMINDER\x10\x02\x12\x18\n\x14INFO_RANKED_REM\
    INDER\x10\x03\x12+\n'INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER\x10\x04*\
    \xb3\x01\n\x16DOTA_ABILITY_PING_TYPE\x12\x16\n\x12ABILITY_PING_READY\x10\
    \x01\x12\x15\n\x11ABILITY_PING_MANA\x10\x02\x12\x19\n\x15ABILITY_PING_CO\
    OLDOWN\x10\x03\x12\x16\n\x12ABILITY_PING_ENEMY\x10\x04\x12\x1a\n\x16ABIL\
    ITY_PING_UNLEARNED\x10\x05\x12\x1b\n\x17ABILITY_PING_INBACKPACK\x10\x06*\
    \xbb\x01\n\x17DOTA_REPLAY_STATE_EVENT\x12&\n\"DOTA_REPLAY_STATE_EVENT_GA\
    ME_START\x10\x01\x12)\n%DOTA_REPLAY_STATE_EVENT_STARTING_HORN\x10\x02\
    \x12'\n#DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD\x10\x03\x12$\n\x20DOTA_REPLA\
    Y_STATE_EVENT_SHOWCASE\x10\x04*\xe5\x01\n\x13EDotaEntityMessages\x12\x14\
    \n\x10DOTA_UNIT_SPEECH\x10\0\x12\x19\n\x15DOTA_UNIT_SPEECH_MUTE\x10\x01\
    \x12\x19\n\x15DOTA_UNIT_ADD_GESTURE\x10\x02\x12\x1c\n\x18DOTA_UNIT_REMOV\
    E_GESTURE\x10\x03\x12!\n\x1dDOTA_UNIT_REMOVE_ALL_GESTURES\x10\x04\x12\
    \x1a\n\x16DOTA_UNIT_FADE_GESTURE\x10\x06\x12%\n!DOTA_UNIT_SPEECH_CLIENTS\
    IDE_RULES\x10\x07*\xb1\x06\n\x15DOTA_PARTICLE_MESSAGE\x12&\n\"DOTA_PARTI\
    CLE_MANAGER_EVENT_CREATE\x10\0\x12&\n\"DOTA_PARTICLE_MANAGER_EVENT_UPDAT\
    E\x10\x01\x12.\n*DOTA_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD\x10\x02\x122\
    \n.DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION\x10\x03\x12/\n+DOTA_PA\
    RTICLE_MANAGER_EVENT_UPDATE_FALLBACK\x10\x04\x12*\n&DOTA_PARTICLE_MANAGE\
    R_EVENT_UPDATE_ENT\x10\x05\x12-\n)DOTA_PARTICLE_MANAGER_EVENT_UPDATE_OFF\
    SET\x10\x06\x12'\n#DOTA_PARTICLE_MANAGER_EVENT_DESTROY\x10\x07\x121\n-DO\
    TA_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING\x10\x08\x12'\n#DOTA_PARTICLE\
    _MANAGER_EVENT_RELEASE\x10\t\x12'\n#DOTA_PARTICLE_MANAGER_EVENT_LATENCY\
    \x10\n\x12+\n'DOTA_PARTICLE_MANAGER_EVENT_SHOULD_DRAW\x10\x0b\x12&\n\"DO\
    TA_PARTICLE_MANAGER_EVENT_FROZEN\x10\x0c\x12?\n;DOTA_PARTICLE_MANAGER_EV\
    ENT_CHANGE_CONTROL_POINT_ATTACHMENT\x10\r\x126\n2DOTA_PARTICLE_MANAGER_E\
    VENT_UPDATE_ENTITY_POSITION\x10\x0e\x122\n.DOTA_PARTICLE_MANAGER_EVENT_S\
    ET_FOW_PROPERTIES\x10\x0f\x12(\n$DOTA_PARTICLE_MANAGER_EVENT_SET_TEXT\
    \x10\x10*\x95\x05\n\x13DOTA_OVERHEAD_ALERT\x12\x17\n\x13OVERHEAD_ALERT_G\
    OLD\x10\0\x12\x17\n\x13OVERHEAD_ALERT_DENY\x10\x01\x12\x1b\n\x17OVERHEAD\
    _ALERT_CRITICAL\x10\x02\x12\x15\n\x11OVERHEAD_ALERT_XP\x10\x03\x12%\n!OV\
    ERHEAD_ALERT_BONUS_SPELL_DAMAGE\x10\x04\x12\x17\n\x13OVERHEAD_ALERT_MISS\
    \x10\x05\x12\x19\n\x15OVERHEAD_ALERT_DAMAGE\x10\x06\x12\x18\n\x14OVERHEA\
    D_ALERT_EVADE\x10\x07\x12\x18\n\x14OVERHEAD_ALERT_BLOCK\x10\x08\x12&\n\"\
    OVERHEAD_ALERT_BONUS_POISON_DAMAGE\x10\t\x12\x17\n\x13OVERHEAD_ALERT_HEA\
    L\x10\n\x12\x1b\n\x17OVERHEAD_ALERT_MANA_ADD\x10\x0b\x12\x1c\n\x18OVERHE\
    AD_ALERT_MANA_LOSS\x10\x0c\x12!\n\x1dOVERHEAD_ALERT_LAST_HIT_EARLY\x10\r\
    \x12!\n\x1dOVERHEAD_ALERT_LAST_HIT_CLOSE\x10\x0e\x12\x20\n\x1cOVERHEAD_A\
    LERT_LAST_HIT_MISS\x10\x0f\x12\x20\n\x1cOVERHEAD_ALERT_MAGICAL_BLOCK\x10\
    \x10\x12\"\n\x1eOVERHEAD_ALERT_INCOMING_DAMAGE\x10\x11\x12\"\n\x1eOVERHE\
    AD_ALERT_OUTGOING_DAMAGE\x10\x12\x12!\n\x1dOVERHEAD_ALERT_DISABLE_RESIST\
    \x10\x13\x12\x18\n\x14OVERHEAD_ALERT_DEATH\x10\x14*k\n\x11DOTA_ROSHAN_PH\
    ASE\x12\x17\n\x13k_SRSP_ROSHAN_ALIVE\x10\0\x12\x1c\n\x18k_SRSP_ROSHAN_BA\
    SE_TIMER\x10\x01\x12\x1f\n\x1bk_SRSP_ROSHAN_VISIBLE_TIMER\x10\x02*\x81\
    \x04\n\x16DOTA_POSITION_CATEGORY\x12\x16\n\x12DOTA_POSITION_NONE\x10\0\
    \x12\x1d\n\x19DOTA_POSITION_BOTTOM_LANE\x10\x01\x12\x1a\n\x16DOTA_POSITI\
    ON_MID_LANE\x10\x02\x12\x1a\n\x16DOTA_POSITION_TOP_LANE\x10\x03\x12\x20\
    \n\x1cDOTA_POSITION_RADIANT_JUNGLE\x10\x04\x12\x1d\n\x19DOTA_POSITION_DI\
    RE_JUNGLE\x10\x05\x12\"\n\x1eDOTA_POSITION_RADIANT_ANCIENTS\x10\x06\x12\
    \x1f\n\x1bDOTA_POSITION_DIRE_ANCIENTS\x10\x07\x12%\n!DOTA_POSITION_RADIA\
    NT_SECRET_SHOP\x10\x08\x12\"\n\x1eDOTA_POSITION_DIRE_SECRET_SHOP\x10\t\
    \x12\x17\n\x13DOTA_POSITION_RIVER\x10\n\x12\x1c\n\x18DOTA_POSITION_ROSHA\
    N_PIT\x10\x0b\x12\x1e\n\x1aDOTA_POSITION_RADIANT_BASE\x10\x0c\x12\x1b\n\
    \x17DOTA_POSITION_DIRE_BASE\x10\r\x12\x1a\n\x16DOTA_POSITION_FOUNTAIN\
    \x10\x0e\x12\x17\n\x13DOTA_POSITION_OTHER\x10\x0f*\xe6\x01\n\x18DOTA_ABI\
    LITY_TARGET_TYPE\x12\x1c\n\x18DOTA_ABILITY_TARGET_NONE\x10\0\x12\x1c\n\
    \x18DOTA_ABILITY_TARGET_SELF\x10\x01\x12!\n\x1dDOTA_ABILITY_TARGET_ALLY_\
    HERO\x10\x02\x12\"\n\x1eDOTA_ABILITY_TARGET_ALLY_CREEP\x10\x03\x12\"\n\
    \x1eDOTA_ABILITY_TARGET_ENEMY_HERO\x10\x04\x12#\n\x1fDOTA_ABILITY_TARGET\
    _ENEMY_CREEP\x10\x05*\x98\x08\n\rEHeroStatType\x12\x18\n\x14k_EHeroStatT\
    ype_None\x10\0\x12#\n\x1ek_EHeroStatType_AxeTotalDamage\x10\xd0\x0f\x12'\
    \n\"k_EHeroStatType_BattleHungerDamage\x10\xd1\x0f\x12'\n\"k_EHeroStatTy\
    pe_CounterHelixDamage\x10\xd2\x0f\x12'\n\"k_EHeroStatType_CullingBladeDa\
    mage\x10\xd3\x0f\x12,\n'k_EHeroStatType_BerserkersCallCastCount\x10\xd4\
    \x0f\x123\n.k_EHeroStatType_BerserkersCallHeroesHitAverage\x10\xd5\x0f\
    \x120\n+k_EHeroStatType_BerserkersCallOtherUnitsHit\x10\xd6\x0f\x123\n.k\
    _EHeroStatType_BerserkersCallHeroAttacksTaken\x10\xd7\x0f\x124\n/k_EHero\
    StatType_BerserkersCallOtherAttacksTaken\x10\xd8\x0f\x12*\n%k_EHeroStatT\
    ype_BattleHungerCastCount\x10\xd9\x0f\x122\n-k_EHeroStatType_BattleHunge\
    rPotentialDuration\x10\xda\x0f\x120\n+k_EHeroStatType_BattleHungerAverag\
    eDuration\x10\xdb\x0f\x12*\n%k_EHeroStatType_CounterHelixProcCount\x10\
    \xdc\x0f\x12.\n)k_EHeroStatType_CounterHelixHeroProcCount\x10\xdd\x0f\
    \x121\n,k_EHeroStatType_CounterHelixHeroesHitAverage\x10\xde\x0f\x123\n.\
    k_EHeroStatType_CounterHelixOtherUnitsHitCount\x10\xdf\x0f\x12*\n%k_EHer\
    oStatType_CullingBladeCastCount\x10\xe0\x0f\x12*\n%k_EHeroStatType_Culli\
    ngBladeKillCount\x10\xe1\x0f\x124\n/k_EHeroStatType_CullingBladeAverageH\
    ealthCulled\x10\xe2\x0f\x127\n2k_EHeroStatType_CullingBladeAverageDamage\
    Available\x10\xe3\x0f\x120\n+k_EHeroStatType_CullingBladeHeroBuffAverage\
    \x10\xe4\x0f*\xa9\x04\n\x17EPlayerVoiceListenState\x12\x0e\n\nkPVLS_None\
    \x10\0\x12\x1a\n\x16kPVLS_DeniedChatBanned\x10\x01\x12\x17\n\x13kPVLS_De\
    niedPartner\x10\x02\x12&\n\"kPVLS_DeniedHLTVTalkerNotSpectator\x10\x03\
    \x12$\n\x20kPVLS_DeniedHLTVNoTalkerPlayerID\x10\x04\x12(\n$kPVLS_DeniedH\
    LTVTalkerNotBroadcaster\x10\x05\x12\x1d\n\x19kPVLS_DeniedTeamSpectator\
    \x10\x06\x12\x17\n\x13kPVLS_DeniedStudent\x10\x08\x12\x10\n\x0ckPVLS_Den\
    ied\x10@\x12&\n\"kPVLS_AllowHLTVTalkerIsBroadcaster\x10A\x12\x1c\n\x18kP\
    VLS_AllowCoBroadcaster\x10B\x12\x16\n\x12kPVLS_AllowAllChat\x10C\x12\x1d\
    \n\x19kPVLS_AllowStudentToCoach\x10D\x12\x1c\n\x18kPVLS_AllowFellowStude\
    nt\x10E\x12\x1c\n\x18kPVLS_AllowTalkerIsCoach\x10F\x12\x1c\n\x18kPVLS_Al\
    lowCoachHearTeam\x10G\x12\x17\n\x13kPVLS_AllowSameTeam\x10H\x12\x17\n\
    \x13kPVLS_AllowShowcase\x10I*B\n\x10EProjectionEvent\x12\x12\n\x0eePE_Fi\
    rstBlood\x10\0\x12\x1a\n\x16ePE_Killstreak_godlike\x10\x01B\x05H\x01\x80\
    \x01\0\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
